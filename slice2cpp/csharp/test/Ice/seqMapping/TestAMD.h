//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __TestAMD_h__
#define __TestAMD_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 9
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class CV;
class I;
class IPrx;
class CR;
class MyClass;
class MyClassPrx;

}

namespace Test
{

using AByteS = ::std::vector<::Ice::Byte>;

using LByteS = ::std::vector<::Ice::Byte>;

using KByteS = ::std::vector<::Ice::Byte>;

using QByteS = ::std::vector<::Ice::Byte>;

using SByteS = ::std::vector<::Ice::Byte>;

using ABoolS = ::std::vector<bool>;

using LBoolS = ::std::vector<bool>;

using KBoolS = ::std::vector<bool>;

using QBoolS = ::std::vector<bool>;

using SBoolS = ::std::vector<bool>;

using AShortS = ::std::vector<short>;

using LShortS = ::std::vector<short>;

using KShortS = ::std::vector<short>;

using QShortS = ::std::vector<short>;

using SShortS = ::std::vector<short>;

using AIntS = ::std::vector<int>;

using LIntS = ::std::vector<int>;

using KIntS = ::std::vector<int>;

using QIntS = ::std::vector<int>;

using SIntS = ::std::vector<int>;

using ALongS = ::std::vector<long long int>;

using LLongS = ::std::vector<long long int>;

using KLongS = ::std::vector<long long int>;

using QLongS = ::std::vector<long long int>;

using SLongS = ::std::vector<long long int>;

using AFloatS = ::std::vector<float>;

using LFloatS = ::std::vector<float>;

using KFloatS = ::std::vector<float>;

using QFloatS = ::std::vector<float>;

using SFloatS = ::std::vector<float>;

using ADoubleS = ::std::vector<double>;

using LDoubleS = ::std::vector<double>;

using KDoubleS = ::std::vector<double>;

using QDoubleS = ::std::vector<double>;

using SDoubleS = ::std::vector<double>;

using AStringS = ::std::vector<::std::string>;

using LStringS = ::std::vector<::std::string>;

using KStringS = ::std::vector<::std::string>;

using QStringS = ::std::vector<::std::string>;

using SStringS = ::std::vector<::std::string>;

using AObjectS = ::std::vector<::std::shared_ptr<::Ice::Value>>;

using LObjectS = ::std::vector<::std::shared_ptr<::Ice::Value>>;

using AObjectPrxS = ::std::vector<::std::shared_ptr<::Ice::ObjectPrx>>;

using LObjectPrxS = ::std::vector<::std::shared_ptr<::Ice::ObjectPrx>>;

using KObjectPrxS = ::std::vector<::std::shared_ptr<::Ice::ObjectPrx>>;

using QObjectPrxS = ::std::vector<::std::shared_ptr<::Ice::ObjectPrx>>;

using SObjectPrxS = ::std::vector<::std::shared_ptr<::Ice::ObjectPrx>>;

struct S
{
    int i;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(i);
    }
};

using AStructS = ::std::vector<S>;

using LStructS = ::std::vector<S>;

using KStructS = ::std::vector<S>;

using QStructS = ::std::vector<S>;

using SStructS = ::std::vector<S>;

struct SD
{
    int i = 1;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(i);
    }
};

using AStructSD = ::std::vector<SD>;

using LStructSD = ::std::vector<SD>;

using KStructSD = ::std::vector<SD>;

using QStructSD = ::std::vector<SD>;

using SStructSD = ::std::vector<SD>;

using ACVS = ::std::vector<::std::shared_ptr<CV>>;

using LCVS = ::std::vector<::std::shared_ptr<CV>>;

using AIPrxS = ::std::vector<::std::shared_ptr<IPrx>>;

using LIPrxS = ::std::vector<::std::shared_ptr<IPrx>>;

using KIPrxS = ::std::vector<::std::shared_ptr<IPrx>>;

using QIPrxS = ::std::vector<::std::shared_ptr<IPrx>>;

using SIPrxS = ::std::vector<::std::shared_ptr<IPrx>>;

using ACRS = ::std::vector<::std::shared_ptr<CR>>;

using LCRS = ::std::vector<::std::shared_ptr<CR>>;

enum class En : unsigned char
{
    A,
    B,
    C
};

using AEnS = ::std::vector<En>;

using LEnS = ::std::vector<En>;

using KEnS = ::std::vector<En>;

using QEnS = ::std::vector<En>;

using SEnS = ::std::vector<En>;

using CustomIntS = ::std::vector<int>;

using CustomCVS = ::std::vector<::std::shared_ptr<CV>>;

using CustomIntSS = ::std::vector<CustomIntS>;

using CustomCVSS = ::std::vector<CustomCVS>;

using SerialSmall = ::std::vector<::Ice::Byte>;

using SerialLarge = ::std::vector<::Ice::Byte>;

using SerialStruct = ::std::vector<::Ice::Byte>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class I : public virtual ::Ice::Object
{
public:

    using ProxyType = IPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class MyClass : public virtual ::Ice::Object
{
public:

    using ProxyType = MyClassPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opAByteS.
     */
    struct OpAByteSResult
    {
        AByteS returnValue;
        AByteS o;
    };

    virtual void opAByteSAsync(AByteS i, ::std::function<void(const AByteS& returnValue, const AByteS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opAByteS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLByteS.
     */
    struct OpLByteSResult
    {
        LByteS returnValue;
        LByteS o;
    };

    virtual void opLByteSAsync(LByteS i, ::std::function<void(const LByteS& returnValue, const LByteS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLByteS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opKByteS.
     */
    struct OpKByteSResult
    {
        KByteS returnValue;
        KByteS o;
    };

    virtual void opKByteSAsync(KByteS i, ::std::function<void(const KByteS& returnValue, const KByteS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opKByteS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opQByteS.
     */
    struct OpQByteSResult
    {
        QByteS returnValue;
        QByteS o;
    };

    virtual void opQByteSAsync(QByteS i, ::std::function<void(const QByteS& returnValue, const QByteS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opQByteS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSByteS.
     */
    struct OpSByteSResult
    {
        SByteS returnValue;
        SByteS o;
    };

    virtual void opSByteSAsync(SByteS i, ::std::function<void(const SByteS& returnValue, const SByteS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSByteS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opABoolS.
     */
    struct OpABoolSResult
    {
        ABoolS returnValue;
        ABoolS o;
    };

    virtual void opABoolSAsync(ABoolS i, ::std::function<void(const ABoolS& returnValue, const ABoolS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opABoolS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLBoolS.
     */
    struct OpLBoolSResult
    {
        LBoolS returnValue;
        LBoolS o;
    };

    virtual void opLBoolSAsync(LBoolS i, ::std::function<void(const LBoolS& returnValue, const LBoolS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLBoolS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opKBoolS.
     */
    struct OpKBoolSResult
    {
        KBoolS returnValue;
        KBoolS o;
    };

    virtual void opKBoolSAsync(KBoolS i, ::std::function<void(const KBoolS& returnValue, const KBoolS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opKBoolS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opQBoolS.
     */
    struct OpQBoolSResult
    {
        QBoolS returnValue;
        QBoolS o;
    };

    virtual void opQBoolSAsync(QBoolS i, ::std::function<void(const QBoolS& returnValue, const QBoolS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opQBoolS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSBoolS.
     */
    struct OpSBoolSResult
    {
        SBoolS returnValue;
        SBoolS o;
    };

    virtual void opSBoolSAsync(SBoolS i, ::std::function<void(const SBoolS& returnValue, const SBoolS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSBoolS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opAShortS.
     */
    struct OpAShortSResult
    {
        AShortS returnValue;
        AShortS o;
    };

    virtual void opAShortSAsync(AShortS i, ::std::function<void(const AShortS& returnValue, const AShortS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opAShortS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLShortS.
     */
    struct OpLShortSResult
    {
        LShortS returnValue;
        LShortS o;
    };

    virtual void opLShortSAsync(LShortS i, ::std::function<void(const LShortS& returnValue, const LShortS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLShortS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opKShortS.
     */
    struct OpKShortSResult
    {
        KShortS returnValue;
        KShortS o;
    };

    virtual void opKShortSAsync(KShortS i, ::std::function<void(const KShortS& returnValue, const KShortS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opKShortS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opQShortS.
     */
    struct OpQShortSResult
    {
        QShortS returnValue;
        QShortS o;
    };

    virtual void opQShortSAsync(QShortS i, ::std::function<void(const QShortS& returnValue, const QShortS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opQShortS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSShortS.
     */
    struct OpSShortSResult
    {
        SShortS returnValue;
        SShortS o;
    };

    virtual void opSShortSAsync(SShortS i, ::std::function<void(const SShortS& returnValue, const SShortS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSShortS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opAIntS.
     */
    struct OpAIntSResult
    {
        AIntS returnValue;
        AIntS o;
    };

    virtual void opAIntSAsync(AIntS i, ::std::function<void(const AIntS& returnValue, const AIntS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opAIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLIntS.
     */
    struct OpLIntSResult
    {
        LIntS returnValue;
        LIntS o;
    };

    virtual void opLIntSAsync(LIntS i, ::std::function<void(const LIntS& returnValue, const LIntS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opKIntS.
     */
    struct OpKIntSResult
    {
        KIntS returnValue;
        KIntS o;
    };

    virtual void opKIntSAsync(KIntS i, ::std::function<void(const KIntS& returnValue, const KIntS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opKIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opQIntS.
     */
    struct OpQIntSResult
    {
        QIntS returnValue;
        QIntS o;
    };

    virtual void opQIntSAsync(QIntS i, ::std::function<void(const QIntS& returnValue, const QIntS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opQIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSIntS.
     */
    struct OpSIntSResult
    {
        SIntS returnValue;
        SIntS o;
    };

    virtual void opSIntSAsync(SIntS i, ::std::function<void(const SIntS& returnValue, const SIntS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opALongS.
     */
    struct OpALongSResult
    {
        ALongS returnValue;
        ALongS o;
    };

    virtual void opALongSAsync(ALongS i, ::std::function<void(const ALongS& returnValue, const ALongS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opALongS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLLongS.
     */
    struct OpLLongSResult
    {
        LLongS returnValue;
        LLongS o;
    };

    virtual void opLLongSAsync(LLongS i, ::std::function<void(const LLongS& returnValue, const LLongS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLLongS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opKLongS.
     */
    struct OpKLongSResult
    {
        KLongS returnValue;
        KLongS o;
    };

    virtual void opKLongSAsync(KLongS i, ::std::function<void(const KLongS& returnValue, const KLongS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opKLongS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opQLongS.
     */
    struct OpQLongSResult
    {
        QLongS returnValue;
        QLongS o;
    };

    virtual void opQLongSAsync(QLongS i, ::std::function<void(const QLongS& returnValue, const QLongS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opQLongS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSLongS.
     */
    struct OpSLongSResult
    {
        SLongS returnValue;
        SLongS o;
    };

    virtual void opSLongSAsync(SLongS i, ::std::function<void(const SLongS& returnValue, const SLongS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSLongS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opAFloatS.
     */
    struct OpAFloatSResult
    {
        AFloatS returnValue;
        AFloatS o;
    };

    virtual void opAFloatSAsync(AFloatS i, ::std::function<void(const AFloatS& returnValue, const AFloatS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opAFloatS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLFloatS.
     */
    struct OpLFloatSResult
    {
        LFloatS returnValue;
        LFloatS o;
    };

    virtual void opLFloatSAsync(LFloatS i, ::std::function<void(const LFloatS& returnValue, const LFloatS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLFloatS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opKFloatS.
     */
    struct OpKFloatSResult
    {
        KFloatS returnValue;
        KFloatS o;
    };

    virtual void opKFloatSAsync(KFloatS i, ::std::function<void(const KFloatS& returnValue, const KFloatS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opKFloatS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opQFloatS.
     */
    struct OpQFloatSResult
    {
        QFloatS returnValue;
        QFloatS o;
    };

    virtual void opQFloatSAsync(QFloatS i, ::std::function<void(const QFloatS& returnValue, const QFloatS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opQFloatS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSFloatS.
     */
    struct OpSFloatSResult
    {
        SFloatS returnValue;
        SFloatS o;
    };

    virtual void opSFloatSAsync(SFloatS i, ::std::function<void(const SFloatS& returnValue, const SFloatS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSFloatS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opADoubleS.
     */
    struct OpADoubleSResult
    {
        ADoubleS returnValue;
        ADoubleS o;
    };

    virtual void opADoubleSAsync(ADoubleS i, ::std::function<void(const ADoubleS& returnValue, const ADoubleS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opADoubleS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLDoubleS.
     */
    struct OpLDoubleSResult
    {
        LDoubleS returnValue;
        LDoubleS o;
    };

    virtual void opLDoubleSAsync(LDoubleS i, ::std::function<void(const LDoubleS& returnValue, const LDoubleS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLDoubleS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opKDoubleS.
     */
    struct OpKDoubleSResult
    {
        KDoubleS returnValue;
        KDoubleS o;
    };

    virtual void opKDoubleSAsync(KDoubleS i, ::std::function<void(const KDoubleS& returnValue, const KDoubleS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opKDoubleS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opQDoubleS.
     */
    struct OpQDoubleSResult
    {
        QDoubleS returnValue;
        QDoubleS o;
    };

    virtual void opQDoubleSAsync(QDoubleS i, ::std::function<void(const QDoubleS& returnValue, const QDoubleS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opQDoubleS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSDoubleS.
     */
    struct OpSDoubleSResult
    {
        SDoubleS returnValue;
        SDoubleS o;
    };

    virtual void opSDoubleSAsync(SDoubleS i, ::std::function<void(const SDoubleS& returnValue, const SDoubleS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSDoubleS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opAStringS.
     */
    struct OpAStringSResult
    {
        AStringS returnValue;
        AStringS o;
    };

    virtual void opAStringSAsync(AStringS i, ::std::function<void(const AStringS& returnValue, const AStringS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opAStringS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLStringS.
     */
    struct OpLStringSResult
    {
        LStringS returnValue;
        LStringS o;
    };

    virtual void opLStringSAsync(LStringS i, ::std::function<void(const LStringS& returnValue, const LStringS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLStringS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opKStringS.
     */
    struct OpKStringSResult
    {
        KStringS returnValue;
        KStringS o;
    };

    virtual void opKStringSAsync(KStringS i, ::std::function<void(const KStringS& returnValue, const KStringS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opKStringS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opQStringS.
     */
    struct OpQStringSResult
    {
        QStringS returnValue;
        QStringS o;
    };

    virtual void opQStringSAsync(QStringS i, ::std::function<void(const QStringS& returnValue, const QStringS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opQStringS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSStringS.
     */
    struct OpSStringSResult
    {
        SStringS returnValue;
        SStringS o;
    };

    virtual void opSStringSAsync(SStringS i, ::std::function<void(const SStringS& returnValue, const SStringS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSStringS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opAObjectS.
     */
    struct OpAObjectSResult
    {
        AObjectS returnValue;
        AObjectS o;
    };

    virtual void opAObjectSAsync(AObjectS i, ::std::function<void(const AObjectS& returnValue, const AObjectS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opAObjectS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLObjectS.
     */
    struct OpLObjectSResult
    {
        LObjectS returnValue;
        LObjectS o;
    };

    virtual void opLObjectSAsync(LObjectS i, ::std::function<void(const LObjectS& returnValue, const LObjectS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLObjectS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opAObjectPrxS.
     */
    struct OpAObjectPrxSResult
    {
        AObjectPrxS returnValue;
        AObjectPrxS o;
    };

    virtual void opAObjectPrxSAsync(AObjectPrxS i, ::std::function<void(const AObjectPrxS& returnValue, const AObjectPrxS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opAObjectPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLObjectPrxS.
     */
    struct OpLObjectPrxSResult
    {
        LObjectPrxS returnValue;
        LObjectPrxS o;
    };

    virtual void opLObjectPrxSAsync(LObjectPrxS i, ::std::function<void(const LObjectPrxS& returnValue, const LObjectPrxS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLObjectPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opKObjectPrxS.
     */
    struct OpKObjectPrxSResult
    {
        KObjectPrxS returnValue;
        KObjectPrxS o;
    };

    virtual void opKObjectPrxSAsync(KObjectPrxS i, ::std::function<void(const KObjectPrxS& returnValue, const KObjectPrxS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opKObjectPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opQObjectPrxS.
     */
    struct OpQObjectPrxSResult
    {
        QObjectPrxS returnValue;
        QObjectPrxS o;
    };

    virtual void opQObjectPrxSAsync(QObjectPrxS i, ::std::function<void(const QObjectPrxS& returnValue, const QObjectPrxS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opQObjectPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSObjectPrxS.
     */
    struct OpSObjectPrxSResult
    {
        SObjectPrxS returnValue;
        SObjectPrxS o;
    };

    virtual void opSObjectPrxSAsync(SObjectPrxS i, ::std::function<void(const SObjectPrxS& returnValue, const SObjectPrxS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSObjectPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opAStructS.
     */
    struct OpAStructSResult
    {
        AStructS returnValue;
        AStructS o;
    };

    virtual void opAStructSAsync(AStructS i, ::std::function<void(const AStructS& returnValue, const AStructS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opAStructS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLStructS.
     */
    struct OpLStructSResult
    {
        LStructS returnValue;
        LStructS o;
    };

    virtual void opLStructSAsync(LStructS i, ::std::function<void(const LStructS& returnValue, const LStructS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLStructS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opKStructS.
     */
    struct OpKStructSResult
    {
        KStructS returnValue;
        KStructS o;
    };

    virtual void opKStructSAsync(KStructS i, ::std::function<void(const KStructS& returnValue, const KStructS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opKStructS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opQStructS.
     */
    struct OpQStructSResult
    {
        QStructS returnValue;
        QStructS o;
    };

    virtual void opQStructSAsync(QStructS i, ::std::function<void(const QStructS& returnValue, const QStructS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opQStructS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSStructS.
     */
    struct OpSStructSResult
    {
        SStructS returnValue;
        SStructS o;
    };

    virtual void opSStructSAsync(SStructS i, ::std::function<void(const SStructS& returnValue, const SStructS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSStructS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opAStructSD.
     */
    struct OpAStructSDResult
    {
        AStructSD returnValue;
        AStructSD o;
    };

    virtual void opAStructSDAsync(AStructSD i, ::std::function<void(const AStructSD& returnValue, const AStructSD& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opAStructSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLStructSD.
     */
    struct OpLStructSDResult
    {
        LStructSD returnValue;
        LStructSD o;
    };

    virtual void opLStructSDAsync(LStructSD i, ::std::function<void(const LStructSD& returnValue, const LStructSD& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLStructSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opKStructSD.
     */
    struct OpKStructSDResult
    {
        KStructSD returnValue;
        KStructSD o;
    };

    virtual void opKStructSDAsync(KStructSD i, ::std::function<void(const KStructSD& returnValue, const KStructSD& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opKStructSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opQStructSD.
     */
    struct OpQStructSDResult
    {
        QStructSD returnValue;
        QStructSD o;
    };

    virtual void opQStructSDAsync(QStructSD i, ::std::function<void(const QStructSD& returnValue, const QStructSD& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opQStructSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSStructSD.
     */
    struct OpSStructSDResult
    {
        SStructSD returnValue;
        SStructSD o;
    };

    virtual void opSStructSDAsync(SStructSD i, ::std::function<void(const SStructSD& returnValue, const SStructSD& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSStructSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opACVS.
     */
    struct OpACVSResult
    {
        ACVS returnValue;
        ACVS o;
    };

    virtual void opACVSAsync(ACVS i, ::std::function<void(const ACVS& returnValue, const ACVS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opACVS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLCVS.
     */
    struct OpLCVSResult
    {
        LCVS returnValue;
        LCVS o;
    };

    virtual void opLCVSAsync(LCVS i, ::std::function<void(const LCVS& returnValue, const LCVS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLCVS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opACRS.
     */
    struct OpACRSResult
    {
        ACRS returnValue;
        ACRS o;
    };

    virtual void opACRSAsync(ACRS i, ::std::function<void(const ACRS& returnValue, const ACRS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opACRS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLCRS.
     */
    struct OpLCRSResult
    {
        LCRS returnValue;
        LCRS o;
    };

    virtual void opLCRSAsync(LCRS i, ::std::function<void(const LCRS& returnValue, const LCRS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLCRS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opAEnS.
     */
    struct OpAEnSResult
    {
        AEnS returnValue;
        AEnS o;
    };

    virtual void opAEnSAsync(AEnS i, ::std::function<void(const AEnS& returnValue, const AEnS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opAEnS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLEnS.
     */
    struct OpLEnSResult
    {
        LEnS returnValue;
        LEnS o;
    };

    virtual void opLEnSAsync(LEnS i, ::std::function<void(const LEnS& returnValue, const LEnS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLEnS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opKEnS.
     */
    struct OpKEnSResult
    {
        KEnS returnValue;
        KEnS o;
    };

    virtual void opKEnSAsync(KEnS i, ::std::function<void(const KEnS& returnValue, const KEnS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opKEnS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opQEnS.
     */
    struct OpQEnSResult
    {
        QEnS returnValue;
        QEnS o;
    };

    virtual void opQEnSAsync(QEnS i, ::std::function<void(const QEnS& returnValue, const QEnS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opQEnS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSEnS.
     */
    struct OpSEnSResult
    {
        SEnS returnValue;
        SEnS o;
    };

    virtual void opSEnSAsync(SEnS i, ::std::function<void(const SEnS& returnValue, const SEnS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSEnS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opAIPrxS.
     */
    struct OpAIPrxSResult
    {
        AIPrxS returnValue;
        AIPrxS o;
    };

    virtual void opAIPrxSAsync(AIPrxS i, ::std::function<void(const AIPrxS& returnValue, const AIPrxS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opAIPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLIPrxS.
     */
    struct OpLIPrxSResult
    {
        LIPrxS returnValue;
        LIPrxS o;
    };

    virtual void opLIPrxSAsync(LIPrxS i, ::std::function<void(const LIPrxS& returnValue, const LIPrxS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLIPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opKIPrxS.
     */
    struct OpKIPrxSResult
    {
        KIPrxS returnValue;
        KIPrxS o;
    };

    virtual void opKIPrxSAsync(KIPrxS i, ::std::function<void(const KIPrxS& returnValue, const KIPrxS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opKIPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opQIPrxS.
     */
    struct OpQIPrxSResult
    {
        QIPrxS returnValue;
        QIPrxS o;
    };

    virtual void opQIPrxSAsync(QIPrxS i, ::std::function<void(const QIPrxS& returnValue, const QIPrxS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opQIPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSIPrxS.
     */
    struct OpSIPrxSResult
    {
        SIPrxS returnValue;
        SIPrxS o;
    };

    virtual void opSIPrxSAsync(SIPrxS i, ::std::function<void(const SIPrxS& returnValue, const SIPrxS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSIPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCustomIntS.
     */
    struct OpCustomIntSResult
    {
        CustomIntS returnValue;
        CustomIntS o;
    };

    virtual void opCustomIntSAsync(CustomIntS i, ::std::function<void(const CustomIntS& returnValue, const CustomIntS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCustomCVS.
     */
    struct OpCustomCVSResult
    {
        CustomCVS returnValue;
        CustomCVS o;
    };

    virtual void opCustomCVSAsync(CustomCVS i, ::std::function<void(const CustomCVS& returnValue, const CustomCVS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomCVS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCustomIntSS.
     */
    struct OpCustomIntSSResult
    {
        CustomIntSS returnValue;
        CustomIntSS o;
    };

    virtual void opCustomIntSSAsync(CustomIntSS i, ::std::function<void(const CustomIntSS& returnValue, const CustomIntSS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomIntSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCustomCVSS.
     */
    struct OpCustomCVSSResult
    {
        CustomCVSS returnValue;
        CustomCVSS o;
    };

    virtual void opCustomCVSSAsync(CustomCVSS i, ::std::function<void(const CustomCVSS& returnValue, const CustomCVSS& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomCVSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSerialSmallCSharp.
     */
    struct OpSerialSmallCSharpResult
    {
        SerialSmall returnValue;
        SerialSmall o;
    };

    virtual void opSerialSmallCSharpAsync(SerialSmall i, ::std::function<void(const SerialSmall& returnValue, const SerialSmall& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSerialSmallCSharp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSerialLargeCSharp.
     */
    struct OpSerialLargeCSharpResult
    {
        SerialLarge returnValue;
        SerialLarge o;
    };

    virtual void opSerialLargeCSharpAsync(SerialLarge i, ::std::function<void(const SerialLarge& returnValue, const SerialLarge& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSerialLargeCSharp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSerialStructCSharp.
     */
    struct OpSerialStructCSharpResult
    {
        SerialStruct returnValue;
        SerialStruct o;
    };

    virtual void opSerialStructCSharpAsync(SerialStruct i, ::std::function<void(const SerialStruct& returnValue, const SerialStruct& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSerialStructCSharp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class CV : public ::Ice::ValueHelper<CV, ::Ice::Value>
{
public:

    virtual ~CV();

    CV() = default;

    CV(const CV&) = default;
    CV(CV&&) = default;
    CV& operator=(const CV&) = default;
    CV& operator=(CV&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CV(int i) :
        i(i)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(i);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int i;
};

/// \cond INTERNAL
static CV _iceS_CV_init;
/// \endcond

class CR : public ::Ice::ValueHelper<CR, ::Ice::Value>
{
public:

    virtual ~CR();

    CR() = default;

    CR(const CR&) = default;
    CR(CR&&) = default;
    CR& operator=(const CR&) = default;
    CR& operator=(CR&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CR(const ::std::shared_ptr<::Test::CV>& v) :
        v(v)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::CV>&> ice_tuple() const
    {
        return std::tie(v);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::CV> v;
};

}

namespace Test
{

class IPrx : public virtual ::Ice::Proxy<IPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    IPrx() = default;
    friend ::std::shared_ptr<IPrx> IceInternal::createProxy<IPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class MyClassPrx : public virtual ::Ice::Proxy<MyClassPrx, ::Ice::ObjectPrx>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MyClassPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    AByteS opAByteS(const AByteS& i, AByteS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpAByteSResult>(true, this, &MyClassPrx::_iceI_opAByteS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opAByteSAsync(const AByteS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpAByteSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpAByteSResult, P>(false, this, &MyClassPrx::_iceI_opAByteS, i, context);
    }

    ::std::function<void()>
    opAByteSAsync(const AByteS& i,
                  ::std::function<void(::Test::AByteS, ::Test::AByteS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpAByteSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpAByteSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAByteS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opAByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAByteSResult>>&, const AByteS&, const ::Ice::Context&);
    /// \endcond

    LByteS opLByteS(const LByteS& i, LByteS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLByteSResult>(true, this, &MyClassPrx::_iceI_opLByteS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLByteSAsync(const LByteS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLByteSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLByteSResult, P>(false, this, &MyClassPrx::_iceI_opLByteS, i, context);
    }

    ::std::function<void()>
    opLByteSAsync(const LByteS& i,
                  ::std::function<void(::Test::LByteS, ::Test::LByteS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLByteSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLByteSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLByteS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLByteSResult>>&, const LByteS&, const ::Ice::Context&);
    /// \endcond

    KByteS opKByteS(const KByteS& i, KByteS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpKByteSResult>(true, this, &MyClassPrx::_iceI_opKByteS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opKByteSAsync(const KByteS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpKByteSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpKByteSResult, P>(false, this, &MyClassPrx::_iceI_opKByteS, i, context);
    }

    ::std::function<void()>
    opKByteSAsync(const KByteS& i,
                  ::std::function<void(::Test::KByteS, ::Test::KByteS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpKByteSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpKByteSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKByteS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opKByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKByteSResult>>&, const KByteS&, const ::Ice::Context&);
    /// \endcond

    QByteS opQByteS(const QByteS& i, QByteS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpQByteSResult>(true, this, &MyClassPrx::_iceI_opQByteS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opQByteSAsync(const QByteS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpQByteSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpQByteSResult, P>(false, this, &MyClassPrx::_iceI_opQByteS, i, context);
    }

    ::std::function<void()>
    opQByteSAsync(const QByteS& i,
                  ::std::function<void(::Test::QByteS, ::Test::QByteS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpQByteSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpQByteSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQByteS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opQByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQByteSResult>>&, const QByteS&, const ::Ice::Context&);
    /// \endcond

    SByteS opSByteS(const SByteS& i, SByteS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSByteSResult>(true, this, &MyClassPrx::_iceI_opSByteS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSByteSAsync(const SByteS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSByteSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSByteSResult, P>(false, this, &MyClassPrx::_iceI_opSByteS, i, context);
    }

    ::std::function<void()>
    opSByteSAsync(const SByteS& i,
                  ::std::function<void(::Test::SByteS, ::Test::SByteS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSByteSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSByteSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSByteS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSByteSResult>>&, const SByteS&, const ::Ice::Context&);
    /// \endcond

    ABoolS opABoolS(const ABoolS& i, ABoolS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpABoolSResult>(true, this, &MyClassPrx::_iceI_opABoolS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opABoolSAsync(const ABoolS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpABoolSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpABoolSResult, P>(false, this, &MyClassPrx::_iceI_opABoolS, i, context);
    }

    ::std::function<void()>
    opABoolSAsync(const ABoolS& i,
                  ::std::function<void(::Test::ABoolS, ::Test::ABoolS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpABoolSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpABoolSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opABoolS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opABoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpABoolSResult>>&, const ABoolS&, const ::Ice::Context&);
    /// \endcond

    LBoolS opLBoolS(const LBoolS& i, LBoolS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLBoolSResult>(true, this, &MyClassPrx::_iceI_opLBoolS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLBoolSAsync(const LBoolS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLBoolSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLBoolSResult, P>(false, this, &MyClassPrx::_iceI_opLBoolS, i, context);
    }

    ::std::function<void()>
    opLBoolSAsync(const LBoolS& i,
                  ::std::function<void(::Test::LBoolS, ::Test::LBoolS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLBoolSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLBoolSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLBoolS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLBoolSResult>>&, const LBoolS&, const ::Ice::Context&);
    /// \endcond

    KBoolS opKBoolS(const KBoolS& i, KBoolS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpKBoolSResult>(true, this, &MyClassPrx::_iceI_opKBoolS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opKBoolSAsync(const KBoolS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpKBoolSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpKBoolSResult, P>(false, this, &MyClassPrx::_iceI_opKBoolS, i, context);
    }

    ::std::function<void()>
    opKBoolSAsync(const KBoolS& i,
                  ::std::function<void(::Test::KBoolS, ::Test::KBoolS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpKBoolSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpKBoolSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKBoolS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opKBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKBoolSResult>>&, const KBoolS&, const ::Ice::Context&);
    /// \endcond

    QBoolS opQBoolS(const QBoolS& i, QBoolS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpQBoolSResult>(true, this, &MyClassPrx::_iceI_opQBoolS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opQBoolSAsync(const QBoolS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpQBoolSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpQBoolSResult, P>(false, this, &MyClassPrx::_iceI_opQBoolS, i, context);
    }

    ::std::function<void()>
    opQBoolSAsync(const QBoolS& i,
                  ::std::function<void(::Test::QBoolS, ::Test::QBoolS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpQBoolSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpQBoolSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQBoolS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opQBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQBoolSResult>>&, const QBoolS&, const ::Ice::Context&);
    /// \endcond

    SBoolS opSBoolS(const SBoolS& i, SBoolS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSBoolSResult>(true, this, &MyClassPrx::_iceI_opSBoolS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSBoolSAsync(const SBoolS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSBoolSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSBoolSResult, P>(false, this, &MyClassPrx::_iceI_opSBoolS, i, context);
    }

    ::std::function<void()>
    opSBoolSAsync(const SBoolS& i,
                  ::std::function<void(::Test::SBoolS, ::Test::SBoolS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSBoolSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSBoolSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSBoolS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSBoolSResult>>&, const SBoolS&, const ::Ice::Context&);
    /// \endcond

    AShortS opAShortS(const AShortS& i, AShortS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpAShortSResult>(true, this, &MyClassPrx::_iceI_opAShortS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opAShortSAsync(const AShortS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpAShortSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpAShortSResult, P>(false, this, &MyClassPrx::_iceI_opAShortS, i, context);
    }

    ::std::function<void()>
    opAShortSAsync(const AShortS& i,
                   ::std::function<void(::Test::AShortS, ::Test::AShortS)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpAShortSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpAShortSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAShortS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opAShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAShortSResult>>&, const AShortS&, const ::Ice::Context&);
    /// \endcond

    LShortS opLShortS(const LShortS& i, LShortS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLShortSResult>(true, this, &MyClassPrx::_iceI_opLShortS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLShortSAsync(const LShortS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLShortSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLShortSResult, P>(false, this, &MyClassPrx::_iceI_opLShortS, i, context);
    }

    ::std::function<void()>
    opLShortSAsync(const LShortS& i,
                   ::std::function<void(::Test::LShortS, ::Test::LShortS)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLShortSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLShortSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLShortS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLShortSResult>>&, const LShortS&, const ::Ice::Context&);
    /// \endcond

    KShortS opKShortS(const KShortS& i, KShortS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpKShortSResult>(true, this, &MyClassPrx::_iceI_opKShortS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opKShortSAsync(const KShortS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpKShortSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpKShortSResult, P>(false, this, &MyClassPrx::_iceI_opKShortS, i, context);
    }

    ::std::function<void()>
    opKShortSAsync(const KShortS& i,
                   ::std::function<void(::Test::KShortS, ::Test::KShortS)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpKShortSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpKShortSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKShortS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opKShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKShortSResult>>&, const KShortS&, const ::Ice::Context&);
    /// \endcond

    QShortS opQShortS(const QShortS& i, QShortS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpQShortSResult>(true, this, &MyClassPrx::_iceI_opQShortS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opQShortSAsync(const QShortS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpQShortSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpQShortSResult, P>(false, this, &MyClassPrx::_iceI_opQShortS, i, context);
    }

    ::std::function<void()>
    opQShortSAsync(const QShortS& i,
                   ::std::function<void(::Test::QShortS, ::Test::QShortS)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpQShortSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpQShortSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQShortS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opQShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQShortSResult>>&, const QShortS&, const ::Ice::Context&);
    /// \endcond

    SShortS opSShortS(const SShortS& i, SShortS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSShortSResult>(true, this, &MyClassPrx::_iceI_opSShortS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSShortSAsync(const SShortS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSShortSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSShortSResult, P>(false, this, &MyClassPrx::_iceI_opSShortS, i, context);
    }

    ::std::function<void()>
    opSShortSAsync(const SShortS& i,
                   ::std::function<void(::Test::SShortS, ::Test::SShortS)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSShortSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSShortSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSShortS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSShortSResult>>&, const SShortS&, const ::Ice::Context&);
    /// \endcond

    AIntS opAIntS(const AIntS& i, AIntS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpAIntSResult>(true, this, &MyClassPrx::_iceI_opAIntS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opAIntSAsync(const AIntS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpAIntSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpAIntSResult, P>(false, this, &MyClassPrx::_iceI_opAIntS, i, context);
    }

    ::std::function<void()>
    opAIntSAsync(const AIntS& i,
                 ::std::function<void(::Test::AIntS, ::Test::AIntS)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpAIntSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpAIntSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAIntS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opAIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAIntSResult>>&, const AIntS&, const ::Ice::Context&);
    /// \endcond

    LIntS opLIntS(const LIntS& i, LIntS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLIntSResult>(true, this, &MyClassPrx::_iceI_opLIntS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLIntSAsync(const LIntS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLIntSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLIntSResult, P>(false, this, &MyClassPrx::_iceI_opLIntS, i, context);
    }

    ::std::function<void()>
    opLIntSAsync(const LIntS& i,
                 ::std::function<void(::Test::LIntS, ::Test::LIntS)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLIntSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLIntSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLIntS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLIntSResult>>&, const LIntS&, const ::Ice::Context&);
    /// \endcond

    KIntS opKIntS(const KIntS& i, KIntS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpKIntSResult>(true, this, &MyClassPrx::_iceI_opKIntS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opKIntSAsync(const KIntS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpKIntSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpKIntSResult, P>(false, this, &MyClassPrx::_iceI_opKIntS, i, context);
    }

    ::std::function<void()>
    opKIntSAsync(const KIntS& i,
                 ::std::function<void(::Test::KIntS, ::Test::KIntS)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpKIntSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpKIntSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKIntS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opKIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKIntSResult>>&, const KIntS&, const ::Ice::Context&);
    /// \endcond

    QIntS opQIntS(const QIntS& i, QIntS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpQIntSResult>(true, this, &MyClassPrx::_iceI_opQIntS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opQIntSAsync(const QIntS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpQIntSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpQIntSResult, P>(false, this, &MyClassPrx::_iceI_opQIntS, i, context);
    }

    ::std::function<void()>
    opQIntSAsync(const QIntS& i,
                 ::std::function<void(::Test::QIntS, ::Test::QIntS)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpQIntSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpQIntSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQIntS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opQIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQIntSResult>>&, const QIntS&, const ::Ice::Context&);
    /// \endcond

    SIntS opSIntS(const SIntS& i, SIntS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSIntSResult>(true, this, &MyClassPrx::_iceI_opSIntS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSIntSAsync(const SIntS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSIntSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSIntSResult, P>(false, this, &MyClassPrx::_iceI_opSIntS, i, context);
    }

    ::std::function<void()>
    opSIntSAsync(const SIntS& i,
                 ::std::function<void(::Test::SIntS, ::Test::SIntS)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSIntSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSIntSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSIntS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSIntSResult>>&, const SIntS&, const ::Ice::Context&);
    /// \endcond

    ALongS opALongS(const ALongS& i, ALongS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpALongSResult>(true, this, &MyClassPrx::_iceI_opALongS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opALongSAsync(const ALongS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpALongSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpALongSResult, P>(false, this, &MyClassPrx::_iceI_opALongS, i, context);
    }

    ::std::function<void()>
    opALongSAsync(const ALongS& i,
                  ::std::function<void(::Test::ALongS, ::Test::ALongS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpALongSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpALongSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opALongS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opALongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpALongSResult>>&, const ALongS&, const ::Ice::Context&);
    /// \endcond

    LLongS opLLongS(const LLongS& i, LLongS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLLongSResult>(true, this, &MyClassPrx::_iceI_opLLongS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLLongSAsync(const LLongS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLLongSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLLongSResult, P>(false, this, &MyClassPrx::_iceI_opLLongS, i, context);
    }

    ::std::function<void()>
    opLLongSAsync(const LLongS& i,
                  ::std::function<void(::Test::LLongS, ::Test::LLongS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLLongSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLLongSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLLongS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLLongSResult>>&, const LLongS&, const ::Ice::Context&);
    /// \endcond

    KLongS opKLongS(const KLongS& i, KLongS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpKLongSResult>(true, this, &MyClassPrx::_iceI_opKLongS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opKLongSAsync(const KLongS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpKLongSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpKLongSResult, P>(false, this, &MyClassPrx::_iceI_opKLongS, i, context);
    }

    ::std::function<void()>
    opKLongSAsync(const KLongS& i,
                  ::std::function<void(::Test::KLongS, ::Test::KLongS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpKLongSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpKLongSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKLongS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opKLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKLongSResult>>&, const KLongS&, const ::Ice::Context&);
    /// \endcond

    QLongS opQLongS(const QLongS& i, QLongS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpQLongSResult>(true, this, &MyClassPrx::_iceI_opQLongS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opQLongSAsync(const QLongS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpQLongSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpQLongSResult, P>(false, this, &MyClassPrx::_iceI_opQLongS, i, context);
    }

    ::std::function<void()>
    opQLongSAsync(const QLongS& i,
                  ::std::function<void(::Test::QLongS, ::Test::QLongS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpQLongSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpQLongSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQLongS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opQLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQLongSResult>>&, const QLongS&, const ::Ice::Context&);
    /// \endcond

    SLongS opSLongS(const SLongS& i, SLongS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSLongSResult>(true, this, &MyClassPrx::_iceI_opSLongS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSLongSAsync(const SLongS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSLongSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSLongSResult, P>(false, this, &MyClassPrx::_iceI_opSLongS, i, context);
    }

    ::std::function<void()>
    opSLongSAsync(const SLongS& i,
                  ::std::function<void(::Test::SLongS, ::Test::SLongS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSLongSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSLongSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSLongS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSLongSResult>>&, const SLongS&, const ::Ice::Context&);
    /// \endcond

    AFloatS opAFloatS(const AFloatS& i, AFloatS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpAFloatSResult>(true, this, &MyClassPrx::_iceI_opAFloatS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opAFloatSAsync(const AFloatS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpAFloatSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpAFloatSResult, P>(false, this, &MyClassPrx::_iceI_opAFloatS, i, context);
    }

    ::std::function<void()>
    opAFloatSAsync(const AFloatS& i,
                   ::std::function<void(::Test::AFloatS, ::Test::AFloatS)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpAFloatSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpAFloatSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAFloatS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opAFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAFloatSResult>>&, const AFloatS&, const ::Ice::Context&);
    /// \endcond

    LFloatS opLFloatS(const LFloatS& i, LFloatS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLFloatSResult>(true, this, &MyClassPrx::_iceI_opLFloatS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLFloatSAsync(const LFloatS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLFloatSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLFloatSResult, P>(false, this, &MyClassPrx::_iceI_opLFloatS, i, context);
    }

    ::std::function<void()>
    opLFloatSAsync(const LFloatS& i,
                   ::std::function<void(::Test::LFloatS, ::Test::LFloatS)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLFloatSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLFloatSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLFloatS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLFloatSResult>>&, const LFloatS&, const ::Ice::Context&);
    /// \endcond

    KFloatS opKFloatS(const KFloatS& i, KFloatS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpKFloatSResult>(true, this, &MyClassPrx::_iceI_opKFloatS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opKFloatSAsync(const KFloatS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpKFloatSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpKFloatSResult, P>(false, this, &MyClassPrx::_iceI_opKFloatS, i, context);
    }

    ::std::function<void()>
    opKFloatSAsync(const KFloatS& i,
                   ::std::function<void(::Test::KFloatS, ::Test::KFloatS)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpKFloatSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpKFloatSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKFloatS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opKFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKFloatSResult>>&, const KFloatS&, const ::Ice::Context&);
    /// \endcond

    QFloatS opQFloatS(const QFloatS& i, QFloatS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpQFloatSResult>(true, this, &MyClassPrx::_iceI_opQFloatS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opQFloatSAsync(const QFloatS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpQFloatSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpQFloatSResult, P>(false, this, &MyClassPrx::_iceI_opQFloatS, i, context);
    }

    ::std::function<void()>
    opQFloatSAsync(const QFloatS& i,
                   ::std::function<void(::Test::QFloatS, ::Test::QFloatS)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpQFloatSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpQFloatSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQFloatS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opQFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQFloatSResult>>&, const QFloatS&, const ::Ice::Context&);
    /// \endcond

    SFloatS opSFloatS(const SFloatS& i, SFloatS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSFloatSResult>(true, this, &MyClassPrx::_iceI_opSFloatS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSFloatSAsync(const SFloatS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSFloatSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSFloatSResult, P>(false, this, &MyClassPrx::_iceI_opSFloatS, i, context);
    }

    ::std::function<void()>
    opSFloatSAsync(const SFloatS& i,
                   ::std::function<void(::Test::SFloatS, ::Test::SFloatS)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSFloatSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSFloatSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSFloatS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSFloatSResult>>&, const SFloatS&, const ::Ice::Context&);
    /// \endcond

    ADoubleS opADoubleS(const ADoubleS& i, ADoubleS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpADoubleSResult>(true, this, &MyClassPrx::_iceI_opADoubleS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opADoubleSAsync(const ADoubleS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpADoubleSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpADoubleSResult, P>(false, this, &MyClassPrx::_iceI_opADoubleS, i, context);
    }

    ::std::function<void()>
    opADoubleSAsync(const ADoubleS& i,
                    ::std::function<void(::Test::ADoubleS, ::Test::ADoubleS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpADoubleSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpADoubleSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opADoubleS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opADoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpADoubleSResult>>&, const ADoubleS&, const ::Ice::Context&);
    /// \endcond

    LDoubleS opLDoubleS(const LDoubleS& i, LDoubleS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLDoubleSResult>(true, this, &MyClassPrx::_iceI_opLDoubleS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLDoubleSAsync(const LDoubleS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLDoubleSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLDoubleSResult, P>(false, this, &MyClassPrx::_iceI_opLDoubleS, i, context);
    }

    ::std::function<void()>
    opLDoubleSAsync(const LDoubleS& i,
                    ::std::function<void(::Test::LDoubleS, ::Test::LDoubleS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLDoubleSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLDoubleSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLDoubleS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLDoubleSResult>>&, const LDoubleS&, const ::Ice::Context&);
    /// \endcond

    KDoubleS opKDoubleS(const KDoubleS& i, KDoubleS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpKDoubleSResult>(true, this, &MyClassPrx::_iceI_opKDoubleS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opKDoubleSAsync(const KDoubleS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpKDoubleSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpKDoubleSResult, P>(false, this, &MyClassPrx::_iceI_opKDoubleS, i, context);
    }

    ::std::function<void()>
    opKDoubleSAsync(const KDoubleS& i,
                    ::std::function<void(::Test::KDoubleS, ::Test::KDoubleS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpKDoubleSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpKDoubleSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKDoubleS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opKDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKDoubleSResult>>&, const KDoubleS&, const ::Ice::Context&);
    /// \endcond

    QDoubleS opQDoubleS(const QDoubleS& i, QDoubleS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpQDoubleSResult>(true, this, &MyClassPrx::_iceI_opQDoubleS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opQDoubleSAsync(const QDoubleS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpQDoubleSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpQDoubleSResult, P>(false, this, &MyClassPrx::_iceI_opQDoubleS, i, context);
    }

    ::std::function<void()>
    opQDoubleSAsync(const QDoubleS& i,
                    ::std::function<void(::Test::QDoubleS, ::Test::QDoubleS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpQDoubleSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpQDoubleSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQDoubleS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opQDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQDoubleSResult>>&, const QDoubleS&, const ::Ice::Context&);
    /// \endcond

    SDoubleS opSDoubleS(const SDoubleS& i, SDoubleS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSDoubleSResult>(true, this, &MyClassPrx::_iceI_opSDoubleS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSDoubleSAsync(const SDoubleS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSDoubleSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSDoubleSResult, P>(false, this, &MyClassPrx::_iceI_opSDoubleS, i, context);
    }

    ::std::function<void()>
    opSDoubleSAsync(const SDoubleS& i,
                    ::std::function<void(::Test::SDoubleS, ::Test::SDoubleS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSDoubleSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSDoubleSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSDoubleS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSDoubleSResult>>&, const SDoubleS&, const ::Ice::Context&);
    /// \endcond

    AStringS opAStringS(const AStringS& i, AStringS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpAStringSResult>(true, this, &MyClassPrx::_iceI_opAStringS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opAStringSAsync(const AStringS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpAStringSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpAStringSResult, P>(false, this, &MyClassPrx::_iceI_opAStringS, i, context);
    }

    ::std::function<void()>
    opAStringSAsync(const AStringS& i,
                    ::std::function<void(::Test::AStringS, ::Test::AStringS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpAStringSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpAStringSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAStringS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opAStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAStringSResult>>&, const AStringS&, const ::Ice::Context&);
    /// \endcond

    LStringS opLStringS(const LStringS& i, LStringS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLStringSResult>(true, this, &MyClassPrx::_iceI_opLStringS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLStringSAsync(const LStringS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLStringSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLStringSResult, P>(false, this, &MyClassPrx::_iceI_opLStringS, i, context);
    }

    ::std::function<void()>
    opLStringSAsync(const LStringS& i,
                    ::std::function<void(::Test::LStringS, ::Test::LStringS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLStringSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLStringSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLStringS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLStringSResult>>&, const LStringS&, const ::Ice::Context&);
    /// \endcond

    KStringS opKStringS(const KStringS& i, KStringS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpKStringSResult>(true, this, &MyClassPrx::_iceI_opKStringS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opKStringSAsync(const KStringS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpKStringSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpKStringSResult, P>(false, this, &MyClassPrx::_iceI_opKStringS, i, context);
    }

    ::std::function<void()>
    opKStringSAsync(const KStringS& i,
                    ::std::function<void(::Test::KStringS, ::Test::KStringS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpKStringSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpKStringSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKStringS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opKStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKStringSResult>>&, const KStringS&, const ::Ice::Context&);
    /// \endcond

    QStringS opQStringS(const QStringS& i, QStringS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpQStringSResult>(true, this, &MyClassPrx::_iceI_opQStringS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opQStringSAsync(const QStringS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpQStringSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpQStringSResult, P>(false, this, &MyClassPrx::_iceI_opQStringS, i, context);
    }

    ::std::function<void()>
    opQStringSAsync(const QStringS& i,
                    ::std::function<void(::Test::QStringS, ::Test::QStringS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpQStringSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpQStringSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQStringS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opQStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQStringSResult>>&, const QStringS&, const ::Ice::Context&);
    /// \endcond

    SStringS opSStringS(const SStringS& i, SStringS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSStringSResult>(true, this, &MyClassPrx::_iceI_opSStringS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSStringSAsync(const SStringS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSStringSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSStringSResult, P>(false, this, &MyClassPrx::_iceI_opSStringS, i, context);
    }

    ::std::function<void()>
    opSStringSAsync(const SStringS& i,
                    ::std::function<void(::Test::SStringS, ::Test::SStringS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSStringSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSStringSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSStringS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSStringSResult>>&, const SStringS&, const ::Ice::Context&);
    /// \endcond

    AObjectS opAObjectS(const AObjectS& i, AObjectS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpAObjectSResult>(true, this, &MyClassPrx::_iceI_opAObjectS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opAObjectSAsync(const AObjectS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpAObjectSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpAObjectSResult, P>(false, this, &MyClassPrx::_iceI_opAObjectS, i, context);
    }

    ::std::function<void()>
    opAObjectSAsync(const AObjectS& i,
                    ::std::function<void(::Test::AObjectS, ::Test::AObjectS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpAObjectSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpAObjectSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAObjectS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opAObjectS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAObjectSResult>>&, const AObjectS&, const ::Ice::Context&);
    /// \endcond

    LObjectS opLObjectS(const LObjectS& i, LObjectS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLObjectSResult>(true, this, &MyClassPrx::_iceI_opLObjectS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLObjectSAsync(const LObjectS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLObjectSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLObjectSResult, P>(false, this, &MyClassPrx::_iceI_opLObjectS, i, context);
    }

    ::std::function<void()>
    opLObjectSAsync(const LObjectS& i,
                    ::std::function<void(::Test::LObjectS, ::Test::LObjectS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLObjectSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLObjectSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLObjectS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLObjectS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLObjectSResult>>&, const LObjectS&, const ::Ice::Context&);
    /// \endcond

    AObjectPrxS opAObjectPrxS(const AObjectPrxS& i, AObjectPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpAObjectPrxSResult>(true, this, &MyClassPrx::_iceI_opAObjectPrxS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opAObjectPrxSAsync(const AObjectPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpAObjectPrxSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpAObjectPrxSResult, P>(false, this, &MyClassPrx::_iceI_opAObjectPrxS, i, context);
    }

    ::std::function<void()>
    opAObjectPrxSAsync(const AObjectPrxS& i,
                       ::std::function<void(::Test::AObjectPrxS, ::Test::AObjectPrxS)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpAObjectPrxSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpAObjectPrxSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAObjectPrxS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opAObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAObjectPrxSResult>>&, const AObjectPrxS&, const ::Ice::Context&);
    /// \endcond

    LObjectPrxS opLObjectPrxS(const LObjectPrxS& i, LObjectPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLObjectPrxSResult>(true, this, &MyClassPrx::_iceI_opLObjectPrxS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLObjectPrxSAsync(const LObjectPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLObjectPrxSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLObjectPrxSResult, P>(false, this, &MyClassPrx::_iceI_opLObjectPrxS, i, context);
    }

    ::std::function<void()>
    opLObjectPrxSAsync(const LObjectPrxS& i,
                       ::std::function<void(::Test::LObjectPrxS, ::Test::LObjectPrxS)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLObjectPrxSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLObjectPrxSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLObjectPrxS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLObjectPrxSResult>>&, const LObjectPrxS&, const ::Ice::Context&);
    /// \endcond

    KObjectPrxS opKObjectPrxS(const KObjectPrxS& i, KObjectPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpKObjectPrxSResult>(true, this, &MyClassPrx::_iceI_opKObjectPrxS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opKObjectPrxSAsync(const KObjectPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpKObjectPrxSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpKObjectPrxSResult, P>(false, this, &MyClassPrx::_iceI_opKObjectPrxS, i, context);
    }

    ::std::function<void()>
    opKObjectPrxSAsync(const KObjectPrxS& i,
                       ::std::function<void(::Test::KObjectPrxS, ::Test::KObjectPrxS)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpKObjectPrxSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpKObjectPrxSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKObjectPrxS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opKObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKObjectPrxSResult>>&, const KObjectPrxS&, const ::Ice::Context&);
    /// \endcond

    QObjectPrxS opQObjectPrxS(const QObjectPrxS& i, QObjectPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpQObjectPrxSResult>(true, this, &MyClassPrx::_iceI_opQObjectPrxS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opQObjectPrxSAsync(const QObjectPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpQObjectPrxSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpQObjectPrxSResult, P>(false, this, &MyClassPrx::_iceI_opQObjectPrxS, i, context);
    }

    ::std::function<void()>
    opQObjectPrxSAsync(const QObjectPrxS& i,
                       ::std::function<void(::Test::QObjectPrxS, ::Test::QObjectPrxS)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpQObjectPrxSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpQObjectPrxSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQObjectPrxS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opQObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQObjectPrxSResult>>&, const QObjectPrxS&, const ::Ice::Context&);
    /// \endcond

    SObjectPrxS opSObjectPrxS(const SObjectPrxS& i, SObjectPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSObjectPrxSResult>(true, this, &MyClassPrx::_iceI_opSObjectPrxS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSObjectPrxSAsync(const SObjectPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSObjectPrxSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSObjectPrxSResult, P>(false, this, &MyClassPrx::_iceI_opSObjectPrxS, i, context);
    }

    ::std::function<void()>
    opSObjectPrxSAsync(const SObjectPrxS& i,
                       ::std::function<void(::Test::SObjectPrxS, ::Test::SObjectPrxS)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSObjectPrxSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSObjectPrxSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSObjectPrxS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSObjectPrxSResult>>&, const SObjectPrxS&, const ::Ice::Context&);
    /// \endcond

    AStructS opAStructS(const AStructS& i, AStructS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpAStructSResult>(true, this, &MyClassPrx::_iceI_opAStructS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opAStructSAsync(const AStructS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpAStructSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpAStructSResult, P>(false, this, &MyClassPrx::_iceI_opAStructS, i, context);
    }

    ::std::function<void()>
    opAStructSAsync(const AStructS& i,
                    ::std::function<void(::Test::AStructS, ::Test::AStructS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpAStructSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpAStructSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAStructS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opAStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAStructSResult>>&, const AStructS&, const ::Ice::Context&);
    /// \endcond

    LStructS opLStructS(const LStructS& i, LStructS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLStructSResult>(true, this, &MyClassPrx::_iceI_opLStructS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLStructSAsync(const LStructS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLStructSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLStructSResult, P>(false, this, &MyClassPrx::_iceI_opLStructS, i, context);
    }

    ::std::function<void()>
    opLStructSAsync(const LStructS& i,
                    ::std::function<void(::Test::LStructS, ::Test::LStructS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLStructSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLStructSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLStructS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLStructSResult>>&, const LStructS&, const ::Ice::Context&);
    /// \endcond

    KStructS opKStructS(const KStructS& i, KStructS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpKStructSResult>(true, this, &MyClassPrx::_iceI_opKStructS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opKStructSAsync(const KStructS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpKStructSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpKStructSResult, P>(false, this, &MyClassPrx::_iceI_opKStructS, i, context);
    }

    ::std::function<void()>
    opKStructSAsync(const KStructS& i,
                    ::std::function<void(::Test::KStructS, ::Test::KStructS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpKStructSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpKStructSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKStructS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opKStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKStructSResult>>&, const KStructS&, const ::Ice::Context&);
    /// \endcond

    QStructS opQStructS(const QStructS& i, QStructS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpQStructSResult>(true, this, &MyClassPrx::_iceI_opQStructS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opQStructSAsync(const QStructS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpQStructSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpQStructSResult, P>(false, this, &MyClassPrx::_iceI_opQStructS, i, context);
    }

    ::std::function<void()>
    opQStructSAsync(const QStructS& i,
                    ::std::function<void(::Test::QStructS, ::Test::QStructS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpQStructSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpQStructSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQStructS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opQStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQStructSResult>>&, const QStructS&, const ::Ice::Context&);
    /// \endcond

    SStructS opSStructS(const SStructS& i, SStructS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSStructSResult>(true, this, &MyClassPrx::_iceI_opSStructS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSStructSAsync(const SStructS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSStructSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSStructSResult, P>(false, this, &MyClassPrx::_iceI_opSStructS, i, context);
    }

    ::std::function<void()>
    opSStructSAsync(const SStructS& i,
                    ::std::function<void(::Test::SStructS, ::Test::SStructS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSStructSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSStructSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSStructS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSStructSResult>>&, const SStructS&, const ::Ice::Context&);
    /// \endcond

    AStructSD opAStructSD(const AStructSD& i, AStructSD& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpAStructSDResult>(true, this, &MyClassPrx::_iceI_opAStructSD, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opAStructSDAsync(const AStructSD& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpAStructSDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpAStructSDResult, P>(false, this, &MyClassPrx::_iceI_opAStructSD, i, context);
    }

    ::std::function<void()>
    opAStructSDAsync(const AStructSD& i,
                     ::std::function<void(::Test::AStructSD, ::Test::AStructSD)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpAStructSDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpAStructSDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAStructSD, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opAStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAStructSDResult>>&, const AStructSD&, const ::Ice::Context&);
    /// \endcond

    LStructSD opLStructSD(const LStructSD& i, LStructSD& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLStructSDResult>(true, this, &MyClassPrx::_iceI_opLStructSD, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLStructSDAsync(const LStructSD& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLStructSDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLStructSDResult, P>(false, this, &MyClassPrx::_iceI_opLStructSD, i, context);
    }

    ::std::function<void()>
    opLStructSDAsync(const LStructSD& i,
                     ::std::function<void(::Test::LStructSD, ::Test::LStructSD)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLStructSDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLStructSDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLStructSD, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLStructSDResult>>&, const LStructSD&, const ::Ice::Context&);
    /// \endcond

    KStructSD opKStructSD(const KStructSD& i, KStructSD& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpKStructSDResult>(true, this, &MyClassPrx::_iceI_opKStructSD, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opKStructSDAsync(const KStructSD& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpKStructSDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpKStructSDResult, P>(false, this, &MyClassPrx::_iceI_opKStructSD, i, context);
    }

    ::std::function<void()>
    opKStructSDAsync(const KStructSD& i,
                     ::std::function<void(::Test::KStructSD, ::Test::KStructSD)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpKStructSDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpKStructSDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKStructSD, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opKStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKStructSDResult>>&, const KStructSD&, const ::Ice::Context&);
    /// \endcond

    QStructSD opQStructSD(const QStructSD& i, QStructSD& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpQStructSDResult>(true, this, &MyClassPrx::_iceI_opQStructSD, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opQStructSDAsync(const QStructSD& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpQStructSDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpQStructSDResult, P>(false, this, &MyClassPrx::_iceI_opQStructSD, i, context);
    }

    ::std::function<void()>
    opQStructSDAsync(const QStructSD& i,
                     ::std::function<void(::Test::QStructSD, ::Test::QStructSD)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpQStructSDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpQStructSDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQStructSD, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opQStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQStructSDResult>>&, const QStructSD&, const ::Ice::Context&);
    /// \endcond

    SStructSD opSStructSD(const SStructSD& i, SStructSD& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSStructSDResult>(true, this, &MyClassPrx::_iceI_opSStructSD, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSStructSDAsync(const SStructSD& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSStructSDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSStructSDResult, P>(false, this, &MyClassPrx::_iceI_opSStructSD, i, context);
    }

    ::std::function<void()>
    opSStructSDAsync(const SStructSD& i,
                     ::std::function<void(::Test::SStructSD, ::Test::SStructSD)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSStructSDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSStructSDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSStructSD, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSStructSDResult>>&, const SStructSD&, const ::Ice::Context&);
    /// \endcond

    ACVS opACVS(const ACVS& i, ACVS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpACVSResult>(true, this, &MyClassPrx::_iceI_opACVS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opACVSAsync(const ACVS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpACVSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpACVSResult, P>(false, this, &MyClassPrx::_iceI_opACVS, i, context);
    }

    ::std::function<void()>
    opACVSAsync(const ACVS& i,
                ::std::function<void(::Test::ACVS, ::Test::ACVS)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpACVSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpACVSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opACVS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opACVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpACVSResult>>&, const ACVS&, const ::Ice::Context&);
    /// \endcond

    LCVS opLCVS(const LCVS& i, LCVS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLCVSResult>(true, this, &MyClassPrx::_iceI_opLCVS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLCVSAsync(const LCVS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLCVSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLCVSResult, P>(false, this, &MyClassPrx::_iceI_opLCVS, i, context);
    }

    ::std::function<void()>
    opLCVSAsync(const LCVS& i,
                ::std::function<void(::Test::LCVS, ::Test::LCVS)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLCVSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLCVSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLCVS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLCVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLCVSResult>>&, const LCVS&, const ::Ice::Context&);
    /// \endcond

    ACRS opACRS(const ACRS& i, ACRS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpACRSResult>(true, this, &MyClassPrx::_iceI_opACRS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opACRSAsync(const ACRS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpACRSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpACRSResult, P>(false, this, &MyClassPrx::_iceI_opACRS, i, context);
    }

    ::std::function<void()>
    opACRSAsync(const ACRS& i,
                ::std::function<void(::Test::ACRS, ::Test::ACRS)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpACRSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpACRSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opACRS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opACRS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpACRSResult>>&, const ACRS&, const ::Ice::Context&);
    /// \endcond

    LCRS opLCRS(const LCRS& i, LCRS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLCRSResult>(true, this, &MyClassPrx::_iceI_opLCRS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLCRSAsync(const LCRS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLCRSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLCRSResult, P>(false, this, &MyClassPrx::_iceI_opLCRS, i, context);
    }

    ::std::function<void()>
    opLCRSAsync(const LCRS& i,
                ::std::function<void(::Test::LCRS, ::Test::LCRS)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLCRSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLCRSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLCRS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLCRS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLCRSResult>>&, const LCRS&, const ::Ice::Context&);
    /// \endcond

    AEnS opAEnS(const AEnS& i, AEnS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpAEnSResult>(true, this, &MyClassPrx::_iceI_opAEnS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opAEnSAsync(const AEnS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpAEnSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpAEnSResult, P>(false, this, &MyClassPrx::_iceI_opAEnS, i, context);
    }

    ::std::function<void()>
    opAEnSAsync(const AEnS& i,
                ::std::function<void(::Test::AEnS, ::Test::AEnS)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpAEnSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpAEnSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAEnS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opAEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAEnSResult>>&, const AEnS&, const ::Ice::Context&);
    /// \endcond

    LEnS opLEnS(const LEnS& i, LEnS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLEnSResult>(true, this, &MyClassPrx::_iceI_opLEnS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLEnSAsync(const LEnS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLEnSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLEnSResult, P>(false, this, &MyClassPrx::_iceI_opLEnS, i, context);
    }

    ::std::function<void()>
    opLEnSAsync(const LEnS& i,
                ::std::function<void(::Test::LEnS, ::Test::LEnS)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLEnSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLEnSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLEnS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLEnSResult>>&, const LEnS&, const ::Ice::Context&);
    /// \endcond

    KEnS opKEnS(const KEnS& i, KEnS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpKEnSResult>(true, this, &MyClassPrx::_iceI_opKEnS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opKEnSAsync(const KEnS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpKEnSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpKEnSResult, P>(false, this, &MyClassPrx::_iceI_opKEnS, i, context);
    }

    ::std::function<void()>
    opKEnSAsync(const KEnS& i,
                ::std::function<void(::Test::KEnS, ::Test::KEnS)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpKEnSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpKEnSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKEnS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opKEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKEnSResult>>&, const KEnS&, const ::Ice::Context&);
    /// \endcond

    QEnS opQEnS(const QEnS& i, QEnS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpQEnSResult>(true, this, &MyClassPrx::_iceI_opQEnS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opQEnSAsync(const QEnS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpQEnSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpQEnSResult, P>(false, this, &MyClassPrx::_iceI_opQEnS, i, context);
    }

    ::std::function<void()>
    opQEnSAsync(const QEnS& i,
                ::std::function<void(::Test::QEnS, ::Test::QEnS)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpQEnSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpQEnSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQEnS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opQEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQEnSResult>>&, const QEnS&, const ::Ice::Context&);
    /// \endcond

    SEnS opSEnS(const SEnS& i, SEnS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSEnSResult>(true, this, &MyClassPrx::_iceI_opSEnS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSEnSAsync(const SEnS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSEnSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSEnSResult, P>(false, this, &MyClassPrx::_iceI_opSEnS, i, context);
    }

    ::std::function<void()>
    opSEnSAsync(const SEnS& i,
                ::std::function<void(::Test::SEnS, ::Test::SEnS)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSEnSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSEnSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSEnS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSEnSResult>>&, const SEnS&, const ::Ice::Context&);
    /// \endcond

    AIPrxS opAIPrxS(const AIPrxS& i, AIPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpAIPrxSResult>(true, this, &MyClassPrx::_iceI_opAIPrxS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opAIPrxSAsync(const AIPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpAIPrxSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpAIPrxSResult, P>(false, this, &MyClassPrx::_iceI_opAIPrxS, i, context);
    }

    ::std::function<void()>
    opAIPrxSAsync(const AIPrxS& i,
                  ::std::function<void(::Test::AIPrxS, ::Test::AIPrxS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpAIPrxSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpAIPrxSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAIPrxS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opAIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAIPrxSResult>>&, const AIPrxS&, const ::Ice::Context&);
    /// \endcond

    LIPrxS opLIPrxS(const LIPrxS& i, LIPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLIPrxSResult>(true, this, &MyClassPrx::_iceI_opLIPrxS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLIPrxSAsync(const LIPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLIPrxSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLIPrxSResult, P>(false, this, &MyClassPrx::_iceI_opLIPrxS, i, context);
    }

    ::std::function<void()>
    opLIPrxSAsync(const LIPrxS& i,
                  ::std::function<void(::Test::LIPrxS, ::Test::LIPrxS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLIPrxSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpLIPrxSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLIPrxS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opLIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLIPrxSResult>>&, const LIPrxS&, const ::Ice::Context&);
    /// \endcond

    KIPrxS opKIPrxS(const KIPrxS& i, KIPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpKIPrxSResult>(true, this, &MyClassPrx::_iceI_opKIPrxS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opKIPrxSAsync(const KIPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpKIPrxSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpKIPrxSResult, P>(false, this, &MyClassPrx::_iceI_opKIPrxS, i, context);
    }

    ::std::function<void()>
    opKIPrxSAsync(const KIPrxS& i,
                  ::std::function<void(::Test::KIPrxS, ::Test::KIPrxS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpKIPrxSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpKIPrxSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKIPrxS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opKIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKIPrxSResult>>&, const KIPrxS&, const ::Ice::Context&);
    /// \endcond

    QIPrxS opQIPrxS(const QIPrxS& i, QIPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpQIPrxSResult>(true, this, &MyClassPrx::_iceI_opQIPrxS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opQIPrxSAsync(const QIPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpQIPrxSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpQIPrxSResult, P>(false, this, &MyClassPrx::_iceI_opQIPrxS, i, context);
    }

    ::std::function<void()>
    opQIPrxSAsync(const QIPrxS& i,
                  ::std::function<void(::Test::QIPrxS, ::Test::QIPrxS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpQIPrxSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpQIPrxSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQIPrxS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opQIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQIPrxSResult>>&, const QIPrxS&, const ::Ice::Context&);
    /// \endcond

    SIPrxS opSIPrxS(const SIPrxS& i, SIPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSIPrxSResult>(true, this, &MyClassPrx::_iceI_opSIPrxS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSIPrxSAsync(const SIPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSIPrxSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSIPrxSResult, P>(false, this, &MyClassPrx::_iceI_opSIPrxS, i, context);
    }

    ::std::function<void()>
    opSIPrxSAsync(const SIPrxS& i,
                  ::std::function<void(::Test::SIPrxS, ::Test::SIPrxS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSIPrxSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSIPrxSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSIPrxS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSIPrxSResult>>&, const SIPrxS&, const ::Ice::Context&);
    /// \endcond

    CustomIntS opCustomIntS(const CustomIntS& i, CustomIntS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpCustomIntSResult>(true, this, &MyClassPrx::_iceI_opCustomIntS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCustomIntSAsync(const CustomIntS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpCustomIntSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpCustomIntSResult, P>(false, this, &MyClassPrx::_iceI_opCustomIntS, i, context);
    }

    ::std::function<void()>
    opCustomIntSAsync(const CustomIntS& i,
                      ::std::function<void(::Test::CustomIntS, ::Test::CustomIntS)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpCustomIntSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpCustomIntSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomIntS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opCustomIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpCustomIntSResult>>&, const CustomIntS&, const ::Ice::Context&);
    /// \endcond

    CustomCVS opCustomCVS(const CustomCVS& i, CustomCVS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpCustomCVSResult>(true, this, &MyClassPrx::_iceI_opCustomCVS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCustomCVSAsync(const CustomCVS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpCustomCVSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpCustomCVSResult, P>(false, this, &MyClassPrx::_iceI_opCustomCVS, i, context);
    }

    ::std::function<void()>
    opCustomCVSAsync(const CustomCVS& i,
                     ::std::function<void(::Test::CustomCVS, ::Test::CustomCVS)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpCustomCVSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpCustomCVSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomCVS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opCustomCVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpCustomCVSResult>>&, const CustomCVS&, const ::Ice::Context&);
    /// \endcond

    CustomIntSS opCustomIntSS(const CustomIntSS& i, CustomIntSS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpCustomIntSSResult>(true, this, &MyClassPrx::_iceI_opCustomIntSS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCustomIntSSAsync(const CustomIntSS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpCustomIntSSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpCustomIntSSResult, P>(false, this, &MyClassPrx::_iceI_opCustomIntSS, i, context);
    }

    ::std::function<void()>
    opCustomIntSSAsync(const CustomIntSS& i,
                       ::std::function<void(::Test::CustomIntSS, ::Test::CustomIntSS)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpCustomIntSSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpCustomIntSSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomIntSS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opCustomIntSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpCustomIntSSResult>>&, const CustomIntSS&, const ::Ice::Context&);
    /// \endcond

    CustomCVSS opCustomCVSS(const CustomCVSS& i, CustomCVSS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpCustomCVSSResult>(true, this, &MyClassPrx::_iceI_opCustomCVSS, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCustomCVSSAsync(const CustomCVSS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpCustomCVSSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpCustomCVSSResult, P>(false, this, &MyClassPrx::_iceI_opCustomCVSS, i, context);
    }

    ::std::function<void()>
    opCustomCVSSAsync(const CustomCVSS& i,
                      ::std::function<void(::Test::CustomCVSS, ::Test::CustomCVSS)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpCustomCVSSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpCustomCVSSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomCVSS, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opCustomCVSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpCustomCVSSResult>>&, const CustomCVSS&, const ::Ice::Context&);
    /// \endcond

    SerialSmall opSerialSmallCSharp(const SerialSmall& i, SerialSmall& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSerialSmallCSharpResult>(true, this, &MyClassPrx::_iceI_opSerialSmallCSharp, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSerialSmallCSharpAsync(const SerialSmall& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSerialSmallCSharpResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSerialSmallCSharpResult, P>(false, this, &MyClassPrx::_iceI_opSerialSmallCSharp, i, context);
    }

    ::std::function<void()>
    opSerialSmallCSharpAsync(const SerialSmall& i,
                             ::std::function<void(::Test::SerialSmall, ::Test::SerialSmall)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSerialSmallCSharpResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSerialSmallCSharpResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSerialSmallCSharp, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSerialSmallCSharp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSerialSmallCSharpResult>>&, const SerialSmall&, const ::Ice::Context&);
    /// \endcond

    SerialLarge opSerialLargeCSharp(const SerialLarge& i, SerialLarge& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSerialLargeCSharpResult>(true, this, &MyClassPrx::_iceI_opSerialLargeCSharp, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSerialLargeCSharpAsync(const SerialLarge& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSerialLargeCSharpResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSerialLargeCSharpResult, P>(false, this, &MyClassPrx::_iceI_opSerialLargeCSharp, i, context);
    }

    ::std::function<void()>
    opSerialLargeCSharpAsync(const SerialLarge& i,
                             ::std::function<void(::Test::SerialLarge, ::Test::SerialLarge)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSerialLargeCSharpResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSerialLargeCSharpResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSerialLargeCSharp, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSerialLargeCSharp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSerialLargeCSharpResult>>&, const SerialLarge&, const ::Ice::Context&);
    /// \endcond

    SerialStruct opSerialStructCSharp(const SerialStruct& i, SerialStruct& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpSerialStructCSharpResult>(true, this, &MyClassPrx::_iceI_opSerialStructCSharp, i, context).get();
        o = ::std::move(_result.o);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSerialStructCSharpAsync(const SerialStruct& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpSerialStructCSharpResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpSerialStructCSharpResult, P>(false, this, &MyClassPrx::_iceI_opSerialStructCSharp, i, context);
    }

    ::std::function<void()>
    opSerialStructCSharpAsync(const SerialStruct& i,
                              ::std::function<void(::Test::SerialStruct, ::Test::SerialStruct)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpSerialStructCSharpResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.o));
        };
        return _makeLamdaOutgoing<MyClass::OpSerialStructCSharpResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSerialStructCSharp, i, context);
    }

    /// \cond INTERNAL
    void _iceI_opSerialStructCSharp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSerialStructCSharpResult>>&, const SerialStruct&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    MyClassPrx() = default;
    friend ::std::shared_ptr<MyClassPrx> IceInternal::createProxy<MyClassPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::S, S>
{
    static void read(S* istr, ::Test::S& v)
    {
        istr->readAll(v.i);
    }
};

template<>
struct StreamableTraits<::Test::SD>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::SD, S>
{
    static void read(S* istr, ::Test::SD& v)
    {
        istr->readAll(v.i);
    }
};

template<typename S>
struct StreamReader<::Test::CV, S>
{
    static void read(S* istr, ::Test::CV& v)
    {
        istr->readAll(v.i);
    }
};

template<typename S>
struct StreamReader<::Test::CR, S>
{
    static void read(S* istr, ::Test::CR& v)
    {
        istr->readAll(v.v);
    }
};

template<>
struct StreamableTraits< ::Test::En>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using CVPtr = ::std::shared_ptr<CV>;

using IPtr = ::std::shared_ptr<I>;
using IPrxPtr = ::std::shared_ptr<IPrx>;

using CRPtr = ::std::shared_ptr<CR>;

using MyClassPtr = ::std::shared_ptr<MyClass>;
using MyClassPrxPtr = ::std::shared_ptr<MyClassPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class CV;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< CV>&);
::IceProxy::Ice::Object* upCast(CV*);
/// \endcond

class I;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< I>&);
::IceProxy::Ice::Object* upCast(I*);
/// \endcond

class CR;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< CR>&);
::IceProxy::Ice::Object* upCast(CR*);
/// \endcond

class MyClass;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< MyClass>&);
::IceProxy::Ice::Object* upCast(MyClass*);
/// \endcond

}

}

namespace Test
{

class CV;
/// \cond INTERNAL
::Ice::Object* upCast(CV*);
/// \endcond
typedef ::IceInternal::Handle< CV> CVPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::CV> CVPrx;
typedef CVPrx CVPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CVPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class I;
/// \cond INTERNAL
::Ice::Object* upCast(I*);
/// \endcond
typedef ::IceInternal::Handle< I> IPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::I> IPrx;
typedef IPrx IPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(IPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class CR;
/// \cond INTERNAL
::Ice::Object* upCast(CR*);
/// \endcond
typedef ::IceInternal::Handle< CR> CRPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::CR> CRPrx;
typedef CRPrx CRPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CRPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class MyClass;
/// \cond INTERNAL
::Ice::Object* upCast(MyClass*);
/// \endcond
typedef ::IceInternal::Handle< MyClass> MyClassPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MyClass> MyClassPrx;
typedef MyClassPrx MyClassPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(MyClassPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Test
{

typedef ::std::vector< ::Ice::Byte> AByteS;

typedef ::std::vector< ::Ice::Byte> LByteS;

typedef ::std::vector< ::Ice::Byte> KByteS;

typedef ::std::vector< ::Ice::Byte> QByteS;

typedef ::std::vector< ::Ice::Byte> SByteS;

typedef ::std::vector<bool> ABoolS;

typedef ::std::vector<bool> LBoolS;

typedef ::std::vector<bool> KBoolS;

typedef ::std::vector<bool> QBoolS;

typedef ::std::vector<bool> SBoolS;

typedef ::std::vector< ::Ice::Short> AShortS;

typedef ::std::vector< ::Ice::Short> LShortS;

typedef ::std::vector< ::Ice::Short> KShortS;

typedef ::std::vector< ::Ice::Short> QShortS;

typedef ::std::vector< ::Ice::Short> SShortS;

typedef ::std::vector< ::Ice::Int> AIntS;

typedef ::std::vector< ::Ice::Int> LIntS;

typedef ::std::vector< ::Ice::Int> KIntS;

typedef ::std::vector< ::Ice::Int> QIntS;

typedef ::std::vector< ::Ice::Int> SIntS;

typedef ::std::vector< ::Ice::Long> ALongS;

typedef ::std::vector< ::Ice::Long> LLongS;

typedef ::std::vector< ::Ice::Long> KLongS;

typedef ::std::vector< ::Ice::Long> QLongS;

typedef ::std::vector< ::Ice::Long> SLongS;

typedef ::std::vector< ::Ice::Float> AFloatS;

typedef ::std::vector< ::Ice::Float> LFloatS;

typedef ::std::vector< ::Ice::Float> KFloatS;

typedef ::std::vector< ::Ice::Float> QFloatS;

typedef ::std::vector< ::Ice::Float> SFloatS;

typedef ::std::vector< ::Ice::Double> ADoubleS;

typedef ::std::vector< ::Ice::Double> LDoubleS;

typedef ::std::vector< ::Ice::Double> KDoubleS;

typedef ::std::vector< ::Ice::Double> QDoubleS;

typedef ::std::vector< ::Ice::Double> SDoubleS;

typedef ::std::vector< ::std::string> AStringS;

typedef ::std::vector< ::std::string> LStringS;

typedef ::std::vector< ::std::string> KStringS;

typedef ::std::vector< ::std::string> QStringS;

typedef ::std::vector< ::std::string> SStringS;

typedef ::std::vector< ::Ice::ObjectPtr> AObjectS;

typedef ::std::vector< ::Ice::ObjectPtr> LObjectS;

typedef ::std::vector< ::Ice::ObjectPrx> AObjectPrxS;

typedef ::std::vector< ::Ice::ObjectPrx> LObjectPrxS;

typedef ::std::vector< ::Ice::ObjectPrx> KObjectPrxS;

typedef ::std::vector< ::Ice::ObjectPrx> QObjectPrxS;

typedef ::std::vector< ::Ice::ObjectPrx> SObjectPrxS;

struct S
{
    ::Ice::Int i;

    bool operator==(const S& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(i != rhs_.i)
        {
            return false;
        }
        return true;
    }

    bool operator<(const S& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(i < rhs_.i)
        {
            return true;
        }
        else if(rhs_.i < i)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const S& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const S& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const S& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const S& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<S> AStructS;

typedef ::std::vector<S> LStructS;

typedef ::std::vector<S> KStructS;

typedef ::std::vector<S> QStructS;

typedef ::std::vector<S> SStructS;

struct SD
{
    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    SD() :
        i(1)
    {
    }
    
    explicit SD(::Ice::Int i) :
        i(i)
    {
    }
    

    ::Ice::Int i;

    bool operator==(const SD& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(i != rhs_.i)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SD& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(i < rhs_.i)
        {
            return true;
        }
        else if(rhs_.i < i)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SD& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const SD& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const SD& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const SD& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<SD> AStructSD;

typedef ::std::vector<SD> LStructSD;

typedef ::std::vector<SD> KStructSD;

typedef ::std::vector<SD> QStructSD;

typedef ::std::vector<SD> SStructSD;

typedef ::std::vector<CVPtr> ACVS;

typedef ::std::vector<CVPtr> LCVS;

typedef ::std::vector<IPrx> AIPrxS;

typedef ::std::vector<IPrx> LIPrxS;

typedef ::std::vector<IPrx> KIPrxS;

typedef ::std::vector<IPrx> QIPrxS;

typedef ::std::vector<IPrx> SIPrxS;

typedef ::std::vector<CRPtr> ACRS;

typedef ::std::vector<CRPtr> LCRS;

enum En
{
    A,
    B,
    C
};

typedef ::std::vector<En> AEnS;

typedef ::std::vector<En> LEnS;

typedef ::std::vector<En> KEnS;

typedef ::std::vector<En> QEnS;

typedef ::std::vector<En> SEnS;

typedef ::std::vector< ::Ice::Int> CustomIntS;

typedef ::std::vector<CVPtr> CustomCVS;

typedef ::std::vector<CustomIntS> CustomIntSS;

typedef ::std::vector<CustomCVS> CustomCVSS;

typedef ::std::vector< ::Ice::Byte> SerialSmall;

typedef ::std::vector< ::Ice::Byte> SerialLarge;

typedef ::std::vector< ::Ice::Byte> SerialStruct;

}

namespace Test
{

/**
 * AMD callback class for Test::MyClass::shutdown_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_shutdown : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_shutdown();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_shutdown> AMD_MyClass_shutdownPtr;

/**
 * AMD callback class for Test::MyClass::opAByteS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opAByteS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opAByteS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const AByteS& result, const AByteS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opAByteS> AMD_MyClass_opAByteSPtr;

/**
 * AMD callback class for Test::MyClass::opLByteS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLByteS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLByteS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LByteS& result, const LByteS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLByteS> AMD_MyClass_opLByteSPtr;

/**
 * AMD callback class for Test::MyClass::opKByteS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opKByteS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opKByteS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const KByteS& result, const KByteS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opKByteS> AMD_MyClass_opKByteSPtr;

/**
 * AMD callback class for Test::MyClass::opQByteS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opQByteS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opQByteS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const QByteS& result, const QByteS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opQByteS> AMD_MyClass_opQByteSPtr;

/**
 * AMD callback class for Test::MyClass::opSByteS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSByteS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSByteS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SByteS& result, const SByteS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSByteS> AMD_MyClass_opSByteSPtr;

/**
 * AMD callback class for Test::MyClass::opABoolS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opABoolS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opABoolS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ABoolS& result, const ABoolS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opABoolS> AMD_MyClass_opABoolSPtr;

/**
 * AMD callback class for Test::MyClass::opLBoolS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLBoolS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLBoolS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LBoolS& result, const LBoolS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLBoolS> AMD_MyClass_opLBoolSPtr;

/**
 * AMD callback class for Test::MyClass::opKBoolS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opKBoolS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opKBoolS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const KBoolS& result, const KBoolS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opKBoolS> AMD_MyClass_opKBoolSPtr;

/**
 * AMD callback class for Test::MyClass::opQBoolS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opQBoolS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opQBoolS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const QBoolS& result, const QBoolS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opQBoolS> AMD_MyClass_opQBoolSPtr;

/**
 * AMD callback class for Test::MyClass::opSBoolS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSBoolS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSBoolS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SBoolS& result, const SBoolS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSBoolS> AMD_MyClass_opSBoolSPtr;

/**
 * AMD callback class for Test::MyClass::opAShortS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opAShortS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opAShortS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const AShortS& result, const AShortS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opAShortS> AMD_MyClass_opAShortSPtr;

/**
 * AMD callback class for Test::MyClass::opLShortS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLShortS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLShortS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LShortS& result, const LShortS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLShortS> AMD_MyClass_opLShortSPtr;

/**
 * AMD callback class for Test::MyClass::opKShortS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opKShortS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opKShortS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const KShortS& result, const KShortS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opKShortS> AMD_MyClass_opKShortSPtr;

/**
 * AMD callback class for Test::MyClass::opQShortS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opQShortS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opQShortS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const QShortS& result, const QShortS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opQShortS> AMD_MyClass_opQShortSPtr;

/**
 * AMD callback class for Test::MyClass::opSShortS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSShortS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSShortS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SShortS& result, const SShortS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSShortS> AMD_MyClass_opSShortSPtr;

/**
 * AMD callback class for Test::MyClass::opAIntS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opAIntS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opAIntS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const AIntS& result, const AIntS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opAIntS> AMD_MyClass_opAIntSPtr;

/**
 * AMD callback class for Test::MyClass::opLIntS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLIntS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLIntS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LIntS& result, const LIntS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLIntS> AMD_MyClass_opLIntSPtr;

/**
 * AMD callback class for Test::MyClass::opKIntS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opKIntS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opKIntS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const KIntS& result, const KIntS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opKIntS> AMD_MyClass_opKIntSPtr;

/**
 * AMD callback class for Test::MyClass::opQIntS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opQIntS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opQIntS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const QIntS& result, const QIntS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opQIntS> AMD_MyClass_opQIntSPtr;

/**
 * AMD callback class for Test::MyClass::opSIntS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSIntS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSIntS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SIntS& result, const SIntS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSIntS> AMD_MyClass_opSIntSPtr;

/**
 * AMD callback class for Test::MyClass::opALongS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opALongS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opALongS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ALongS& result, const ALongS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opALongS> AMD_MyClass_opALongSPtr;

/**
 * AMD callback class for Test::MyClass::opLLongS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLLongS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLLongS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LLongS& result, const LLongS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLLongS> AMD_MyClass_opLLongSPtr;

/**
 * AMD callback class for Test::MyClass::opKLongS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opKLongS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opKLongS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const KLongS& result, const KLongS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opKLongS> AMD_MyClass_opKLongSPtr;

/**
 * AMD callback class for Test::MyClass::opQLongS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opQLongS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opQLongS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const QLongS& result, const QLongS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opQLongS> AMD_MyClass_opQLongSPtr;

/**
 * AMD callback class for Test::MyClass::opSLongS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSLongS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSLongS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SLongS& result, const SLongS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSLongS> AMD_MyClass_opSLongSPtr;

/**
 * AMD callback class for Test::MyClass::opAFloatS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opAFloatS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opAFloatS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const AFloatS& result, const AFloatS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opAFloatS> AMD_MyClass_opAFloatSPtr;

/**
 * AMD callback class for Test::MyClass::opLFloatS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLFloatS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLFloatS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LFloatS& result, const LFloatS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLFloatS> AMD_MyClass_opLFloatSPtr;

/**
 * AMD callback class for Test::MyClass::opKFloatS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opKFloatS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opKFloatS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const KFloatS& result, const KFloatS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opKFloatS> AMD_MyClass_opKFloatSPtr;

/**
 * AMD callback class for Test::MyClass::opQFloatS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opQFloatS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opQFloatS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const QFloatS& result, const QFloatS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opQFloatS> AMD_MyClass_opQFloatSPtr;

/**
 * AMD callback class for Test::MyClass::opSFloatS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSFloatS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSFloatS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SFloatS& result, const SFloatS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSFloatS> AMD_MyClass_opSFloatSPtr;

/**
 * AMD callback class for Test::MyClass::opADoubleS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opADoubleS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opADoubleS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ADoubleS& result, const ADoubleS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opADoubleS> AMD_MyClass_opADoubleSPtr;

/**
 * AMD callback class for Test::MyClass::opLDoubleS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLDoubleS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLDoubleS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LDoubleS& result, const LDoubleS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLDoubleS> AMD_MyClass_opLDoubleSPtr;

/**
 * AMD callback class for Test::MyClass::opKDoubleS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opKDoubleS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opKDoubleS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const KDoubleS& result, const KDoubleS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opKDoubleS> AMD_MyClass_opKDoubleSPtr;

/**
 * AMD callback class for Test::MyClass::opQDoubleS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opQDoubleS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opQDoubleS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const QDoubleS& result, const QDoubleS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opQDoubleS> AMD_MyClass_opQDoubleSPtr;

/**
 * AMD callback class for Test::MyClass::opSDoubleS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSDoubleS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSDoubleS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SDoubleS& result, const SDoubleS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSDoubleS> AMD_MyClass_opSDoubleSPtr;

/**
 * AMD callback class for Test::MyClass::opAStringS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opAStringS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opAStringS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const AStringS& result, const AStringS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opAStringS> AMD_MyClass_opAStringSPtr;

/**
 * AMD callback class for Test::MyClass::opLStringS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLStringS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLStringS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LStringS& result, const LStringS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLStringS> AMD_MyClass_opLStringSPtr;

/**
 * AMD callback class for Test::MyClass::opKStringS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opKStringS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opKStringS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const KStringS& result, const KStringS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opKStringS> AMD_MyClass_opKStringSPtr;

/**
 * AMD callback class for Test::MyClass::opQStringS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opQStringS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opQStringS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const QStringS& result, const QStringS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opQStringS> AMD_MyClass_opQStringSPtr;

/**
 * AMD callback class for Test::MyClass::opSStringS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSStringS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSStringS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SStringS& result, const SStringS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSStringS> AMD_MyClass_opSStringSPtr;

/**
 * AMD callback class for Test::MyClass::opAObjectS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opAObjectS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opAObjectS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const AObjectS& result, const AObjectS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opAObjectS> AMD_MyClass_opAObjectSPtr;

/**
 * AMD callback class for Test::MyClass::opLObjectS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLObjectS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLObjectS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LObjectS& result, const LObjectS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLObjectS> AMD_MyClass_opLObjectSPtr;

/**
 * AMD callback class for Test::MyClass::opAObjectPrxS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opAObjectPrxS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opAObjectPrxS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const AObjectPrxS& result, const AObjectPrxS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opAObjectPrxS> AMD_MyClass_opAObjectPrxSPtr;

/**
 * AMD callback class for Test::MyClass::opLObjectPrxS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLObjectPrxS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLObjectPrxS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LObjectPrxS& result, const LObjectPrxS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLObjectPrxS> AMD_MyClass_opLObjectPrxSPtr;

/**
 * AMD callback class for Test::MyClass::opKObjectPrxS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opKObjectPrxS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opKObjectPrxS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const KObjectPrxS& result, const KObjectPrxS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opKObjectPrxS> AMD_MyClass_opKObjectPrxSPtr;

/**
 * AMD callback class for Test::MyClass::opQObjectPrxS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opQObjectPrxS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opQObjectPrxS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const QObjectPrxS& result, const QObjectPrxS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opQObjectPrxS> AMD_MyClass_opQObjectPrxSPtr;

/**
 * AMD callback class for Test::MyClass::opSObjectPrxS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSObjectPrxS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSObjectPrxS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SObjectPrxS& result, const SObjectPrxS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSObjectPrxS> AMD_MyClass_opSObjectPrxSPtr;

/**
 * AMD callback class for Test::MyClass::opAStructS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opAStructS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opAStructS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const AStructS& result, const AStructS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opAStructS> AMD_MyClass_opAStructSPtr;

/**
 * AMD callback class for Test::MyClass::opLStructS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLStructS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLStructS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LStructS& result, const LStructS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLStructS> AMD_MyClass_opLStructSPtr;

/**
 * AMD callback class for Test::MyClass::opKStructS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opKStructS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opKStructS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const KStructS& result, const KStructS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opKStructS> AMD_MyClass_opKStructSPtr;

/**
 * AMD callback class for Test::MyClass::opQStructS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opQStructS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opQStructS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const QStructS& result, const QStructS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opQStructS> AMD_MyClass_opQStructSPtr;

/**
 * AMD callback class for Test::MyClass::opSStructS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSStructS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSStructS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SStructS& result, const SStructS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSStructS> AMD_MyClass_opSStructSPtr;

/**
 * AMD callback class for Test::MyClass::opAStructSD_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opAStructSD : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opAStructSD();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const AStructSD& result, const AStructSD& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opAStructSD> AMD_MyClass_opAStructSDPtr;

/**
 * AMD callback class for Test::MyClass::opLStructSD_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLStructSD : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLStructSD();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LStructSD& result, const LStructSD& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLStructSD> AMD_MyClass_opLStructSDPtr;

/**
 * AMD callback class for Test::MyClass::opKStructSD_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opKStructSD : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opKStructSD();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const KStructSD& result, const KStructSD& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opKStructSD> AMD_MyClass_opKStructSDPtr;

/**
 * AMD callback class for Test::MyClass::opQStructSD_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opQStructSD : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opQStructSD();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const QStructSD& result, const QStructSD& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opQStructSD> AMD_MyClass_opQStructSDPtr;

/**
 * AMD callback class for Test::MyClass::opSStructSD_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSStructSD : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSStructSD();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SStructSD& result, const SStructSD& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSStructSD> AMD_MyClass_opSStructSDPtr;

/**
 * AMD callback class for Test::MyClass::opACVS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opACVS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opACVS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ACVS& result, const ACVS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opACVS> AMD_MyClass_opACVSPtr;

/**
 * AMD callback class for Test::MyClass::opLCVS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLCVS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLCVS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LCVS& result, const LCVS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLCVS> AMD_MyClass_opLCVSPtr;

/**
 * AMD callback class for Test::MyClass::opACRS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opACRS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opACRS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ACRS& result, const ACRS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opACRS> AMD_MyClass_opACRSPtr;

/**
 * AMD callback class for Test::MyClass::opLCRS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLCRS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLCRS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LCRS& result, const LCRS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLCRS> AMD_MyClass_opLCRSPtr;

/**
 * AMD callback class for Test::MyClass::opAEnS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opAEnS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opAEnS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const AEnS& result, const AEnS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opAEnS> AMD_MyClass_opAEnSPtr;

/**
 * AMD callback class for Test::MyClass::opLEnS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLEnS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLEnS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LEnS& result, const LEnS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLEnS> AMD_MyClass_opLEnSPtr;

/**
 * AMD callback class for Test::MyClass::opKEnS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opKEnS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opKEnS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const KEnS& result, const KEnS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opKEnS> AMD_MyClass_opKEnSPtr;

/**
 * AMD callback class for Test::MyClass::opQEnS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opQEnS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opQEnS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const QEnS& result, const QEnS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opQEnS> AMD_MyClass_opQEnSPtr;

/**
 * AMD callback class for Test::MyClass::opSEnS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSEnS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSEnS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SEnS& result, const SEnS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSEnS> AMD_MyClass_opSEnSPtr;

/**
 * AMD callback class for Test::MyClass::opAIPrxS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opAIPrxS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opAIPrxS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const AIPrxS& result, const AIPrxS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opAIPrxS> AMD_MyClass_opAIPrxSPtr;

/**
 * AMD callback class for Test::MyClass::opLIPrxS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opLIPrxS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opLIPrxS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const LIPrxS& result, const LIPrxS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opLIPrxS> AMD_MyClass_opLIPrxSPtr;

/**
 * AMD callback class for Test::MyClass::opKIPrxS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opKIPrxS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opKIPrxS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const KIPrxS& result, const KIPrxS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opKIPrxS> AMD_MyClass_opKIPrxSPtr;

/**
 * AMD callback class for Test::MyClass::opQIPrxS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opQIPrxS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opQIPrxS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const QIPrxS& result, const QIPrxS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opQIPrxS> AMD_MyClass_opQIPrxSPtr;

/**
 * AMD callback class for Test::MyClass::opSIPrxS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSIPrxS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSIPrxS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SIPrxS& result, const SIPrxS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSIPrxS> AMD_MyClass_opSIPrxSPtr;

/**
 * AMD callback class for Test::MyClass::opCustomIntS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opCustomIntS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opCustomIntS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const CustomIntS& result, const CustomIntS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opCustomIntS> AMD_MyClass_opCustomIntSPtr;

/**
 * AMD callback class for Test::MyClass::opCustomCVS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opCustomCVS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opCustomCVS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const CustomCVS& result, const CustomCVS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opCustomCVS> AMD_MyClass_opCustomCVSPtr;

/**
 * AMD callback class for Test::MyClass::opCustomIntSS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opCustomIntSS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opCustomIntSS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const CustomIntSS& result, const CustomIntSS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opCustomIntSS> AMD_MyClass_opCustomIntSSPtr;

/**
 * AMD callback class for Test::MyClass::opCustomCVSS_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opCustomCVSS : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opCustomCVSS();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const CustomCVSS& result, const CustomCVSS& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opCustomCVSS> AMD_MyClass_opCustomCVSSPtr;

/**
 * AMD callback class for Test::MyClass::opSerialSmallCSharp_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSerialSmallCSharp : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSerialSmallCSharp();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SerialSmall& result, const SerialSmall& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSerialSmallCSharp> AMD_MyClass_opSerialSmallCSharpPtr;

/**
 * AMD callback class for Test::MyClass::opSerialLargeCSharp_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSerialLargeCSharp : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSerialLargeCSharp();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SerialLarge& result, const SerialLarge& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSerialLargeCSharp> AMD_MyClass_opSerialLargeCSharpPtr;

/**
 * AMD callback class for Test::MyClass::opSerialStructCSharp_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_MyClass_opSerialStructCSharp : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_MyClass_opSerialStructCSharp();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const SerialStruct& result, const SerialStruct& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_MyClass_opSerialStructCSharp> AMD_MyClass_opSerialStructCSharpPtr;

}

/// \cond INTERNAL
namespace IceAsync
{

namespace Test
{

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_shutdown : public ::Test::AMD_MyClass_shutdown, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_shutdown(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opAByteS : public ::Test::AMD_MyClass_opAByteS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opAByteS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::AByteS&, const ::Test::AByteS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLByteS : public ::Test::AMD_MyClass_opLByteS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLByteS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LByteS&, const ::Test::LByteS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opKByteS : public ::Test::AMD_MyClass_opKByteS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opKByteS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::KByteS&, const ::Test::KByteS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opQByteS : public ::Test::AMD_MyClass_opQByteS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opQByteS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::QByteS&, const ::Test::QByteS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSByteS : public ::Test::AMD_MyClass_opSByteS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSByteS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SByteS&, const ::Test::SByteS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opABoolS : public ::Test::AMD_MyClass_opABoolS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opABoolS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::ABoolS&, const ::Test::ABoolS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLBoolS : public ::Test::AMD_MyClass_opLBoolS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLBoolS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LBoolS&, const ::Test::LBoolS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opKBoolS : public ::Test::AMD_MyClass_opKBoolS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opKBoolS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::KBoolS&, const ::Test::KBoolS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opQBoolS : public ::Test::AMD_MyClass_opQBoolS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opQBoolS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::QBoolS&, const ::Test::QBoolS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSBoolS : public ::Test::AMD_MyClass_opSBoolS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSBoolS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SBoolS&, const ::Test::SBoolS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opAShortS : public ::Test::AMD_MyClass_opAShortS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opAShortS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::AShortS&, const ::Test::AShortS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLShortS : public ::Test::AMD_MyClass_opLShortS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLShortS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LShortS&, const ::Test::LShortS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opKShortS : public ::Test::AMD_MyClass_opKShortS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opKShortS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::KShortS&, const ::Test::KShortS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opQShortS : public ::Test::AMD_MyClass_opQShortS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opQShortS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::QShortS&, const ::Test::QShortS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSShortS : public ::Test::AMD_MyClass_opSShortS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSShortS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SShortS&, const ::Test::SShortS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opAIntS : public ::Test::AMD_MyClass_opAIntS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opAIntS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::AIntS&, const ::Test::AIntS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLIntS : public ::Test::AMD_MyClass_opLIntS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLIntS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LIntS&, const ::Test::LIntS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opKIntS : public ::Test::AMD_MyClass_opKIntS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opKIntS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::KIntS&, const ::Test::KIntS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opQIntS : public ::Test::AMD_MyClass_opQIntS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opQIntS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::QIntS&, const ::Test::QIntS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSIntS : public ::Test::AMD_MyClass_opSIntS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSIntS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SIntS&, const ::Test::SIntS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opALongS : public ::Test::AMD_MyClass_opALongS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opALongS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::ALongS&, const ::Test::ALongS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLLongS : public ::Test::AMD_MyClass_opLLongS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLLongS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LLongS&, const ::Test::LLongS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opKLongS : public ::Test::AMD_MyClass_opKLongS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opKLongS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::KLongS&, const ::Test::KLongS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opQLongS : public ::Test::AMD_MyClass_opQLongS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opQLongS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::QLongS&, const ::Test::QLongS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSLongS : public ::Test::AMD_MyClass_opSLongS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSLongS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SLongS&, const ::Test::SLongS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opAFloatS : public ::Test::AMD_MyClass_opAFloatS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opAFloatS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::AFloatS&, const ::Test::AFloatS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLFloatS : public ::Test::AMD_MyClass_opLFloatS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLFloatS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LFloatS&, const ::Test::LFloatS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opKFloatS : public ::Test::AMD_MyClass_opKFloatS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opKFloatS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::KFloatS&, const ::Test::KFloatS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opQFloatS : public ::Test::AMD_MyClass_opQFloatS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opQFloatS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::QFloatS&, const ::Test::QFloatS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSFloatS : public ::Test::AMD_MyClass_opSFloatS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSFloatS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SFloatS&, const ::Test::SFloatS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opADoubleS : public ::Test::AMD_MyClass_opADoubleS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opADoubleS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::ADoubleS&, const ::Test::ADoubleS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLDoubleS : public ::Test::AMD_MyClass_opLDoubleS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLDoubleS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LDoubleS&, const ::Test::LDoubleS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opKDoubleS : public ::Test::AMD_MyClass_opKDoubleS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opKDoubleS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::KDoubleS&, const ::Test::KDoubleS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opQDoubleS : public ::Test::AMD_MyClass_opQDoubleS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opQDoubleS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::QDoubleS&, const ::Test::QDoubleS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSDoubleS : public ::Test::AMD_MyClass_opSDoubleS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSDoubleS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SDoubleS&, const ::Test::SDoubleS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opAStringS : public ::Test::AMD_MyClass_opAStringS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opAStringS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::AStringS&, const ::Test::AStringS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLStringS : public ::Test::AMD_MyClass_opLStringS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLStringS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LStringS&, const ::Test::LStringS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opKStringS : public ::Test::AMD_MyClass_opKStringS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opKStringS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::KStringS&, const ::Test::KStringS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opQStringS : public ::Test::AMD_MyClass_opQStringS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opQStringS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::QStringS&, const ::Test::QStringS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSStringS : public ::Test::AMD_MyClass_opSStringS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSStringS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SStringS&, const ::Test::SStringS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opAObjectS : public ::Test::AMD_MyClass_opAObjectS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opAObjectS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::AObjectS&, const ::Test::AObjectS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLObjectS : public ::Test::AMD_MyClass_opLObjectS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLObjectS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LObjectS&, const ::Test::LObjectS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opAObjectPrxS : public ::Test::AMD_MyClass_opAObjectPrxS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opAObjectPrxS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::AObjectPrxS&, const ::Test::AObjectPrxS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLObjectPrxS : public ::Test::AMD_MyClass_opLObjectPrxS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLObjectPrxS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LObjectPrxS&, const ::Test::LObjectPrxS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opKObjectPrxS : public ::Test::AMD_MyClass_opKObjectPrxS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opKObjectPrxS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::KObjectPrxS&, const ::Test::KObjectPrxS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opQObjectPrxS : public ::Test::AMD_MyClass_opQObjectPrxS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opQObjectPrxS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::QObjectPrxS&, const ::Test::QObjectPrxS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSObjectPrxS : public ::Test::AMD_MyClass_opSObjectPrxS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSObjectPrxS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SObjectPrxS&, const ::Test::SObjectPrxS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opAStructS : public ::Test::AMD_MyClass_opAStructS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opAStructS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::AStructS&, const ::Test::AStructS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLStructS : public ::Test::AMD_MyClass_opLStructS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLStructS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LStructS&, const ::Test::LStructS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opKStructS : public ::Test::AMD_MyClass_opKStructS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opKStructS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::KStructS&, const ::Test::KStructS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opQStructS : public ::Test::AMD_MyClass_opQStructS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opQStructS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::QStructS&, const ::Test::QStructS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSStructS : public ::Test::AMD_MyClass_opSStructS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSStructS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SStructS&, const ::Test::SStructS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opAStructSD : public ::Test::AMD_MyClass_opAStructSD, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opAStructSD(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::AStructSD&, const ::Test::AStructSD&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLStructSD : public ::Test::AMD_MyClass_opLStructSD, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLStructSD(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LStructSD&, const ::Test::LStructSD&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opKStructSD : public ::Test::AMD_MyClass_opKStructSD, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opKStructSD(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::KStructSD&, const ::Test::KStructSD&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opQStructSD : public ::Test::AMD_MyClass_opQStructSD, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opQStructSD(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::QStructSD&, const ::Test::QStructSD&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSStructSD : public ::Test::AMD_MyClass_opSStructSD, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSStructSD(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SStructSD&, const ::Test::SStructSD&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opACVS : public ::Test::AMD_MyClass_opACVS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opACVS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::ACVS&, const ::Test::ACVS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLCVS : public ::Test::AMD_MyClass_opLCVS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLCVS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LCVS&, const ::Test::LCVS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opACRS : public ::Test::AMD_MyClass_opACRS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opACRS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::ACRS&, const ::Test::ACRS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLCRS : public ::Test::AMD_MyClass_opLCRS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLCRS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LCRS&, const ::Test::LCRS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opAEnS : public ::Test::AMD_MyClass_opAEnS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opAEnS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::AEnS&, const ::Test::AEnS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLEnS : public ::Test::AMD_MyClass_opLEnS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLEnS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LEnS&, const ::Test::LEnS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opKEnS : public ::Test::AMD_MyClass_opKEnS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opKEnS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::KEnS&, const ::Test::KEnS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opQEnS : public ::Test::AMD_MyClass_opQEnS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opQEnS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::QEnS&, const ::Test::QEnS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSEnS : public ::Test::AMD_MyClass_opSEnS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSEnS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SEnS&, const ::Test::SEnS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opAIPrxS : public ::Test::AMD_MyClass_opAIPrxS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opAIPrxS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::AIPrxS&, const ::Test::AIPrxS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opLIPrxS : public ::Test::AMD_MyClass_opLIPrxS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opLIPrxS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::LIPrxS&, const ::Test::LIPrxS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opKIPrxS : public ::Test::AMD_MyClass_opKIPrxS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opKIPrxS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::KIPrxS&, const ::Test::KIPrxS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opQIPrxS : public ::Test::AMD_MyClass_opQIPrxS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opQIPrxS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::QIPrxS&, const ::Test::QIPrxS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSIPrxS : public ::Test::AMD_MyClass_opSIPrxS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSIPrxS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SIPrxS&, const ::Test::SIPrxS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opCustomIntS : public ::Test::AMD_MyClass_opCustomIntS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opCustomIntS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::CustomIntS&, const ::Test::CustomIntS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opCustomCVS : public ::Test::AMD_MyClass_opCustomCVS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opCustomCVS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::CustomCVS&, const ::Test::CustomCVS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opCustomIntSS : public ::Test::AMD_MyClass_opCustomIntSS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opCustomIntSS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::CustomIntSS&, const ::Test::CustomIntSS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opCustomCVSS : public ::Test::AMD_MyClass_opCustomCVSS, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opCustomCVSS(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::CustomCVSS&, const ::Test::CustomCVSS&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSerialSmallCSharp : public ::Test::AMD_MyClass_opSerialSmallCSharp, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSerialSmallCSharp(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SerialSmall&, const ::Test::SerialSmall&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSerialLargeCSharp : public ::Test::AMD_MyClass_opSerialLargeCSharp, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSerialLargeCSharp(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SerialLarge&, const ::Test::SerialLarge&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_MyClass_opSerialStructCSharp : public ::Test::AMD_MyClass_opSerialStructCSharp, public ::IceInternal::IncomingAsync
{
public:

    AMD_MyClass_opSerialStructCSharp(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::SerialStruct&, const ::Test::SerialStruct&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

}

}
/// \endcond

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_shutdown.
 */
class Callback_MyClass_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_shutdown_Base> Callback_MyClass_shutdownPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opAByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAByteS.
 */
class Callback_MyClass_opAByteS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opAByteS_Base> Callback_MyClass_opAByteSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLByteS.
 */
class Callback_MyClass_opLByteS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLByteS_Base> Callback_MyClass_opLByteSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opKByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKByteS.
 */
class Callback_MyClass_opKByteS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opKByteS_Base> Callback_MyClass_opKByteSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opQByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQByteS.
 */
class Callback_MyClass_opQByteS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opQByteS_Base> Callback_MyClass_opQByteSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSByteS.
 */
class Callback_MyClass_opSByteS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSByteS_Base> Callback_MyClass_opSByteSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opABoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opABoolS.
 */
class Callback_MyClass_opABoolS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opABoolS_Base> Callback_MyClass_opABoolSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLBoolS.
 */
class Callback_MyClass_opLBoolS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLBoolS_Base> Callback_MyClass_opLBoolSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opKBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKBoolS.
 */
class Callback_MyClass_opKBoolS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opKBoolS_Base> Callback_MyClass_opKBoolSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opQBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQBoolS.
 */
class Callback_MyClass_opQBoolS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opQBoolS_Base> Callback_MyClass_opQBoolSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSBoolS.
 */
class Callback_MyClass_opSBoolS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSBoolS_Base> Callback_MyClass_opSBoolSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opAShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAShortS.
 */
class Callback_MyClass_opAShortS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opAShortS_Base> Callback_MyClass_opAShortSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLShortS.
 */
class Callback_MyClass_opLShortS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLShortS_Base> Callback_MyClass_opLShortSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opKShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKShortS.
 */
class Callback_MyClass_opKShortS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opKShortS_Base> Callback_MyClass_opKShortSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opQShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQShortS.
 */
class Callback_MyClass_opQShortS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opQShortS_Base> Callback_MyClass_opQShortSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSShortS.
 */
class Callback_MyClass_opSShortS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSShortS_Base> Callback_MyClass_opSShortSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opAIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAIntS.
 */
class Callback_MyClass_opAIntS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opAIntS_Base> Callback_MyClass_opAIntSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLIntS.
 */
class Callback_MyClass_opLIntS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLIntS_Base> Callback_MyClass_opLIntSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opKIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKIntS.
 */
class Callback_MyClass_opKIntS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opKIntS_Base> Callback_MyClass_opKIntSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opQIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQIntS.
 */
class Callback_MyClass_opQIntS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opQIntS_Base> Callback_MyClass_opQIntSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSIntS.
 */
class Callback_MyClass_opSIntS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSIntS_Base> Callback_MyClass_opSIntSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opALongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opALongS.
 */
class Callback_MyClass_opALongS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opALongS_Base> Callback_MyClass_opALongSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLLongS.
 */
class Callback_MyClass_opLLongS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLLongS_Base> Callback_MyClass_opLLongSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opKLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKLongS.
 */
class Callback_MyClass_opKLongS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opKLongS_Base> Callback_MyClass_opKLongSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opQLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQLongS.
 */
class Callback_MyClass_opQLongS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opQLongS_Base> Callback_MyClass_opQLongSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSLongS.
 */
class Callback_MyClass_opSLongS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSLongS_Base> Callback_MyClass_opSLongSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opAFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAFloatS.
 */
class Callback_MyClass_opAFloatS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opAFloatS_Base> Callback_MyClass_opAFloatSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLFloatS.
 */
class Callback_MyClass_opLFloatS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLFloatS_Base> Callback_MyClass_opLFloatSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opKFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKFloatS.
 */
class Callback_MyClass_opKFloatS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opKFloatS_Base> Callback_MyClass_opKFloatSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opQFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQFloatS.
 */
class Callback_MyClass_opQFloatS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opQFloatS_Base> Callback_MyClass_opQFloatSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSFloatS.
 */
class Callback_MyClass_opSFloatS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSFloatS_Base> Callback_MyClass_opSFloatSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opADoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opADoubleS.
 */
class Callback_MyClass_opADoubleS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opADoubleS_Base> Callback_MyClass_opADoubleSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLDoubleS.
 */
class Callback_MyClass_opLDoubleS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLDoubleS_Base> Callback_MyClass_opLDoubleSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opKDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKDoubleS.
 */
class Callback_MyClass_opKDoubleS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opKDoubleS_Base> Callback_MyClass_opKDoubleSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opQDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQDoubleS.
 */
class Callback_MyClass_opQDoubleS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opQDoubleS_Base> Callback_MyClass_opQDoubleSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSDoubleS.
 */
class Callback_MyClass_opSDoubleS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSDoubleS_Base> Callback_MyClass_opSDoubleSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opAStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAStringS.
 */
class Callback_MyClass_opAStringS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opAStringS_Base> Callback_MyClass_opAStringSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLStringS.
 */
class Callback_MyClass_opLStringS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLStringS_Base> Callback_MyClass_opLStringSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opKStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKStringS.
 */
class Callback_MyClass_opKStringS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opKStringS_Base> Callback_MyClass_opKStringSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opQStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQStringS.
 */
class Callback_MyClass_opQStringS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opQStringS_Base> Callback_MyClass_opQStringSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSStringS.
 */
class Callback_MyClass_opSStringS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSStringS_Base> Callback_MyClass_opSStringSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opAObjectS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAObjectS.
 */
class Callback_MyClass_opAObjectS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opAObjectS_Base> Callback_MyClass_opAObjectSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLObjectS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLObjectS.
 */
class Callback_MyClass_opLObjectS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLObjectS_Base> Callback_MyClass_opLObjectSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opAObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAObjectPrxS.
 */
class Callback_MyClass_opAObjectPrxS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opAObjectPrxS_Base> Callback_MyClass_opAObjectPrxSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLObjectPrxS.
 */
class Callback_MyClass_opLObjectPrxS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLObjectPrxS_Base> Callback_MyClass_opLObjectPrxSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opKObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKObjectPrxS.
 */
class Callback_MyClass_opKObjectPrxS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opKObjectPrxS_Base> Callback_MyClass_opKObjectPrxSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opQObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQObjectPrxS.
 */
class Callback_MyClass_opQObjectPrxS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opQObjectPrxS_Base> Callback_MyClass_opQObjectPrxSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSObjectPrxS.
 */
class Callback_MyClass_opSObjectPrxS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSObjectPrxS_Base> Callback_MyClass_opSObjectPrxSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opAStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAStructS.
 */
class Callback_MyClass_opAStructS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opAStructS_Base> Callback_MyClass_opAStructSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLStructS.
 */
class Callback_MyClass_opLStructS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLStructS_Base> Callback_MyClass_opLStructSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opKStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKStructS.
 */
class Callback_MyClass_opKStructS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opKStructS_Base> Callback_MyClass_opKStructSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opQStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQStructS.
 */
class Callback_MyClass_opQStructS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opQStructS_Base> Callback_MyClass_opQStructSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSStructS.
 */
class Callback_MyClass_opSStructS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSStructS_Base> Callback_MyClass_opSStructSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opAStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAStructSD.
 */
class Callback_MyClass_opAStructSD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opAStructSD_Base> Callback_MyClass_opAStructSDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLStructSD.
 */
class Callback_MyClass_opLStructSD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLStructSD_Base> Callback_MyClass_opLStructSDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opKStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKStructSD.
 */
class Callback_MyClass_opKStructSD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opKStructSD_Base> Callback_MyClass_opKStructSDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opQStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQStructSD.
 */
class Callback_MyClass_opQStructSD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opQStructSD_Base> Callback_MyClass_opQStructSDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSStructSD.
 */
class Callback_MyClass_opSStructSD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSStructSD_Base> Callback_MyClass_opSStructSDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opACVS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opACVS.
 */
class Callback_MyClass_opACVS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opACVS_Base> Callback_MyClass_opACVSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLCVS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLCVS.
 */
class Callback_MyClass_opLCVS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLCVS_Base> Callback_MyClass_opLCVSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opACRS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opACRS.
 */
class Callback_MyClass_opACRS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opACRS_Base> Callback_MyClass_opACRSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLCRS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLCRS.
 */
class Callback_MyClass_opLCRS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLCRS_Base> Callback_MyClass_opLCRSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opAEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAEnS.
 */
class Callback_MyClass_opAEnS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opAEnS_Base> Callback_MyClass_opAEnSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLEnS.
 */
class Callback_MyClass_opLEnS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLEnS_Base> Callback_MyClass_opLEnSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opKEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKEnS.
 */
class Callback_MyClass_opKEnS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opKEnS_Base> Callback_MyClass_opKEnSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opQEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQEnS.
 */
class Callback_MyClass_opQEnS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opQEnS_Base> Callback_MyClass_opQEnSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSEnS.
 */
class Callback_MyClass_opSEnS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSEnS_Base> Callback_MyClass_opSEnSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opAIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAIPrxS.
 */
class Callback_MyClass_opAIPrxS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opAIPrxS_Base> Callback_MyClass_opAIPrxSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLIPrxS.
 */
class Callback_MyClass_opLIPrxS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLIPrxS_Base> Callback_MyClass_opLIPrxSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opKIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKIPrxS.
 */
class Callback_MyClass_opKIPrxS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opKIPrxS_Base> Callback_MyClass_opKIPrxSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opQIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQIPrxS.
 */
class Callback_MyClass_opQIPrxS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opQIPrxS_Base> Callback_MyClass_opQIPrxSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSIPrxS.
 */
class Callback_MyClass_opSIPrxS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSIPrxS_Base> Callback_MyClass_opSIPrxSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opCustomIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opCustomIntS.
 */
class Callback_MyClass_opCustomIntS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opCustomIntS_Base> Callback_MyClass_opCustomIntSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opCustomCVS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opCustomCVS.
 */
class Callback_MyClass_opCustomCVS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opCustomCVS_Base> Callback_MyClass_opCustomCVSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opCustomIntSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opCustomIntSS.
 */
class Callback_MyClass_opCustomIntSS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opCustomIntSS_Base> Callback_MyClass_opCustomIntSSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opCustomCVSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opCustomCVSS.
 */
class Callback_MyClass_opCustomCVSS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opCustomCVSS_Base> Callback_MyClass_opCustomCVSSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSerialSmallCSharp.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSerialSmallCSharp.
 */
class Callback_MyClass_opSerialSmallCSharp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSerialSmallCSharp_Base> Callback_MyClass_opSerialSmallCSharpPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSerialLargeCSharp.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSerialLargeCSharp.
 */
class Callback_MyClass_opSerialLargeCSharp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSerialLargeCSharp_Base> Callback_MyClass_opSerialLargeCSharpPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opSerialStructCSharp.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSerialStructCSharp.
 */
class Callback_MyClass_opSerialStructCSharp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opSerialStructCSharp_Base> Callback_MyClass_opSerialStructCSharpPtr;

}

namespace IceProxy
{

namespace Test
{

class CV : public virtual ::Ice::Proxy<CV, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class I : public virtual ::Ice::Proxy<I, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class CR : public virtual ::Ice::Proxy<CR, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class MyClass : public virtual ::Ice::Proxy<MyClass, ::IceProxy::Ice::Object>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_MyClass_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_MyClass_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::AByteS opAByteS(const ::Test::AByteS& i, ::Test::AByteS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opAByteS(o, _iceI_begin_opAByteS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opAByteS(const ::Test::AByteS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opAByteS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opAByteS(const ::Test::AByteS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAByteS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAByteS(const ::Test::AByteS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAByteS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAByteS(const ::Test::AByteS& i, const ::Test::Callback_MyClass_opAByteSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAByteS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAByteS(const ::Test::AByteS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opAByteSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAByteS(i, context, cb, cookie);
    }

    ::Test::AByteS end_opAByteS(::Test::AByteS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opAByteS(::Test::AByteS& iceP_o, ::Test::AByteS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opAByteS(const ::Test::AByteS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LByteS opLByteS(const ::Test::LByteS& i, ::Test::LByteS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLByteS(o, _iceI_begin_opLByteS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLByteS(const ::Test::LByteS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLByteS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLByteS(const ::Test::LByteS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLByteS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLByteS(const ::Test::LByteS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLByteS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLByteS(const ::Test::LByteS& i, const ::Test::Callback_MyClass_opLByteSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLByteS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLByteS(const ::Test::LByteS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLByteSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLByteS(i, context, cb, cookie);
    }

    ::Test::LByteS end_opLByteS(::Test::LByteS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLByteS(::Test::LByteS& iceP_o, ::Test::LByteS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLByteS(const ::Test::LByteS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::KByteS opKByteS(const ::Test::KByteS& i, ::Test::KByteS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opKByteS(o, _iceI_begin_opKByteS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opKByteS(const ::Test::KByteS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opKByteS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opKByteS(const ::Test::KByteS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKByteS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKByteS(const ::Test::KByteS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKByteS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKByteS(const ::Test::KByteS& i, const ::Test::Callback_MyClass_opKByteSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKByteS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKByteS(const ::Test::KByteS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opKByteSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKByteS(i, context, cb, cookie);
    }

    ::Test::KByteS end_opKByteS(::Test::KByteS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opKByteS(::Test::KByteS& iceP_o, ::Test::KByteS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opKByteS(const ::Test::KByteS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::QByteS opQByteS(const ::Test::QByteS& i, ::Test::QByteS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opQByteS(o, _iceI_begin_opQByteS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opQByteS(const ::Test::QByteS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opQByteS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opQByteS(const ::Test::QByteS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQByteS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQByteS(const ::Test::QByteS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQByteS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQByteS(const ::Test::QByteS& i, const ::Test::Callback_MyClass_opQByteSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQByteS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQByteS(const ::Test::QByteS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opQByteSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQByteS(i, context, cb, cookie);
    }

    ::Test::QByteS end_opQByteS(::Test::QByteS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opQByteS(::Test::QByteS& iceP_o, ::Test::QByteS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opQByteS(const ::Test::QByteS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SByteS opSByteS(const ::Test::SByteS& i, ::Test::SByteS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSByteS(o, _iceI_begin_opSByteS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSByteS(const ::Test::SByteS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSByteS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSByteS(const ::Test::SByteS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSByteS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSByteS(const ::Test::SByteS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSByteS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSByteS(const ::Test::SByteS& i, const ::Test::Callback_MyClass_opSByteSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSByteS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSByteS(const ::Test::SByteS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSByteSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSByteS(i, context, cb, cookie);
    }

    ::Test::SByteS end_opSByteS(::Test::SByteS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSByteS(::Test::SByteS& iceP_o, ::Test::SByteS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSByteS(const ::Test::SByteS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ABoolS opABoolS(const ::Test::ABoolS& i, ::Test::ABoolS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opABoolS(o, _iceI_begin_opABoolS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opABoolS(const ::Test::ABoolS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opABoolS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opABoolS(const ::Test::ABoolS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opABoolS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opABoolS(const ::Test::ABoolS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opABoolS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opABoolS(const ::Test::ABoolS& i, const ::Test::Callback_MyClass_opABoolSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opABoolS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opABoolS(const ::Test::ABoolS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opABoolSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opABoolS(i, context, cb, cookie);
    }

    ::Test::ABoolS end_opABoolS(::Test::ABoolS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opABoolS(::Test::ABoolS& iceP_o, ::Test::ABoolS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opABoolS(const ::Test::ABoolS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LBoolS opLBoolS(const ::Test::LBoolS& i, ::Test::LBoolS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLBoolS(o, _iceI_begin_opLBoolS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLBoolS(const ::Test::LBoolS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLBoolS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLBoolS(const ::Test::LBoolS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLBoolS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLBoolS(const ::Test::LBoolS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLBoolS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLBoolS(const ::Test::LBoolS& i, const ::Test::Callback_MyClass_opLBoolSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLBoolS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLBoolS(const ::Test::LBoolS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLBoolSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLBoolS(i, context, cb, cookie);
    }

    ::Test::LBoolS end_opLBoolS(::Test::LBoolS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLBoolS(::Test::LBoolS& iceP_o, ::Test::LBoolS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLBoolS(const ::Test::LBoolS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::KBoolS opKBoolS(const ::Test::KBoolS& i, ::Test::KBoolS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opKBoolS(o, _iceI_begin_opKBoolS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opKBoolS(const ::Test::KBoolS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opKBoolS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opKBoolS(const ::Test::KBoolS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKBoolS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKBoolS(const ::Test::KBoolS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKBoolS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKBoolS(const ::Test::KBoolS& i, const ::Test::Callback_MyClass_opKBoolSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKBoolS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKBoolS(const ::Test::KBoolS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opKBoolSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKBoolS(i, context, cb, cookie);
    }

    ::Test::KBoolS end_opKBoolS(::Test::KBoolS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opKBoolS(::Test::KBoolS& iceP_o, ::Test::KBoolS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opKBoolS(const ::Test::KBoolS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::QBoolS opQBoolS(const ::Test::QBoolS& i, ::Test::QBoolS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opQBoolS(o, _iceI_begin_opQBoolS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opQBoolS(const ::Test::QBoolS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opQBoolS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opQBoolS(const ::Test::QBoolS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQBoolS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQBoolS(const ::Test::QBoolS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQBoolS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQBoolS(const ::Test::QBoolS& i, const ::Test::Callback_MyClass_opQBoolSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQBoolS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQBoolS(const ::Test::QBoolS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opQBoolSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQBoolS(i, context, cb, cookie);
    }

    ::Test::QBoolS end_opQBoolS(::Test::QBoolS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opQBoolS(::Test::QBoolS& iceP_o, ::Test::QBoolS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opQBoolS(const ::Test::QBoolS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SBoolS opSBoolS(const ::Test::SBoolS& i, ::Test::SBoolS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSBoolS(o, _iceI_begin_opSBoolS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSBoolS(const ::Test::SBoolS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSBoolS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSBoolS(const ::Test::SBoolS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSBoolS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSBoolS(const ::Test::SBoolS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSBoolS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSBoolS(const ::Test::SBoolS& i, const ::Test::Callback_MyClass_opSBoolSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSBoolS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSBoolS(const ::Test::SBoolS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSBoolSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSBoolS(i, context, cb, cookie);
    }

    ::Test::SBoolS end_opSBoolS(::Test::SBoolS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSBoolS(::Test::SBoolS& iceP_o, ::Test::SBoolS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSBoolS(const ::Test::SBoolS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::AShortS opAShortS(const ::Test::AShortS& i, ::Test::AShortS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opAShortS(o, _iceI_begin_opAShortS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opAShortS(const ::Test::AShortS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opAShortS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opAShortS(const ::Test::AShortS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAShortS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAShortS(const ::Test::AShortS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAShortS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAShortS(const ::Test::AShortS& i, const ::Test::Callback_MyClass_opAShortSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAShortS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAShortS(const ::Test::AShortS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opAShortSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAShortS(i, context, cb, cookie);
    }

    ::Test::AShortS end_opAShortS(::Test::AShortS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opAShortS(::Test::AShortS& iceP_o, ::Test::AShortS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opAShortS(const ::Test::AShortS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LShortS opLShortS(const ::Test::LShortS& i, ::Test::LShortS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLShortS(o, _iceI_begin_opLShortS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLShortS(const ::Test::LShortS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLShortS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLShortS(const ::Test::LShortS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLShortS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLShortS(const ::Test::LShortS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLShortS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLShortS(const ::Test::LShortS& i, const ::Test::Callback_MyClass_opLShortSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLShortS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLShortS(const ::Test::LShortS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLShortSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLShortS(i, context, cb, cookie);
    }

    ::Test::LShortS end_opLShortS(::Test::LShortS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLShortS(::Test::LShortS& iceP_o, ::Test::LShortS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLShortS(const ::Test::LShortS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::KShortS opKShortS(const ::Test::KShortS& i, ::Test::KShortS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opKShortS(o, _iceI_begin_opKShortS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opKShortS(const ::Test::KShortS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opKShortS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opKShortS(const ::Test::KShortS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKShortS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKShortS(const ::Test::KShortS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKShortS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKShortS(const ::Test::KShortS& i, const ::Test::Callback_MyClass_opKShortSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKShortS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKShortS(const ::Test::KShortS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opKShortSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKShortS(i, context, cb, cookie);
    }

    ::Test::KShortS end_opKShortS(::Test::KShortS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opKShortS(::Test::KShortS& iceP_o, ::Test::KShortS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opKShortS(const ::Test::KShortS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::QShortS opQShortS(const ::Test::QShortS& i, ::Test::QShortS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opQShortS(o, _iceI_begin_opQShortS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opQShortS(const ::Test::QShortS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opQShortS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opQShortS(const ::Test::QShortS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQShortS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQShortS(const ::Test::QShortS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQShortS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQShortS(const ::Test::QShortS& i, const ::Test::Callback_MyClass_opQShortSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQShortS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQShortS(const ::Test::QShortS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opQShortSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQShortS(i, context, cb, cookie);
    }

    ::Test::QShortS end_opQShortS(::Test::QShortS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opQShortS(::Test::QShortS& iceP_o, ::Test::QShortS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opQShortS(const ::Test::QShortS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SShortS opSShortS(const ::Test::SShortS& i, ::Test::SShortS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSShortS(o, _iceI_begin_opSShortS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSShortS(const ::Test::SShortS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSShortS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSShortS(const ::Test::SShortS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSShortS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSShortS(const ::Test::SShortS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSShortS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSShortS(const ::Test::SShortS& i, const ::Test::Callback_MyClass_opSShortSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSShortS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSShortS(const ::Test::SShortS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSShortSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSShortS(i, context, cb, cookie);
    }

    ::Test::SShortS end_opSShortS(::Test::SShortS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSShortS(::Test::SShortS& iceP_o, ::Test::SShortS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSShortS(const ::Test::SShortS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::AIntS opAIntS(const ::Test::AIntS& i, ::Test::AIntS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opAIntS(o, _iceI_begin_opAIntS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opAIntS(const ::Test::AIntS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opAIntS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opAIntS(const ::Test::AIntS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAIntS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAIntS(const ::Test::AIntS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAIntS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAIntS(const ::Test::AIntS& i, const ::Test::Callback_MyClass_opAIntSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAIntS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAIntS(const ::Test::AIntS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opAIntSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAIntS(i, context, cb, cookie);
    }

    ::Test::AIntS end_opAIntS(::Test::AIntS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opAIntS(::Test::AIntS& iceP_o, ::Test::AIntS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opAIntS(const ::Test::AIntS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LIntS opLIntS(const ::Test::LIntS& i, ::Test::LIntS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLIntS(o, _iceI_begin_opLIntS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLIntS(const ::Test::LIntS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLIntS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLIntS(const ::Test::LIntS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLIntS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLIntS(const ::Test::LIntS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLIntS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLIntS(const ::Test::LIntS& i, const ::Test::Callback_MyClass_opLIntSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLIntS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLIntS(const ::Test::LIntS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLIntSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLIntS(i, context, cb, cookie);
    }

    ::Test::LIntS end_opLIntS(::Test::LIntS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLIntS(::Test::LIntS& iceP_o, ::Test::LIntS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLIntS(const ::Test::LIntS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::KIntS opKIntS(const ::Test::KIntS& i, ::Test::KIntS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opKIntS(o, _iceI_begin_opKIntS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opKIntS(const ::Test::KIntS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opKIntS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opKIntS(const ::Test::KIntS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKIntS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKIntS(const ::Test::KIntS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKIntS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKIntS(const ::Test::KIntS& i, const ::Test::Callback_MyClass_opKIntSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKIntS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKIntS(const ::Test::KIntS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opKIntSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKIntS(i, context, cb, cookie);
    }

    ::Test::KIntS end_opKIntS(::Test::KIntS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opKIntS(::Test::KIntS& iceP_o, ::Test::KIntS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opKIntS(const ::Test::KIntS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::QIntS opQIntS(const ::Test::QIntS& i, ::Test::QIntS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opQIntS(o, _iceI_begin_opQIntS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opQIntS(const ::Test::QIntS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opQIntS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opQIntS(const ::Test::QIntS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQIntS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQIntS(const ::Test::QIntS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQIntS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQIntS(const ::Test::QIntS& i, const ::Test::Callback_MyClass_opQIntSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQIntS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQIntS(const ::Test::QIntS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opQIntSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQIntS(i, context, cb, cookie);
    }

    ::Test::QIntS end_opQIntS(::Test::QIntS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opQIntS(::Test::QIntS& iceP_o, ::Test::QIntS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opQIntS(const ::Test::QIntS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SIntS opSIntS(const ::Test::SIntS& i, ::Test::SIntS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSIntS(o, _iceI_begin_opSIntS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSIntS(const ::Test::SIntS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSIntS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSIntS(const ::Test::SIntS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSIntS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSIntS(const ::Test::SIntS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSIntS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSIntS(const ::Test::SIntS& i, const ::Test::Callback_MyClass_opSIntSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSIntS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSIntS(const ::Test::SIntS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSIntSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSIntS(i, context, cb, cookie);
    }

    ::Test::SIntS end_opSIntS(::Test::SIntS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSIntS(::Test::SIntS& iceP_o, ::Test::SIntS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSIntS(const ::Test::SIntS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ALongS opALongS(const ::Test::ALongS& i, ::Test::ALongS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opALongS(o, _iceI_begin_opALongS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opALongS(const ::Test::ALongS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opALongS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opALongS(const ::Test::ALongS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opALongS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opALongS(const ::Test::ALongS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opALongS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opALongS(const ::Test::ALongS& i, const ::Test::Callback_MyClass_opALongSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opALongS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opALongS(const ::Test::ALongS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opALongSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opALongS(i, context, cb, cookie);
    }

    ::Test::ALongS end_opALongS(::Test::ALongS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opALongS(::Test::ALongS& iceP_o, ::Test::ALongS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opALongS(const ::Test::ALongS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LLongS opLLongS(const ::Test::LLongS& i, ::Test::LLongS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLLongS(o, _iceI_begin_opLLongS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLLongS(const ::Test::LLongS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLLongS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLLongS(const ::Test::LLongS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLLongS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLLongS(const ::Test::LLongS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLLongS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLLongS(const ::Test::LLongS& i, const ::Test::Callback_MyClass_opLLongSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLLongS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLLongS(const ::Test::LLongS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLLongSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLLongS(i, context, cb, cookie);
    }

    ::Test::LLongS end_opLLongS(::Test::LLongS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLLongS(::Test::LLongS& iceP_o, ::Test::LLongS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLLongS(const ::Test::LLongS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::KLongS opKLongS(const ::Test::KLongS& i, ::Test::KLongS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opKLongS(o, _iceI_begin_opKLongS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opKLongS(const ::Test::KLongS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opKLongS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opKLongS(const ::Test::KLongS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKLongS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKLongS(const ::Test::KLongS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKLongS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKLongS(const ::Test::KLongS& i, const ::Test::Callback_MyClass_opKLongSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKLongS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKLongS(const ::Test::KLongS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opKLongSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKLongS(i, context, cb, cookie);
    }

    ::Test::KLongS end_opKLongS(::Test::KLongS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opKLongS(::Test::KLongS& iceP_o, ::Test::KLongS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opKLongS(const ::Test::KLongS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::QLongS opQLongS(const ::Test::QLongS& i, ::Test::QLongS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opQLongS(o, _iceI_begin_opQLongS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opQLongS(const ::Test::QLongS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opQLongS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opQLongS(const ::Test::QLongS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQLongS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQLongS(const ::Test::QLongS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQLongS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQLongS(const ::Test::QLongS& i, const ::Test::Callback_MyClass_opQLongSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQLongS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQLongS(const ::Test::QLongS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opQLongSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQLongS(i, context, cb, cookie);
    }

    ::Test::QLongS end_opQLongS(::Test::QLongS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opQLongS(::Test::QLongS& iceP_o, ::Test::QLongS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opQLongS(const ::Test::QLongS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SLongS opSLongS(const ::Test::SLongS& i, ::Test::SLongS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSLongS(o, _iceI_begin_opSLongS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSLongS(const ::Test::SLongS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSLongS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSLongS(const ::Test::SLongS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSLongS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSLongS(const ::Test::SLongS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSLongS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSLongS(const ::Test::SLongS& i, const ::Test::Callback_MyClass_opSLongSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSLongS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSLongS(const ::Test::SLongS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSLongSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSLongS(i, context, cb, cookie);
    }

    ::Test::SLongS end_opSLongS(::Test::SLongS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSLongS(::Test::SLongS& iceP_o, ::Test::SLongS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSLongS(const ::Test::SLongS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::AFloatS opAFloatS(const ::Test::AFloatS& i, ::Test::AFloatS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opAFloatS(o, _iceI_begin_opAFloatS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opAFloatS(const ::Test::AFloatS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opAFloatS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opAFloatS(const ::Test::AFloatS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAFloatS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAFloatS(const ::Test::AFloatS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAFloatS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAFloatS(const ::Test::AFloatS& i, const ::Test::Callback_MyClass_opAFloatSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAFloatS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAFloatS(const ::Test::AFloatS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opAFloatSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAFloatS(i, context, cb, cookie);
    }

    ::Test::AFloatS end_opAFloatS(::Test::AFloatS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opAFloatS(::Test::AFloatS& iceP_o, ::Test::AFloatS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opAFloatS(const ::Test::AFloatS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LFloatS opLFloatS(const ::Test::LFloatS& i, ::Test::LFloatS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLFloatS(o, _iceI_begin_opLFloatS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLFloatS(const ::Test::LFloatS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLFloatS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLFloatS(const ::Test::LFloatS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLFloatS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLFloatS(const ::Test::LFloatS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLFloatS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLFloatS(const ::Test::LFloatS& i, const ::Test::Callback_MyClass_opLFloatSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLFloatS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLFloatS(const ::Test::LFloatS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLFloatSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLFloatS(i, context, cb, cookie);
    }

    ::Test::LFloatS end_opLFloatS(::Test::LFloatS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLFloatS(::Test::LFloatS& iceP_o, ::Test::LFloatS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLFloatS(const ::Test::LFloatS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::KFloatS opKFloatS(const ::Test::KFloatS& i, ::Test::KFloatS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opKFloatS(o, _iceI_begin_opKFloatS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opKFloatS(const ::Test::KFloatS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opKFloatS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opKFloatS(const ::Test::KFloatS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKFloatS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKFloatS(const ::Test::KFloatS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKFloatS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKFloatS(const ::Test::KFloatS& i, const ::Test::Callback_MyClass_opKFloatSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKFloatS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKFloatS(const ::Test::KFloatS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opKFloatSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKFloatS(i, context, cb, cookie);
    }

    ::Test::KFloatS end_opKFloatS(::Test::KFloatS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opKFloatS(::Test::KFloatS& iceP_o, ::Test::KFloatS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opKFloatS(const ::Test::KFloatS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::QFloatS opQFloatS(const ::Test::QFloatS& i, ::Test::QFloatS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opQFloatS(o, _iceI_begin_opQFloatS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opQFloatS(const ::Test::QFloatS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opQFloatS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opQFloatS(const ::Test::QFloatS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQFloatS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQFloatS(const ::Test::QFloatS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQFloatS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQFloatS(const ::Test::QFloatS& i, const ::Test::Callback_MyClass_opQFloatSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQFloatS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQFloatS(const ::Test::QFloatS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opQFloatSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQFloatS(i, context, cb, cookie);
    }

    ::Test::QFloatS end_opQFloatS(::Test::QFloatS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opQFloatS(::Test::QFloatS& iceP_o, ::Test::QFloatS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opQFloatS(const ::Test::QFloatS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SFloatS opSFloatS(const ::Test::SFloatS& i, ::Test::SFloatS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSFloatS(o, _iceI_begin_opSFloatS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSFloatS(const ::Test::SFloatS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSFloatS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSFloatS(const ::Test::SFloatS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSFloatS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSFloatS(const ::Test::SFloatS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSFloatS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSFloatS(const ::Test::SFloatS& i, const ::Test::Callback_MyClass_opSFloatSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSFloatS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSFloatS(const ::Test::SFloatS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSFloatSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSFloatS(i, context, cb, cookie);
    }

    ::Test::SFloatS end_opSFloatS(::Test::SFloatS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSFloatS(::Test::SFloatS& iceP_o, ::Test::SFloatS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSFloatS(const ::Test::SFloatS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ADoubleS opADoubleS(const ::Test::ADoubleS& i, ::Test::ADoubleS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opADoubleS(o, _iceI_begin_opADoubleS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opADoubleS(const ::Test::ADoubleS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opADoubleS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opADoubleS(const ::Test::ADoubleS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opADoubleS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opADoubleS(const ::Test::ADoubleS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opADoubleS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opADoubleS(const ::Test::ADoubleS& i, const ::Test::Callback_MyClass_opADoubleSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opADoubleS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opADoubleS(const ::Test::ADoubleS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opADoubleSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opADoubleS(i, context, cb, cookie);
    }

    ::Test::ADoubleS end_opADoubleS(::Test::ADoubleS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opADoubleS(::Test::ADoubleS& iceP_o, ::Test::ADoubleS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opADoubleS(const ::Test::ADoubleS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LDoubleS opLDoubleS(const ::Test::LDoubleS& i, ::Test::LDoubleS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLDoubleS(o, _iceI_begin_opLDoubleS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLDoubleS(const ::Test::LDoubleS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLDoubleS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLDoubleS(const ::Test::LDoubleS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLDoubleS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLDoubleS(const ::Test::LDoubleS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLDoubleS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLDoubleS(const ::Test::LDoubleS& i, const ::Test::Callback_MyClass_opLDoubleSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLDoubleS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLDoubleS(const ::Test::LDoubleS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLDoubleSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLDoubleS(i, context, cb, cookie);
    }

    ::Test::LDoubleS end_opLDoubleS(::Test::LDoubleS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLDoubleS(::Test::LDoubleS& iceP_o, ::Test::LDoubleS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLDoubleS(const ::Test::LDoubleS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::KDoubleS opKDoubleS(const ::Test::KDoubleS& i, ::Test::KDoubleS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opKDoubleS(o, _iceI_begin_opKDoubleS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opKDoubleS(const ::Test::KDoubleS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opKDoubleS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opKDoubleS(const ::Test::KDoubleS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKDoubleS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKDoubleS(const ::Test::KDoubleS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKDoubleS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKDoubleS(const ::Test::KDoubleS& i, const ::Test::Callback_MyClass_opKDoubleSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKDoubleS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKDoubleS(const ::Test::KDoubleS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opKDoubleSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKDoubleS(i, context, cb, cookie);
    }

    ::Test::KDoubleS end_opKDoubleS(::Test::KDoubleS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opKDoubleS(::Test::KDoubleS& iceP_o, ::Test::KDoubleS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opKDoubleS(const ::Test::KDoubleS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::QDoubleS opQDoubleS(const ::Test::QDoubleS& i, ::Test::QDoubleS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opQDoubleS(o, _iceI_begin_opQDoubleS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opQDoubleS(const ::Test::QDoubleS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opQDoubleS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opQDoubleS(const ::Test::QDoubleS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQDoubleS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQDoubleS(const ::Test::QDoubleS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQDoubleS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQDoubleS(const ::Test::QDoubleS& i, const ::Test::Callback_MyClass_opQDoubleSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQDoubleS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQDoubleS(const ::Test::QDoubleS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opQDoubleSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQDoubleS(i, context, cb, cookie);
    }

    ::Test::QDoubleS end_opQDoubleS(::Test::QDoubleS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opQDoubleS(::Test::QDoubleS& iceP_o, ::Test::QDoubleS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opQDoubleS(const ::Test::QDoubleS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SDoubleS opSDoubleS(const ::Test::SDoubleS& i, ::Test::SDoubleS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSDoubleS(o, _iceI_begin_opSDoubleS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSDoubleS(const ::Test::SDoubleS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSDoubleS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSDoubleS(const ::Test::SDoubleS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSDoubleS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSDoubleS(const ::Test::SDoubleS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSDoubleS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSDoubleS(const ::Test::SDoubleS& i, const ::Test::Callback_MyClass_opSDoubleSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSDoubleS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSDoubleS(const ::Test::SDoubleS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSDoubleSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSDoubleS(i, context, cb, cookie);
    }

    ::Test::SDoubleS end_opSDoubleS(::Test::SDoubleS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSDoubleS(::Test::SDoubleS& iceP_o, ::Test::SDoubleS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSDoubleS(const ::Test::SDoubleS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::AStringS opAStringS(const ::Test::AStringS& i, ::Test::AStringS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opAStringS(o, _iceI_begin_opAStringS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opAStringS(const ::Test::AStringS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opAStringS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opAStringS(const ::Test::AStringS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAStringS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAStringS(const ::Test::AStringS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAStringS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAStringS(const ::Test::AStringS& i, const ::Test::Callback_MyClass_opAStringSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAStringS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAStringS(const ::Test::AStringS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opAStringSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAStringS(i, context, cb, cookie);
    }

    ::Test::AStringS end_opAStringS(::Test::AStringS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opAStringS(::Test::AStringS& iceP_o, ::Test::AStringS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opAStringS(const ::Test::AStringS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LStringS opLStringS(const ::Test::LStringS& i, ::Test::LStringS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLStringS(o, _iceI_begin_opLStringS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLStringS(const ::Test::LStringS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLStringS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLStringS(const ::Test::LStringS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLStringS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLStringS(const ::Test::LStringS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLStringS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLStringS(const ::Test::LStringS& i, const ::Test::Callback_MyClass_opLStringSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLStringS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLStringS(const ::Test::LStringS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLStringSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLStringS(i, context, cb, cookie);
    }

    ::Test::LStringS end_opLStringS(::Test::LStringS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLStringS(::Test::LStringS& iceP_o, ::Test::LStringS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLStringS(const ::Test::LStringS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::KStringS opKStringS(const ::Test::KStringS& i, ::Test::KStringS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opKStringS(o, _iceI_begin_opKStringS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opKStringS(const ::Test::KStringS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opKStringS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opKStringS(const ::Test::KStringS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKStringS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKStringS(const ::Test::KStringS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKStringS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKStringS(const ::Test::KStringS& i, const ::Test::Callback_MyClass_opKStringSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKStringS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKStringS(const ::Test::KStringS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opKStringSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKStringS(i, context, cb, cookie);
    }

    ::Test::KStringS end_opKStringS(::Test::KStringS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opKStringS(::Test::KStringS& iceP_o, ::Test::KStringS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opKStringS(const ::Test::KStringS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::QStringS opQStringS(const ::Test::QStringS& i, ::Test::QStringS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opQStringS(o, _iceI_begin_opQStringS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opQStringS(const ::Test::QStringS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opQStringS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opQStringS(const ::Test::QStringS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQStringS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQStringS(const ::Test::QStringS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQStringS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQStringS(const ::Test::QStringS& i, const ::Test::Callback_MyClass_opQStringSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQStringS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQStringS(const ::Test::QStringS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opQStringSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQStringS(i, context, cb, cookie);
    }

    ::Test::QStringS end_opQStringS(::Test::QStringS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opQStringS(::Test::QStringS& iceP_o, ::Test::QStringS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opQStringS(const ::Test::QStringS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SStringS opSStringS(const ::Test::SStringS& i, ::Test::SStringS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSStringS(o, _iceI_begin_opSStringS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSStringS(const ::Test::SStringS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSStringS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSStringS(const ::Test::SStringS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSStringS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSStringS(const ::Test::SStringS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSStringS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSStringS(const ::Test::SStringS& i, const ::Test::Callback_MyClass_opSStringSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSStringS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSStringS(const ::Test::SStringS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSStringSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSStringS(i, context, cb, cookie);
    }

    ::Test::SStringS end_opSStringS(::Test::SStringS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSStringS(::Test::SStringS& iceP_o, ::Test::SStringS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSStringS(const ::Test::SStringS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::AObjectS opAObjectS(const ::Test::AObjectS& i, ::Test::AObjectS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opAObjectS(o, _iceI_begin_opAObjectS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opAObjectS(const ::Test::AObjectS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opAObjectS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opAObjectS(const ::Test::AObjectS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAObjectS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAObjectS(const ::Test::AObjectS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAObjectS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAObjectS(const ::Test::AObjectS& i, const ::Test::Callback_MyClass_opAObjectSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAObjectS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAObjectS(const ::Test::AObjectS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opAObjectSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAObjectS(i, context, cb, cookie);
    }

    ::Test::AObjectS end_opAObjectS(::Test::AObjectS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opAObjectS(::Test::AObjectS& iceP_o, ::Test::AObjectS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opAObjectS(const ::Test::AObjectS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LObjectS opLObjectS(const ::Test::LObjectS& i, ::Test::LObjectS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLObjectS(o, _iceI_begin_opLObjectS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLObjectS(const ::Test::LObjectS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLObjectS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLObjectS(const ::Test::LObjectS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLObjectS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLObjectS(const ::Test::LObjectS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLObjectS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLObjectS(const ::Test::LObjectS& i, const ::Test::Callback_MyClass_opLObjectSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLObjectS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLObjectS(const ::Test::LObjectS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLObjectSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLObjectS(i, context, cb, cookie);
    }

    ::Test::LObjectS end_opLObjectS(::Test::LObjectS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLObjectS(::Test::LObjectS& iceP_o, ::Test::LObjectS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLObjectS(const ::Test::LObjectS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::AObjectPrxS opAObjectPrxS(const ::Test::AObjectPrxS& i, ::Test::AObjectPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opAObjectPrxS(o, _iceI_begin_opAObjectPrxS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opAObjectPrxS(const ::Test::AObjectPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opAObjectPrxS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opAObjectPrxS(const ::Test::AObjectPrxS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAObjectPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAObjectPrxS(const ::Test::AObjectPrxS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAObjectPrxS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAObjectPrxS(const ::Test::AObjectPrxS& i, const ::Test::Callback_MyClass_opAObjectPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAObjectPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAObjectPrxS(const ::Test::AObjectPrxS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opAObjectPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAObjectPrxS(i, context, cb, cookie);
    }

    ::Test::AObjectPrxS end_opAObjectPrxS(::Test::AObjectPrxS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opAObjectPrxS(::Test::AObjectPrxS& iceP_o, ::Test::AObjectPrxS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opAObjectPrxS(const ::Test::AObjectPrxS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LObjectPrxS opLObjectPrxS(const ::Test::LObjectPrxS& i, ::Test::LObjectPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLObjectPrxS(o, _iceI_begin_opLObjectPrxS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLObjectPrxS(const ::Test::LObjectPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLObjectPrxS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLObjectPrxS(const ::Test::LObjectPrxS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLObjectPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLObjectPrxS(const ::Test::LObjectPrxS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLObjectPrxS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLObjectPrxS(const ::Test::LObjectPrxS& i, const ::Test::Callback_MyClass_opLObjectPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLObjectPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLObjectPrxS(const ::Test::LObjectPrxS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLObjectPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLObjectPrxS(i, context, cb, cookie);
    }

    ::Test::LObjectPrxS end_opLObjectPrxS(::Test::LObjectPrxS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLObjectPrxS(::Test::LObjectPrxS& iceP_o, ::Test::LObjectPrxS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLObjectPrxS(const ::Test::LObjectPrxS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::KObjectPrxS opKObjectPrxS(const ::Test::KObjectPrxS& i, ::Test::KObjectPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opKObjectPrxS(o, _iceI_begin_opKObjectPrxS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opKObjectPrxS(const ::Test::KObjectPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opKObjectPrxS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opKObjectPrxS(const ::Test::KObjectPrxS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKObjectPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKObjectPrxS(const ::Test::KObjectPrxS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKObjectPrxS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKObjectPrxS(const ::Test::KObjectPrxS& i, const ::Test::Callback_MyClass_opKObjectPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKObjectPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKObjectPrxS(const ::Test::KObjectPrxS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opKObjectPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKObjectPrxS(i, context, cb, cookie);
    }

    ::Test::KObjectPrxS end_opKObjectPrxS(::Test::KObjectPrxS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opKObjectPrxS(::Test::KObjectPrxS& iceP_o, ::Test::KObjectPrxS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opKObjectPrxS(const ::Test::KObjectPrxS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::QObjectPrxS opQObjectPrxS(const ::Test::QObjectPrxS& i, ::Test::QObjectPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opQObjectPrxS(o, _iceI_begin_opQObjectPrxS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opQObjectPrxS(const ::Test::QObjectPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opQObjectPrxS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opQObjectPrxS(const ::Test::QObjectPrxS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQObjectPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQObjectPrxS(const ::Test::QObjectPrxS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQObjectPrxS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQObjectPrxS(const ::Test::QObjectPrxS& i, const ::Test::Callback_MyClass_opQObjectPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQObjectPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQObjectPrxS(const ::Test::QObjectPrxS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opQObjectPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQObjectPrxS(i, context, cb, cookie);
    }

    ::Test::QObjectPrxS end_opQObjectPrxS(::Test::QObjectPrxS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opQObjectPrxS(::Test::QObjectPrxS& iceP_o, ::Test::QObjectPrxS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opQObjectPrxS(const ::Test::QObjectPrxS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SObjectPrxS opSObjectPrxS(const ::Test::SObjectPrxS& i, ::Test::SObjectPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSObjectPrxS(o, _iceI_begin_opSObjectPrxS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSObjectPrxS(const ::Test::SObjectPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSObjectPrxS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSObjectPrxS(const ::Test::SObjectPrxS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSObjectPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSObjectPrxS(const ::Test::SObjectPrxS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSObjectPrxS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSObjectPrxS(const ::Test::SObjectPrxS& i, const ::Test::Callback_MyClass_opSObjectPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSObjectPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSObjectPrxS(const ::Test::SObjectPrxS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSObjectPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSObjectPrxS(i, context, cb, cookie);
    }

    ::Test::SObjectPrxS end_opSObjectPrxS(::Test::SObjectPrxS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSObjectPrxS(::Test::SObjectPrxS& iceP_o, ::Test::SObjectPrxS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSObjectPrxS(const ::Test::SObjectPrxS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::AStructS opAStructS(const ::Test::AStructS& i, ::Test::AStructS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opAStructS(o, _iceI_begin_opAStructS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opAStructS(const ::Test::AStructS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opAStructS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opAStructS(const ::Test::AStructS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAStructS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAStructS(const ::Test::AStructS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAStructS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAStructS(const ::Test::AStructS& i, const ::Test::Callback_MyClass_opAStructSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAStructS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAStructS(const ::Test::AStructS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opAStructSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAStructS(i, context, cb, cookie);
    }

    ::Test::AStructS end_opAStructS(::Test::AStructS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opAStructS(::Test::AStructS& iceP_o, ::Test::AStructS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opAStructS(const ::Test::AStructS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LStructS opLStructS(const ::Test::LStructS& i, ::Test::LStructS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLStructS(o, _iceI_begin_opLStructS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLStructS(const ::Test::LStructS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLStructS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLStructS(const ::Test::LStructS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLStructS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLStructS(const ::Test::LStructS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLStructS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLStructS(const ::Test::LStructS& i, const ::Test::Callback_MyClass_opLStructSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLStructS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLStructS(const ::Test::LStructS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLStructSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLStructS(i, context, cb, cookie);
    }

    ::Test::LStructS end_opLStructS(::Test::LStructS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLStructS(::Test::LStructS& iceP_o, ::Test::LStructS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLStructS(const ::Test::LStructS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::KStructS opKStructS(const ::Test::KStructS& i, ::Test::KStructS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opKStructS(o, _iceI_begin_opKStructS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opKStructS(const ::Test::KStructS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opKStructS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opKStructS(const ::Test::KStructS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKStructS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKStructS(const ::Test::KStructS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKStructS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKStructS(const ::Test::KStructS& i, const ::Test::Callback_MyClass_opKStructSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKStructS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKStructS(const ::Test::KStructS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opKStructSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKStructS(i, context, cb, cookie);
    }

    ::Test::KStructS end_opKStructS(::Test::KStructS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opKStructS(::Test::KStructS& iceP_o, ::Test::KStructS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opKStructS(const ::Test::KStructS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::QStructS opQStructS(const ::Test::QStructS& i, ::Test::QStructS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opQStructS(o, _iceI_begin_opQStructS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opQStructS(const ::Test::QStructS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opQStructS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opQStructS(const ::Test::QStructS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQStructS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQStructS(const ::Test::QStructS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQStructS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQStructS(const ::Test::QStructS& i, const ::Test::Callback_MyClass_opQStructSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQStructS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQStructS(const ::Test::QStructS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opQStructSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQStructS(i, context, cb, cookie);
    }

    ::Test::QStructS end_opQStructS(::Test::QStructS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opQStructS(::Test::QStructS& iceP_o, ::Test::QStructS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opQStructS(const ::Test::QStructS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SStructS opSStructS(const ::Test::SStructS& i, ::Test::SStructS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSStructS(o, _iceI_begin_opSStructS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSStructS(const ::Test::SStructS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSStructS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSStructS(const ::Test::SStructS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSStructS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSStructS(const ::Test::SStructS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSStructS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSStructS(const ::Test::SStructS& i, const ::Test::Callback_MyClass_opSStructSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSStructS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSStructS(const ::Test::SStructS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSStructSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSStructS(i, context, cb, cookie);
    }

    ::Test::SStructS end_opSStructS(::Test::SStructS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSStructS(::Test::SStructS& iceP_o, ::Test::SStructS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSStructS(const ::Test::SStructS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::AStructSD opAStructSD(const ::Test::AStructSD& i, ::Test::AStructSD& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opAStructSD(o, _iceI_begin_opAStructSD(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opAStructSD(const ::Test::AStructSD& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opAStructSD(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opAStructSD(const ::Test::AStructSD& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAStructSD(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAStructSD(const ::Test::AStructSD& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAStructSD(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAStructSD(const ::Test::AStructSD& i, const ::Test::Callback_MyClass_opAStructSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAStructSD(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAStructSD(const ::Test::AStructSD& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opAStructSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAStructSD(i, context, cb, cookie);
    }

    ::Test::AStructSD end_opAStructSD(::Test::AStructSD& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opAStructSD(::Test::AStructSD& iceP_o, ::Test::AStructSD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opAStructSD(const ::Test::AStructSD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LStructSD opLStructSD(const ::Test::LStructSD& i, ::Test::LStructSD& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLStructSD(o, _iceI_begin_opLStructSD(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLStructSD(const ::Test::LStructSD& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLStructSD(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLStructSD(const ::Test::LStructSD& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLStructSD(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLStructSD(const ::Test::LStructSD& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLStructSD(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLStructSD(const ::Test::LStructSD& i, const ::Test::Callback_MyClass_opLStructSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLStructSD(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLStructSD(const ::Test::LStructSD& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLStructSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLStructSD(i, context, cb, cookie);
    }

    ::Test::LStructSD end_opLStructSD(::Test::LStructSD& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLStructSD(::Test::LStructSD& iceP_o, ::Test::LStructSD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLStructSD(const ::Test::LStructSD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::KStructSD opKStructSD(const ::Test::KStructSD& i, ::Test::KStructSD& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opKStructSD(o, _iceI_begin_opKStructSD(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opKStructSD(const ::Test::KStructSD& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opKStructSD(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opKStructSD(const ::Test::KStructSD& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKStructSD(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKStructSD(const ::Test::KStructSD& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKStructSD(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKStructSD(const ::Test::KStructSD& i, const ::Test::Callback_MyClass_opKStructSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKStructSD(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKStructSD(const ::Test::KStructSD& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opKStructSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKStructSD(i, context, cb, cookie);
    }

    ::Test::KStructSD end_opKStructSD(::Test::KStructSD& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opKStructSD(::Test::KStructSD& iceP_o, ::Test::KStructSD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opKStructSD(const ::Test::KStructSD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::QStructSD opQStructSD(const ::Test::QStructSD& i, ::Test::QStructSD& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opQStructSD(o, _iceI_begin_opQStructSD(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opQStructSD(const ::Test::QStructSD& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opQStructSD(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opQStructSD(const ::Test::QStructSD& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQStructSD(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQStructSD(const ::Test::QStructSD& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQStructSD(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQStructSD(const ::Test::QStructSD& i, const ::Test::Callback_MyClass_opQStructSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQStructSD(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQStructSD(const ::Test::QStructSD& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opQStructSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQStructSD(i, context, cb, cookie);
    }

    ::Test::QStructSD end_opQStructSD(::Test::QStructSD& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opQStructSD(::Test::QStructSD& iceP_o, ::Test::QStructSD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opQStructSD(const ::Test::QStructSD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SStructSD opSStructSD(const ::Test::SStructSD& i, ::Test::SStructSD& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSStructSD(o, _iceI_begin_opSStructSD(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSStructSD(const ::Test::SStructSD& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSStructSD(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSStructSD(const ::Test::SStructSD& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSStructSD(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSStructSD(const ::Test::SStructSD& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSStructSD(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSStructSD(const ::Test::SStructSD& i, const ::Test::Callback_MyClass_opSStructSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSStructSD(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSStructSD(const ::Test::SStructSD& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSStructSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSStructSD(i, context, cb, cookie);
    }

    ::Test::SStructSD end_opSStructSD(::Test::SStructSD& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSStructSD(::Test::SStructSD& iceP_o, ::Test::SStructSD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSStructSD(const ::Test::SStructSD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ACVS opACVS(const ::Test::ACVS& i, ::Test::ACVS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opACVS(o, _iceI_begin_opACVS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opACVS(const ::Test::ACVS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opACVS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opACVS(const ::Test::ACVS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opACVS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opACVS(const ::Test::ACVS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opACVS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opACVS(const ::Test::ACVS& i, const ::Test::Callback_MyClass_opACVSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opACVS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opACVS(const ::Test::ACVS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opACVSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opACVS(i, context, cb, cookie);
    }

    ::Test::ACVS end_opACVS(::Test::ACVS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opACVS(::Test::ACVS& iceP_o, ::Test::ACVS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opACVS(const ::Test::ACVS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LCVS opLCVS(const ::Test::LCVS& i, ::Test::LCVS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLCVS(o, _iceI_begin_opLCVS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLCVS(const ::Test::LCVS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLCVS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLCVS(const ::Test::LCVS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLCVS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLCVS(const ::Test::LCVS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLCVS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLCVS(const ::Test::LCVS& i, const ::Test::Callback_MyClass_opLCVSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLCVS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLCVS(const ::Test::LCVS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLCVSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLCVS(i, context, cb, cookie);
    }

    ::Test::LCVS end_opLCVS(::Test::LCVS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLCVS(::Test::LCVS& iceP_o, ::Test::LCVS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLCVS(const ::Test::LCVS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ACRS opACRS(const ::Test::ACRS& i, ::Test::ACRS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opACRS(o, _iceI_begin_opACRS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opACRS(const ::Test::ACRS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opACRS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opACRS(const ::Test::ACRS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opACRS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opACRS(const ::Test::ACRS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opACRS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opACRS(const ::Test::ACRS& i, const ::Test::Callback_MyClass_opACRSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opACRS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opACRS(const ::Test::ACRS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opACRSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opACRS(i, context, cb, cookie);
    }

    ::Test::ACRS end_opACRS(::Test::ACRS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opACRS(::Test::ACRS& iceP_o, ::Test::ACRS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opACRS(const ::Test::ACRS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LCRS opLCRS(const ::Test::LCRS& i, ::Test::LCRS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLCRS(o, _iceI_begin_opLCRS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLCRS(const ::Test::LCRS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLCRS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLCRS(const ::Test::LCRS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLCRS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLCRS(const ::Test::LCRS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLCRS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLCRS(const ::Test::LCRS& i, const ::Test::Callback_MyClass_opLCRSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLCRS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLCRS(const ::Test::LCRS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLCRSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLCRS(i, context, cb, cookie);
    }

    ::Test::LCRS end_opLCRS(::Test::LCRS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLCRS(::Test::LCRS& iceP_o, ::Test::LCRS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLCRS(const ::Test::LCRS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::AEnS opAEnS(const ::Test::AEnS& i, ::Test::AEnS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opAEnS(o, _iceI_begin_opAEnS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opAEnS(const ::Test::AEnS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opAEnS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opAEnS(const ::Test::AEnS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAEnS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAEnS(const ::Test::AEnS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAEnS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAEnS(const ::Test::AEnS& i, const ::Test::Callback_MyClass_opAEnSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAEnS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAEnS(const ::Test::AEnS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opAEnSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAEnS(i, context, cb, cookie);
    }

    ::Test::AEnS end_opAEnS(::Test::AEnS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opAEnS(::Test::AEnS& iceP_o, ::Test::AEnS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opAEnS(const ::Test::AEnS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LEnS opLEnS(const ::Test::LEnS& i, ::Test::LEnS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLEnS(o, _iceI_begin_opLEnS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLEnS(const ::Test::LEnS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLEnS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLEnS(const ::Test::LEnS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLEnS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLEnS(const ::Test::LEnS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLEnS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLEnS(const ::Test::LEnS& i, const ::Test::Callback_MyClass_opLEnSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLEnS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLEnS(const ::Test::LEnS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLEnSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLEnS(i, context, cb, cookie);
    }

    ::Test::LEnS end_opLEnS(::Test::LEnS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLEnS(::Test::LEnS& iceP_o, ::Test::LEnS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLEnS(const ::Test::LEnS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::KEnS opKEnS(const ::Test::KEnS& i, ::Test::KEnS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opKEnS(o, _iceI_begin_opKEnS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opKEnS(const ::Test::KEnS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opKEnS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opKEnS(const ::Test::KEnS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKEnS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKEnS(const ::Test::KEnS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKEnS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKEnS(const ::Test::KEnS& i, const ::Test::Callback_MyClass_opKEnSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKEnS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKEnS(const ::Test::KEnS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opKEnSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKEnS(i, context, cb, cookie);
    }

    ::Test::KEnS end_opKEnS(::Test::KEnS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opKEnS(::Test::KEnS& iceP_o, ::Test::KEnS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opKEnS(const ::Test::KEnS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::QEnS opQEnS(const ::Test::QEnS& i, ::Test::QEnS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opQEnS(o, _iceI_begin_opQEnS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opQEnS(const ::Test::QEnS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opQEnS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opQEnS(const ::Test::QEnS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQEnS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQEnS(const ::Test::QEnS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQEnS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQEnS(const ::Test::QEnS& i, const ::Test::Callback_MyClass_opQEnSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQEnS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQEnS(const ::Test::QEnS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opQEnSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQEnS(i, context, cb, cookie);
    }

    ::Test::QEnS end_opQEnS(::Test::QEnS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opQEnS(::Test::QEnS& iceP_o, ::Test::QEnS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opQEnS(const ::Test::QEnS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SEnS opSEnS(const ::Test::SEnS& i, ::Test::SEnS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSEnS(o, _iceI_begin_opSEnS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSEnS(const ::Test::SEnS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSEnS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSEnS(const ::Test::SEnS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSEnS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSEnS(const ::Test::SEnS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSEnS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSEnS(const ::Test::SEnS& i, const ::Test::Callback_MyClass_opSEnSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSEnS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSEnS(const ::Test::SEnS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSEnSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSEnS(i, context, cb, cookie);
    }

    ::Test::SEnS end_opSEnS(::Test::SEnS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSEnS(::Test::SEnS& iceP_o, ::Test::SEnS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSEnS(const ::Test::SEnS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::AIPrxS opAIPrxS(const ::Test::AIPrxS& i, ::Test::AIPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opAIPrxS(o, _iceI_begin_opAIPrxS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opAIPrxS(const ::Test::AIPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opAIPrxS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opAIPrxS(const ::Test::AIPrxS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAIPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAIPrxS(const ::Test::AIPrxS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAIPrxS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAIPrxS(const ::Test::AIPrxS& i, const ::Test::Callback_MyClass_opAIPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAIPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opAIPrxS(const ::Test::AIPrxS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opAIPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opAIPrxS(i, context, cb, cookie);
    }

    ::Test::AIPrxS end_opAIPrxS(::Test::AIPrxS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opAIPrxS(::Test::AIPrxS& iceP_o, ::Test::AIPrxS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opAIPrxS(const ::Test::AIPrxS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LIPrxS opLIPrxS(const ::Test::LIPrxS& i, ::Test::LIPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLIPrxS(o, _iceI_begin_opLIPrxS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLIPrxS(const ::Test::LIPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLIPrxS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLIPrxS(const ::Test::LIPrxS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLIPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLIPrxS(const ::Test::LIPrxS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLIPrxS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLIPrxS(const ::Test::LIPrxS& i, const ::Test::Callback_MyClass_opLIPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLIPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLIPrxS(const ::Test::LIPrxS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLIPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLIPrxS(i, context, cb, cookie);
    }

    ::Test::LIPrxS end_opLIPrxS(::Test::LIPrxS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLIPrxS(::Test::LIPrxS& iceP_o, ::Test::LIPrxS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLIPrxS(const ::Test::LIPrxS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::KIPrxS opKIPrxS(const ::Test::KIPrxS& i, ::Test::KIPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opKIPrxS(o, _iceI_begin_opKIPrxS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opKIPrxS(const ::Test::KIPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opKIPrxS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opKIPrxS(const ::Test::KIPrxS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKIPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKIPrxS(const ::Test::KIPrxS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKIPrxS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKIPrxS(const ::Test::KIPrxS& i, const ::Test::Callback_MyClass_opKIPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKIPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opKIPrxS(const ::Test::KIPrxS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opKIPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opKIPrxS(i, context, cb, cookie);
    }

    ::Test::KIPrxS end_opKIPrxS(::Test::KIPrxS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opKIPrxS(::Test::KIPrxS& iceP_o, ::Test::KIPrxS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opKIPrxS(const ::Test::KIPrxS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::QIPrxS opQIPrxS(const ::Test::QIPrxS& i, ::Test::QIPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opQIPrxS(o, _iceI_begin_opQIPrxS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opQIPrxS(const ::Test::QIPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opQIPrxS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opQIPrxS(const ::Test::QIPrxS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQIPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQIPrxS(const ::Test::QIPrxS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQIPrxS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQIPrxS(const ::Test::QIPrxS& i, const ::Test::Callback_MyClass_opQIPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQIPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opQIPrxS(const ::Test::QIPrxS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opQIPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opQIPrxS(i, context, cb, cookie);
    }

    ::Test::QIPrxS end_opQIPrxS(::Test::QIPrxS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opQIPrxS(::Test::QIPrxS& iceP_o, ::Test::QIPrxS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opQIPrxS(const ::Test::QIPrxS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SIPrxS opSIPrxS(const ::Test::SIPrxS& i, ::Test::SIPrxS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSIPrxS(o, _iceI_begin_opSIPrxS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSIPrxS(const ::Test::SIPrxS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSIPrxS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSIPrxS(const ::Test::SIPrxS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSIPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSIPrxS(const ::Test::SIPrxS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSIPrxS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSIPrxS(const ::Test::SIPrxS& i, const ::Test::Callback_MyClass_opSIPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSIPrxS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSIPrxS(const ::Test::SIPrxS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSIPrxSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSIPrxS(i, context, cb, cookie);
    }

    ::Test::SIPrxS end_opSIPrxS(::Test::SIPrxS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSIPrxS(::Test::SIPrxS& iceP_o, ::Test::SIPrxS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSIPrxS(const ::Test::SIPrxS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CustomIntS opCustomIntS(const ::Test::CustomIntS& i, ::Test::CustomIntS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCustomIntS(o, _iceI_begin_opCustomIntS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCustomIntS(const ::Test::CustomIntS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCustomIntS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntS(const ::Test::CustomIntS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntS(const ::Test::CustomIntS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntS(const ::Test::CustomIntS& i, const ::Test::Callback_MyClass_opCustomIntSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntS(const ::Test::CustomIntS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opCustomIntSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntS(i, context, cb, cookie);
    }

    ::Test::CustomIntS end_opCustomIntS(::Test::CustomIntS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCustomIntS(::Test::CustomIntS& iceP_o, ::Test::CustomIntS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCustomIntS(const ::Test::CustomIntS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CustomCVS opCustomCVS(const ::Test::CustomCVS& i, ::Test::CustomCVS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCustomCVS(o, _iceI_begin_opCustomCVS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCustomCVS(const ::Test::CustomCVS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCustomCVS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCustomCVS(const ::Test::CustomCVS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomCVS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomCVS(const ::Test::CustomCVS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomCVS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomCVS(const ::Test::CustomCVS& i, const ::Test::Callback_MyClass_opCustomCVSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomCVS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomCVS(const ::Test::CustomCVS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opCustomCVSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomCVS(i, context, cb, cookie);
    }

    ::Test::CustomCVS end_opCustomCVS(::Test::CustomCVS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCustomCVS(::Test::CustomCVS& iceP_o, ::Test::CustomCVS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCustomCVS(const ::Test::CustomCVS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CustomIntSS opCustomIntSS(const ::Test::CustomIntSS& i, ::Test::CustomIntSS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCustomIntSS(o, _iceI_begin_opCustomIntSS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCustomIntSS(const ::Test::CustomIntSS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCustomIntSS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntSS(const ::Test::CustomIntSS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntSS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntSS(const ::Test::CustomIntSS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntSS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntSS(const ::Test::CustomIntSS& i, const ::Test::Callback_MyClass_opCustomIntSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntSS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntSS(const ::Test::CustomIntSS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opCustomIntSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntSS(i, context, cb, cookie);
    }

    ::Test::CustomIntSS end_opCustomIntSS(::Test::CustomIntSS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCustomIntSS(::Test::CustomIntSS& iceP_o, ::Test::CustomIntSS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCustomIntSS(const ::Test::CustomIntSS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CustomCVSS opCustomCVSS(const ::Test::CustomCVSS& i, ::Test::CustomCVSS& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCustomCVSS(o, _iceI_begin_opCustomCVSS(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCustomCVSS(const ::Test::CustomCVSS& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCustomCVSS(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCustomCVSS(const ::Test::CustomCVSS& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomCVSS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomCVSS(const ::Test::CustomCVSS& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomCVSS(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomCVSS(const ::Test::CustomCVSS& i, const ::Test::Callback_MyClass_opCustomCVSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomCVSS(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomCVSS(const ::Test::CustomCVSS& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opCustomCVSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomCVSS(i, context, cb, cookie);
    }

    ::Test::CustomCVSS end_opCustomCVSS(::Test::CustomCVSS& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCustomCVSS(::Test::CustomCVSS& iceP_o, ::Test::CustomCVSS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCustomCVSS(const ::Test::CustomCVSS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SerialSmall opSerialSmallCSharp(const ::Test::SerialSmall& i, ::Test::SerialSmall& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSerialSmallCSharp(o, _iceI_begin_opSerialSmallCSharp(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSerialSmallCSharp(const ::Test::SerialSmall& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSerialSmallCSharp(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSerialSmallCSharp(const ::Test::SerialSmall& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerialSmallCSharp(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerialSmallCSharp(const ::Test::SerialSmall& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerialSmallCSharp(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerialSmallCSharp(const ::Test::SerialSmall& i, const ::Test::Callback_MyClass_opSerialSmallCSharpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerialSmallCSharp(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerialSmallCSharp(const ::Test::SerialSmall& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSerialSmallCSharpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerialSmallCSharp(i, context, cb, cookie);
    }

    ::Test::SerialSmall end_opSerialSmallCSharp(::Test::SerialSmall& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSerialSmallCSharp(::Test::SerialSmall& iceP_o, ::Test::SerialSmall& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSerialSmallCSharp(const ::Test::SerialSmall&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SerialLarge opSerialLargeCSharp(const ::Test::SerialLarge& i, ::Test::SerialLarge& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSerialLargeCSharp(o, _iceI_begin_opSerialLargeCSharp(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSerialLargeCSharp(const ::Test::SerialLarge& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSerialLargeCSharp(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSerialLargeCSharp(const ::Test::SerialLarge& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerialLargeCSharp(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerialLargeCSharp(const ::Test::SerialLarge& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerialLargeCSharp(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerialLargeCSharp(const ::Test::SerialLarge& i, const ::Test::Callback_MyClass_opSerialLargeCSharpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerialLargeCSharp(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerialLargeCSharp(const ::Test::SerialLarge& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSerialLargeCSharpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerialLargeCSharp(i, context, cb, cookie);
    }

    ::Test::SerialLarge end_opSerialLargeCSharp(::Test::SerialLarge& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSerialLargeCSharp(::Test::SerialLarge& iceP_o, ::Test::SerialLarge& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSerialLargeCSharp(const ::Test::SerialLarge&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SerialStruct opSerialStructCSharp(const ::Test::SerialStruct& i, ::Test::SerialStruct& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSerialStructCSharp(o, _iceI_begin_opSerialStructCSharp(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSerialStructCSharp(const ::Test::SerialStruct& i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSerialStructCSharp(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSerialStructCSharp(const ::Test::SerialStruct& i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerialStructCSharp(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerialStructCSharp(const ::Test::SerialStruct& i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerialStructCSharp(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerialStructCSharp(const ::Test::SerialStruct& i, const ::Test::Callback_MyClass_opSerialStructCSharpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerialStructCSharp(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerialStructCSharp(const ::Test::SerialStruct& i, const ::Ice::Context& context, const ::Test::Callback_MyClass_opSerialStructCSharpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerialStructCSharp(i, context, cb, cookie);
    }

    ::Test::SerialStruct end_opSerialStructCSharp(::Test::SerialStruct& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSerialStructCSharp(::Test::SerialStruct& iceP_o, ::Test::SerialStruct& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSerialStructCSharp(const ::Test::SerialStruct&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class CV : public virtual ::Ice::Object
{
public:

    typedef CVPrx ProxyType;
    typedef CVPtr PointerType;

    virtual ~CV();

    CV()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CV(::Ice::Int i) :
        i(i)
    {
    }

#ifdef ICE_CPP11_COMPILER
    CV(const CV&) = default;
    CV& operator=(const CV&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int i;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CV_init = ::Test::CV::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CV& lhs, const CV& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const CV& lhs, const CV& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class I : public virtual ::Ice::Object
{
public:

    typedef IPrx ProxyType;
    typedef IPtr PointerType;

    virtual ~I();

#ifdef ICE_CPP11_COMPILER
    I() = default;
    I(const I&) = default;
    I& operator=(const I&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const I& lhs, const I& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const I& lhs, const I& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class CR : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef CRPrx ProxyType;
    typedef CRPtr PointerType;

    virtual ~CR();

    CR()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CR(const ::Test::CVPtr& v) :
        v(v)
    {
    }

#ifdef ICE_CPP11_COMPILER
    CR(const CR&) = default;
    CR& operator=(const CR&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::CVPtr v;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CR_init = ::Test::CR::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CR& lhs, const CR& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const CR& lhs, const CR& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class MyClass : public virtual ::Ice::Object
{
public:

    typedef MyClassPrx ProxyType;
    typedef MyClassPtr PointerType;

    virtual ~MyClass();

#ifdef ICE_CPP11_COMPILER
    MyClass() = default;
    MyClass(const MyClass&) = default;
    MyClass& operator=(const MyClass&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void shutdown_async(const ::Test::AMD_MyClass_shutdownPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opAByteS_async(const ::Test::AMD_MyClass_opAByteSPtr& cb, const AByteS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opAByteS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLByteS_async(const ::Test::AMD_MyClass_opLByteSPtr& cb, const LByteS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLByteS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opKByteS_async(const ::Test::AMD_MyClass_opKByteSPtr& cb, const KByteS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opKByteS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opQByteS_async(const ::Test::AMD_MyClass_opQByteSPtr& cb, const QByteS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opQByteS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSByteS_async(const ::Test::AMD_MyClass_opSByteSPtr& cb, const SByteS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSByteS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opABoolS_async(const ::Test::AMD_MyClass_opABoolSPtr& cb, const ABoolS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opABoolS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLBoolS_async(const ::Test::AMD_MyClass_opLBoolSPtr& cb, const LBoolS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLBoolS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opKBoolS_async(const ::Test::AMD_MyClass_opKBoolSPtr& cb, const KBoolS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opKBoolS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opQBoolS_async(const ::Test::AMD_MyClass_opQBoolSPtr& cb, const QBoolS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opQBoolS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSBoolS_async(const ::Test::AMD_MyClass_opSBoolSPtr& cb, const SBoolS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSBoolS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opAShortS_async(const ::Test::AMD_MyClass_opAShortSPtr& cb, const AShortS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opAShortS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLShortS_async(const ::Test::AMD_MyClass_opLShortSPtr& cb, const LShortS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLShortS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opKShortS_async(const ::Test::AMD_MyClass_opKShortSPtr& cb, const KShortS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opKShortS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opQShortS_async(const ::Test::AMD_MyClass_opQShortSPtr& cb, const QShortS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opQShortS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSShortS_async(const ::Test::AMD_MyClass_opSShortSPtr& cb, const SShortS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSShortS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opAIntS_async(const ::Test::AMD_MyClass_opAIntSPtr& cb, const AIntS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opAIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLIntS_async(const ::Test::AMD_MyClass_opLIntSPtr& cb, const LIntS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opKIntS_async(const ::Test::AMD_MyClass_opKIntSPtr& cb, const KIntS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opKIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opQIntS_async(const ::Test::AMD_MyClass_opQIntSPtr& cb, const QIntS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opQIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSIntS_async(const ::Test::AMD_MyClass_opSIntSPtr& cb, const SIntS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opALongS_async(const ::Test::AMD_MyClass_opALongSPtr& cb, const ALongS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opALongS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLLongS_async(const ::Test::AMD_MyClass_opLLongSPtr& cb, const LLongS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLLongS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opKLongS_async(const ::Test::AMD_MyClass_opKLongSPtr& cb, const KLongS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opKLongS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opQLongS_async(const ::Test::AMD_MyClass_opQLongSPtr& cb, const QLongS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opQLongS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSLongS_async(const ::Test::AMD_MyClass_opSLongSPtr& cb, const SLongS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSLongS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opAFloatS_async(const ::Test::AMD_MyClass_opAFloatSPtr& cb, const AFloatS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opAFloatS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLFloatS_async(const ::Test::AMD_MyClass_opLFloatSPtr& cb, const LFloatS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLFloatS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opKFloatS_async(const ::Test::AMD_MyClass_opKFloatSPtr& cb, const KFloatS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opKFloatS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opQFloatS_async(const ::Test::AMD_MyClass_opQFloatSPtr& cb, const QFloatS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opQFloatS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSFloatS_async(const ::Test::AMD_MyClass_opSFloatSPtr& cb, const SFloatS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSFloatS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opADoubleS_async(const ::Test::AMD_MyClass_opADoubleSPtr& cb, const ADoubleS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opADoubleS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLDoubleS_async(const ::Test::AMD_MyClass_opLDoubleSPtr& cb, const LDoubleS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLDoubleS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opKDoubleS_async(const ::Test::AMD_MyClass_opKDoubleSPtr& cb, const KDoubleS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opKDoubleS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opQDoubleS_async(const ::Test::AMD_MyClass_opQDoubleSPtr& cb, const QDoubleS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opQDoubleS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSDoubleS_async(const ::Test::AMD_MyClass_opSDoubleSPtr& cb, const SDoubleS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSDoubleS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opAStringS_async(const ::Test::AMD_MyClass_opAStringSPtr& cb, const AStringS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opAStringS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLStringS_async(const ::Test::AMD_MyClass_opLStringSPtr& cb, const LStringS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLStringS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opKStringS_async(const ::Test::AMD_MyClass_opKStringSPtr& cb, const KStringS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opKStringS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opQStringS_async(const ::Test::AMD_MyClass_opQStringSPtr& cb, const QStringS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opQStringS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSStringS_async(const ::Test::AMD_MyClass_opSStringSPtr& cb, const SStringS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSStringS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opAObjectS_async(const ::Test::AMD_MyClass_opAObjectSPtr& cb, const AObjectS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opAObjectS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLObjectS_async(const ::Test::AMD_MyClass_opLObjectSPtr& cb, const LObjectS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLObjectS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opAObjectPrxS_async(const ::Test::AMD_MyClass_opAObjectPrxSPtr& cb, const AObjectPrxS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opAObjectPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLObjectPrxS_async(const ::Test::AMD_MyClass_opLObjectPrxSPtr& cb, const LObjectPrxS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLObjectPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opKObjectPrxS_async(const ::Test::AMD_MyClass_opKObjectPrxSPtr& cb, const KObjectPrxS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opKObjectPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opQObjectPrxS_async(const ::Test::AMD_MyClass_opQObjectPrxSPtr& cb, const QObjectPrxS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opQObjectPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSObjectPrxS_async(const ::Test::AMD_MyClass_opSObjectPrxSPtr& cb, const SObjectPrxS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSObjectPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opAStructS_async(const ::Test::AMD_MyClass_opAStructSPtr& cb, const AStructS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opAStructS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLStructS_async(const ::Test::AMD_MyClass_opLStructSPtr& cb, const LStructS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLStructS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opKStructS_async(const ::Test::AMD_MyClass_opKStructSPtr& cb, const KStructS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opKStructS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opQStructS_async(const ::Test::AMD_MyClass_opQStructSPtr& cb, const QStructS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opQStructS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSStructS_async(const ::Test::AMD_MyClass_opSStructSPtr& cb, const SStructS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSStructS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opAStructSD_async(const ::Test::AMD_MyClass_opAStructSDPtr& cb, const AStructSD& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opAStructSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLStructSD_async(const ::Test::AMD_MyClass_opLStructSDPtr& cb, const LStructSD& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLStructSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opKStructSD_async(const ::Test::AMD_MyClass_opKStructSDPtr& cb, const KStructSD& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opKStructSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opQStructSD_async(const ::Test::AMD_MyClass_opQStructSDPtr& cb, const QStructSD& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opQStructSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSStructSD_async(const ::Test::AMD_MyClass_opSStructSDPtr& cb, const SStructSD& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSStructSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opACVS_async(const ::Test::AMD_MyClass_opACVSPtr& cb, const ACVS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opACVS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLCVS_async(const ::Test::AMD_MyClass_opLCVSPtr& cb, const LCVS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLCVS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opACRS_async(const ::Test::AMD_MyClass_opACRSPtr& cb, const ACRS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opACRS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLCRS_async(const ::Test::AMD_MyClass_opLCRSPtr& cb, const LCRS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLCRS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opAEnS_async(const ::Test::AMD_MyClass_opAEnSPtr& cb, const AEnS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opAEnS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLEnS_async(const ::Test::AMD_MyClass_opLEnSPtr& cb, const LEnS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLEnS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opKEnS_async(const ::Test::AMD_MyClass_opKEnSPtr& cb, const KEnS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opKEnS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opQEnS_async(const ::Test::AMD_MyClass_opQEnSPtr& cb, const QEnS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opQEnS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSEnS_async(const ::Test::AMD_MyClass_opSEnSPtr& cb, const SEnS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSEnS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opAIPrxS_async(const ::Test::AMD_MyClass_opAIPrxSPtr& cb, const AIPrxS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opAIPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLIPrxS_async(const ::Test::AMD_MyClass_opLIPrxSPtr& cb, const LIPrxS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLIPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opKIPrxS_async(const ::Test::AMD_MyClass_opKIPrxSPtr& cb, const KIPrxS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opKIPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opQIPrxS_async(const ::Test::AMD_MyClass_opQIPrxSPtr& cb, const QIPrxS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opQIPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSIPrxS_async(const ::Test::AMD_MyClass_opSIPrxSPtr& cb, const SIPrxS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSIPrxS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opCustomIntS_async(const ::Test::AMD_MyClass_opCustomIntSPtr& cb, const CustomIntS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opCustomCVS_async(const ::Test::AMD_MyClass_opCustomCVSPtr& cb, const CustomCVS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomCVS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opCustomIntSS_async(const ::Test::AMD_MyClass_opCustomIntSSPtr& cb, const CustomIntSS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomIntSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opCustomCVSS_async(const ::Test::AMD_MyClass_opCustomCVSSPtr& cb, const CustomCVSS& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomCVSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSerialSmallCSharp_async(const ::Test::AMD_MyClass_opSerialSmallCSharpPtr& cb, const SerialSmall& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSerialSmallCSharp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSerialLargeCSharp_async(const ::Test::AMD_MyClass_opSerialLargeCSharpPtr& cb, const SerialLarge& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSerialLargeCSharp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSerialStructCSharp_async(const ::Test::AMD_MyClass_opSerialStructCSharpPtr& cb, const SerialStruct& i, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSerialStructCSharp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const MyClass& lhs, const MyClass& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const MyClass& lhs, const MyClass& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Test::S, S>
{
    static void write(S* ostr, const ::Test::S& v)
    {
        ostr->write(v.i);
    }
};

template<typename S>
struct StreamReader< ::Test::S, S>
{
    static void read(S* istr, ::Test::S& v)
    {
        istr->read(v.i);
    }
};

template<>
struct StreamableTraits< ::Test::SD>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Test::SD, S>
{
    static void write(S* ostr, const ::Test::SD& v)
    {
        ostr->write(v.i);
    }
};

template<typename S>
struct StreamReader< ::Test::SD, S>
{
    static void read(S* istr, ::Test::SD& v)
    {
        istr->read(v.i);
    }
};

template<typename S>
struct StreamWriter< ::Test::CV, S>
{
    static void write(S* ostr, const ::Test::CV& v)
    {
        ostr->write(v.i);
    }
};

template<typename S>
struct StreamReader< ::Test::CV, S>
{
    static void read(S* istr, ::Test::CV& v)
    {
        istr->read(v.i);
    }
};

template<typename S>
struct StreamWriter< ::Test::CR, S>
{
    static void write(S* ostr, const ::Test::CR& v)
    {
        ostr->write(v.v);
    }
};

template<typename S>
struct StreamReader< ::Test::CR, S>
{
    static void read(S* istr, ::Test::CR& v)
    {
        istr->read(v.v);
    }
};

template<>
struct StreamableTraits< ::Test::En>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_shutdown.
 */
template<class T>
class CallbackNC_MyClass_shutdown : public Callback_MyClass_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyClass_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_shutdown.
 */
template<class T, typename CT>
class Callback_MyClass_shutdown : public Callback_MyClass_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyClass_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T, typename CT> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T, typename CT> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T, typename CT> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T, typename CT> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opAByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAByteS.
 */
template<class T>
class CallbackNC_MyClass_opAByteS : public Callback_MyClass_opAByteS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const AByteS&, const AByteS&);

    CallbackNC_MyClass_opAByteS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AByteS iceP_o;
        AByteS ret;
        try
        {
            ret = proxy->end_opAByteS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAByteS.
 */
template<class T> Callback_MyClass_opAByteSPtr
newCallback_MyClass_opAByteS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AByteS&, const AByteS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAByteS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAByteS.
 */
template<class T> Callback_MyClass_opAByteSPtr
newCallback_MyClass_opAByteS(T* instance, void (T::*cb)(const AByteS&, const AByteS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAByteS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opAByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAByteS.
 */
template<class T, typename CT>
class Callback_MyClass_opAByteS : public Callback_MyClass_opAByteS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const AByteS&, const AByteS&, const CT&);

    Callback_MyClass_opAByteS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AByteS iceP_o;
        AByteS ret;
        try
        {
            ret = proxy->end_opAByteS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAByteS.
 */
template<class T, typename CT> Callback_MyClass_opAByteSPtr
newCallback_MyClass_opAByteS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AByteS&, const AByteS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAByteS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAByteS.
 */
template<class T, typename CT> Callback_MyClass_opAByteSPtr
newCallback_MyClass_opAByteS(T* instance, void (T::*cb)(const AByteS&, const AByteS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAByteS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLByteS.
 */
template<class T>
class CallbackNC_MyClass_opLByteS : public Callback_MyClass_opLByteS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LByteS&, const LByteS&);

    CallbackNC_MyClass_opLByteS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LByteS iceP_o;
        LByteS ret;
        try
        {
            ret = proxy->end_opLByteS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLByteS.
 */
template<class T> Callback_MyClass_opLByteSPtr
newCallback_MyClass_opLByteS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LByteS&, const LByteS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLByteS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLByteS.
 */
template<class T> Callback_MyClass_opLByteSPtr
newCallback_MyClass_opLByteS(T* instance, void (T::*cb)(const LByteS&, const LByteS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLByteS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLByteS.
 */
template<class T, typename CT>
class Callback_MyClass_opLByteS : public Callback_MyClass_opLByteS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LByteS&, const LByteS&, const CT&);

    Callback_MyClass_opLByteS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LByteS iceP_o;
        LByteS ret;
        try
        {
            ret = proxy->end_opLByteS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLByteS.
 */
template<class T, typename CT> Callback_MyClass_opLByteSPtr
newCallback_MyClass_opLByteS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LByteS&, const LByteS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLByteS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLByteS.
 */
template<class T, typename CT> Callback_MyClass_opLByteSPtr
newCallback_MyClass_opLByteS(T* instance, void (T::*cb)(const LByteS&, const LByteS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLByteS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opKByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKByteS.
 */
template<class T>
class CallbackNC_MyClass_opKByteS : public Callback_MyClass_opKByteS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const KByteS&, const KByteS&);

    CallbackNC_MyClass_opKByteS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KByteS iceP_o;
        KByteS ret;
        try
        {
            ret = proxy->end_opKByteS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKByteS.
 */
template<class T> Callback_MyClass_opKByteSPtr
newCallback_MyClass_opKByteS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KByteS&, const KByteS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKByteS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKByteS.
 */
template<class T> Callback_MyClass_opKByteSPtr
newCallback_MyClass_opKByteS(T* instance, void (T::*cb)(const KByteS&, const KByteS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKByteS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opKByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKByteS.
 */
template<class T, typename CT>
class Callback_MyClass_opKByteS : public Callback_MyClass_opKByteS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const KByteS&, const KByteS&, const CT&);

    Callback_MyClass_opKByteS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KByteS iceP_o;
        KByteS ret;
        try
        {
            ret = proxy->end_opKByteS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKByteS.
 */
template<class T, typename CT> Callback_MyClass_opKByteSPtr
newCallback_MyClass_opKByteS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KByteS&, const KByteS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKByteS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKByteS.
 */
template<class T, typename CT> Callback_MyClass_opKByteSPtr
newCallback_MyClass_opKByteS(T* instance, void (T::*cb)(const KByteS&, const KByteS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKByteS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opQByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQByteS.
 */
template<class T>
class CallbackNC_MyClass_opQByteS : public Callback_MyClass_opQByteS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const QByteS&, const QByteS&);

    CallbackNC_MyClass_opQByteS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QByteS iceP_o;
        QByteS ret;
        try
        {
            ret = proxy->end_opQByteS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQByteS.
 */
template<class T> Callback_MyClass_opQByteSPtr
newCallback_MyClass_opQByteS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QByteS&, const QByteS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQByteS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQByteS.
 */
template<class T> Callback_MyClass_opQByteSPtr
newCallback_MyClass_opQByteS(T* instance, void (T::*cb)(const QByteS&, const QByteS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQByteS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opQByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQByteS.
 */
template<class T, typename CT>
class Callback_MyClass_opQByteS : public Callback_MyClass_opQByteS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const QByteS&, const QByteS&, const CT&);

    Callback_MyClass_opQByteS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QByteS iceP_o;
        QByteS ret;
        try
        {
            ret = proxy->end_opQByteS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQByteS.
 */
template<class T, typename CT> Callback_MyClass_opQByteSPtr
newCallback_MyClass_opQByteS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QByteS&, const QByteS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQByteS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQByteS.
 */
template<class T, typename CT> Callback_MyClass_opQByteSPtr
newCallback_MyClass_opQByteS(T* instance, void (T::*cb)(const QByteS&, const QByteS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQByteS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSByteS.
 */
template<class T>
class CallbackNC_MyClass_opSByteS : public Callback_MyClass_opSByteS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SByteS&, const SByteS&);

    CallbackNC_MyClass_opSByteS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SByteS iceP_o;
        SByteS ret;
        try
        {
            ret = proxy->end_opSByteS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSByteS.
 */
template<class T> Callback_MyClass_opSByteSPtr
newCallback_MyClass_opSByteS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SByteS&, const SByteS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSByteS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSByteS.
 */
template<class T> Callback_MyClass_opSByteSPtr
newCallback_MyClass_opSByteS(T* instance, void (T::*cb)(const SByteS&, const SByteS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSByteS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSByteS.
 */
template<class T, typename CT>
class Callback_MyClass_opSByteS : public Callback_MyClass_opSByteS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SByteS&, const SByteS&, const CT&);

    Callback_MyClass_opSByteS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SByteS iceP_o;
        SByteS ret;
        try
        {
            ret = proxy->end_opSByteS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSByteS.
 */
template<class T, typename CT> Callback_MyClass_opSByteSPtr
newCallback_MyClass_opSByteS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SByteS&, const SByteS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSByteS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSByteS.
 */
template<class T, typename CT> Callback_MyClass_opSByteSPtr
newCallback_MyClass_opSByteS(T* instance, void (T::*cb)(const SByteS&, const SByteS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSByteS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opABoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opABoolS.
 */
template<class T>
class CallbackNC_MyClass_opABoolS : public Callback_MyClass_opABoolS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ABoolS&, const ABoolS&);

    CallbackNC_MyClass_opABoolS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ABoolS iceP_o;
        ABoolS ret;
        try
        {
            ret = proxy->end_opABoolS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opABoolS.
 */
template<class T> Callback_MyClass_opABoolSPtr
newCallback_MyClass_opABoolS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ABoolS&, const ABoolS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opABoolS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opABoolS.
 */
template<class T> Callback_MyClass_opABoolSPtr
newCallback_MyClass_opABoolS(T* instance, void (T::*cb)(const ABoolS&, const ABoolS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opABoolS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opABoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opABoolS.
 */
template<class T, typename CT>
class Callback_MyClass_opABoolS : public Callback_MyClass_opABoolS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ABoolS&, const ABoolS&, const CT&);

    Callback_MyClass_opABoolS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ABoolS iceP_o;
        ABoolS ret;
        try
        {
            ret = proxy->end_opABoolS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opABoolS.
 */
template<class T, typename CT> Callback_MyClass_opABoolSPtr
newCallback_MyClass_opABoolS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ABoolS&, const ABoolS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opABoolS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opABoolS.
 */
template<class T, typename CT> Callback_MyClass_opABoolSPtr
newCallback_MyClass_opABoolS(T* instance, void (T::*cb)(const ABoolS&, const ABoolS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opABoolS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLBoolS.
 */
template<class T>
class CallbackNC_MyClass_opLBoolS : public Callback_MyClass_opLBoolS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LBoolS&, const LBoolS&);

    CallbackNC_MyClass_opLBoolS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LBoolS iceP_o;
        LBoolS ret;
        try
        {
            ret = proxy->end_opLBoolS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLBoolS.
 */
template<class T> Callback_MyClass_opLBoolSPtr
newCallback_MyClass_opLBoolS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LBoolS&, const LBoolS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLBoolS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLBoolS.
 */
template<class T> Callback_MyClass_opLBoolSPtr
newCallback_MyClass_opLBoolS(T* instance, void (T::*cb)(const LBoolS&, const LBoolS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLBoolS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLBoolS.
 */
template<class T, typename CT>
class Callback_MyClass_opLBoolS : public Callback_MyClass_opLBoolS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LBoolS&, const LBoolS&, const CT&);

    Callback_MyClass_opLBoolS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LBoolS iceP_o;
        LBoolS ret;
        try
        {
            ret = proxy->end_opLBoolS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLBoolS.
 */
template<class T, typename CT> Callback_MyClass_opLBoolSPtr
newCallback_MyClass_opLBoolS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LBoolS&, const LBoolS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLBoolS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLBoolS.
 */
template<class T, typename CT> Callback_MyClass_opLBoolSPtr
newCallback_MyClass_opLBoolS(T* instance, void (T::*cb)(const LBoolS&, const LBoolS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLBoolS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opKBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKBoolS.
 */
template<class T>
class CallbackNC_MyClass_opKBoolS : public Callback_MyClass_opKBoolS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const KBoolS&, const KBoolS&);

    CallbackNC_MyClass_opKBoolS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KBoolS iceP_o;
        KBoolS ret;
        try
        {
            ret = proxy->end_opKBoolS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKBoolS.
 */
template<class T> Callback_MyClass_opKBoolSPtr
newCallback_MyClass_opKBoolS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KBoolS&, const KBoolS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKBoolS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKBoolS.
 */
template<class T> Callback_MyClass_opKBoolSPtr
newCallback_MyClass_opKBoolS(T* instance, void (T::*cb)(const KBoolS&, const KBoolS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKBoolS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opKBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKBoolS.
 */
template<class T, typename CT>
class Callback_MyClass_opKBoolS : public Callback_MyClass_opKBoolS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const KBoolS&, const KBoolS&, const CT&);

    Callback_MyClass_opKBoolS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KBoolS iceP_o;
        KBoolS ret;
        try
        {
            ret = proxy->end_opKBoolS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKBoolS.
 */
template<class T, typename CT> Callback_MyClass_opKBoolSPtr
newCallback_MyClass_opKBoolS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KBoolS&, const KBoolS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKBoolS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKBoolS.
 */
template<class T, typename CT> Callback_MyClass_opKBoolSPtr
newCallback_MyClass_opKBoolS(T* instance, void (T::*cb)(const KBoolS&, const KBoolS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKBoolS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opQBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQBoolS.
 */
template<class T>
class CallbackNC_MyClass_opQBoolS : public Callback_MyClass_opQBoolS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const QBoolS&, const QBoolS&);

    CallbackNC_MyClass_opQBoolS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QBoolS iceP_o;
        QBoolS ret;
        try
        {
            ret = proxy->end_opQBoolS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQBoolS.
 */
template<class T> Callback_MyClass_opQBoolSPtr
newCallback_MyClass_opQBoolS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QBoolS&, const QBoolS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQBoolS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQBoolS.
 */
template<class T> Callback_MyClass_opQBoolSPtr
newCallback_MyClass_opQBoolS(T* instance, void (T::*cb)(const QBoolS&, const QBoolS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQBoolS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opQBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQBoolS.
 */
template<class T, typename CT>
class Callback_MyClass_opQBoolS : public Callback_MyClass_opQBoolS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const QBoolS&, const QBoolS&, const CT&);

    Callback_MyClass_opQBoolS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QBoolS iceP_o;
        QBoolS ret;
        try
        {
            ret = proxy->end_opQBoolS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQBoolS.
 */
template<class T, typename CT> Callback_MyClass_opQBoolSPtr
newCallback_MyClass_opQBoolS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QBoolS&, const QBoolS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQBoolS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQBoolS.
 */
template<class T, typename CT> Callback_MyClass_opQBoolSPtr
newCallback_MyClass_opQBoolS(T* instance, void (T::*cb)(const QBoolS&, const QBoolS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQBoolS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSBoolS.
 */
template<class T>
class CallbackNC_MyClass_opSBoolS : public Callback_MyClass_opSBoolS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SBoolS&, const SBoolS&);

    CallbackNC_MyClass_opSBoolS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SBoolS iceP_o;
        SBoolS ret;
        try
        {
            ret = proxy->end_opSBoolS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSBoolS.
 */
template<class T> Callback_MyClass_opSBoolSPtr
newCallback_MyClass_opSBoolS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SBoolS&, const SBoolS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSBoolS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSBoolS.
 */
template<class T> Callback_MyClass_opSBoolSPtr
newCallback_MyClass_opSBoolS(T* instance, void (T::*cb)(const SBoolS&, const SBoolS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSBoolS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSBoolS.
 */
template<class T, typename CT>
class Callback_MyClass_opSBoolS : public Callback_MyClass_opSBoolS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SBoolS&, const SBoolS&, const CT&);

    Callback_MyClass_opSBoolS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SBoolS iceP_o;
        SBoolS ret;
        try
        {
            ret = proxy->end_opSBoolS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSBoolS.
 */
template<class T, typename CT> Callback_MyClass_opSBoolSPtr
newCallback_MyClass_opSBoolS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SBoolS&, const SBoolS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSBoolS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSBoolS.
 */
template<class T, typename CT> Callback_MyClass_opSBoolSPtr
newCallback_MyClass_opSBoolS(T* instance, void (T::*cb)(const SBoolS&, const SBoolS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSBoolS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opAShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAShortS.
 */
template<class T>
class CallbackNC_MyClass_opAShortS : public Callback_MyClass_opAShortS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const AShortS&, const AShortS&);

    CallbackNC_MyClass_opAShortS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AShortS iceP_o;
        AShortS ret;
        try
        {
            ret = proxy->end_opAShortS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAShortS.
 */
template<class T> Callback_MyClass_opAShortSPtr
newCallback_MyClass_opAShortS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AShortS&, const AShortS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAShortS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAShortS.
 */
template<class T> Callback_MyClass_opAShortSPtr
newCallback_MyClass_opAShortS(T* instance, void (T::*cb)(const AShortS&, const AShortS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAShortS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opAShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAShortS.
 */
template<class T, typename CT>
class Callback_MyClass_opAShortS : public Callback_MyClass_opAShortS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const AShortS&, const AShortS&, const CT&);

    Callback_MyClass_opAShortS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AShortS iceP_o;
        AShortS ret;
        try
        {
            ret = proxy->end_opAShortS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAShortS.
 */
template<class T, typename CT> Callback_MyClass_opAShortSPtr
newCallback_MyClass_opAShortS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AShortS&, const AShortS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAShortS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAShortS.
 */
template<class T, typename CT> Callback_MyClass_opAShortSPtr
newCallback_MyClass_opAShortS(T* instance, void (T::*cb)(const AShortS&, const AShortS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAShortS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLShortS.
 */
template<class T>
class CallbackNC_MyClass_opLShortS : public Callback_MyClass_opLShortS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LShortS&, const LShortS&);

    CallbackNC_MyClass_opLShortS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LShortS iceP_o;
        LShortS ret;
        try
        {
            ret = proxy->end_opLShortS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLShortS.
 */
template<class T> Callback_MyClass_opLShortSPtr
newCallback_MyClass_opLShortS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LShortS&, const LShortS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLShortS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLShortS.
 */
template<class T> Callback_MyClass_opLShortSPtr
newCallback_MyClass_opLShortS(T* instance, void (T::*cb)(const LShortS&, const LShortS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLShortS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLShortS.
 */
template<class T, typename CT>
class Callback_MyClass_opLShortS : public Callback_MyClass_opLShortS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LShortS&, const LShortS&, const CT&);

    Callback_MyClass_opLShortS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LShortS iceP_o;
        LShortS ret;
        try
        {
            ret = proxy->end_opLShortS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLShortS.
 */
template<class T, typename CT> Callback_MyClass_opLShortSPtr
newCallback_MyClass_opLShortS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LShortS&, const LShortS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLShortS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLShortS.
 */
template<class T, typename CT> Callback_MyClass_opLShortSPtr
newCallback_MyClass_opLShortS(T* instance, void (T::*cb)(const LShortS&, const LShortS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLShortS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opKShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKShortS.
 */
template<class T>
class CallbackNC_MyClass_opKShortS : public Callback_MyClass_opKShortS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const KShortS&, const KShortS&);

    CallbackNC_MyClass_opKShortS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KShortS iceP_o;
        KShortS ret;
        try
        {
            ret = proxy->end_opKShortS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKShortS.
 */
template<class T> Callback_MyClass_opKShortSPtr
newCallback_MyClass_opKShortS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KShortS&, const KShortS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKShortS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKShortS.
 */
template<class T> Callback_MyClass_opKShortSPtr
newCallback_MyClass_opKShortS(T* instance, void (T::*cb)(const KShortS&, const KShortS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKShortS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opKShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKShortS.
 */
template<class T, typename CT>
class Callback_MyClass_opKShortS : public Callback_MyClass_opKShortS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const KShortS&, const KShortS&, const CT&);

    Callback_MyClass_opKShortS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KShortS iceP_o;
        KShortS ret;
        try
        {
            ret = proxy->end_opKShortS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKShortS.
 */
template<class T, typename CT> Callback_MyClass_opKShortSPtr
newCallback_MyClass_opKShortS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KShortS&, const KShortS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKShortS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKShortS.
 */
template<class T, typename CT> Callback_MyClass_opKShortSPtr
newCallback_MyClass_opKShortS(T* instance, void (T::*cb)(const KShortS&, const KShortS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKShortS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opQShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQShortS.
 */
template<class T>
class CallbackNC_MyClass_opQShortS : public Callback_MyClass_opQShortS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const QShortS&, const QShortS&);

    CallbackNC_MyClass_opQShortS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QShortS iceP_o;
        QShortS ret;
        try
        {
            ret = proxy->end_opQShortS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQShortS.
 */
template<class T> Callback_MyClass_opQShortSPtr
newCallback_MyClass_opQShortS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QShortS&, const QShortS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQShortS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQShortS.
 */
template<class T> Callback_MyClass_opQShortSPtr
newCallback_MyClass_opQShortS(T* instance, void (T::*cb)(const QShortS&, const QShortS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQShortS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opQShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQShortS.
 */
template<class T, typename CT>
class Callback_MyClass_opQShortS : public Callback_MyClass_opQShortS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const QShortS&, const QShortS&, const CT&);

    Callback_MyClass_opQShortS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QShortS iceP_o;
        QShortS ret;
        try
        {
            ret = proxy->end_opQShortS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQShortS.
 */
template<class T, typename CT> Callback_MyClass_opQShortSPtr
newCallback_MyClass_opQShortS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QShortS&, const QShortS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQShortS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQShortS.
 */
template<class T, typename CT> Callback_MyClass_opQShortSPtr
newCallback_MyClass_opQShortS(T* instance, void (T::*cb)(const QShortS&, const QShortS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQShortS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSShortS.
 */
template<class T>
class CallbackNC_MyClass_opSShortS : public Callback_MyClass_opSShortS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SShortS&, const SShortS&);

    CallbackNC_MyClass_opSShortS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SShortS iceP_o;
        SShortS ret;
        try
        {
            ret = proxy->end_opSShortS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSShortS.
 */
template<class T> Callback_MyClass_opSShortSPtr
newCallback_MyClass_opSShortS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SShortS&, const SShortS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSShortS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSShortS.
 */
template<class T> Callback_MyClass_opSShortSPtr
newCallback_MyClass_opSShortS(T* instance, void (T::*cb)(const SShortS&, const SShortS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSShortS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSShortS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSShortS.
 */
template<class T, typename CT>
class Callback_MyClass_opSShortS : public Callback_MyClass_opSShortS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SShortS&, const SShortS&, const CT&);

    Callback_MyClass_opSShortS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SShortS iceP_o;
        SShortS ret;
        try
        {
            ret = proxy->end_opSShortS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSShortS.
 */
template<class T, typename CT> Callback_MyClass_opSShortSPtr
newCallback_MyClass_opSShortS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SShortS&, const SShortS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSShortS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSShortS.
 */
template<class T, typename CT> Callback_MyClass_opSShortSPtr
newCallback_MyClass_opSShortS(T* instance, void (T::*cb)(const SShortS&, const SShortS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSShortS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opAIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAIntS.
 */
template<class T>
class CallbackNC_MyClass_opAIntS : public Callback_MyClass_opAIntS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const AIntS&, const AIntS&);

    CallbackNC_MyClass_opAIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AIntS iceP_o;
        AIntS ret;
        try
        {
            ret = proxy->end_opAIntS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAIntS.
 */
template<class T> Callback_MyClass_opAIntSPtr
newCallback_MyClass_opAIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AIntS&, const AIntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAIntS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAIntS.
 */
template<class T> Callback_MyClass_opAIntSPtr
newCallback_MyClass_opAIntS(T* instance, void (T::*cb)(const AIntS&, const AIntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAIntS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opAIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAIntS.
 */
template<class T, typename CT>
class Callback_MyClass_opAIntS : public Callback_MyClass_opAIntS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const AIntS&, const AIntS&, const CT&);

    Callback_MyClass_opAIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AIntS iceP_o;
        AIntS ret;
        try
        {
            ret = proxy->end_opAIntS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAIntS.
 */
template<class T, typename CT> Callback_MyClass_opAIntSPtr
newCallback_MyClass_opAIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AIntS&, const AIntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAIntS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAIntS.
 */
template<class T, typename CT> Callback_MyClass_opAIntSPtr
newCallback_MyClass_opAIntS(T* instance, void (T::*cb)(const AIntS&, const AIntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAIntS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLIntS.
 */
template<class T>
class CallbackNC_MyClass_opLIntS : public Callback_MyClass_opLIntS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LIntS&, const LIntS&);

    CallbackNC_MyClass_opLIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LIntS iceP_o;
        LIntS ret;
        try
        {
            ret = proxy->end_opLIntS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLIntS.
 */
template<class T> Callback_MyClass_opLIntSPtr
newCallback_MyClass_opLIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LIntS&, const LIntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLIntS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLIntS.
 */
template<class T> Callback_MyClass_opLIntSPtr
newCallback_MyClass_opLIntS(T* instance, void (T::*cb)(const LIntS&, const LIntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLIntS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLIntS.
 */
template<class T, typename CT>
class Callback_MyClass_opLIntS : public Callback_MyClass_opLIntS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LIntS&, const LIntS&, const CT&);

    Callback_MyClass_opLIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LIntS iceP_o;
        LIntS ret;
        try
        {
            ret = proxy->end_opLIntS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLIntS.
 */
template<class T, typename CT> Callback_MyClass_opLIntSPtr
newCallback_MyClass_opLIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LIntS&, const LIntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLIntS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLIntS.
 */
template<class T, typename CT> Callback_MyClass_opLIntSPtr
newCallback_MyClass_opLIntS(T* instance, void (T::*cb)(const LIntS&, const LIntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLIntS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opKIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKIntS.
 */
template<class T>
class CallbackNC_MyClass_opKIntS : public Callback_MyClass_opKIntS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const KIntS&, const KIntS&);

    CallbackNC_MyClass_opKIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KIntS iceP_o;
        KIntS ret;
        try
        {
            ret = proxy->end_opKIntS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKIntS.
 */
template<class T> Callback_MyClass_opKIntSPtr
newCallback_MyClass_opKIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KIntS&, const KIntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKIntS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKIntS.
 */
template<class T> Callback_MyClass_opKIntSPtr
newCallback_MyClass_opKIntS(T* instance, void (T::*cb)(const KIntS&, const KIntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKIntS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opKIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKIntS.
 */
template<class T, typename CT>
class Callback_MyClass_opKIntS : public Callback_MyClass_opKIntS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const KIntS&, const KIntS&, const CT&);

    Callback_MyClass_opKIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KIntS iceP_o;
        KIntS ret;
        try
        {
            ret = proxy->end_opKIntS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKIntS.
 */
template<class T, typename CT> Callback_MyClass_opKIntSPtr
newCallback_MyClass_opKIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KIntS&, const KIntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKIntS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKIntS.
 */
template<class T, typename CT> Callback_MyClass_opKIntSPtr
newCallback_MyClass_opKIntS(T* instance, void (T::*cb)(const KIntS&, const KIntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKIntS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opQIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQIntS.
 */
template<class T>
class CallbackNC_MyClass_opQIntS : public Callback_MyClass_opQIntS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const QIntS&, const QIntS&);

    CallbackNC_MyClass_opQIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QIntS iceP_o;
        QIntS ret;
        try
        {
            ret = proxy->end_opQIntS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQIntS.
 */
template<class T> Callback_MyClass_opQIntSPtr
newCallback_MyClass_opQIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QIntS&, const QIntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQIntS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQIntS.
 */
template<class T> Callback_MyClass_opQIntSPtr
newCallback_MyClass_opQIntS(T* instance, void (T::*cb)(const QIntS&, const QIntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQIntS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opQIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQIntS.
 */
template<class T, typename CT>
class Callback_MyClass_opQIntS : public Callback_MyClass_opQIntS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const QIntS&, const QIntS&, const CT&);

    Callback_MyClass_opQIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QIntS iceP_o;
        QIntS ret;
        try
        {
            ret = proxy->end_opQIntS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQIntS.
 */
template<class T, typename CT> Callback_MyClass_opQIntSPtr
newCallback_MyClass_opQIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QIntS&, const QIntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQIntS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQIntS.
 */
template<class T, typename CT> Callback_MyClass_opQIntSPtr
newCallback_MyClass_opQIntS(T* instance, void (T::*cb)(const QIntS&, const QIntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQIntS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSIntS.
 */
template<class T>
class CallbackNC_MyClass_opSIntS : public Callback_MyClass_opSIntS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SIntS&, const SIntS&);

    CallbackNC_MyClass_opSIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SIntS iceP_o;
        SIntS ret;
        try
        {
            ret = proxy->end_opSIntS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSIntS.
 */
template<class T> Callback_MyClass_opSIntSPtr
newCallback_MyClass_opSIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SIntS&, const SIntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSIntS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSIntS.
 */
template<class T> Callback_MyClass_opSIntSPtr
newCallback_MyClass_opSIntS(T* instance, void (T::*cb)(const SIntS&, const SIntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSIntS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSIntS.
 */
template<class T, typename CT>
class Callback_MyClass_opSIntS : public Callback_MyClass_opSIntS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SIntS&, const SIntS&, const CT&);

    Callback_MyClass_opSIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SIntS iceP_o;
        SIntS ret;
        try
        {
            ret = proxy->end_opSIntS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSIntS.
 */
template<class T, typename CT> Callback_MyClass_opSIntSPtr
newCallback_MyClass_opSIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SIntS&, const SIntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSIntS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSIntS.
 */
template<class T, typename CT> Callback_MyClass_opSIntSPtr
newCallback_MyClass_opSIntS(T* instance, void (T::*cb)(const SIntS&, const SIntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSIntS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opALongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opALongS.
 */
template<class T>
class CallbackNC_MyClass_opALongS : public Callback_MyClass_opALongS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ALongS&, const ALongS&);

    CallbackNC_MyClass_opALongS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ALongS iceP_o;
        ALongS ret;
        try
        {
            ret = proxy->end_opALongS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opALongS.
 */
template<class T> Callback_MyClass_opALongSPtr
newCallback_MyClass_opALongS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ALongS&, const ALongS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opALongS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opALongS.
 */
template<class T> Callback_MyClass_opALongSPtr
newCallback_MyClass_opALongS(T* instance, void (T::*cb)(const ALongS&, const ALongS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opALongS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opALongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opALongS.
 */
template<class T, typename CT>
class Callback_MyClass_opALongS : public Callback_MyClass_opALongS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ALongS&, const ALongS&, const CT&);

    Callback_MyClass_opALongS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ALongS iceP_o;
        ALongS ret;
        try
        {
            ret = proxy->end_opALongS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opALongS.
 */
template<class T, typename CT> Callback_MyClass_opALongSPtr
newCallback_MyClass_opALongS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ALongS&, const ALongS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opALongS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opALongS.
 */
template<class T, typename CT> Callback_MyClass_opALongSPtr
newCallback_MyClass_opALongS(T* instance, void (T::*cb)(const ALongS&, const ALongS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opALongS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLLongS.
 */
template<class T>
class CallbackNC_MyClass_opLLongS : public Callback_MyClass_opLLongS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LLongS&, const LLongS&);

    CallbackNC_MyClass_opLLongS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LLongS iceP_o;
        LLongS ret;
        try
        {
            ret = proxy->end_opLLongS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLLongS.
 */
template<class T> Callback_MyClass_opLLongSPtr
newCallback_MyClass_opLLongS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LLongS&, const LLongS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLLongS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLLongS.
 */
template<class T> Callback_MyClass_opLLongSPtr
newCallback_MyClass_opLLongS(T* instance, void (T::*cb)(const LLongS&, const LLongS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLLongS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLLongS.
 */
template<class T, typename CT>
class Callback_MyClass_opLLongS : public Callback_MyClass_opLLongS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LLongS&, const LLongS&, const CT&);

    Callback_MyClass_opLLongS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LLongS iceP_o;
        LLongS ret;
        try
        {
            ret = proxy->end_opLLongS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLLongS.
 */
template<class T, typename CT> Callback_MyClass_opLLongSPtr
newCallback_MyClass_opLLongS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LLongS&, const LLongS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLLongS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLLongS.
 */
template<class T, typename CT> Callback_MyClass_opLLongSPtr
newCallback_MyClass_opLLongS(T* instance, void (T::*cb)(const LLongS&, const LLongS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLLongS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opKLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKLongS.
 */
template<class T>
class CallbackNC_MyClass_opKLongS : public Callback_MyClass_opKLongS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const KLongS&, const KLongS&);

    CallbackNC_MyClass_opKLongS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KLongS iceP_o;
        KLongS ret;
        try
        {
            ret = proxy->end_opKLongS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKLongS.
 */
template<class T> Callback_MyClass_opKLongSPtr
newCallback_MyClass_opKLongS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KLongS&, const KLongS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKLongS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKLongS.
 */
template<class T> Callback_MyClass_opKLongSPtr
newCallback_MyClass_opKLongS(T* instance, void (T::*cb)(const KLongS&, const KLongS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKLongS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opKLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKLongS.
 */
template<class T, typename CT>
class Callback_MyClass_opKLongS : public Callback_MyClass_opKLongS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const KLongS&, const KLongS&, const CT&);

    Callback_MyClass_opKLongS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KLongS iceP_o;
        KLongS ret;
        try
        {
            ret = proxy->end_opKLongS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKLongS.
 */
template<class T, typename CT> Callback_MyClass_opKLongSPtr
newCallback_MyClass_opKLongS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KLongS&, const KLongS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKLongS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKLongS.
 */
template<class T, typename CT> Callback_MyClass_opKLongSPtr
newCallback_MyClass_opKLongS(T* instance, void (T::*cb)(const KLongS&, const KLongS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKLongS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opQLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQLongS.
 */
template<class T>
class CallbackNC_MyClass_opQLongS : public Callback_MyClass_opQLongS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const QLongS&, const QLongS&);

    CallbackNC_MyClass_opQLongS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QLongS iceP_o;
        QLongS ret;
        try
        {
            ret = proxy->end_opQLongS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQLongS.
 */
template<class T> Callback_MyClass_opQLongSPtr
newCallback_MyClass_opQLongS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QLongS&, const QLongS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQLongS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQLongS.
 */
template<class T> Callback_MyClass_opQLongSPtr
newCallback_MyClass_opQLongS(T* instance, void (T::*cb)(const QLongS&, const QLongS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQLongS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opQLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQLongS.
 */
template<class T, typename CT>
class Callback_MyClass_opQLongS : public Callback_MyClass_opQLongS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const QLongS&, const QLongS&, const CT&);

    Callback_MyClass_opQLongS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QLongS iceP_o;
        QLongS ret;
        try
        {
            ret = proxy->end_opQLongS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQLongS.
 */
template<class T, typename CT> Callback_MyClass_opQLongSPtr
newCallback_MyClass_opQLongS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QLongS&, const QLongS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQLongS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQLongS.
 */
template<class T, typename CT> Callback_MyClass_opQLongSPtr
newCallback_MyClass_opQLongS(T* instance, void (T::*cb)(const QLongS&, const QLongS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQLongS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSLongS.
 */
template<class T>
class CallbackNC_MyClass_opSLongS : public Callback_MyClass_opSLongS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SLongS&, const SLongS&);

    CallbackNC_MyClass_opSLongS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SLongS iceP_o;
        SLongS ret;
        try
        {
            ret = proxy->end_opSLongS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSLongS.
 */
template<class T> Callback_MyClass_opSLongSPtr
newCallback_MyClass_opSLongS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SLongS&, const SLongS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSLongS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSLongS.
 */
template<class T> Callback_MyClass_opSLongSPtr
newCallback_MyClass_opSLongS(T* instance, void (T::*cb)(const SLongS&, const SLongS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSLongS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSLongS.
 */
template<class T, typename CT>
class Callback_MyClass_opSLongS : public Callback_MyClass_opSLongS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SLongS&, const SLongS&, const CT&);

    Callback_MyClass_opSLongS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SLongS iceP_o;
        SLongS ret;
        try
        {
            ret = proxy->end_opSLongS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSLongS.
 */
template<class T, typename CT> Callback_MyClass_opSLongSPtr
newCallback_MyClass_opSLongS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SLongS&, const SLongS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSLongS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSLongS.
 */
template<class T, typename CT> Callback_MyClass_opSLongSPtr
newCallback_MyClass_opSLongS(T* instance, void (T::*cb)(const SLongS&, const SLongS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSLongS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opAFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAFloatS.
 */
template<class T>
class CallbackNC_MyClass_opAFloatS : public Callback_MyClass_opAFloatS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const AFloatS&, const AFloatS&);

    CallbackNC_MyClass_opAFloatS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AFloatS iceP_o;
        AFloatS ret;
        try
        {
            ret = proxy->end_opAFloatS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAFloatS.
 */
template<class T> Callback_MyClass_opAFloatSPtr
newCallback_MyClass_opAFloatS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AFloatS&, const AFloatS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAFloatS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAFloatS.
 */
template<class T> Callback_MyClass_opAFloatSPtr
newCallback_MyClass_opAFloatS(T* instance, void (T::*cb)(const AFloatS&, const AFloatS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAFloatS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opAFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAFloatS.
 */
template<class T, typename CT>
class Callback_MyClass_opAFloatS : public Callback_MyClass_opAFloatS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const AFloatS&, const AFloatS&, const CT&);

    Callback_MyClass_opAFloatS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AFloatS iceP_o;
        AFloatS ret;
        try
        {
            ret = proxy->end_opAFloatS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAFloatS.
 */
template<class T, typename CT> Callback_MyClass_opAFloatSPtr
newCallback_MyClass_opAFloatS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AFloatS&, const AFloatS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAFloatS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAFloatS.
 */
template<class T, typename CT> Callback_MyClass_opAFloatSPtr
newCallback_MyClass_opAFloatS(T* instance, void (T::*cb)(const AFloatS&, const AFloatS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAFloatS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLFloatS.
 */
template<class T>
class CallbackNC_MyClass_opLFloatS : public Callback_MyClass_opLFloatS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LFloatS&, const LFloatS&);

    CallbackNC_MyClass_opLFloatS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LFloatS iceP_o;
        LFloatS ret;
        try
        {
            ret = proxy->end_opLFloatS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLFloatS.
 */
template<class T> Callback_MyClass_opLFloatSPtr
newCallback_MyClass_opLFloatS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LFloatS&, const LFloatS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLFloatS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLFloatS.
 */
template<class T> Callback_MyClass_opLFloatSPtr
newCallback_MyClass_opLFloatS(T* instance, void (T::*cb)(const LFloatS&, const LFloatS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLFloatS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLFloatS.
 */
template<class T, typename CT>
class Callback_MyClass_opLFloatS : public Callback_MyClass_opLFloatS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LFloatS&, const LFloatS&, const CT&);

    Callback_MyClass_opLFloatS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LFloatS iceP_o;
        LFloatS ret;
        try
        {
            ret = proxy->end_opLFloatS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLFloatS.
 */
template<class T, typename CT> Callback_MyClass_opLFloatSPtr
newCallback_MyClass_opLFloatS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LFloatS&, const LFloatS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLFloatS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLFloatS.
 */
template<class T, typename CT> Callback_MyClass_opLFloatSPtr
newCallback_MyClass_opLFloatS(T* instance, void (T::*cb)(const LFloatS&, const LFloatS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLFloatS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opKFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKFloatS.
 */
template<class T>
class CallbackNC_MyClass_opKFloatS : public Callback_MyClass_opKFloatS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const KFloatS&, const KFloatS&);

    CallbackNC_MyClass_opKFloatS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KFloatS iceP_o;
        KFloatS ret;
        try
        {
            ret = proxy->end_opKFloatS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKFloatS.
 */
template<class T> Callback_MyClass_opKFloatSPtr
newCallback_MyClass_opKFloatS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KFloatS&, const KFloatS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKFloatS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKFloatS.
 */
template<class T> Callback_MyClass_opKFloatSPtr
newCallback_MyClass_opKFloatS(T* instance, void (T::*cb)(const KFloatS&, const KFloatS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKFloatS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opKFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKFloatS.
 */
template<class T, typename CT>
class Callback_MyClass_opKFloatS : public Callback_MyClass_opKFloatS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const KFloatS&, const KFloatS&, const CT&);

    Callback_MyClass_opKFloatS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KFloatS iceP_o;
        KFloatS ret;
        try
        {
            ret = proxy->end_opKFloatS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKFloatS.
 */
template<class T, typename CT> Callback_MyClass_opKFloatSPtr
newCallback_MyClass_opKFloatS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KFloatS&, const KFloatS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKFloatS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKFloatS.
 */
template<class T, typename CT> Callback_MyClass_opKFloatSPtr
newCallback_MyClass_opKFloatS(T* instance, void (T::*cb)(const KFloatS&, const KFloatS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKFloatS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opQFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQFloatS.
 */
template<class T>
class CallbackNC_MyClass_opQFloatS : public Callback_MyClass_opQFloatS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const QFloatS&, const QFloatS&);

    CallbackNC_MyClass_opQFloatS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QFloatS iceP_o;
        QFloatS ret;
        try
        {
            ret = proxy->end_opQFloatS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQFloatS.
 */
template<class T> Callback_MyClass_opQFloatSPtr
newCallback_MyClass_opQFloatS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QFloatS&, const QFloatS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQFloatS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQFloatS.
 */
template<class T> Callback_MyClass_opQFloatSPtr
newCallback_MyClass_opQFloatS(T* instance, void (T::*cb)(const QFloatS&, const QFloatS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQFloatS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opQFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQFloatS.
 */
template<class T, typename CT>
class Callback_MyClass_opQFloatS : public Callback_MyClass_opQFloatS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const QFloatS&, const QFloatS&, const CT&);

    Callback_MyClass_opQFloatS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QFloatS iceP_o;
        QFloatS ret;
        try
        {
            ret = proxy->end_opQFloatS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQFloatS.
 */
template<class T, typename CT> Callback_MyClass_opQFloatSPtr
newCallback_MyClass_opQFloatS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QFloatS&, const QFloatS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQFloatS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQFloatS.
 */
template<class T, typename CT> Callback_MyClass_opQFloatSPtr
newCallback_MyClass_opQFloatS(T* instance, void (T::*cb)(const QFloatS&, const QFloatS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQFloatS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSFloatS.
 */
template<class T>
class CallbackNC_MyClass_opSFloatS : public Callback_MyClass_opSFloatS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SFloatS&, const SFloatS&);

    CallbackNC_MyClass_opSFloatS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SFloatS iceP_o;
        SFloatS ret;
        try
        {
            ret = proxy->end_opSFloatS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSFloatS.
 */
template<class T> Callback_MyClass_opSFloatSPtr
newCallback_MyClass_opSFloatS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SFloatS&, const SFloatS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSFloatS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSFloatS.
 */
template<class T> Callback_MyClass_opSFloatSPtr
newCallback_MyClass_opSFloatS(T* instance, void (T::*cb)(const SFloatS&, const SFloatS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSFloatS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSFloatS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSFloatS.
 */
template<class T, typename CT>
class Callback_MyClass_opSFloatS : public Callback_MyClass_opSFloatS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SFloatS&, const SFloatS&, const CT&);

    Callback_MyClass_opSFloatS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SFloatS iceP_o;
        SFloatS ret;
        try
        {
            ret = proxy->end_opSFloatS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSFloatS.
 */
template<class T, typename CT> Callback_MyClass_opSFloatSPtr
newCallback_MyClass_opSFloatS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SFloatS&, const SFloatS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSFloatS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSFloatS.
 */
template<class T, typename CT> Callback_MyClass_opSFloatSPtr
newCallback_MyClass_opSFloatS(T* instance, void (T::*cb)(const SFloatS&, const SFloatS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSFloatS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opADoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opADoubleS.
 */
template<class T>
class CallbackNC_MyClass_opADoubleS : public Callback_MyClass_opADoubleS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ADoubleS&, const ADoubleS&);

    CallbackNC_MyClass_opADoubleS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ADoubleS iceP_o;
        ADoubleS ret;
        try
        {
            ret = proxy->end_opADoubleS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opADoubleS.
 */
template<class T> Callback_MyClass_opADoubleSPtr
newCallback_MyClass_opADoubleS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ADoubleS&, const ADoubleS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opADoubleS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opADoubleS.
 */
template<class T> Callback_MyClass_opADoubleSPtr
newCallback_MyClass_opADoubleS(T* instance, void (T::*cb)(const ADoubleS&, const ADoubleS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opADoubleS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opADoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opADoubleS.
 */
template<class T, typename CT>
class Callback_MyClass_opADoubleS : public Callback_MyClass_opADoubleS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ADoubleS&, const ADoubleS&, const CT&);

    Callback_MyClass_opADoubleS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ADoubleS iceP_o;
        ADoubleS ret;
        try
        {
            ret = proxy->end_opADoubleS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opADoubleS.
 */
template<class T, typename CT> Callback_MyClass_opADoubleSPtr
newCallback_MyClass_opADoubleS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ADoubleS&, const ADoubleS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opADoubleS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opADoubleS.
 */
template<class T, typename CT> Callback_MyClass_opADoubleSPtr
newCallback_MyClass_opADoubleS(T* instance, void (T::*cb)(const ADoubleS&, const ADoubleS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opADoubleS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLDoubleS.
 */
template<class T>
class CallbackNC_MyClass_opLDoubleS : public Callback_MyClass_opLDoubleS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LDoubleS&, const LDoubleS&);

    CallbackNC_MyClass_opLDoubleS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LDoubleS iceP_o;
        LDoubleS ret;
        try
        {
            ret = proxy->end_opLDoubleS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLDoubleS.
 */
template<class T> Callback_MyClass_opLDoubleSPtr
newCallback_MyClass_opLDoubleS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LDoubleS&, const LDoubleS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLDoubleS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLDoubleS.
 */
template<class T> Callback_MyClass_opLDoubleSPtr
newCallback_MyClass_opLDoubleS(T* instance, void (T::*cb)(const LDoubleS&, const LDoubleS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLDoubleS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLDoubleS.
 */
template<class T, typename CT>
class Callback_MyClass_opLDoubleS : public Callback_MyClass_opLDoubleS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LDoubleS&, const LDoubleS&, const CT&);

    Callback_MyClass_opLDoubleS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LDoubleS iceP_o;
        LDoubleS ret;
        try
        {
            ret = proxy->end_opLDoubleS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLDoubleS.
 */
template<class T, typename CT> Callback_MyClass_opLDoubleSPtr
newCallback_MyClass_opLDoubleS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LDoubleS&, const LDoubleS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLDoubleS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLDoubleS.
 */
template<class T, typename CT> Callback_MyClass_opLDoubleSPtr
newCallback_MyClass_opLDoubleS(T* instance, void (T::*cb)(const LDoubleS&, const LDoubleS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLDoubleS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opKDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKDoubleS.
 */
template<class T>
class CallbackNC_MyClass_opKDoubleS : public Callback_MyClass_opKDoubleS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const KDoubleS&, const KDoubleS&);

    CallbackNC_MyClass_opKDoubleS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KDoubleS iceP_o;
        KDoubleS ret;
        try
        {
            ret = proxy->end_opKDoubleS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKDoubleS.
 */
template<class T> Callback_MyClass_opKDoubleSPtr
newCallback_MyClass_opKDoubleS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KDoubleS&, const KDoubleS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKDoubleS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKDoubleS.
 */
template<class T> Callback_MyClass_opKDoubleSPtr
newCallback_MyClass_opKDoubleS(T* instance, void (T::*cb)(const KDoubleS&, const KDoubleS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKDoubleS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opKDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKDoubleS.
 */
template<class T, typename CT>
class Callback_MyClass_opKDoubleS : public Callback_MyClass_opKDoubleS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const KDoubleS&, const KDoubleS&, const CT&);

    Callback_MyClass_opKDoubleS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KDoubleS iceP_o;
        KDoubleS ret;
        try
        {
            ret = proxy->end_opKDoubleS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKDoubleS.
 */
template<class T, typename CT> Callback_MyClass_opKDoubleSPtr
newCallback_MyClass_opKDoubleS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KDoubleS&, const KDoubleS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKDoubleS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKDoubleS.
 */
template<class T, typename CT> Callback_MyClass_opKDoubleSPtr
newCallback_MyClass_opKDoubleS(T* instance, void (T::*cb)(const KDoubleS&, const KDoubleS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKDoubleS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opQDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQDoubleS.
 */
template<class T>
class CallbackNC_MyClass_opQDoubleS : public Callback_MyClass_opQDoubleS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const QDoubleS&, const QDoubleS&);

    CallbackNC_MyClass_opQDoubleS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QDoubleS iceP_o;
        QDoubleS ret;
        try
        {
            ret = proxy->end_opQDoubleS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQDoubleS.
 */
template<class T> Callback_MyClass_opQDoubleSPtr
newCallback_MyClass_opQDoubleS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QDoubleS&, const QDoubleS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQDoubleS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQDoubleS.
 */
template<class T> Callback_MyClass_opQDoubleSPtr
newCallback_MyClass_opQDoubleS(T* instance, void (T::*cb)(const QDoubleS&, const QDoubleS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQDoubleS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opQDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQDoubleS.
 */
template<class T, typename CT>
class Callback_MyClass_opQDoubleS : public Callback_MyClass_opQDoubleS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const QDoubleS&, const QDoubleS&, const CT&);

    Callback_MyClass_opQDoubleS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QDoubleS iceP_o;
        QDoubleS ret;
        try
        {
            ret = proxy->end_opQDoubleS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQDoubleS.
 */
template<class T, typename CT> Callback_MyClass_opQDoubleSPtr
newCallback_MyClass_opQDoubleS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QDoubleS&, const QDoubleS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQDoubleS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQDoubleS.
 */
template<class T, typename CT> Callback_MyClass_opQDoubleSPtr
newCallback_MyClass_opQDoubleS(T* instance, void (T::*cb)(const QDoubleS&, const QDoubleS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQDoubleS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSDoubleS.
 */
template<class T>
class CallbackNC_MyClass_opSDoubleS : public Callback_MyClass_opSDoubleS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SDoubleS&, const SDoubleS&);

    CallbackNC_MyClass_opSDoubleS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SDoubleS iceP_o;
        SDoubleS ret;
        try
        {
            ret = proxy->end_opSDoubleS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSDoubleS.
 */
template<class T> Callback_MyClass_opSDoubleSPtr
newCallback_MyClass_opSDoubleS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SDoubleS&, const SDoubleS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSDoubleS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSDoubleS.
 */
template<class T> Callback_MyClass_opSDoubleSPtr
newCallback_MyClass_opSDoubleS(T* instance, void (T::*cb)(const SDoubleS&, const SDoubleS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSDoubleS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSDoubleS.
 */
template<class T, typename CT>
class Callback_MyClass_opSDoubleS : public Callback_MyClass_opSDoubleS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SDoubleS&, const SDoubleS&, const CT&);

    Callback_MyClass_opSDoubleS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SDoubleS iceP_o;
        SDoubleS ret;
        try
        {
            ret = proxy->end_opSDoubleS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSDoubleS.
 */
template<class T, typename CT> Callback_MyClass_opSDoubleSPtr
newCallback_MyClass_opSDoubleS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SDoubleS&, const SDoubleS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSDoubleS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSDoubleS.
 */
template<class T, typename CT> Callback_MyClass_opSDoubleSPtr
newCallback_MyClass_opSDoubleS(T* instance, void (T::*cb)(const SDoubleS&, const SDoubleS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSDoubleS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opAStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAStringS.
 */
template<class T>
class CallbackNC_MyClass_opAStringS : public Callback_MyClass_opAStringS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const AStringS&, const AStringS&);

    CallbackNC_MyClass_opAStringS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AStringS iceP_o;
        AStringS ret;
        try
        {
            ret = proxy->end_opAStringS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAStringS.
 */
template<class T> Callback_MyClass_opAStringSPtr
newCallback_MyClass_opAStringS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AStringS&, const AStringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAStringS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAStringS.
 */
template<class T> Callback_MyClass_opAStringSPtr
newCallback_MyClass_opAStringS(T* instance, void (T::*cb)(const AStringS&, const AStringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAStringS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opAStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAStringS.
 */
template<class T, typename CT>
class Callback_MyClass_opAStringS : public Callback_MyClass_opAStringS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const AStringS&, const AStringS&, const CT&);

    Callback_MyClass_opAStringS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AStringS iceP_o;
        AStringS ret;
        try
        {
            ret = proxy->end_opAStringS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAStringS.
 */
template<class T, typename CT> Callback_MyClass_opAStringSPtr
newCallback_MyClass_opAStringS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AStringS&, const AStringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAStringS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAStringS.
 */
template<class T, typename CT> Callback_MyClass_opAStringSPtr
newCallback_MyClass_opAStringS(T* instance, void (T::*cb)(const AStringS&, const AStringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAStringS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLStringS.
 */
template<class T>
class CallbackNC_MyClass_opLStringS : public Callback_MyClass_opLStringS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LStringS&, const LStringS&);

    CallbackNC_MyClass_opLStringS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LStringS iceP_o;
        LStringS ret;
        try
        {
            ret = proxy->end_opLStringS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLStringS.
 */
template<class T> Callback_MyClass_opLStringSPtr
newCallback_MyClass_opLStringS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LStringS&, const LStringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLStringS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLStringS.
 */
template<class T> Callback_MyClass_opLStringSPtr
newCallback_MyClass_opLStringS(T* instance, void (T::*cb)(const LStringS&, const LStringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLStringS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLStringS.
 */
template<class T, typename CT>
class Callback_MyClass_opLStringS : public Callback_MyClass_opLStringS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LStringS&, const LStringS&, const CT&);

    Callback_MyClass_opLStringS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LStringS iceP_o;
        LStringS ret;
        try
        {
            ret = proxy->end_opLStringS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLStringS.
 */
template<class T, typename CT> Callback_MyClass_opLStringSPtr
newCallback_MyClass_opLStringS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LStringS&, const LStringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLStringS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLStringS.
 */
template<class T, typename CT> Callback_MyClass_opLStringSPtr
newCallback_MyClass_opLStringS(T* instance, void (T::*cb)(const LStringS&, const LStringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLStringS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opKStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKStringS.
 */
template<class T>
class CallbackNC_MyClass_opKStringS : public Callback_MyClass_opKStringS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const KStringS&, const KStringS&);

    CallbackNC_MyClass_opKStringS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KStringS iceP_o;
        KStringS ret;
        try
        {
            ret = proxy->end_opKStringS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKStringS.
 */
template<class T> Callback_MyClass_opKStringSPtr
newCallback_MyClass_opKStringS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KStringS&, const KStringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKStringS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKStringS.
 */
template<class T> Callback_MyClass_opKStringSPtr
newCallback_MyClass_opKStringS(T* instance, void (T::*cb)(const KStringS&, const KStringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKStringS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opKStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKStringS.
 */
template<class T, typename CT>
class Callback_MyClass_opKStringS : public Callback_MyClass_opKStringS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const KStringS&, const KStringS&, const CT&);

    Callback_MyClass_opKStringS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KStringS iceP_o;
        KStringS ret;
        try
        {
            ret = proxy->end_opKStringS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKStringS.
 */
template<class T, typename CT> Callback_MyClass_opKStringSPtr
newCallback_MyClass_opKStringS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KStringS&, const KStringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKStringS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKStringS.
 */
template<class T, typename CT> Callback_MyClass_opKStringSPtr
newCallback_MyClass_opKStringS(T* instance, void (T::*cb)(const KStringS&, const KStringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKStringS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opQStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQStringS.
 */
template<class T>
class CallbackNC_MyClass_opQStringS : public Callback_MyClass_opQStringS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const QStringS&, const QStringS&);

    CallbackNC_MyClass_opQStringS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QStringS iceP_o;
        QStringS ret;
        try
        {
            ret = proxy->end_opQStringS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQStringS.
 */
template<class T> Callback_MyClass_opQStringSPtr
newCallback_MyClass_opQStringS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QStringS&, const QStringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQStringS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQStringS.
 */
template<class T> Callback_MyClass_opQStringSPtr
newCallback_MyClass_opQStringS(T* instance, void (T::*cb)(const QStringS&, const QStringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQStringS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opQStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQStringS.
 */
template<class T, typename CT>
class Callback_MyClass_opQStringS : public Callback_MyClass_opQStringS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const QStringS&, const QStringS&, const CT&);

    Callback_MyClass_opQStringS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QStringS iceP_o;
        QStringS ret;
        try
        {
            ret = proxy->end_opQStringS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQStringS.
 */
template<class T, typename CT> Callback_MyClass_opQStringSPtr
newCallback_MyClass_opQStringS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QStringS&, const QStringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQStringS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQStringS.
 */
template<class T, typename CT> Callback_MyClass_opQStringSPtr
newCallback_MyClass_opQStringS(T* instance, void (T::*cb)(const QStringS&, const QStringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQStringS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSStringS.
 */
template<class T>
class CallbackNC_MyClass_opSStringS : public Callback_MyClass_opSStringS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SStringS&, const SStringS&);

    CallbackNC_MyClass_opSStringS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SStringS iceP_o;
        SStringS ret;
        try
        {
            ret = proxy->end_opSStringS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSStringS.
 */
template<class T> Callback_MyClass_opSStringSPtr
newCallback_MyClass_opSStringS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SStringS&, const SStringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSStringS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSStringS.
 */
template<class T> Callback_MyClass_opSStringSPtr
newCallback_MyClass_opSStringS(T* instance, void (T::*cb)(const SStringS&, const SStringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSStringS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSStringS.
 */
template<class T, typename CT>
class Callback_MyClass_opSStringS : public Callback_MyClass_opSStringS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SStringS&, const SStringS&, const CT&);

    Callback_MyClass_opSStringS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SStringS iceP_o;
        SStringS ret;
        try
        {
            ret = proxy->end_opSStringS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSStringS.
 */
template<class T, typename CT> Callback_MyClass_opSStringSPtr
newCallback_MyClass_opSStringS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SStringS&, const SStringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSStringS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSStringS.
 */
template<class T, typename CT> Callback_MyClass_opSStringSPtr
newCallback_MyClass_opSStringS(T* instance, void (T::*cb)(const SStringS&, const SStringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSStringS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opAObjectS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAObjectS.
 */
template<class T>
class CallbackNC_MyClass_opAObjectS : public Callback_MyClass_opAObjectS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const AObjectS&, const AObjectS&);

    CallbackNC_MyClass_opAObjectS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AObjectS iceP_o;
        AObjectS ret;
        try
        {
            ret = proxy->end_opAObjectS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAObjectS.
 */
template<class T> Callback_MyClass_opAObjectSPtr
newCallback_MyClass_opAObjectS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AObjectS&, const AObjectS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAObjectS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAObjectS.
 */
template<class T> Callback_MyClass_opAObjectSPtr
newCallback_MyClass_opAObjectS(T* instance, void (T::*cb)(const AObjectS&, const AObjectS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAObjectS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opAObjectS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAObjectS.
 */
template<class T, typename CT>
class Callback_MyClass_opAObjectS : public Callback_MyClass_opAObjectS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const AObjectS&, const AObjectS&, const CT&);

    Callback_MyClass_opAObjectS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AObjectS iceP_o;
        AObjectS ret;
        try
        {
            ret = proxy->end_opAObjectS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAObjectS.
 */
template<class T, typename CT> Callback_MyClass_opAObjectSPtr
newCallback_MyClass_opAObjectS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AObjectS&, const AObjectS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAObjectS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAObjectS.
 */
template<class T, typename CT> Callback_MyClass_opAObjectSPtr
newCallback_MyClass_opAObjectS(T* instance, void (T::*cb)(const AObjectS&, const AObjectS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAObjectS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLObjectS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLObjectS.
 */
template<class T>
class CallbackNC_MyClass_opLObjectS : public Callback_MyClass_opLObjectS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LObjectS&, const LObjectS&);

    CallbackNC_MyClass_opLObjectS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LObjectS iceP_o;
        LObjectS ret;
        try
        {
            ret = proxy->end_opLObjectS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLObjectS.
 */
template<class T> Callback_MyClass_opLObjectSPtr
newCallback_MyClass_opLObjectS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LObjectS&, const LObjectS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLObjectS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLObjectS.
 */
template<class T> Callback_MyClass_opLObjectSPtr
newCallback_MyClass_opLObjectS(T* instance, void (T::*cb)(const LObjectS&, const LObjectS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLObjectS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLObjectS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLObjectS.
 */
template<class T, typename CT>
class Callback_MyClass_opLObjectS : public Callback_MyClass_opLObjectS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LObjectS&, const LObjectS&, const CT&);

    Callback_MyClass_opLObjectS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LObjectS iceP_o;
        LObjectS ret;
        try
        {
            ret = proxy->end_opLObjectS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLObjectS.
 */
template<class T, typename CT> Callback_MyClass_opLObjectSPtr
newCallback_MyClass_opLObjectS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LObjectS&, const LObjectS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLObjectS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLObjectS.
 */
template<class T, typename CT> Callback_MyClass_opLObjectSPtr
newCallback_MyClass_opLObjectS(T* instance, void (T::*cb)(const LObjectS&, const LObjectS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLObjectS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opAObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAObjectPrxS.
 */
template<class T>
class CallbackNC_MyClass_opAObjectPrxS : public Callback_MyClass_opAObjectPrxS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const AObjectPrxS&, const AObjectPrxS&);

    CallbackNC_MyClass_opAObjectPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AObjectPrxS iceP_o;
        AObjectPrxS ret;
        try
        {
            ret = proxy->end_opAObjectPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAObjectPrxS.
 */
template<class T> Callback_MyClass_opAObjectPrxSPtr
newCallback_MyClass_opAObjectPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AObjectPrxS&, const AObjectPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAObjectPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAObjectPrxS.
 */
template<class T> Callback_MyClass_opAObjectPrxSPtr
newCallback_MyClass_opAObjectPrxS(T* instance, void (T::*cb)(const AObjectPrxS&, const AObjectPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAObjectPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opAObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAObjectPrxS.
 */
template<class T, typename CT>
class Callback_MyClass_opAObjectPrxS : public Callback_MyClass_opAObjectPrxS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const AObjectPrxS&, const AObjectPrxS&, const CT&);

    Callback_MyClass_opAObjectPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AObjectPrxS iceP_o;
        AObjectPrxS ret;
        try
        {
            ret = proxy->end_opAObjectPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAObjectPrxS.
 */
template<class T, typename CT> Callback_MyClass_opAObjectPrxSPtr
newCallback_MyClass_opAObjectPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AObjectPrxS&, const AObjectPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAObjectPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAObjectPrxS.
 */
template<class T, typename CT> Callback_MyClass_opAObjectPrxSPtr
newCallback_MyClass_opAObjectPrxS(T* instance, void (T::*cb)(const AObjectPrxS&, const AObjectPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAObjectPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLObjectPrxS.
 */
template<class T>
class CallbackNC_MyClass_opLObjectPrxS : public Callback_MyClass_opLObjectPrxS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LObjectPrxS&, const LObjectPrxS&);

    CallbackNC_MyClass_opLObjectPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LObjectPrxS iceP_o;
        LObjectPrxS ret;
        try
        {
            ret = proxy->end_opLObjectPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLObjectPrxS.
 */
template<class T> Callback_MyClass_opLObjectPrxSPtr
newCallback_MyClass_opLObjectPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LObjectPrxS&, const LObjectPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLObjectPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLObjectPrxS.
 */
template<class T> Callback_MyClass_opLObjectPrxSPtr
newCallback_MyClass_opLObjectPrxS(T* instance, void (T::*cb)(const LObjectPrxS&, const LObjectPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLObjectPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLObjectPrxS.
 */
template<class T, typename CT>
class Callback_MyClass_opLObjectPrxS : public Callback_MyClass_opLObjectPrxS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LObjectPrxS&, const LObjectPrxS&, const CT&);

    Callback_MyClass_opLObjectPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LObjectPrxS iceP_o;
        LObjectPrxS ret;
        try
        {
            ret = proxy->end_opLObjectPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLObjectPrxS.
 */
template<class T, typename CT> Callback_MyClass_opLObjectPrxSPtr
newCallback_MyClass_opLObjectPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LObjectPrxS&, const LObjectPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLObjectPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLObjectPrxS.
 */
template<class T, typename CT> Callback_MyClass_opLObjectPrxSPtr
newCallback_MyClass_opLObjectPrxS(T* instance, void (T::*cb)(const LObjectPrxS&, const LObjectPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLObjectPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opKObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKObjectPrxS.
 */
template<class T>
class CallbackNC_MyClass_opKObjectPrxS : public Callback_MyClass_opKObjectPrxS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const KObjectPrxS&, const KObjectPrxS&);

    CallbackNC_MyClass_opKObjectPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KObjectPrxS iceP_o;
        KObjectPrxS ret;
        try
        {
            ret = proxy->end_opKObjectPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKObjectPrxS.
 */
template<class T> Callback_MyClass_opKObjectPrxSPtr
newCallback_MyClass_opKObjectPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KObjectPrxS&, const KObjectPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKObjectPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKObjectPrxS.
 */
template<class T> Callback_MyClass_opKObjectPrxSPtr
newCallback_MyClass_opKObjectPrxS(T* instance, void (T::*cb)(const KObjectPrxS&, const KObjectPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKObjectPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opKObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKObjectPrxS.
 */
template<class T, typename CT>
class Callback_MyClass_opKObjectPrxS : public Callback_MyClass_opKObjectPrxS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const KObjectPrxS&, const KObjectPrxS&, const CT&);

    Callback_MyClass_opKObjectPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KObjectPrxS iceP_o;
        KObjectPrxS ret;
        try
        {
            ret = proxy->end_opKObjectPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKObjectPrxS.
 */
template<class T, typename CT> Callback_MyClass_opKObjectPrxSPtr
newCallback_MyClass_opKObjectPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KObjectPrxS&, const KObjectPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKObjectPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKObjectPrxS.
 */
template<class T, typename CT> Callback_MyClass_opKObjectPrxSPtr
newCallback_MyClass_opKObjectPrxS(T* instance, void (T::*cb)(const KObjectPrxS&, const KObjectPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKObjectPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opQObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQObjectPrxS.
 */
template<class T>
class CallbackNC_MyClass_opQObjectPrxS : public Callback_MyClass_opQObjectPrxS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const QObjectPrxS&, const QObjectPrxS&);

    CallbackNC_MyClass_opQObjectPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QObjectPrxS iceP_o;
        QObjectPrxS ret;
        try
        {
            ret = proxy->end_opQObjectPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQObjectPrxS.
 */
template<class T> Callback_MyClass_opQObjectPrxSPtr
newCallback_MyClass_opQObjectPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QObjectPrxS&, const QObjectPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQObjectPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQObjectPrxS.
 */
template<class T> Callback_MyClass_opQObjectPrxSPtr
newCallback_MyClass_opQObjectPrxS(T* instance, void (T::*cb)(const QObjectPrxS&, const QObjectPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQObjectPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opQObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQObjectPrxS.
 */
template<class T, typename CT>
class Callback_MyClass_opQObjectPrxS : public Callback_MyClass_opQObjectPrxS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const QObjectPrxS&, const QObjectPrxS&, const CT&);

    Callback_MyClass_opQObjectPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QObjectPrxS iceP_o;
        QObjectPrxS ret;
        try
        {
            ret = proxy->end_opQObjectPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQObjectPrxS.
 */
template<class T, typename CT> Callback_MyClass_opQObjectPrxSPtr
newCallback_MyClass_opQObjectPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QObjectPrxS&, const QObjectPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQObjectPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQObjectPrxS.
 */
template<class T, typename CT> Callback_MyClass_opQObjectPrxSPtr
newCallback_MyClass_opQObjectPrxS(T* instance, void (T::*cb)(const QObjectPrxS&, const QObjectPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQObjectPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSObjectPrxS.
 */
template<class T>
class CallbackNC_MyClass_opSObjectPrxS : public Callback_MyClass_opSObjectPrxS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SObjectPrxS&, const SObjectPrxS&);

    CallbackNC_MyClass_opSObjectPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SObjectPrxS iceP_o;
        SObjectPrxS ret;
        try
        {
            ret = proxy->end_opSObjectPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSObjectPrxS.
 */
template<class T> Callback_MyClass_opSObjectPrxSPtr
newCallback_MyClass_opSObjectPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SObjectPrxS&, const SObjectPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSObjectPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSObjectPrxS.
 */
template<class T> Callback_MyClass_opSObjectPrxSPtr
newCallback_MyClass_opSObjectPrxS(T* instance, void (T::*cb)(const SObjectPrxS&, const SObjectPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSObjectPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSObjectPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSObjectPrxS.
 */
template<class T, typename CT>
class Callback_MyClass_opSObjectPrxS : public Callback_MyClass_opSObjectPrxS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SObjectPrxS&, const SObjectPrxS&, const CT&);

    Callback_MyClass_opSObjectPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SObjectPrxS iceP_o;
        SObjectPrxS ret;
        try
        {
            ret = proxy->end_opSObjectPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSObjectPrxS.
 */
template<class T, typename CT> Callback_MyClass_opSObjectPrxSPtr
newCallback_MyClass_opSObjectPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SObjectPrxS&, const SObjectPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSObjectPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSObjectPrxS.
 */
template<class T, typename CT> Callback_MyClass_opSObjectPrxSPtr
newCallback_MyClass_opSObjectPrxS(T* instance, void (T::*cb)(const SObjectPrxS&, const SObjectPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSObjectPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opAStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAStructS.
 */
template<class T>
class CallbackNC_MyClass_opAStructS : public Callback_MyClass_opAStructS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const AStructS&, const AStructS&);

    CallbackNC_MyClass_opAStructS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AStructS iceP_o;
        AStructS ret;
        try
        {
            ret = proxy->end_opAStructS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAStructS.
 */
template<class T> Callback_MyClass_opAStructSPtr
newCallback_MyClass_opAStructS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AStructS&, const AStructS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAStructS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAStructS.
 */
template<class T> Callback_MyClass_opAStructSPtr
newCallback_MyClass_opAStructS(T* instance, void (T::*cb)(const AStructS&, const AStructS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAStructS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opAStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAStructS.
 */
template<class T, typename CT>
class Callback_MyClass_opAStructS : public Callback_MyClass_opAStructS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const AStructS&, const AStructS&, const CT&);

    Callback_MyClass_opAStructS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AStructS iceP_o;
        AStructS ret;
        try
        {
            ret = proxy->end_opAStructS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAStructS.
 */
template<class T, typename CT> Callback_MyClass_opAStructSPtr
newCallback_MyClass_opAStructS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AStructS&, const AStructS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAStructS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAStructS.
 */
template<class T, typename CT> Callback_MyClass_opAStructSPtr
newCallback_MyClass_opAStructS(T* instance, void (T::*cb)(const AStructS&, const AStructS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAStructS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLStructS.
 */
template<class T>
class CallbackNC_MyClass_opLStructS : public Callback_MyClass_opLStructS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LStructS&, const LStructS&);

    CallbackNC_MyClass_opLStructS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LStructS iceP_o;
        LStructS ret;
        try
        {
            ret = proxy->end_opLStructS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLStructS.
 */
template<class T> Callback_MyClass_opLStructSPtr
newCallback_MyClass_opLStructS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LStructS&, const LStructS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLStructS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLStructS.
 */
template<class T> Callback_MyClass_opLStructSPtr
newCallback_MyClass_opLStructS(T* instance, void (T::*cb)(const LStructS&, const LStructS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLStructS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLStructS.
 */
template<class T, typename CT>
class Callback_MyClass_opLStructS : public Callback_MyClass_opLStructS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LStructS&, const LStructS&, const CT&);

    Callback_MyClass_opLStructS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LStructS iceP_o;
        LStructS ret;
        try
        {
            ret = proxy->end_opLStructS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLStructS.
 */
template<class T, typename CT> Callback_MyClass_opLStructSPtr
newCallback_MyClass_opLStructS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LStructS&, const LStructS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLStructS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLStructS.
 */
template<class T, typename CT> Callback_MyClass_opLStructSPtr
newCallback_MyClass_opLStructS(T* instance, void (T::*cb)(const LStructS&, const LStructS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLStructS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opKStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKStructS.
 */
template<class T>
class CallbackNC_MyClass_opKStructS : public Callback_MyClass_opKStructS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const KStructS&, const KStructS&);

    CallbackNC_MyClass_opKStructS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KStructS iceP_o;
        KStructS ret;
        try
        {
            ret = proxy->end_opKStructS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKStructS.
 */
template<class T> Callback_MyClass_opKStructSPtr
newCallback_MyClass_opKStructS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KStructS&, const KStructS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKStructS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKStructS.
 */
template<class T> Callback_MyClass_opKStructSPtr
newCallback_MyClass_opKStructS(T* instance, void (T::*cb)(const KStructS&, const KStructS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKStructS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opKStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKStructS.
 */
template<class T, typename CT>
class Callback_MyClass_opKStructS : public Callback_MyClass_opKStructS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const KStructS&, const KStructS&, const CT&);

    Callback_MyClass_opKStructS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KStructS iceP_o;
        KStructS ret;
        try
        {
            ret = proxy->end_opKStructS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKStructS.
 */
template<class T, typename CT> Callback_MyClass_opKStructSPtr
newCallback_MyClass_opKStructS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KStructS&, const KStructS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKStructS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKStructS.
 */
template<class T, typename CT> Callback_MyClass_opKStructSPtr
newCallback_MyClass_opKStructS(T* instance, void (T::*cb)(const KStructS&, const KStructS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKStructS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opQStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQStructS.
 */
template<class T>
class CallbackNC_MyClass_opQStructS : public Callback_MyClass_opQStructS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const QStructS&, const QStructS&);

    CallbackNC_MyClass_opQStructS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QStructS iceP_o;
        QStructS ret;
        try
        {
            ret = proxy->end_opQStructS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQStructS.
 */
template<class T> Callback_MyClass_opQStructSPtr
newCallback_MyClass_opQStructS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QStructS&, const QStructS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQStructS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQStructS.
 */
template<class T> Callback_MyClass_opQStructSPtr
newCallback_MyClass_opQStructS(T* instance, void (T::*cb)(const QStructS&, const QStructS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQStructS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opQStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQStructS.
 */
template<class T, typename CT>
class Callback_MyClass_opQStructS : public Callback_MyClass_opQStructS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const QStructS&, const QStructS&, const CT&);

    Callback_MyClass_opQStructS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QStructS iceP_o;
        QStructS ret;
        try
        {
            ret = proxy->end_opQStructS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQStructS.
 */
template<class T, typename CT> Callback_MyClass_opQStructSPtr
newCallback_MyClass_opQStructS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QStructS&, const QStructS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQStructS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQStructS.
 */
template<class T, typename CT> Callback_MyClass_opQStructSPtr
newCallback_MyClass_opQStructS(T* instance, void (T::*cb)(const QStructS&, const QStructS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQStructS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSStructS.
 */
template<class T>
class CallbackNC_MyClass_opSStructS : public Callback_MyClass_opSStructS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SStructS&, const SStructS&);

    CallbackNC_MyClass_opSStructS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SStructS iceP_o;
        SStructS ret;
        try
        {
            ret = proxy->end_opSStructS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSStructS.
 */
template<class T> Callback_MyClass_opSStructSPtr
newCallback_MyClass_opSStructS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SStructS&, const SStructS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSStructS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSStructS.
 */
template<class T> Callback_MyClass_opSStructSPtr
newCallback_MyClass_opSStructS(T* instance, void (T::*cb)(const SStructS&, const SStructS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSStructS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSStructS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSStructS.
 */
template<class T, typename CT>
class Callback_MyClass_opSStructS : public Callback_MyClass_opSStructS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SStructS&, const SStructS&, const CT&);

    Callback_MyClass_opSStructS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SStructS iceP_o;
        SStructS ret;
        try
        {
            ret = proxy->end_opSStructS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSStructS.
 */
template<class T, typename CT> Callback_MyClass_opSStructSPtr
newCallback_MyClass_opSStructS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SStructS&, const SStructS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSStructS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSStructS.
 */
template<class T, typename CT> Callback_MyClass_opSStructSPtr
newCallback_MyClass_opSStructS(T* instance, void (T::*cb)(const SStructS&, const SStructS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSStructS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opAStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAStructSD.
 */
template<class T>
class CallbackNC_MyClass_opAStructSD : public Callback_MyClass_opAStructSD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const AStructSD&, const AStructSD&);

    CallbackNC_MyClass_opAStructSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AStructSD iceP_o;
        AStructSD ret;
        try
        {
            ret = proxy->end_opAStructSD(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAStructSD.
 */
template<class T> Callback_MyClass_opAStructSDPtr
newCallback_MyClass_opAStructSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const AStructSD&, const AStructSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAStructSD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAStructSD.
 */
template<class T> Callback_MyClass_opAStructSDPtr
newCallback_MyClass_opAStructSD(T* instance, void (T::*cb)(const AStructSD&, const AStructSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAStructSD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opAStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAStructSD.
 */
template<class T, typename CT>
class Callback_MyClass_opAStructSD : public Callback_MyClass_opAStructSD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const AStructSD&, const AStructSD&, const CT&);

    Callback_MyClass_opAStructSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AStructSD iceP_o;
        AStructSD ret;
        try
        {
            ret = proxy->end_opAStructSD(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAStructSD.
 */
template<class T, typename CT> Callback_MyClass_opAStructSDPtr
newCallback_MyClass_opAStructSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const AStructSD&, const AStructSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAStructSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAStructSD.
 */
template<class T, typename CT> Callback_MyClass_opAStructSDPtr
newCallback_MyClass_opAStructSD(T* instance, void (T::*cb)(const AStructSD&, const AStructSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAStructSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLStructSD.
 */
template<class T>
class CallbackNC_MyClass_opLStructSD : public Callback_MyClass_opLStructSD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LStructSD&, const LStructSD&);

    CallbackNC_MyClass_opLStructSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LStructSD iceP_o;
        LStructSD ret;
        try
        {
            ret = proxy->end_opLStructSD(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLStructSD.
 */
template<class T> Callback_MyClass_opLStructSDPtr
newCallback_MyClass_opLStructSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const LStructSD&, const LStructSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLStructSD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLStructSD.
 */
template<class T> Callback_MyClass_opLStructSDPtr
newCallback_MyClass_opLStructSD(T* instance, void (T::*cb)(const LStructSD&, const LStructSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLStructSD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLStructSD.
 */
template<class T, typename CT>
class Callback_MyClass_opLStructSD : public Callback_MyClass_opLStructSD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LStructSD&, const LStructSD&, const CT&);

    Callback_MyClass_opLStructSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LStructSD iceP_o;
        LStructSD ret;
        try
        {
            ret = proxy->end_opLStructSD(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLStructSD.
 */
template<class T, typename CT> Callback_MyClass_opLStructSDPtr
newCallback_MyClass_opLStructSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const LStructSD&, const LStructSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLStructSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLStructSD.
 */
template<class T, typename CT> Callback_MyClass_opLStructSDPtr
newCallback_MyClass_opLStructSD(T* instance, void (T::*cb)(const LStructSD&, const LStructSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLStructSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opKStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKStructSD.
 */
template<class T>
class CallbackNC_MyClass_opKStructSD : public Callback_MyClass_opKStructSD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const KStructSD&, const KStructSD&);

    CallbackNC_MyClass_opKStructSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KStructSD iceP_o;
        KStructSD ret;
        try
        {
            ret = proxy->end_opKStructSD(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKStructSD.
 */
template<class T> Callback_MyClass_opKStructSDPtr
newCallback_MyClass_opKStructSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const KStructSD&, const KStructSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKStructSD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKStructSD.
 */
template<class T> Callback_MyClass_opKStructSDPtr
newCallback_MyClass_opKStructSD(T* instance, void (T::*cb)(const KStructSD&, const KStructSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKStructSD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opKStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKStructSD.
 */
template<class T, typename CT>
class Callback_MyClass_opKStructSD : public Callback_MyClass_opKStructSD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const KStructSD&, const KStructSD&, const CT&);

    Callback_MyClass_opKStructSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KStructSD iceP_o;
        KStructSD ret;
        try
        {
            ret = proxy->end_opKStructSD(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKStructSD.
 */
template<class T, typename CT> Callback_MyClass_opKStructSDPtr
newCallback_MyClass_opKStructSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const KStructSD&, const KStructSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKStructSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKStructSD.
 */
template<class T, typename CT> Callback_MyClass_opKStructSDPtr
newCallback_MyClass_opKStructSD(T* instance, void (T::*cb)(const KStructSD&, const KStructSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKStructSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opQStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQStructSD.
 */
template<class T>
class CallbackNC_MyClass_opQStructSD : public Callback_MyClass_opQStructSD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const QStructSD&, const QStructSD&);

    CallbackNC_MyClass_opQStructSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QStructSD iceP_o;
        QStructSD ret;
        try
        {
            ret = proxy->end_opQStructSD(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQStructSD.
 */
template<class T> Callback_MyClass_opQStructSDPtr
newCallback_MyClass_opQStructSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const QStructSD&, const QStructSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQStructSD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQStructSD.
 */
template<class T> Callback_MyClass_opQStructSDPtr
newCallback_MyClass_opQStructSD(T* instance, void (T::*cb)(const QStructSD&, const QStructSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQStructSD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opQStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQStructSD.
 */
template<class T, typename CT>
class Callback_MyClass_opQStructSD : public Callback_MyClass_opQStructSD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const QStructSD&, const QStructSD&, const CT&);

    Callback_MyClass_opQStructSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QStructSD iceP_o;
        QStructSD ret;
        try
        {
            ret = proxy->end_opQStructSD(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQStructSD.
 */
template<class T, typename CT> Callback_MyClass_opQStructSDPtr
newCallback_MyClass_opQStructSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const QStructSD&, const QStructSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQStructSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQStructSD.
 */
template<class T, typename CT> Callback_MyClass_opQStructSDPtr
newCallback_MyClass_opQStructSD(T* instance, void (T::*cb)(const QStructSD&, const QStructSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQStructSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSStructSD.
 */
template<class T>
class CallbackNC_MyClass_opSStructSD : public Callback_MyClass_opSStructSD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SStructSD&, const SStructSD&);

    CallbackNC_MyClass_opSStructSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SStructSD iceP_o;
        SStructSD ret;
        try
        {
            ret = proxy->end_opSStructSD(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSStructSD.
 */
template<class T> Callback_MyClass_opSStructSDPtr
newCallback_MyClass_opSStructSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const SStructSD&, const SStructSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSStructSD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSStructSD.
 */
template<class T> Callback_MyClass_opSStructSDPtr
newCallback_MyClass_opSStructSD(T* instance, void (T::*cb)(const SStructSD&, const SStructSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSStructSD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSStructSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSStructSD.
 */
template<class T, typename CT>
class Callback_MyClass_opSStructSD : public Callback_MyClass_opSStructSD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SStructSD&, const SStructSD&, const CT&);

    Callback_MyClass_opSStructSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SStructSD iceP_o;
        SStructSD ret;
        try
        {
            ret = proxy->end_opSStructSD(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSStructSD.
 */
template<class T, typename CT> Callback_MyClass_opSStructSDPtr
newCallback_MyClass_opSStructSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const SStructSD&, const SStructSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSStructSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSStructSD.
 */
template<class T, typename CT> Callback_MyClass_opSStructSDPtr
newCallback_MyClass_opSStructSD(T* instance, void (T::*cb)(const SStructSD&, const SStructSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSStructSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opACVS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opACVS.
 */
template<class T>
class CallbackNC_MyClass_opACVS : public Callback_MyClass_opACVS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ACVS&, const ACVS&);

    CallbackNC_MyClass_opACVS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ACVS iceP_o;
        ACVS ret;
        try
        {
            ret = proxy->end_opACVS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opACVS.
 */
template<class T> Callback_MyClass_opACVSPtr
newCallback_MyClass_opACVS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ACVS&, const ACVS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opACVS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opACVS.
 */
template<class T> Callback_MyClass_opACVSPtr
newCallback_MyClass_opACVS(T* instance, void (T::*cb)(const ACVS&, const ACVS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opACVS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opACVS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opACVS.
 */
template<class T, typename CT>
class Callback_MyClass_opACVS : public Callback_MyClass_opACVS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ACVS&, const ACVS&, const CT&);

    Callback_MyClass_opACVS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ACVS iceP_o;
        ACVS ret;
        try
        {
            ret = proxy->end_opACVS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opACVS.
 */
template<class T, typename CT> Callback_MyClass_opACVSPtr
newCallback_MyClass_opACVS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ACVS&, const ACVS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opACVS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opACVS.
 */
template<class T, typename CT> Callback_MyClass_opACVSPtr
newCallback_MyClass_opACVS(T* instance, void (T::*cb)(const ACVS&, const ACVS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opACVS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLCVS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLCVS.
 */
template<class T>
class CallbackNC_MyClass_opLCVS : public Callback_MyClass_opLCVS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LCVS&, const LCVS&);

    CallbackNC_MyClass_opLCVS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LCVS iceP_o;
        LCVS ret;
        try
        {
            ret = proxy->end_opLCVS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLCVS.
 */
template<class T> Callback_MyClass_opLCVSPtr
newCallback_MyClass_opLCVS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LCVS&, const LCVS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLCVS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLCVS.
 */
template<class T> Callback_MyClass_opLCVSPtr
newCallback_MyClass_opLCVS(T* instance, void (T::*cb)(const LCVS&, const LCVS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLCVS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLCVS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLCVS.
 */
template<class T, typename CT>
class Callback_MyClass_opLCVS : public Callback_MyClass_opLCVS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LCVS&, const LCVS&, const CT&);

    Callback_MyClass_opLCVS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LCVS iceP_o;
        LCVS ret;
        try
        {
            ret = proxy->end_opLCVS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLCVS.
 */
template<class T, typename CT> Callback_MyClass_opLCVSPtr
newCallback_MyClass_opLCVS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LCVS&, const LCVS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLCVS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLCVS.
 */
template<class T, typename CT> Callback_MyClass_opLCVSPtr
newCallback_MyClass_opLCVS(T* instance, void (T::*cb)(const LCVS&, const LCVS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLCVS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opACRS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opACRS.
 */
template<class T>
class CallbackNC_MyClass_opACRS : public Callback_MyClass_opACRS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ACRS&, const ACRS&);

    CallbackNC_MyClass_opACRS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ACRS iceP_o;
        ACRS ret;
        try
        {
            ret = proxy->end_opACRS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opACRS.
 */
template<class T> Callback_MyClass_opACRSPtr
newCallback_MyClass_opACRS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ACRS&, const ACRS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opACRS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opACRS.
 */
template<class T> Callback_MyClass_opACRSPtr
newCallback_MyClass_opACRS(T* instance, void (T::*cb)(const ACRS&, const ACRS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opACRS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opACRS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opACRS.
 */
template<class T, typename CT>
class Callback_MyClass_opACRS : public Callback_MyClass_opACRS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ACRS&, const ACRS&, const CT&);

    Callback_MyClass_opACRS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ACRS iceP_o;
        ACRS ret;
        try
        {
            ret = proxy->end_opACRS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opACRS.
 */
template<class T, typename CT> Callback_MyClass_opACRSPtr
newCallback_MyClass_opACRS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ACRS&, const ACRS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opACRS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opACRS.
 */
template<class T, typename CT> Callback_MyClass_opACRSPtr
newCallback_MyClass_opACRS(T* instance, void (T::*cb)(const ACRS&, const ACRS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opACRS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLCRS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLCRS.
 */
template<class T>
class CallbackNC_MyClass_opLCRS : public Callback_MyClass_opLCRS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LCRS&, const LCRS&);

    CallbackNC_MyClass_opLCRS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LCRS iceP_o;
        LCRS ret;
        try
        {
            ret = proxy->end_opLCRS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLCRS.
 */
template<class T> Callback_MyClass_opLCRSPtr
newCallback_MyClass_opLCRS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LCRS&, const LCRS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLCRS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLCRS.
 */
template<class T> Callback_MyClass_opLCRSPtr
newCallback_MyClass_opLCRS(T* instance, void (T::*cb)(const LCRS&, const LCRS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLCRS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLCRS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLCRS.
 */
template<class T, typename CT>
class Callback_MyClass_opLCRS : public Callback_MyClass_opLCRS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LCRS&, const LCRS&, const CT&);

    Callback_MyClass_opLCRS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LCRS iceP_o;
        LCRS ret;
        try
        {
            ret = proxy->end_opLCRS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLCRS.
 */
template<class T, typename CT> Callback_MyClass_opLCRSPtr
newCallback_MyClass_opLCRS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LCRS&, const LCRS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLCRS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLCRS.
 */
template<class T, typename CT> Callback_MyClass_opLCRSPtr
newCallback_MyClass_opLCRS(T* instance, void (T::*cb)(const LCRS&, const LCRS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLCRS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opAEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAEnS.
 */
template<class T>
class CallbackNC_MyClass_opAEnS : public Callback_MyClass_opAEnS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const AEnS&, const AEnS&);

    CallbackNC_MyClass_opAEnS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AEnS iceP_o;
        AEnS ret;
        try
        {
            ret = proxy->end_opAEnS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAEnS.
 */
template<class T> Callback_MyClass_opAEnSPtr
newCallback_MyClass_opAEnS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AEnS&, const AEnS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAEnS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAEnS.
 */
template<class T> Callback_MyClass_opAEnSPtr
newCallback_MyClass_opAEnS(T* instance, void (T::*cb)(const AEnS&, const AEnS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAEnS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opAEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAEnS.
 */
template<class T, typename CT>
class Callback_MyClass_opAEnS : public Callback_MyClass_opAEnS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const AEnS&, const AEnS&, const CT&);

    Callback_MyClass_opAEnS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AEnS iceP_o;
        AEnS ret;
        try
        {
            ret = proxy->end_opAEnS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAEnS.
 */
template<class T, typename CT> Callback_MyClass_opAEnSPtr
newCallback_MyClass_opAEnS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AEnS&, const AEnS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAEnS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAEnS.
 */
template<class T, typename CT> Callback_MyClass_opAEnSPtr
newCallback_MyClass_opAEnS(T* instance, void (T::*cb)(const AEnS&, const AEnS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAEnS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLEnS.
 */
template<class T>
class CallbackNC_MyClass_opLEnS : public Callback_MyClass_opLEnS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LEnS&, const LEnS&);

    CallbackNC_MyClass_opLEnS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LEnS iceP_o;
        LEnS ret;
        try
        {
            ret = proxy->end_opLEnS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLEnS.
 */
template<class T> Callback_MyClass_opLEnSPtr
newCallback_MyClass_opLEnS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LEnS&, const LEnS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLEnS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLEnS.
 */
template<class T> Callback_MyClass_opLEnSPtr
newCallback_MyClass_opLEnS(T* instance, void (T::*cb)(const LEnS&, const LEnS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLEnS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLEnS.
 */
template<class T, typename CT>
class Callback_MyClass_opLEnS : public Callback_MyClass_opLEnS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LEnS&, const LEnS&, const CT&);

    Callback_MyClass_opLEnS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LEnS iceP_o;
        LEnS ret;
        try
        {
            ret = proxy->end_opLEnS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLEnS.
 */
template<class T, typename CT> Callback_MyClass_opLEnSPtr
newCallback_MyClass_opLEnS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LEnS&, const LEnS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLEnS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLEnS.
 */
template<class T, typename CT> Callback_MyClass_opLEnSPtr
newCallback_MyClass_opLEnS(T* instance, void (T::*cb)(const LEnS&, const LEnS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLEnS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opKEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKEnS.
 */
template<class T>
class CallbackNC_MyClass_opKEnS : public Callback_MyClass_opKEnS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const KEnS&, const KEnS&);

    CallbackNC_MyClass_opKEnS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KEnS iceP_o;
        KEnS ret;
        try
        {
            ret = proxy->end_opKEnS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKEnS.
 */
template<class T> Callback_MyClass_opKEnSPtr
newCallback_MyClass_opKEnS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KEnS&, const KEnS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKEnS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKEnS.
 */
template<class T> Callback_MyClass_opKEnSPtr
newCallback_MyClass_opKEnS(T* instance, void (T::*cb)(const KEnS&, const KEnS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKEnS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opKEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKEnS.
 */
template<class T, typename CT>
class Callback_MyClass_opKEnS : public Callback_MyClass_opKEnS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const KEnS&, const KEnS&, const CT&);

    Callback_MyClass_opKEnS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KEnS iceP_o;
        KEnS ret;
        try
        {
            ret = proxy->end_opKEnS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKEnS.
 */
template<class T, typename CT> Callback_MyClass_opKEnSPtr
newCallback_MyClass_opKEnS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KEnS&, const KEnS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKEnS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKEnS.
 */
template<class T, typename CT> Callback_MyClass_opKEnSPtr
newCallback_MyClass_opKEnS(T* instance, void (T::*cb)(const KEnS&, const KEnS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKEnS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opQEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQEnS.
 */
template<class T>
class CallbackNC_MyClass_opQEnS : public Callback_MyClass_opQEnS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const QEnS&, const QEnS&);

    CallbackNC_MyClass_opQEnS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QEnS iceP_o;
        QEnS ret;
        try
        {
            ret = proxy->end_opQEnS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQEnS.
 */
template<class T> Callback_MyClass_opQEnSPtr
newCallback_MyClass_opQEnS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QEnS&, const QEnS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQEnS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQEnS.
 */
template<class T> Callback_MyClass_opQEnSPtr
newCallback_MyClass_opQEnS(T* instance, void (T::*cb)(const QEnS&, const QEnS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQEnS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opQEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQEnS.
 */
template<class T, typename CT>
class Callback_MyClass_opQEnS : public Callback_MyClass_opQEnS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const QEnS&, const QEnS&, const CT&);

    Callback_MyClass_opQEnS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QEnS iceP_o;
        QEnS ret;
        try
        {
            ret = proxy->end_opQEnS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQEnS.
 */
template<class T, typename CT> Callback_MyClass_opQEnSPtr
newCallback_MyClass_opQEnS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QEnS&, const QEnS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQEnS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQEnS.
 */
template<class T, typename CT> Callback_MyClass_opQEnSPtr
newCallback_MyClass_opQEnS(T* instance, void (T::*cb)(const QEnS&, const QEnS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQEnS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSEnS.
 */
template<class T>
class CallbackNC_MyClass_opSEnS : public Callback_MyClass_opSEnS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SEnS&, const SEnS&);

    CallbackNC_MyClass_opSEnS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SEnS iceP_o;
        SEnS ret;
        try
        {
            ret = proxy->end_opSEnS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSEnS.
 */
template<class T> Callback_MyClass_opSEnSPtr
newCallback_MyClass_opSEnS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SEnS&, const SEnS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSEnS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSEnS.
 */
template<class T> Callback_MyClass_opSEnSPtr
newCallback_MyClass_opSEnS(T* instance, void (T::*cb)(const SEnS&, const SEnS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSEnS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSEnS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSEnS.
 */
template<class T, typename CT>
class Callback_MyClass_opSEnS : public Callback_MyClass_opSEnS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SEnS&, const SEnS&, const CT&);

    Callback_MyClass_opSEnS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SEnS iceP_o;
        SEnS ret;
        try
        {
            ret = proxy->end_opSEnS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSEnS.
 */
template<class T, typename CT> Callback_MyClass_opSEnSPtr
newCallback_MyClass_opSEnS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SEnS&, const SEnS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSEnS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSEnS.
 */
template<class T, typename CT> Callback_MyClass_opSEnSPtr
newCallback_MyClass_opSEnS(T* instance, void (T::*cb)(const SEnS&, const SEnS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSEnS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opAIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAIPrxS.
 */
template<class T>
class CallbackNC_MyClass_opAIPrxS : public Callback_MyClass_opAIPrxS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const AIPrxS&, const AIPrxS&);

    CallbackNC_MyClass_opAIPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AIPrxS iceP_o;
        AIPrxS ret;
        try
        {
            ret = proxy->end_opAIPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAIPrxS.
 */
template<class T> Callback_MyClass_opAIPrxSPtr
newCallback_MyClass_opAIPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AIPrxS&, const AIPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAIPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAIPrxS.
 */
template<class T> Callback_MyClass_opAIPrxSPtr
newCallback_MyClass_opAIPrxS(T* instance, void (T::*cb)(const AIPrxS&, const AIPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opAIPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opAIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opAIPrxS.
 */
template<class T, typename CT>
class Callback_MyClass_opAIPrxS : public Callback_MyClass_opAIPrxS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const AIPrxS&, const AIPrxS&, const CT&);

    Callback_MyClass_opAIPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        AIPrxS iceP_o;
        AIPrxS ret;
        try
        {
            ret = proxy->end_opAIPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAIPrxS.
 */
template<class T, typename CT> Callback_MyClass_opAIPrxSPtr
newCallback_MyClass_opAIPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const AIPrxS&, const AIPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAIPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opAIPrxS.
 */
template<class T, typename CT> Callback_MyClass_opAIPrxSPtr
newCallback_MyClass_opAIPrxS(T* instance, void (T::*cb)(const AIPrxS&, const AIPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opAIPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLIPrxS.
 */
template<class T>
class CallbackNC_MyClass_opLIPrxS : public Callback_MyClass_opLIPrxS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LIPrxS&, const LIPrxS&);

    CallbackNC_MyClass_opLIPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LIPrxS iceP_o;
        LIPrxS ret;
        try
        {
            ret = proxy->end_opLIPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLIPrxS.
 */
template<class T> Callback_MyClass_opLIPrxSPtr
newCallback_MyClass_opLIPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LIPrxS&, const LIPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLIPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLIPrxS.
 */
template<class T> Callback_MyClass_opLIPrxSPtr
newCallback_MyClass_opLIPrxS(T* instance, void (T::*cb)(const LIPrxS&, const LIPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLIPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLIPrxS.
 */
template<class T, typename CT>
class Callback_MyClass_opLIPrxS : public Callback_MyClass_opLIPrxS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LIPrxS&, const LIPrxS&, const CT&);

    Callback_MyClass_opLIPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LIPrxS iceP_o;
        LIPrxS ret;
        try
        {
            ret = proxy->end_opLIPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLIPrxS.
 */
template<class T, typename CT> Callback_MyClass_opLIPrxSPtr
newCallback_MyClass_opLIPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LIPrxS&, const LIPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLIPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLIPrxS.
 */
template<class T, typename CT> Callback_MyClass_opLIPrxSPtr
newCallback_MyClass_opLIPrxS(T* instance, void (T::*cb)(const LIPrxS&, const LIPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLIPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opKIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKIPrxS.
 */
template<class T>
class CallbackNC_MyClass_opKIPrxS : public Callback_MyClass_opKIPrxS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const KIPrxS&, const KIPrxS&);

    CallbackNC_MyClass_opKIPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KIPrxS iceP_o;
        KIPrxS ret;
        try
        {
            ret = proxy->end_opKIPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKIPrxS.
 */
template<class T> Callback_MyClass_opKIPrxSPtr
newCallback_MyClass_opKIPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KIPrxS&, const KIPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKIPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKIPrxS.
 */
template<class T> Callback_MyClass_opKIPrxSPtr
newCallback_MyClass_opKIPrxS(T* instance, void (T::*cb)(const KIPrxS&, const KIPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opKIPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opKIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opKIPrxS.
 */
template<class T, typename CT>
class Callback_MyClass_opKIPrxS : public Callback_MyClass_opKIPrxS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const KIPrxS&, const KIPrxS&, const CT&);

    Callback_MyClass_opKIPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        KIPrxS iceP_o;
        KIPrxS ret;
        try
        {
            ret = proxy->end_opKIPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKIPrxS.
 */
template<class T, typename CT> Callback_MyClass_opKIPrxSPtr
newCallback_MyClass_opKIPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const KIPrxS&, const KIPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKIPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opKIPrxS.
 */
template<class T, typename CT> Callback_MyClass_opKIPrxSPtr
newCallback_MyClass_opKIPrxS(T* instance, void (T::*cb)(const KIPrxS&, const KIPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opKIPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opQIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQIPrxS.
 */
template<class T>
class CallbackNC_MyClass_opQIPrxS : public Callback_MyClass_opQIPrxS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const QIPrxS&, const QIPrxS&);

    CallbackNC_MyClass_opQIPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QIPrxS iceP_o;
        QIPrxS ret;
        try
        {
            ret = proxy->end_opQIPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQIPrxS.
 */
template<class T> Callback_MyClass_opQIPrxSPtr
newCallback_MyClass_opQIPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QIPrxS&, const QIPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQIPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQIPrxS.
 */
template<class T> Callback_MyClass_opQIPrxSPtr
newCallback_MyClass_opQIPrxS(T* instance, void (T::*cb)(const QIPrxS&, const QIPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opQIPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opQIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opQIPrxS.
 */
template<class T, typename CT>
class Callback_MyClass_opQIPrxS : public Callback_MyClass_opQIPrxS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const QIPrxS&, const QIPrxS&, const CT&);

    Callback_MyClass_opQIPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        QIPrxS iceP_o;
        QIPrxS ret;
        try
        {
            ret = proxy->end_opQIPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQIPrxS.
 */
template<class T, typename CT> Callback_MyClass_opQIPrxSPtr
newCallback_MyClass_opQIPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const QIPrxS&, const QIPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQIPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opQIPrxS.
 */
template<class T, typename CT> Callback_MyClass_opQIPrxSPtr
newCallback_MyClass_opQIPrxS(T* instance, void (T::*cb)(const QIPrxS&, const QIPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opQIPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSIPrxS.
 */
template<class T>
class CallbackNC_MyClass_opSIPrxS : public Callback_MyClass_opSIPrxS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SIPrxS&, const SIPrxS&);

    CallbackNC_MyClass_opSIPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SIPrxS iceP_o;
        SIPrxS ret;
        try
        {
            ret = proxy->end_opSIPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSIPrxS.
 */
template<class T> Callback_MyClass_opSIPrxSPtr
newCallback_MyClass_opSIPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SIPrxS&, const SIPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSIPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSIPrxS.
 */
template<class T> Callback_MyClass_opSIPrxSPtr
newCallback_MyClass_opSIPrxS(T* instance, void (T::*cb)(const SIPrxS&, const SIPrxS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSIPrxS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSIPrxS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSIPrxS.
 */
template<class T, typename CT>
class Callback_MyClass_opSIPrxS : public Callback_MyClass_opSIPrxS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SIPrxS&, const SIPrxS&, const CT&);

    Callback_MyClass_opSIPrxS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SIPrxS iceP_o;
        SIPrxS ret;
        try
        {
            ret = proxy->end_opSIPrxS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSIPrxS.
 */
template<class T, typename CT> Callback_MyClass_opSIPrxSPtr
newCallback_MyClass_opSIPrxS(const IceUtil::Handle<T>& instance, void (T::*cb)(const SIPrxS&, const SIPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSIPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSIPrxS.
 */
template<class T, typename CT> Callback_MyClass_opSIPrxSPtr
newCallback_MyClass_opSIPrxS(T* instance, void (T::*cb)(const SIPrxS&, const SIPrxS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSIPrxS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opCustomIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opCustomIntS.
 */
template<class T>
class CallbackNC_MyClass_opCustomIntS : public Callback_MyClass_opCustomIntS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CustomIntS&, const CustomIntS&);

    CallbackNC_MyClass_opCustomIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        CustomIntS iceP_o;
        CustomIntS ret;
        try
        {
            ret = proxy->end_opCustomIntS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomIntS.
 */
template<class T> Callback_MyClass_opCustomIntSPtr
newCallback_MyClass_opCustomIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const CustomIntS&, const CustomIntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opCustomIntS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomIntS.
 */
template<class T> Callback_MyClass_opCustomIntSPtr
newCallback_MyClass_opCustomIntS(T* instance, void (T::*cb)(const CustomIntS&, const CustomIntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opCustomIntS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opCustomIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opCustomIntS.
 */
template<class T, typename CT>
class Callback_MyClass_opCustomIntS : public Callback_MyClass_opCustomIntS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CustomIntS&, const CustomIntS&, const CT&);

    Callback_MyClass_opCustomIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        CustomIntS iceP_o;
        CustomIntS ret;
        try
        {
            ret = proxy->end_opCustomIntS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomIntS.
 */
template<class T, typename CT> Callback_MyClass_opCustomIntSPtr
newCallback_MyClass_opCustomIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const CustomIntS&, const CustomIntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opCustomIntS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomIntS.
 */
template<class T, typename CT> Callback_MyClass_opCustomIntSPtr
newCallback_MyClass_opCustomIntS(T* instance, void (T::*cb)(const CustomIntS&, const CustomIntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opCustomIntS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opCustomCVS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opCustomCVS.
 */
template<class T>
class CallbackNC_MyClass_opCustomCVS : public Callback_MyClass_opCustomCVS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CustomCVS&, const CustomCVS&);

    CallbackNC_MyClass_opCustomCVS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        CustomCVS iceP_o;
        CustomCVS ret;
        try
        {
            ret = proxy->end_opCustomCVS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomCVS.
 */
template<class T> Callback_MyClass_opCustomCVSPtr
newCallback_MyClass_opCustomCVS(const IceUtil::Handle<T>& instance, void (T::*cb)(const CustomCVS&, const CustomCVS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opCustomCVS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomCVS.
 */
template<class T> Callback_MyClass_opCustomCVSPtr
newCallback_MyClass_opCustomCVS(T* instance, void (T::*cb)(const CustomCVS&, const CustomCVS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opCustomCVS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opCustomCVS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opCustomCVS.
 */
template<class T, typename CT>
class Callback_MyClass_opCustomCVS : public Callback_MyClass_opCustomCVS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CustomCVS&, const CustomCVS&, const CT&);

    Callback_MyClass_opCustomCVS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        CustomCVS iceP_o;
        CustomCVS ret;
        try
        {
            ret = proxy->end_opCustomCVS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomCVS.
 */
template<class T, typename CT> Callback_MyClass_opCustomCVSPtr
newCallback_MyClass_opCustomCVS(const IceUtil::Handle<T>& instance, void (T::*cb)(const CustomCVS&, const CustomCVS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opCustomCVS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomCVS.
 */
template<class T, typename CT> Callback_MyClass_opCustomCVSPtr
newCallback_MyClass_opCustomCVS(T* instance, void (T::*cb)(const CustomCVS&, const CustomCVS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opCustomCVS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opCustomIntSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opCustomIntSS.
 */
template<class T>
class CallbackNC_MyClass_opCustomIntSS : public Callback_MyClass_opCustomIntSS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CustomIntSS&, const CustomIntSS&);

    CallbackNC_MyClass_opCustomIntSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        CustomIntSS iceP_o;
        CustomIntSS ret;
        try
        {
            ret = proxy->end_opCustomIntSS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomIntSS.
 */
template<class T> Callback_MyClass_opCustomIntSSPtr
newCallback_MyClass_opCustomIntSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const CustomIntSS&, const CustomIntSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opCustomIntSS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomIntSS.
 */
template<class T> Callback_MyClass_opCustomIntSSPtr
newCallback_MyClass_opCustomIntSS(T* instance, void (T::*cb)(const CustomIntSS&, const CustomIntSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opCustomIntSS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opCustomIntSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opCustomIntSS.
 */
template<class T, typename CT>
class Callback_MyClass_opCustomIntSS : public Callback_MyClass_opCustomIntSS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CustomIntSS&, const CustomIntSS&, const CT&);

    Callback_MyClass_opCustomIntSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        CustomIntSS iceP_o;
        CustomIntSS ret;
        try
        {
            ret = proxy->end_opCustomIntSS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomIntSS.
 */
template<class T, typename CT> Callback_MyClass_opCustomIntSSPtr
newCallback_MyClass_opCustomIntSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const CustomIntSS&, const CustomIntSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opCustomIntSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomIntSS.
 */
template<class T, typename CT> Callback_MyClass_opCustomIntSSPtr
newCallback_MyClass_opCustomIntSS(T* instance, void (T::*cb)(const CustomIntSS&, const CustomIntSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opCustomIntSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opCustomCVSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opCustomCVSS.
 */
template<class T>
class CallbackNC_MyClass_opCustomCVSS : public Callback_MyClass_opCustomCVSS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CustomCVSS&, const CustomCVSS&);

    CallbackNC_MyClass_opCustomCVSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        CustomCVSS iceP_o;
        CustomCVSS ret;
        try
        {
            ret = proxy->end_opCustomCVSS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomCVSS.
 */
template<class T> Callback_MyClass_opCustomCVSSPtr
newCallback_MyClass_opCustomCVSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const CustomCVSS&, const CustomCVSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opCustomCVSS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomCVSS.
 */
template<class T> Callback_MyClass_opCustomCVSSPtr
newCallback_MyClass_opCustomCVSS(T* instance, void (T::*cb)(const CustomCVSS&, const CustomCVSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opCustomCVSS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opCustomCVSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opCustomCVSS.
 */
template<class T, typename CT>
class Callback_MyClass_opCustomCVSS : public Callback_MyClass_opCustomCVSS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CustomCVSS&, const CustomCVSS&, const CT&);

    Callback_MyClass_opCustomCVSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        CustomCVSS iceP_o;
        CustomCVSS ret;
        try
        {
            ret = proxy->end_opCustomCVSS(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomCVSS.
 */
template<class T, typename CT> Callback_MyClass_opCustomCVSSPtr
newCallback_MyClass_opCustomCVSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const CustomCVSS&, const CustomCVSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opCustomCVSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opCustomCVSS.
 */
template<class T, typename CT> Callback_MyClass_opCustomCVSSPtr
newCallback_MyClass_opCustomCVSS(T* instance, void (T::*cb)(const CustomCVSS&, const CustomCVSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opCustomCVSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSerialSmallCSharp.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSerialSmallCSharp.
 */
template<class T>
class CallbackNC_MyClass_opSerialSmallCSharp : public Callback_MyClass_opSerialSmallCSharp_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SerialSmall&, const SerialSmall&);

    CallbackNC_MyClass_opSerialSmallCSharp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SerialSmall iceP_o;
        SerialSmall ret;
        try
        {
            ret = proxy->end_opSerialSmallCSharp(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSerialSmallCSharp.
 */
template<class T> Callback_MyClass_opSerialSmallCSharpPtr
newCallback_MyClass_opSerialSmallCSharp(const IceUtil::Handle<T>& instance, void (T::*cb)(const SerialSmall&, const SerialSmall&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSerialSmallCSharp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSerialSmallCSharp.
 */
template<class T> Callback_MyClass_opSerialSmallCSharpPtr
newCallback_MyClass_opSerialSmallCSharp(T* instance, void (T::*cb)(const SerialSmall&, const SerialSmall&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSerialSmallCSharp<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSerialSmallCSharp.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSerialSmallCSharp.
 */
template<class T, typename CT>
class Callback_MyClass_opSerialSmallCSharp : public Callback_MyClass_opSerialSmallCSharp_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SerialSmall&, const SerialSmall&, const CT&);

    Callback_MyClass_opSerialSmallCSharp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SerialSmall iceP_o;
        SerialSmall ret;
        try
        {
            ret = proxy->end_opSerialSmallCSharp(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSerialSmallCSharp.
 */
template<class T, typename CT> Callback_MyClass_opSerialSmallCSharpPtr
newCallback_MyClass_opSerialSmallCSharp(const IceUtil::Handle<T>& instance, void (T::*cb)(const SerialSmall&, const SerialSmall&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSerialSmallCSharp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSerialSmallCSharp.
 */
template<class T, typename CT> Callback_MyClass_opSerialSmallCSharpPtr
newCallback_MyClass_opSerialSmallCSharp(T* instance, void (T::*cb)(const SerialSmall&, const SerialSmall&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSerialSmallCSharp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSerialLargeCSharp.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSerialLargeCSharp.
 */
template<class T>
class CallbackNC_MyClass_opSerialLargeCSharp : public Callback_MyClass_opSerialLargeCSharp_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SerialLarge&, const SerialLarge&);

    CallbackNC_MyClass_opSerialLargeCSharp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SerialLarge iceP_o;
        SerialLarge ret;
        try
        {
            ret = proxy->end_opSerialLargeCSharp(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSerialLargeCSharp.
 */
template<class T> Callback_MyClass_opSerialLargeCSharpPtr
newCallback_MyClass_opSerialLargeCSharp(const IceUtil::Handle<T>& instance, void (T::*cb)(const SerialLarge&, const SerialLarge&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSerialLargeCSharp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSerialLargeCSharp.
 */
template<class T> Callback_MyClass_opSerialLargeCSharpPtr
newCallback_MyClass_opSerialLargeCSharp(T* instance, void (T::*cb)(const SerialLarge&, const SerialLarge&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSerialLargeCSharp<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSerialLargeCSharp.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSerialLargeCSharp.
 */
template<class T, typename CT>
class Callback_MyClass_opSerialLargeCSharp : public Callback_MyClass_opSerialLargeCSharp_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SerialLarge&, const SerialLarge&, const CT&);

    Callback_MyClass_opSerialLargeCSharp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SerialLarge iceP_o;
        SerialLarge ret;
        try
        {
            ret = proxy->end_opSerialLargeCSharp(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSerialLargeCSharp.
 */
template<class T, typename CT> Callback_MyClass_opSerialLargeCSharpPtr
newCallback_MyClass_opSerialLargeCSharp(const IceUtil::Handle<T>& instance, void (T::*cb)(const SerialLarge&, const SerialLarge&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSerialLargeCSharp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSerialLargeCSharp.
 */
template<class T, typename CT> Callback_MyClass_opSerialLargeCSharpPtr
newCallback_MyClass_opSerialLargeCSharp(T* instance, void (T::*cb)(const SerialLarge&, const SerialLarge&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSerialLargeCSharp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opSerialStructCSharp.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSerialStructCSharp.
 */
template<class T>
class CallbackNC_MyClass_opSerialStructCSharp : public Callback_MyClass_opSerialStructCSharp_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SerialStruct&, const SerialStruct&);

    CallbackNC_MyClass_opSerialStructCSharp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SerialStruct iceP_o;
        SerialStruct ret;
        try
        {
            ret = proxy->end_opSerialStructCSharp(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSerialStructCSharp.
 */
template<class T> Callback_MyClass_opSerialStructCSharpPtr
newCallback_MyClass_opSerialStructCSharp(const IceUtil::Handle<T>& instance, void (T::*cb)(const SerialStruct&, const SerialStruct&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSerialStructCSharp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSerialStructCSharp.
 */
template<class T> Callback_MyClass_opSerialStructCSharpPtr
newCallback_MyClass_opSerialStructCSharp(T* instance, void (T::*cb)(const SerialStruct&, const SerialStruct&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opSerialStructCSharp<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opSerialStructCSharp.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opSerialStructCSharp.
 */
template<class T, typename CT>
class Callback_MyClass_opSerialStructCSharp : public Callback_MyClass_opSerialStructCSharp_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SerialStruct&, const SerialStruct&, const CT&);

    Callback_MyClass_opSerialStructCSharp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        SerialStruct iceP_o;
        SerialStruct ret;
        try
        {
            ret = proxy->end_opSerialStructCSharp(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSerialStructCSharp.
 */
template<class T, typename CT> Callback_MyClass_opSerialStructCSharpPtr
newCallback_MyClass_opSerialStructCSharp(const IceUtil::Handle<T>& instance, void (T::*cb)(const SerialStruct&, const SerialStruct&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSerialStructCSharp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opSerialStructCSharp.
 */
template<class T, typename CT> Callback_MyClass_opSerialStructCSharpPtr
newCallback_MyClass_opSerialStructCSharp(T* instance, void (T::*cb)(const SerialStruct&, const SerialStruct&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opSerialStructCSharp<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
