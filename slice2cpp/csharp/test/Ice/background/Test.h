// Copyright (c) ZeroC, Inc.
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file 'Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

// clang-format off

#ifndef Test_h_
#define Test_h_

#include <Ice/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/BuiltinSequences.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{
    class BackgroundPrx;

    class BackgroundControllerPrx;

}

namespace Test
{

class BackgroundPrx : public Ice::Proxy<BackgroundPrx, Ice::ObjectPrx>
{
public:

    void op(const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] std::future<void> opAsync(const Ice::Context& context = Ice::noExplicitContext) const;

    std::function<void()> // NOLINT(modernize-use-nodiscard)
    opAsync(std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_op(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const Ice::Context&) const;
    /// \endcond

    void opWithPayload(const ::Ice::ByteSeq& seq, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] std::future<void> opWithPayloadAsync(const ::Ice::ByteSeq& seq, const Ice::Context& context = Ice::noExplicitContext) const;

    std::function<void()> // NOLINT(modernize-use-nodiscard)
    opWithPayloadAsync(const ::Ice::ByteSeq& seq, std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opWithPayload(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const ::Ice::ByteSeq&, const Ice::Context&) const;
    /// \endcond

    void shutdown(const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] std::future<void> shutdownAsync(const Ice::Context& context = Ice::noExplicitContext) const;

    std::function<void()> // NOLINT(modernize-use-nodiscard)
    shutdownAsync(std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_shutdown(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const Ice::Context&) const;
    /// \endcond

    /// Obtains the Slice type ID of this interface.
    /// @return The fully-scoped type ID.
    static const char* ice_staticId() noexcept;

    BackgroundPrx(const BackgroundPrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

    BackgroundPrx(BackgroundPrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

    BackgroundPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

    ~BackgroundPrx() override;

    BackgroundPrx& operator=(const BackgroundPrx& rhs) noexcept
    {
        if (this != &rhs)
        {
            Ice::ObjectPrx::operator=(rhs);
        }
        return *this;
    }

    BackgroundPrx& operator=(BackgroundPrx&& rhs) noexcept
    {
        if (this != &rhs)
        {
            Ice::ObjectPrx::operator=(std::move(rhs));
        }
        return *this;
    }

    /// \cond INTERNAL
    static BackgroundPrx _fromReference(IceInternal::ReferencePtr ref) { return BackgroundPrx(std::move(ref)); }

protected:

    BackgroundPrx() = default;

    explicit BackgroundPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
    {
    }
    /// \endcond
};

class BackgroundControllerPrx : public Ice::Proxy<BackgroundControllerPrx, Ice::ObjectPrx>
{
public:

    void pauseCall(std::string_view call, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] std::future<void> pauseCallAsync(std::string_view call, const Ice::Context& context = Ice::noExplicitContext) const;

    std::function<void()> // NOLINT(modernize-use-nodiscard)
    pauseCallAsync(std::string_view call, std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_pauseCall(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::string_view, const Ice::Context&) const;
    /// \endcond

    void resumeCall(std::string_view call, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] std::future<void> resumeCallAsync(std::string_view call, const Ice::Context& context = Ice::noExplicitContext) const;

    std::function<void()> // NOLINT(modernize-use-nodiscard)
    resumeCallAsync(std::string_view call, std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_resumeCall(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::string_view, const Ice::Context&) const;
    /// \endcond

    void holdAdapter(const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] std::future<void> holdAdapterAsync(const Ice::Context& context = Ice::noExplicitContext) const;

    std::function<void()> // NOLINT(modernize-use-nodiscard)
    holdAdapterAsync(std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_holdAdapter(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const Ice::Context&) const;
    /// \endcond

    void resumeAdapter(const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] std::future<void> resumeAdapterAsync(const Ice::Context& context = Ice::noExplicitContext) const;

    std::function<void()> // NOLINT(modernize-use-nodiscard)
    resumeAdapterAsync(std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_resumeAdapter(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const Ice::Context&) const;
    /// \endcond

    void initializeException(bool enable, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] std::future<void> initializeExceptionAsync(bool enable, const Ice::Context& context = Ice::noExplicitContext) const;

    std::function<void()> // NOLINT(modernize-use-nodiscard)
    initializeExceptionAsync(bool enable, std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_initializeException(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, bool, const Ice::Context&) const;
    /// \endcond

    void readReady(bool enable, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] std::future<void> readReadyAsync(bool enable, const Ice::Context& context = Ice::noExplicitContext) const;

    std::function<void()> // NOLINT(modernize-use-nodiscard)
    readReadyAsync(bool enable, std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_readReady(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, bool, const Ice::Context&) const;
    /// \endcond

    void readException(bool enable, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] std::future<void> readExceptionAsync(bool enable, const Ice::Context& context = Ice::noExplicitContext) const;

    std::function<void()> // NOLINT(modernize-use-nodiscard)
    readExceptionAsync(bool enable, std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_readException(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, bool, const Ice::Context&) const;
    /// \endcond

    void writeReady(bool enable, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] std::future<void> writeReadyAsync(bool enable, const Ice::Context& context = Ice::noExplicitContext) const;

    std::function<void()> // NOLINT(modernize-use-nodiscard)
    writeReadyAsync(bool enable, std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_writeReady(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, bool, const Ice::Context&) const;
    /// \endcond

    void writeException(bool enable, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] std::future<void> writeExceptionAsync(bool enable, const Ice::Context& context = Ice::noExplicitContext) const;

    std::function<void()> // NOLINT(modernize-use-nodiscard)
    writeExceptionAsync(bool enable, std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_writeException(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, bool, const Ice::Context&) const;
    /// \endcond

    void buffered(bool enable, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] std::future<void> bufferedAsync(bool enable, const Ice::Context& context = Ice::noExplicitContext) const;

    std::function<void()> // NOLINT(modernize-use-nodiscard)
    bufferedAsync(bool enable, std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_buffered(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, bool, const Ice::Context&) const;
    /// \endcond

    /// Obtains the Slice type ID of this interface.
    /// @return The fully-scoped type ID.
    static const char* ice_staticId() noexcept;

    BackgroundControllerPrx(const BackgroundControllerPrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

    BackgroundControllerPrx(BackgroundControllerPrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

    BackgroundControllerPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

    ~BackgroundControllerPrx() override;

    BackgroundControllerPrx& operator=(const BackgroundControllerPrx& rhs) noexcept
    {
        if (this != &rhs)
        {
            Ice::ObjectPrx::operator=(rhs);
        }
        return *this;
    }

    BackgroundControllerPrx& operator=(BackgroundControllerPrx&& rhs) noexcept
    {
        if (this != &rhs)
        {
            Ice::ObjectPrx::operator=(std::move(rhs));
        }
        return *this;
    }

    /// \cond INTERNAL
    static BackgroundControllerPrx _fromReference(IceInternal::ReferencePtr ref) { return BackgroundControllerPrx(std::move(ref)); }

protected:

    BackgroundControllerPrx() = default;

    explicit BackgroundControllerPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
    {
    }
    /// \endcond
};

}

namespace Test
{

class Background : public virtual Ice::Object
{
public:

    using ProxyType = BackgroundPrx;

    /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
    /// @param current The Current object for the invocation.
    /// @return A list of fully-scoped type IDs.
    [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

    /// Obtains a Slice type ID representing the most-derived interface supported by this object.
    /// @param current The Current object for the invocation.
    /// @return A fully-scoped type ID.
    [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

    /// Obtains the Slice type ID corresponding to this interface.
    /// @return A fully-scoped type ID.
    static const char* ice_staticId() noexcept;

    virtual void op(const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_op(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual void opWithPayload(::Ice::ByteSeq seq, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opWithPayload(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual void shutdown(const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_shutdown(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
    /// \endcond
};

using BackgroundPtr = std::shared_ptr<Background>;

class BackgroundController : public virtual Ice::Object
{
public:

    using ProxyType = BackgroundControllerPrx;

    /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
    /// @param current The Current object for the invocation.
    /// @return A list of fully-scoped type IDs.
    [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

    /// Obtains a Slice type ID representing the most-derived interface supported by this object.
    /// @param current The Current object for the invocation.
    /// @return A fully-scoped type ID.
    [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

    /// Obtains the Slice type ID corresponding to this interface.
    /// @return A fully-scoped type ID.
    static const char* ice_staticId() noexcept;

    virtual void pauseCall(std::string call, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_pauseCall(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual void resumeCall(std::string call, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_resumeCall(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual void holdAdapter(const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_holdAdapter(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual void resumeAdapter(const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_resumeAdapter(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual void initializeException(bool enable, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_initializeException(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual void readReady(bool enable, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_readReady(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual void readException(bool enable, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_readException(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual void writeReady(bool enable, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_writeReady(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual void writeException(bool enable, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_writeException(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual void buffered(bool enable, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_buffered(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
    /// \endcond
};

using BackgroundControllerPtr = std::shared_ptr<BackgroundController>;

}

#include <Ice/PopDisableWarnings.h>
#endif
