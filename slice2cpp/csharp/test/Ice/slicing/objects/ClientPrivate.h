//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `ClientPrivate.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __ClientPrivate_h__
#define __ClientPrivate_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Test.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{

class D3;

using D3Ptr = ::std::shared_ptr<D3>;
class PCUnknown;

using PCUnknownPtr = ::std::shared_ptr<PCUnknown>;
class PCDerived;

using PCDerivedPtr = ::std::shared_ptr<PCDerived>;
class PCDerived2;

using PCDerived2Ptr = ::std::shared_ptr<PCDerived2>;
class PCDerived3;

using PCDerived3Ptr = ::std::shared_ptr<PCDerived3>;
class CompactPCDerived;

using CompactPCDerivedPtr = ::std::shared_ptr<CompactPCDerived>;

}

namespace Test
{

class D3 : public B
{
public:

    D3() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D3(::std::string sb, ::std::shared_ptr<::Test::B> pb, ::std::string sd3, ::std::shared_ptr<::Test::B> pd3) :
        B(::std::move(sb), ::std::move(pb)),
        sd3(::std::move(sd3)),
        pd3(::std::move(pd3))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb, sd3, pd3);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<D3> ice_clone() const { return ::std::static_pointer_cast <D3>(_iceCloneImpl()); }

    ::std::string sd3;
    ::std::shared_ptr<::Test::B> pd3;

protected:

    D3(const D3&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

/// \cond INTERNAL
static D3 _iceS_D3_init;
/// \endcond

class PCUnknown : public PBase
{
public:

    PCUnknown() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PCUnknown(::std::int32_t pi, ::std::string pu) :
        PBase(pi),
        pu(::std::move(pu))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&> ice_tuple() const
    {
        return std::tie(pi, pu);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<PCUnknown> ice_clone() const { return ::std::static_pointer_cast <PCUnknown>(_iceCloneImpl()); }

    ::std::string pu;

protected:

    PCUnknown(const PCUnknown&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class PCDerived : public PDerived
{
public:

    PCDerived() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PCDerived(::std::int32_t pi, ::std::string ps, ::std::shared_ptr<::Test::PBase> pb, ::Test::PBaseSeq pbs) :
        PDerived(pi, ::std::move(ps), ::std::move(pb)),
        pbs(::std::move(pbs))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&, const ::Test::PBaseSeq&> ice_tuple() const
    {
        return std::tie(pi, ps, pb, pbs);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<PCDerived> ice_clone() const { return ::std::static_pointer_cast <PCDerived>(_iceCloneImpl()); }

    ::Test::PBaseSeq pbs;

protected:

    PCDerived(const PCDerived&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class PCDerived2 : public PCDerived
{
public:

    PCDerived2() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PCDerived2(::std::int32_t pi, ::std::string ps, ::std::shared_ptr<::Test::PBase> pb, ::Test::PBaseSeq pbs, ::std::int32_t pcd2) :
        PCDerived(pi, ::std::move(ps), ::std::move(pb), ::std::move(pbs)),
        pcd2(pcd2)
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&, const ::Test::PBaseSeq&, const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(pi, ps, pb, pbs, pcd2);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<PCDerived2> ice_clone() const { return ::std::static_pointer_cast <PCDerived2>(_iceCloneImpl()); }

    ::std::int32_t pcd2;

protected:

    PCDerived2(const PCDerived2&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class PCDerived3 : public PCDerived2
{
public:

    PCDerived3() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PCDerived3(::std::int32_t pi, ::std::string ps, ::std::shared_ptr<::Test::PBase> pb, ::Test::PBaseSeq pbs, ::std::int32_t pcd2, ::std::shared_ptr<::Ice::Value> pcd3) :
        PCDerived2(pi, ::std::move(ps), ::std::move(pb), ::std::move(pbs), pcd2),
        pcd3(::std::move(pcd3))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&, const ::Test::PBaseSeq&, const ::std::int32_t&, const ::std::shared_ptr<::Ice::Value>&> ice_tuple() const
    {
        return std::tie(pi, ps, pb, pbs, pcd2, pcd3);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<PCDerived3> ice_clone() const { return ::std::static_pointer_cast <PCDerived3>(_iceCloneImpl()); }

    ::std::shared_ptr<::Ice::Value> pcd3;

protected:

    PCDerived3(const PCDerived3&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class CompactPCDerived : public CompactPDerived
{
public:

    CompactPCDerived() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    CompactPCDerived(::std::int32_t pi, ::std::string ps, ::std::shared_ptr<::Test::PBase> pb, ::Test::PBaseSeq pbs) :
        CompactPDerived(pi, ::std::move(ps), ::std::move(pb)),
        pbs(::std::move(pbs))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&, const ::Test::PBaseSeq&> ice_tuple() const
    {
        return std::tie(pi, ps, pb, pbs);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<CompactPCDerived> ice_clone() const { return ::std::static_pointer_cast <CompactPCDerived>(_iceCloneImpl()); }

    ::Test::PBaseSeq pbs;

protected:

    CompactPCDerived(const CompactPCDerived&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamWriter<::Test::D3>
{
    static void write(OutputStream* ostr, const ::Test::D3& v)
    {
        ostr->writeAll(v.sd3, v.pd3);
    }
};

template<>
struct StreamReader<::Test::D3>
{
    static void read(InputStream* istr, ::Test::D3& v)
    {
        istr->readAll(v.sd3, v.pd3);
    }
};

template<>
struct StreamWriter<::Test::PCUnknown>
{
    static void write(OutputStream* ostr, const ::Test::PCUnknown& v)
    {
        ostr->writeAll(v.pu);
    }
};

template<>
struct StreamReader<::Test::PCUnknown>
{
    static void read(InputStream* istr, ::Test::PCUnknown& v)
    {
        istr->readAll(v.pu);
    }
};

template<>
struct StreamWriter<::Test::PCDerived>
{
    static void write(OutputStream* ostr, const ::Test::PCDerived& v)
    {
        ostr->writeAll(v.pbs);
    }
};

template<>
struct StreamReader<::Test::PCDerived>
{
    static void read(InputStream* istr, ::Test::PCDerived& v)
    {
        istr->readAll(v.pbs);
    }
};

template<>
struct StreamWriter<::Test::PCDerived2>
{
    static void write(OutputStream* ostr, const ::Test::PCDerived2& v)
    {
        ostr->writeAll(v.pcd2);
    }
};

template<>
struct StreamReader<::Test::PCDerived2>
{
    static void read(InputStream* istr, ::Test::PCDerived2& v)
    {
        istr->readAll(v.pcd2);
    }
};

template<>
struct StreamWriter<::Test::PCDerived3>
{
    static void write(OutputStream* ostr, const ::Test::PCDerived3& v)
    {
        ostr->writeAll(v.pcd3);
    }
};

template<>
struct StreamReader<::Test::PCDerived3>
{
    static void read(InputStream* istr, ::Test::PCDerived3& v)
    {
        istr->readAll(v.pcd3);
    }
};

template<>
struct StreamWriter<::Test::CompactPCDerived>
{
    static void write(OutputStream* ostr, const ::Test::CompactPCDerived& v)
    {
        ostr->writeAll(v.pbs);
    }
};

template<>
struct StreamReader<::Test::CompactPCDerived>
{
    static void read(InputStream* istr, ::Test::CompactPCDerived& v)
    {
        istr->readAll(v.pbs);
    }
};

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
