//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <TestAMD.h>
#include <IceUtil/PushDisableWarnings.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::SBase> iceC_Test_SBase_init("::Test::SBase");

const ::IceInternal::DefaultValueFactoryInit<::Test::SBSKnownDerived> iceC_Test_SBSKnownDerived_init("::Test::SBSKnownDerived");

const ::IceInternal::DefaultValueFactoryInit<::Test::B> iceC_Test_B_init("::Test::B");

const ::IceInternal::DefaultValueFactoryInit<::Test::D1> iceC_Test_D1_init("::Test::D1");

const ::IceInternal::DefaultValueFactoryInit<::Test::SS1> iceC_Test_SS1_init("::Test::SS1");

const ::IceInternal::DefaultValueFactoryInit<::Test::SS2> iceC_Test_SS2_init("::Test::SS2");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::BaseException> iceC_Test_BaseException_init("::Test::BaseException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::DerivedException> iceC_Test_DerivedException_init("::Test::DerivedException");

const ::IceInternal::DefaultValueFactoryInit<::Test::PBase> iceC_Test_PBase_init("::Test::PBase");

const ::IceInternal::DefaultValueFactoryInit<::Test::Preserved> iceC_Test_Preserved_init("::Test::Preserved");

const ::IceInternal::DefaultValueFactoryInit<::Test::PDerived> iceC_Test_PDerived_init("::Test::PDerived");

const ::IceInternal::DefaultValueFactoryInit<::Test::PNode> iceC_Test_PNode_init("::Test::PNode");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::PreservedException> iceC_Test_PreservedException_init("::Test::PreservedException");

const ::std::string iceC_Test_TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};
const ::std::string iceC_Test_TestIntf_ops[] =
{
    "D1AsB",
    "D1AsD1",
    "D2AsB",
    "PBSUnknown2AsPreservedWithGraph",
    "PBSUnknownAsPreserved",
    "PBSUnknownAsPreservedWithGraph",
    "SBSKnownDerivedAsSBSKnownDerived",
    "SBSKnownDerivedAsSBase",
    "SBSUnknownDerivedAsSBase",
    "SBSUnknownDerivedAsSBaseCompact",
    "SBaseAsObject",
    "SBaseAsSBase",
    "SUnknownAsObject",
    "checkPBSUnknown",
    "checkPBSUnknown2WithGraph",
    "checkPBSUnknownWithGraph",
    "checkSUnknown",
    "dictionaryTest",
    "exchangePBase",
    "exchangePNode",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "oneElementCycle",
    "paramTest1",
    "paramTest2",
    "paramTest3",
    "paramTest4",
    "returnTest1",
    "returnTest2",
    "returnTest3",
    "sequenceTest",
    "shutdown",
    "throwBaseAsBase",
    "throwDerivedAsBase",
    "throwDerivedAsDerived",
    "throwPreservedException",
    "throwUnknownDerivedAsBase",
    "twoElementCycle",
    "useForward"
};
const ::std::string iceC_Test_TestIntf_SBaseAsObject_name = "SBaseAsObject";
const ::std::string iceC_Test_TestIntf_SBaseAsSBase_name = "SBaseAsSBase";
const ::std::string iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name = "SBSKnownDerivedAsSBase";
const ::std::string iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name = "SBSKnownDerivedAsSBSKnownDerived";
const ::std::string iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name = "SBSUnknownDerivedAsSBase";
const ::std::string iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name = "SBSUnknownDerivedAsSBaseCompact";
const ::std::string iceC_Test_TestIntf_SUnknownAsObject_name = "SUnknownAsObject";
const ::std::string iceC_Test_TestIntf_checkSUnknown_name = "checkSUnknown";
const ::std::string iceC_Test_TestIntf_oneElementCycle_name = "oneElementCycle";
const ::std::string iceC_Test_TestIntf_twoElementCycle_name = "twoElementCycle";
const ::std::string iceC_Test_TestIntf_D1AsB_name = "D1AsB";
const ::std::string iceC_Test_TestIntf_D1AsD1_name = "D1AsD1";
const ::std::string iceC_Test_TestIntf_D2AsB_name = "D2AsB";
const ::std::string iceC_Test_TestIntf_paramTest1_name = "paramTest1";
const ::std::string iceC_Test_TestIntf_paramTest2_name = "paramTest2";
const ::std::string iceC_Test_TestIntf_paramTest3_name = "paramTest3";
const ::std::string iceC_Test_TestIntf_paramTest4_name = "paramTest4";
const ::std::string iceC_Test_TestIntf_returnTest1_name = "returnTest1";
const ::std::string iceC_Test_TestIntf_returnTest2_name = "returnTest2";
const ::std::string iceC_Test_TestIntf_returnTest3_name = "returnTest3";
const ::std::string iceC_Test_TestIntf_sequenceTest_name = "sequenceTest";
const ::std::string iceC_Test_TestIntf_dictionaryTest_name = "dictionaryTest";
const ::std::string iceC_Test_TestIntf_exchangePBase_name = "exchangePBase";
const ::std::string iceC_Test_TestIntf_PBSUnknownAsPreserved_name = "PBSUnknownAsPreserved";
const ::std::string iceC_Test_TestIntf_checkPBSUnknown_name = "checkPBSUnknown";
const ::std::string iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name = "PBSUnknownAsPreservedWithGraph";
const ::std::string iceC_Test_TestIntf_checkPBSUnknownWithGraph_name = "checkPBSUnknownWithGraph";
const ::std::string iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name = "PBSUnknown2AsPreservedWithGraph";
const ::std::string iceC_Test_TestIntf_checkPBSUnknown2WithGraph_name = "checkPBSUnknown2WithGraph";
const ::std::string iceC_Test_TestIntf_exchangePNode_name = "exchangePNode";
const ::std::string iceC_Test_TestIntf_throwBaseAsBase_name = "throwBaseAsBase";
const ::std::string iceC_Test_TestIntf_throwDerivedAsBase_name = "throwDerivedAsBase";
const ::std::string iceC_Test_TestIntf_throwDerivedAsDerived_name = "throwDerivedAsDerived";
const ::std::string iceC_Test_TestIntf_throwUnknownDerivedAsBase_name = "throwUnknownDerivedAsBase";
const ::std::string iceC_Test_TestIntf_throwPreservedException_name = "throwPreservedException";
const ::std::string iceC_Test_TestIntf_useForward_name = "useForward";
const ::std::string iceC_Test_TestIntf_shutdown_name = "shutdown";

const ::IceInternal::DefaultValueFactoryInit<::Test::Hidden> iceC_Test_Hidden_init("::Test::Hidden");

const ::IceInternal::DefaultValueFactoryInit<::Test::Forward> iceC_Test_Forward_init("::Test::Forward");

}

Test::BaseException::~BaseException()
{
}

const ::std::string&
Test::BaseException::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseException";
    return typeId;
}

/// \cond STREAM
bool
Test::BaseException::_usesClasses() const
{
    return true;
}
/// \endcond

Test::DerivedException::~DerivedException()
{
}

const ::std::string&
Test::DerivedException::ice_staticId()
{
    static const ::std::string typeId = "::Test::DerivedException";
    return typeId;
}

Test::PreservedException::~PreservedException()
{
}

const ::std::string&
Test::PreservedException::ice_staticId()
{
    static const ::std::string typeId = "::Test::PreservedException";
    return typeId;
}

::std::shared_ptr<::Ice::SlicedData>
Test::PreservedException::ice_getSlicedData() const
{
    return _slicedData;
}

/// \cond STREAM
void
Test::PreservedException::_write(::Ice::OutputStream* ostr) const
{
    ostr->startException(_slicedData);
    _writeImpl(ostr);
    ostr->endException();
}

void
Test::PreservedException::_read(::Ice::InputStream* istr)
{
    istr->startException();
    _readImpl(istr);
    _slicedData = istr->endException(true);
}
/// \endcond

bool
Test::TestIntf::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_TestIntf_ids, iceC_Test_TestIntf_ids + 2, s);
}

::std::vector<::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_TestIntf_ids[0], &iceC_Test_TestIntf_ids[2]);
}

::std::string
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBaseAsObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<::Ice::Value>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->SBaseAsObjectAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBaseAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<SBase>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->SBaseAsSBaseAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSKnownDerivedAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<SBase>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->SBSKnownDerivedAsSBaseAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSKnownDerivedAsSBSKnownDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<SBSKnownDerived>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->SBSKnownDerivedAsSBSKnownDerivedAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSUnknownDerivedAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<SBase>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->SBSUnknownDerivedAsSBaseAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSUnknownDerivedAsSBaseCompact(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::CompactFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<SBase>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->SBSUnknownDerivedAsSBaseCompactAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SUnknownAsObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<::Ice::Value>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->SUnknownAsObjectAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkSUnknown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<::Ice::Value> iceP_o;
    istr->readAll(iceP_o);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->checkSUnknownAsync(::std::move(iceP_o), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_oneElementCycle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<B>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->oneElementCycleAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_twoElementCycle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<B>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->twoElementCycleAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D1AsB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<B>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->D1AsBAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D1AsD1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<D1>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->D1AsD1Async(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D2AsB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<B>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->D2AsBAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<B>& iceP_p1, const ::std::shared_ptr<B>& iceP_p2)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_p1, iceP_p2);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->paramTest1Async(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<B>& iceP_p2, const ::std::shared_ptr<B>& iceP_p1)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_p2, iceP_p1);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->paramTest2Async(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest3(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<B>& ret, const ::std::shared_ptr<B>& iceP_p1, const ::std::shared_ptr<B>& iceP_p2)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_p1, iceP_p2, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->paramTest3Async(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest4(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<B>& ret, const ::std::shared_ptr<B>& iceP_p)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_p, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->paramTest4Async(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<B>& ret, const ::std::shared_ptr<B>& iceP_p1, const ::std::shared_ptr<B>& iceP_p2)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_p1, iceP_p2, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->returnTest1Async(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<B>& ret, const ::std::shared_ptr<B>& iceP_p2, const ::std::shared_ptr<B>& iceP_p1)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_p2, iceP_p1, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->returnTest2Async(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest3(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<B> iceP_p1;
    ::std::shared_ptr<B> iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<B>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->returnTest3Async(::std::move(iceP_p1), ::std::move(iceP_p2), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_sequenceTest(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<SS1> iceP_p1;
    ::std::shared_ptr<SS2> iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const SS3& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->sequenceTestAsync(::std::move(iceP_p1), ::std::move(iceP_p2), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_dictionaryTest(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BDict iceP_bin;
    istr->readAll(iceP_bin);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const BDict& ret, const BDict& iceP_bout)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_bout, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->dictionaryTestAsync(::std::move(iceP_bin), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_exchangePBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<PBase> iceP_pb;
    istr->readAll(iceP_pb);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<PBase>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->exchangePBaseAsync(::std::move(iceP_pb), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknownAsPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<Preserved>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->PBSUnknownAsPreservedAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<Preserved> iceP_p;
    istr->readAll(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->checkPBSUnknownAsync(::std::move(iceP_p), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknownAsPreservedWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<Preserved>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->PBSUnknownAsPreservedWithGraphAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknownWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<Preserved> iceP_p;
    istr->readAll(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->checkPBSUnknownWithGraphAsync(::std::move(iceP_p), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknown2AsPreservedWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<Preserved>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->PBSUnknown2AsPreservedWithGraphAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknown2WithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<Preserved> iceP_p;
    istr->readAll(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->checkPBSUnknown2WithGraphAsync(::std::move(iceP_p), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_exchangePNode(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<PNode> iceP_pn;
    istr->readAll(iceP_pn);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<PNode>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->exchangePNodeAsync(::std::move(iceP_pn), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwBaseAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->throwBaseAsBaseAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->throwDerivedAsBaseAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwDerivedAsDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->throwDerivedAsDerivedAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwUnknownDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->throwUnknownDerivedAsBaseAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwPreservedException(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->throwPreservedExceptionAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_useForward(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<Forward>& iceP_f)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_f);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->useForwardAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->shutdownAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_TestIntf_ops, iceC_Test_TestIntf_ops + 41, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_TestIntf_ops)
    {
        case 0:
        {
            return _iceD_D1AsB(in, current);
        }
        case 1:
        {
            return _iceD_D1AsD1(in, current);
        }
        case 2:
        {
            return _iceD_D2AsB(in, current);
        }
        case 3:
        {
            return _iceD_PBSUnknown2AsPreservedWithGraph(in, current);
        }
        case 4:
        {
            return _iceD_PBSUnknownAsPreserved(in, current);
        }
        case 5:
        {
            return _iceD_PBSUnknownAsPreservedWithGraph(in, current);
        }
        case 6:
        {
            return _iceD_SBSKnownDerivedAsSBSKnownDerived(in, current);
        }
        case 7:
        {
            return _iceD_SBSKnownDerivedAsSBase(in, current);
        }
        case 8:
        {
            return _iceD_SBSUnknownDerivedAsSBase(in, current);
        }
        case 9:
        {
            return _iceD_SBSUnknownDerivedAsSBaseCompact(in, current);
        }
        case 10:
        {
            return _iceD_SBaseAsObject(in, current);
        }
        case 11:
        {
            return _iceD_SBaseAsSBase(in, current);
        }
        case 12:
        {
            return _iceD_SUnknownAsObject(in, current);
        }
        case 13:
        {
            return _iceD_checkPBSUnknown(in, current);
        }
        case 14:
        {
            return _iceD_checkPBSUnknown2WithGraph(in, current);
        }
        case 15:
        {
            return _iceD_checkPBSUnknownWithGraph(in, current);
        }
        case 16:
        {
            return _iceD_checkSUnknown(in, current);
        }
        case 17:
        {
            return _iceD_dictionaryTest(in, current);
        }
        case 18:
        {
            return _iceD_exchangePBase(in, current);
        }
        case 19:
        {
            return _iceD_exchangePNode(in, current);
        }
        case 20:
        {
            return _iceD_ice_id(in, current);
        }
        case 21:
        {
            return _iceD_ice_ids(in, current);
        }
        case 22:
        {
            return _iceD_ice_isA(in, current);
        }
        case 23:
        {
            return _iceD_ice_ping(in, current);
        }
        case 24:
        {
            return _iceD_oneElementCycle(in, current);
        }
        case 25:
        {
            return _iceD_paramTest1(in, current);
        }
        case 26:
        {
            return _iceD_paramTest2(in, current);
        }
        case 27:
        {
            return _iceD_paramTest3(in, current);
        }
        case 28:
        {
            return _iceD_paramTest4(in, current);
        }
        case 29:
        {
            return _iceD_returnTest1(in, current);
        }
        case 30:
        {
            return _iceD_returnTest2(in, current);
        }
        case 31:
        {
            return _iceD_returnTest3(in, current);
        }
        case 32:
        {
            return _iceD_sequenceTest(in, current);
        }
        case 33:
        {
            return _iceD_shutdown(in, current);
        }
        case 34:
        {
            return _iceD_throwBaseAsBase(in, current);
        }
        case 35:
        {
            return _iceD_throwDerivedAsBase(in, current);
        }
        case 36:
        {
            return _iceD_throwDerivedAsDerived(in, current);
        }
        case 37:
        {
            return _iceD_throwPreservedException(in, current);
        }
        case 38:
        {
            return _iceD_throwUnknownDerivedAsBase(in, current);
        }
        case 39:
        {
            return _iceD_twoElementCycle(in, current);
        }
        case 40:
        {
            return _iceD_useForward(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::SBase::~SBase()
{
}

const ::std::string&
Test::SBase::ice_staticId()
{
    static const ::std::string typeId = "::Test::SBase";
    return typeId;
}

Test::SBSKnownDerived::~SBSKnownDerived()
{
}

const ::std::string&
Test::SBSKnownDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::SBSKnownDerived";
    return typeId;
}

Test::B::~B()
{
}

const ::std::string&
Test::B::ice_staticId()
{
    static const ::std::string typeId = "::Test::B";
    return typeId;
}

Test::D1::~D1()
{
}

const ::std::string&
Test::D1::ice_staticId()
{
    static const ::std::string typeId = "::Test::D1";
    return typeId;
}

Test::SS1::~SS1()
{
}

const ::std::string&
Test::SS1::ice_staticId()
{
    static const ::std::string typeId = "::Test::SS1";
    return typeId;
}

Test::SS2::~SS2()
{
}

const ::std::string&
Test::SS2::ice_staticId()
{
    static const ::std::string typeId = "::Test::SS2";
    return typeId;
}

Test::PBase::~PBase()
{
}

const ::std::string&
Test::PBase::ice_staticId()
{
    static const ::std::string typeId = "::Test::PBase";
    return typeId;
}

Test::Preserved::~Preserved()
{
}

::std::shared_ptr<::Ice::SlicedData>
Test::Preserved::ice_getSlicedData() const
{
    return _iceSlicedData;
}

/// \cond STREAM
void
Test::Preserved::_iceWrite(::Ice::OutputStream* ostr) const
{
    ostr->startValue(_iceSlicedData);
    _iceWriteImpl(ostr);
    ostr->endValue();
}

void
Test::Preserved::_iceRead(::Ice::InputStream* istr)
{
    istr->startValue();
    _iceReadImpl(istr);
    _iceSlicedData = istr->endValue(true);
}
/// \endcond

const ::std::string&
Test::Preserved::ice_staticId()
{
    static const ::std::string typeId = "::Test::Preserved";
    return typeId;
}

Test::PDerived::~PDerived()
{
}

const ::std::string&
Test::PDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::PDerived";
    return typeId;
}

Test::PNode::~PNode()
{
}

::std::shared_ptr<::Ice::SlicedData>
Test::PNode::ice_getSlicedData() const
{
    return _iceSlicedData;
}

/// \cond STREAM
void
Test::PNode::_iceWrite(::Ice::OutputStream* ostr) const
{
    ostr->startValue(_iceSlicedData);
    _iceWriteImpl(ostr);
    ostr->endValue();
}

void
Test::PNode::_iceRead(::Ice::InputStream* istr)
{
    istr->startValue();
    _iceReadImpl(istr);
    _iceSlicedData = istr->endValue(true);
}
/// \endcond

const ::std::string&
Test::PNode::ice_staticId()
{
    static const ::std::string typeId = "::Test::PNode";
    return typeId;
}

Test::Hidden::~Hidden()
{
}

const ::std::string&
Test::Hidden::ice_staticId()
{
    static const ::std::string typeId = "::Test::Hidden";
    return typeId;
}

Test::Forward::~Forward()
{
}

const ::std::string&
Test::Forward::ice_staticId()
{
    static const ::std::string typeId = "::Test::Forward";
    return typeId;
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBaseAsObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBaseAsObject_name);
    outAsync->invoke(iceC_Test_TestIntf_SBaseAsObject_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<::Ice::Value> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBaseAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBaseAsSBase_name);
    outAsync->invoke(iceC_Test_TestIntf_SBaseAsSBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name);
    outAsync->invoke(iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBSKnownDerived>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name);
    outAsync->invoke(iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBSKnownDerived> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name);
    outAsync->invoke(iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name);
    outAsync->invoke(iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::CompactFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SUnknownAsObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SUnknownAsObject_name);
    outAsync->invoke(iceC_Test_TestIntf_SUnknownAsObject_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<::Ice::Value> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_checkSUnknown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<::Ice::Value>& iceP_o, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_checkSUnknown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_o);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_oneElementCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_oneElementCycle_name);
    outAsync->invoke(iceC_Test_TestIntf_oneElementCycle_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_twoElementCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_twoElementCycle_name);
    outAsync->invoke(iceC_Test_TestIntf_twoElementCycle_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_D1AsB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_D1AsB_name);
    outAsync->invoke(iceC_Test_TestIntf_D1AsB_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_D1AsD1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::D1>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_D1AsD1_name);
    outAsync->invoke(iceC_Test_TestIntf_D1AsD1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<D1> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_D2AsB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_D2AsB_name);
    outAsync->invoke(iceC_Test_TestIntf_D2AsB_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_paramTest1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest1Result>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest1_name);
    outAsync->invoke(iceC_Test_TestIntf_paramTest1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::ParamTest1Result v;
            istr->readAll(v.p1, v.p2);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_paramTest2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest2Result>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest2_name);
    outAsync->invoke(iceC_Test_TestIntf_paramTest2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::ParamTest2Result v;
            istr->readAll(v.p2, v.p1);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_paramTest3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest3Result>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest3_name);
    outAsync->invoke(iceC_Test_TestIntf_paramTest3_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::ParamTest3Result v;
            istr->readAll(v.p1, v.p2, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_paramTest4(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest4Result>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest4_name);
    outAsync->invoke(iceC_Test_TestIntf_paramTest4_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::ParamTest4Result v;
            istr->readAll(v.p, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_returnTest1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ReturnTest1Result>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_returnTest1_name);
    outAsync->invoke(iceC_Test_TestIntf_returnTest1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::ReturnTest1Result v;
            istr->readAll(v.p1, v.p2, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_returnTest2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ReturnTest2Result>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_returnTest2_name);
    outAsync->invoke(iceC_Test_TestIntf_returnTest2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::ReturnTest2Result v;
            istr->readAll(v.p2, v.p1, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_returnTest3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>& outAsync, const ::std::shared_ptr<B>& iceP_p1, const ::std::shared_ptr<B>& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_returnTest3_name);
    outAsync->invoke(iceC_Test_TestIntf_returnTest3_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_sequenceTest(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::SS3>>& outAsync, const ::std::shared_ptr<SS1>& iceP_p1, const ::std::shared_ptr<SS2>& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_sequenceTest_name);
    outAsync->invoke(iceC_Test_TestIntf_sequenceTest_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            SS3 ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_dictionaryTest(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::DictionaryTestResult>>& outAsync, const BDict& iceP_bin, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_dictionaryTest_name);
    outAsync->invoke(iceC_Test_TestIntf_dictionaryTest_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_bin);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::DictionaryTestResult v;
            istr->readAll(v.bout, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_exchangePBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::PBase>>>& outAsync, const ::std::shared_ptr<PBase>& iceP_pb, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_exchangePBase_name);
    outAsync->invoke(iceC_Test_TestIntf_exchangePBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_pb);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<PBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_PBSUnknownAsPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Preserved>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_PBSUnknownAsPreserved_name);
    outAsync->invoke(iceC_Test_TestIntf_PBSUnknownAsPreserved_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<Preserved> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_checkPBSUnknown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_checkPBSUnknown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Preserved>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name);
    outAsync->invoke(iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<Preserved> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_checkPBSUnknownWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_checkPBSUnknownWithGraph_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Preserved>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name);
    outAsync->invoke(iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<Preserved> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_checkPBSUnknown2WithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_checkPBSUnknown2WithGraph_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_exchangePNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::PNode>>>& outAsync, const ::std::shared_ptr<PNode>& iceP_pn, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_exchangePNode_name);
    outAsync->invoke(iceC_Test_TestIntf_exchangePNode_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_pn);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<PNode> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwBaseAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwBaseAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_throwBaseAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwDerivedAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_throwDerivedAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwDerivedAsDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwDerivedAsDerived_name);
    outAsync->invoke(iceC_Test_TestIntf_throwDerivedAsDerived_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DerivedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwUnknownDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwUnknownDerivedAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_throwUnknownDerivedAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwPreservedException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwPreservedException_name);
    outAsync->invoke(iceC_Test_TestIntf_throwPreservedException_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const PreservedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_useForward(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Forward>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_useForward_name);
    outAsync->invoke(iceC_Test_TestIntf_useForward_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<Forward> iceP_f;
            istr->readAll(iceP_f);
            istr->readPendingValues();
            return iceP_f;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::TestIntfPrx::_newInstance() const
{
    return ::IceInternal::createProxy<TestIntfPrx>();
}
/// \endcond

const ::std::string&
Test::TestIntfPrx::ice_staticId()
{
    return TestIntf::ice_staticId();
}

namespace Ice
{
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_Test_TestIntf_SBaseAsObject_name = "SBaseAsObject";

const ::std::string iceC_Test_TestIntf_SBaseAsSBase_name = "SBaseAsSBase";

const ::std::string iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name = "SBSKnownDerivedAsSBase";

const ::std::string iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name = "SBSKnownDerivedAsSBSKnownDerived";

const ::std::string iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name = "SBSUnknownDerivedAsSBase";

const ::std::string iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name = "SBSUnknownDerivedAsSBaseCompact";

const ::std::string iceC_Test_TestIntf_SUnknownAsObject_name = "SUnknownAsObject";

const ::std::string iceC_Test_TestIntf_checkSUnknown_name = "checkSUnknown";

const ::std::string iceC_Test_TestIntf_oneElementCycle_name = "oneElementCycle";

const ::std::string iceC_Test_TestIntf_twoElementCycle_name = "twoElementCycle";

const ::std::string iceC_Test_TestIntf_D1AsB_name = "D1AsB";

const ::std::string iceC_Test_TestIntf_D1AsD1_name = "D1AsD1";

const ::std::string iceC_Test_TestIntf_D2AsB_name = "D2AsB";

const ::std::string iceC_Test_TestIntf_paramTest1_name = "paramTest1";

const ::std::string iceC_Test_TestIntf_paramTest2_name = "paramTest2";

const ::std::string iceC_Test_TestIntf_paramTest3_name = "paramTest3";

const ::std::string iceC_Test_TestIntf_paramTest4_name = "paramTest4";

const ::std::string iceC_Test_TestIntf_returnTest1_name = "returnTest1";

const ::std::string iceC_Test_TestIntf_returnTest2_name = "returnTest2";

const ::std::string iceC_Test_TestIntf_returnTest3_name = "returnTest3";

const ::std::string iceC_Test_TestIntf_sequenceTest_name = "sequenceTest";

const ::std::string iceC_Test_TestIntf_dictionaryTest_name = "dictionaryTest";

const ::std::string iceC_Test_TestIntf_exchangePBase_name = "exchangePBase";

const ::std::string iceC_Test_TestIntf_PBSUnknownAsPreserved_name = "PBSUnknownAsPreserved";

const ::std::string iceC_Test_TestIntf_checkPBSUnknown_name = "checkPBSUnknown";

const ::std::string iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name = "PBSUnknownAsPreservedWithGraph";

const ::std::string iceC_Test_TestIntf_checkPBSUnknownWithGraph_name = "checkPBSUnknownWithGraph";

const ::std::string iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name = "PBSUnknown2AsPreservedWithGraph";

const ::std::string iceC_Test_TestIntf_checkPBSUnknown2WithGraph_name = "checkPBSUnknown2WithGraph";

const ::std::string iceC_Test_TestIntf_exchangePNode_name = "exchangePNode";

const ::std::string iceC_Test_TestIntf_throwBaseAsBase_name = "throwBaseAsBase";

const ::std::string iceC_Test_TestIntf_throwDerivedAsBase_name = "throwDerivedAsBase";

const ::std::string iceC_Test_TestIntf_throwDerivedAsDerived_name = "throwDerivedAsDerived";

const ::std::string iceC_Test_TestIntf_throwUnknownDerivedAsBase_name = "throwUnknownDerivedAsBase";

const ::std::string iceC_Test_TestIntf_throwPreservedException_name = "throwPreservedException";

const ::std::string iceC_Test_TestIntf_useForward_name = "useForward";

const ::std::string iceC_Test_TestIntf_shutdown_name = "shutdown";

}

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::BaseException> iceC_Test_BaseException_init("::Test::BaseException");

}

Test::BaseException::BaseException(const ::std::string& sbe, const BPtr& pb) :
    ::Ice::UserException(),
    sbe(sbe),
    pb(pb)
{
}
Test::BaseException::~BaseException()
{
}

::std::string
Test::BaseException::ice_id() const
{
    return "::Test::BaseException";
}

Test::BaseException*
Test::BaseException::ice_clone() const
{
    return new BaseException(*this);
}

void
Test::BaseException::ice_throw() const
{
    throw *this;
}

bool
Test::BaseException::_usesClasses() const
{
    return true;
}

/// \cond STREAM
void
Test::BaseException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::BaseException", -1, true);
    ::Ice::StreamWriter< BaseException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::BaseException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BaseException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::DerivedException> iceC_Test_DerivedException_init("::Test::DerivedException");

}

Test::DerivedException::DerivedException(const ::std::string& sbe, const BPtr& pb, const ::std::string& sde, const D1Ptr& pd1) :
    BaseException(sbe, pb),
    sde(sde),
    pd1(pd1)
{
}
Test::DerivedException::~DerivedException()
{
}

::std::string
Test::DerivedException::ice_id() const
{
    return "::Test::DerivedException";
}

Test::DerivedException*
Test::DerivedException::ice_clone() const
{
    return new DerivedException(*this);
}

void
Test::DerivedException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::DerivedException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::DerivedException", -1, false);
    ::Ice::StreamWriter< DerivedException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    BaseException::_writeImpl(ostr);
}

void
Test::DerivedException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< DerivedException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    BaseException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::PreservedException> iceC_Test_PreservedException_init("::Test::PreservedException");

}
Test::PreservedException::~PreservedException()
{
}

::std::string
Test::PreservedException::ice_id() const
{
    return "::Test::PreservedException";
}

Test::PreservedException*
Test::PreservedException::ice_clone() const
{
    return new PreservedException(*this);
}

void
Test::PreservedException::ice_throw() const
{
    throw *this;
}

::Ice::SlicedDataPtr
Test::PreservedException::ice_getSlicedData() const
{
    return _slicedData;
}

void
Test::PreservedException::_write(::Ice::OutputStream* ostr) const
{
    ostr->startException(_slicedData);
    _writeImpl(ostr);
    ostr->endException();
}

void
Test::PreservedException::_read(::Ice::InputStream* istr)
{
    istr->startException();
    _readImpl(istr);
    _slicedData = istr->endException(true);
}

/// \cond STREAM
void
Test::PreservedException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::PreservedException", -1, true);
    ::Ice::StreamWriter< PreservedException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::PreservedException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< PreservedException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

Test::AMD_TestIntf_SBaseAsObject::~AMD_TestIntf_SBaseAsObject()
{
}

Test::AMD_TestIntf_SBaseAsSBase::~AMD_TestIntf_SBaseAsSBase()
{
}

Test::AMD_TestIntf_SBSKnownDerivedAsSBase::~AMD_TestIntf_SBSKnownDerivedAsSBase()
{
}

Test::AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived::~AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived()
{
}

Test::AMD_TestIntf_SBSUnknownDerivedAsSBase::~AMD_TestIntf_SBSUnknownDerivedAsSBase()
{
}

Test::AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact::~AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact()
{
}

Test::AMD_TestIntf_SUnknownAsObject::~AMD_TestIntf_SUnknownAsObject()
{
}

Test::AMD_TestIntf_checkSUnknown::~AMD_TestIntf_checkSUnknown()
{
}

Test::AMD_TestIntf_oneElementCycle::~AMD_TestIntf_oneElementCycle()
{
}

Test::AMD_TestIntf_twoElementCycle::~AMD_TestIntf_twoElementCycle()
{
}

Test::AMD_TestIntf_D1AsB::~AMD_TestIntf_D1AsB()
{
}

Test::AMD_TestIntf_D1AsD1::~AMD_TestIntf_D1AsD1()
{
}

Test::AMD_TestIntf_D2AsB::~AMD_TestIntf_D2AsB()
{
}

Test::AMD_TestIntf_paramTest1::~AMD_TestIntf_paramTest1()
{
}

Test::AMD_TestIntf_paramTest2::~AMD_TestIntf_paramTest2()
{
}

Test::AMD_TestIntf_paramTest3::~AMD_TestIntf_paramTest3()
{
}

Test::AMD_TestIntf_paramTest4::~AMD_TestIntf_paramTest4()
{
}

Test::AMD_TestIntf_returnTest1::~AMD_TestIntf_returnTest1()
{
}

Test::AMD_TestIntf_returnTest2::~AMD_TestIntf_returnTest2()
{
}

Test::AMD_TestIntf_returnTest3::~AMD_TestIntf_returnTest3()
{
}

Test::AMD_TestIntf_sequenceTest::~AMD_TestIntf_sequenceTest()
{
}

Test::AMD_TestIntf_dictionaryTest::~AMD_TestIntf_dictionaryTest()
{
}

Test::AMD_TestIntf_exchangePBase::~AMD_TestIntf_exchangePBase()
{
}

Test::AMD_TestIntf_PBSUnknownAsPreserved::~AMD_TestIntf_PBSUnknownAsPreserved()
{
}

Test::AMD_TestIntf_checkPBSUnknown::~AMD_TestIntf_checkPBSUnknown()
{
}

Test::AMD_TestIntf_PBSUnknownAsPreservedWithGraph::~AMD_TestIntf_PBSUnknownAsPreservedWithGraph()
{
}

Test::AMD_TestIntf_checkPBSUnknownWithGraph::~AMD_TestIntf_checkPBSUnknownWithGraph()
{
}

Test::AMD_TestIntf_PBSUnknown2AsPreservedWithGraph::~AMD_TestIntf_PBSUnknown2AsPreservedWithGraph()
{
}

Test::AMD_TestIntf_checkPBSUnknown2WithGraph::~AMD_TestIntf_checkPBSUnknown2WithGraph()
{
}

Test::AMD_TestIntf_exchangePNode::~AMD_TestIntf_exchangePNode()
{
}

Test::AMD_TestIntf_throwBaseAsBase::~AMD_TestIntf_throwBaseAsBase()
{
}

Test::AMD_TestIntf_throwDerivedAsBase::~AMD_TestIntf_throwDerivedAsBase()
{
}

Test::AMD_TestIntf_throwDerivedAsDerived::~AMD_TestIntf_throwDerivedAsDerived()
{
}

Test::AMD_TestIntf_throwUnknownDerivedAsBase::~AMD_TestIntf_throwUnknownDerivedAsBase()
{
}

Test::AMD_TestIntf_throwPreservedException::~AMD_TestIntf_throwPreservedException()
{
}

Test::AMD_TestIntf_useForward::~AMD_TestIntf_useForward()
{
}

Test::AMD_TestIntf_shutdown::~AMD_TestIntf_shutdown()
{
}

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_SBaseAsObject::AMD_TestIntf_SBaseAsObject(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_SBaseAsObject::ice_response(const ::Ice::ValuePtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_SBaseAsSBase::AMD_TestIntf_SBaseAsSBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_SBaseAsSBase::ice_response(const ::Test::SBasePtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_SBSKnownDerivedAsSBase::AMD_TestIntf_SBSKnownDerivedAsSBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_SBSKnownDerivedAsSBase::ice_response(const ::Test::SBasePtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived::AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived::ice_response(const ::Test::SBSKnownDerivedPtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_SBSUnknownDerivedAsSBase::AMD_TestIntf_SBSUnknownDerivedAsSBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_SBSUnknownDerivedAsSBase::ice_response(const ::Test::SBasePtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact::AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact::ice_response(const ::Test::SBasePtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_SUnknownAsObject::AMD_TestIntf_SUnknownAsObject(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_SUnknownAsObject::ice_response(const ::Ice::ValuePtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_checkSUnknown::AMD_TestIntf_checkSUnknown(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_checkSUnknown::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_oneElementCycle::AMD_TestIntf_oneElementCycle(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_oneElementCycle::ice_response(const ::Test::BPtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_twoElementCycle::AMD_TestIntf_twoElementCycle(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_twoElementCycle::ice_response(const ::Test::BPtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_D1AsB::AMD_TestIntf_D1AsB(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_D1AsB::ice_response(const ::Test::BPtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_D1AsD1::AMD_TestIntf_D1AsD1(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_D1AsD1::ice_response(const ::Test::D1Ptr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_D2AsB::AMD_TestIntf_D2AsB(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_D2AsB::ice_response(const ::Test::BPtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_paramTest1::AMD_TestIntf_paramTest1(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_paramTest1::ice_response(const ::Test::BPtr& p1, const ::Test::BPtr& p2)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(p1);
    ostr->write(p2);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_paramTest2::AMD_TestIntf_paramTest2(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_paramTest2::ice_response(const ::Test::BPtr& p2, const ::Test::BPtr& p1)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(p2);
    ostr->write(p1);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_paramTest3::AMD_TestIntf_paramTest3(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_paramTest3::ice_response(const ::Test::BPtr& ret, const ::Test::BPtr& p1, const ::Test::BPtr& p2)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(p1);
    ostr->write(p2);
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_paramTest4::AMD_TestIntf_paramTest4(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_paramTest4::ice_response(const ::Test::BPtr& ret, const ::Test::BPtr& p)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(p);
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_returnTest1::AMD_TestIntf_returnTest1(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_returnTest1::ice_response(const ::Test::BPtr& ret, const ::Test::BPtr& p1, const ::Test::BPtr& p2)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(p1);
    ostr->write(p2);
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_returnTest2::AMD_TestIntf_returnTest2(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_returnTest2::ice_response(const ::Test::BPtr& ret, const ::Test::BPtr& p2, const ::Test::BPtr& p1)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(p2);
    ostr->write(p1);
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_returnTest3::AMD_TestIntf_returnTest3(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_returnTest3::ice_response(const ::Test::BPtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_sequenceTest::AMD_TestIntf_sequenceTest(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_sequenceTest::ice_response(const ::Test::SS3& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_dictionaryTest::AMD_TestIntf_dictionaryTest(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_dictionaryTest::ice_response(const ::Test::BDict& ret, const ::Test::BDict& bout)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(bout);
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_exchangePBase::AMD_TestIntf_exchangePBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_exchangePBase::ice_response(const ::Test::PBasePtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_PBSUnknownAsPreserved::AMD_TestIntf_PBSUnknownAsPreserved(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_PBSUnknownAsPreserved::ice_response(const ::Test::PreservedPtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_checkPBSUnknown::AMD_TestIntf_checkPBSUnknown(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_checkPBSUnknown::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_PBSUnknownAsPreservedWithGraph::AMD_TestIntf_PBSUnknownAsPreservedWithGraph(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_PBSUnknownAsPreservedWithGraph::ice_response(const ::Test::PreservedPtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_checkPBSUnknownWithGraph::AMD_TestIntf_checkPBSUnknownWithGraph(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_checkPBSUnknownWithGraph::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_PBSUnknown2AsPreservedWithGraph::AMD_TestIntf_PBSUnknown2AsPreservedWithGraph(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_PBSUnknown2AsPreservedWithGraph::ice_response(const ::Test::PreservedPtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_checkPBSUnknown2WithGraph::AMD_TestIntf_checkPBSUnknown2WithGraph(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_checkPBSUnknown2WithGraph::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_exchangePNode::AMD_TestIntf_exchangePNode(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_exchangePNode::ice_response(const ::Test::PNodePtr& ret)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_throwBaseAsBase::AMD_TestIntf_throwBaseAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_throwBaseAsBase::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_throwDerivedAsBase::AMD_TestIntf_throwDerivedAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_throwDerivedAsBase::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_throwDerivedAsDerived::AMD_TestIntf_throwDerivedAsDerived(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_throwDerivedAsDerived::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_throwUnknownDerivedAsBase::AMD_TestIntf_throwUnknownDerivedAsBase(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_throwUnknownDerivedAsBase::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_throwPreservedException::AMD_TestIntf_throwPreservedException(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_throwPreservedException::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_useForward::AMD_TestIntf_useForward(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_useForward::ice_response(const ::Test::ForwardPtr& f)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(f);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_shutdown::AMD_TestIntf_shutdown(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_shutdown::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(TestIntf* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< TestIntf>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new TestIntf;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_SBaseAsObject(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBaseAsObject_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_SBaseAsObject_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_SBaseAsObject_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_SBaseAsObject_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::ValuePtr
IceProxy::Test::TestIntf::end_SBaseAsObject(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_SBaseAsObject_name);
    ::Ice::ValuePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_SBaseAsSBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBaseAsSBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_SBaseAsSBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_SBaseAsSBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_SBaseAsSBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SBasePtr
IceProxy::Test::TestIntf::end_SBaseAsSBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_SBaseAsSBase_name);
    ::Test::SBasePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_SBSKnownDerivedAsSBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SBasePtr
IceProxy::Test::TestIntf::end_SBSKnownDerivedAsSBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name);
    ::Test::SBasePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SBSKnownDerivedPtr
IceProxy::Test::TestIntf::end_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name);
    ::Test::SBSKnownDerivedPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_SBSUnknownDerivedAsSBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SBasePtr
IceProxy::Test::TestIntf::end_SBSUnknownDerivedAsSBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name);
    ::Test::SBasePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SBasePtr
IceProxy::Test::TestIntf::end_SBSUnknownDerivedAsSBaseCompact(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name);
    ::Test::SBasePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_SUnknownAsObject(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SUnknownAsObject_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_SUnknownAsObject_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_SUnknownAsObject_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_SUnknownAsObject_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::ValuePtr
IceProxy::Test::TestIntf::end_SUnknownAsObject(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_SUnknownAsObject_name);
    ::Ice::ValuePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_checkSUnknown(const ::Ice::ValuePtr& iceP_o, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_checkSUnknown_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_checkSUnknown_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_o);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_checkSUnknown_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_checkSUnknown(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_TestIntf_checkSUnknown_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_oneElementCycle(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_oneElementCycle_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_oneElementCycle_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_oneElementCycle_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_oneElementCycle_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_oneElementCycle(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_oneElementCycle_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_twoElementCycle(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_twoElementCycle_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_twoElementCycle_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_twoElementCycle_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_twoElementCycle_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_twoElementCycle(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_twoElementCycle_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_D1AsB(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_D1AsB_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_D1AsB_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_D1AsB_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_D1AsB_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_D1AsB(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_D1AsB_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_D1AsD1(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_D1AsD1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_D1AsD1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_D1AsD1_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_D1AsD1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::D1Ptr
IceProxy::Test::TestIntf::end_D1AsD1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_D1AsD1_name);
    ::Test::D1Ptr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_D2AsB(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_D2AsB_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_D2AsB_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_D2AsB_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_D2AsB_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_D2AsB(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_D2AsB_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_paramTest1(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_paramTest1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_paramTest1_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_paramTest1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_paramTest1(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest1_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->readPendingValues();
    result->_endReadParams();
}

void IceProxy::Test::TestIntf::_iceI_end_paramTest1(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest1_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_paramTest2(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_paramTest2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_paramTest2_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_paramTest2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_paramTest2(::Test::BPtr& iceP_p2, ::Test::BPtr& iceP_p1, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(iceP_p1);
    istr->readPendingValues();
    result->_endReadParams();
}

void IceProxy::Test::TestIntf::_iceI_end_paramTest2(::Test::BPtr& iceP_p2, ::Test::BPtr& iceP_p1, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(iceP_p1);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_paramTest3(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest3_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_paramTest3_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_paramTest3_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_paramTest3_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_paramTest3(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest3_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_paramTest3(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, ::Test::BPtr& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest3_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_paramTest4(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest4_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_paramTest4_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_paramTest4_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_paramTest4_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_paramTest4(::Test::BPtr& iceP_p, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest4_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_paramTest4(::Test::BPtr& iceP_p, ::Test::BPtr& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest4_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_returnTest1(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_returnTest1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_returnTest1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_returnTest1_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_returnTest1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_returnTest1(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_returnTest1_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_returnTest1(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, ::Test::BPtr& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_returnTest1_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_returnTest2(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_returnTest2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_returnTest2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_returnTest2_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_returnTest2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_returnTest2(::Test::BPtr& iceP_p2, ::Test::BPtr& iceP_p1, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_returnTest2_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(iceP_p1);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_returnTest2(::Test::BPtr& iceP_p2, ::Test::BPtr& iceP_p1, ::Test::BPtr& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_returnTest2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(iceP_p1);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_returnTest3(const ::Test::BPtr& iceP_p1, const ::Test::BPtr& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_returnTest3_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_returnTest3_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_returnTest3_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_returnTest3_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_returnTest3(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_returnTest3_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_sequenceTest(const ::Test::SS1Ptr& iceP_p1, const ::Test::SS2Ptr& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_sequenceTest_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_sequenceTest_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_sequenceTest_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_sequenceTest_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SS3
IceProxy::Test::TestIntf::end_sequenceTest(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_sequenceTest_name);
    ::Test::SS3 ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_dictionaryTest(const ::Test::BDict& iceP_bin, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_dictionaryTest_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_dictionaryTest_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_dictionaryTest_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_bin);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_dictionaryTest_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BDict
IceProxy::Test::TestIntf::end_dictionaryTest(::Test::BDict& iceP_bout, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_dictionaryTest_name);
    ::Test::BDict ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_bout);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_dictionaryTest(::Test::BDict& iceP_bout, ::Test::BDict& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_dictionaryTest_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_bout);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_exchangePBase(const ::Test::PBasePtr& iceP_pb, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_exchangePBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_exchangePBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_exchangePBase_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_pb);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_exchangePBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::PBasePtr
IceProxy::Test::TestIntf::end_exchangePBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_exchangePBase_name);
    ::Test::PBasePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_PBSUnknownAsPreserved(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_PBSUnknownAsPreserved_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_PBSUnknownAsPreserved_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_PBSUnknownAsPreserved_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_PBSUnknownAsPreserved_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::PreservedPtr
IceProxy::Test::TestIntf::end_PBSUnknownAsPreserved(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_PBSUnknownAsPreserved_name);
    ::Test::PreservedPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_checkPBSUnknown(const ::Test::PreservedPtr& iceP_p, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_checkPBSUnknown_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_checkPBSUnknown_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_p);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_checkPBSUnknown_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_checkPBSUnknown(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_TestIntf_checkPBSUnknown_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_PBSUnknownAsPreservedWithGraph(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::PreservedPtr
IceProxy::Test::TestIntf::end_PBSUnknownAsPreservedWithGraph(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name);
    ::Test::PreservedPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& iceP_p, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_checkPBSUnknownWithGraph_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_checkPBSUnknownWithGraph_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_p);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_checkPBSUnknownWithGraph_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_checkPBSUnknownWithGraph(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_TestIntf_checkPBSUnknownWithGraph_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::PreservedPtr
IceProxy::Test::TestIntf::end_PBSUnknown2AsPreservedWithGraph(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name);
    ::Test::PreservedPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& iceP_p, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_checkPBSUnknown2WithGraph_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_checkPBSUnknown2WithGraph_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_p);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_checkPBSUnknown2WithGraph_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_checkPBSUnknown2WithGraph(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_TestIntf_checkPBSUnknown2WithGraph_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_exchangePNode(const ::Test::PNodePtr& iceP_pn, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_exchangePNode_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_exchangePNode_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_exchangePNode_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_pn);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_exchangePNode_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::PNodePtr
IceProxy::Test::TestIntf::end_exchangePNode(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_exchangePNode_name);
    ::Test::PNodePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_throwBaseAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwBaseAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_throwBaseAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_throwBaseAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_throwBaseAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_throwBaseAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_throwBaseAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::BaseException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_throwDerivedAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwDerivedAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_throwDerivedAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_throwDerivedAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_throwDerivedAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_throwDerivedAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_throwDerivedAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::BaseException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_throwDerivedAsDerived(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwDerivedAsDerived_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_throwDerivedAsDerived_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_throwDerivedAsDerived_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_throwDerivedAsDerived_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_throwDerivedAsDerived(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_throwDerivedAsDerived_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::DerivedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_throwUnknownDerivedAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwUnknownDerivedAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_throwUnknownDerivedAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_throwUnknownDerivedAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_throwUnknownDerivedAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_throwUnknownDerivedAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_throwUnknownDerivedAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::BaseException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_throwPreservedException(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwPreservedException_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_throwPreservedException_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_throwPreservedException_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_throwPreservedException_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_throwPreservedException(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_throwPreservedException_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::PreservedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_useForward(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_useForward_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_useForward_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_useForward_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_useForward_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_useForward(::Test::ForwardPtr& iceP_f, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_useForward_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_f);
    istr->readPendingValues();
    result->_endReadParams();
}

void IceProxy::Test::TestIntf::_iceI_end_useForward(::Test::ForwardPtr& iceP_f, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_useForward_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_f);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_shutdown(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_shutdown_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_shutdown_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_shutdown_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_shutdown(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_TestIntf_shutdown_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::TestIntf::_newInstance() const
{
    return new TestIntf;
}
/// \endcond

const ::std::string&
IceProxy::Test::TestIntf::ice_staticId()
{
    return ::Test::TestIntf::ice_staticId();
}

Test::TestIntf::~TestIntf()
{
}

namespace
{
const ::std::string iceC_Test_TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};

}

bool
Test::TestIntf::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_TestIntf_ids, iceC_Test_TestIntf_ids + 2, s);
}

::std::vector< ::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_TestIntf_ids[0], &iceC_Test_TestIntf_ids[2]);
}

const ::std::string&
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBaseAsObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->SBaseAsObject_async(new IceAsync::Test::AMD_TestIntf_SBaseAsObject(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBaseAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->SBaseAsSBase_async(new IceAsync::Test::AMD_TestIntf_SBaseAsSBase(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSKnownDerivedAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->SBSKnownDerivedAsSBase_async(new IceAsync::Test::AMD_TestIntf_SBSKnownDerivedAsSBase(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSKnownDerivedAsSBSKnownDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->SBSKnownDerivedAsSBSKnownDerived_async(new IceAsync::Test::AMD_TestIntf_SBSKnownDerivedAsSBSKnownDerived(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSUnknownDerivedAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->SBSUnknownDerivedAsSBase_async(new IceAsync::Test::AMD_TestIntf_SBSUnknownDerivedAsSBase(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSUnknownDerivedAsSBaseCompact(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::CompactFormat);
    this->SBSUnknownDerivedAsSBaseCompact_async(new IceAsync::Test::AMD_TestIntf_SBSUnknownDerivedAsSBaseCompact(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SUnknownAsObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->SUnknownAsObject_async(new IceAsync::Test::AMD_TestIntf_SUnknownAsObject(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkSUnknown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::ValuePtr iceP_o;
    istr->read(iceP_o);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->checkSUnknown_async(new IceAsync::Test::AMD_TestIntf_checkSUnknown(inS), iceP_o, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_oneElementCycle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->oneElementCycle_async(new IceAsync::Test::AMD_TestIntf_oneElementCycle(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_twoElementCycle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->twoElementCycle_async(new IceAsync::Test::AMD_TestIntf_twoElementCycle(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D1AsB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->D1AsB_async(new IceAsync::Test::AMD_TestIntf_D1AsB(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D1AsD1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->D1AsD1_async(new IceAsync::Test::AMD_TestIntf_D1AsD1(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D2AsB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->D2AsB_async(new IceAsync::Test::AMD_TestIntf_D2AsB(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->paramTest1_async(new IceAsync::Test::AMD_TestIntf_paramTest1(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->paramTest2_async(new IceAsync::Test::AMD_TestIntf_paramTest2(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest3(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->paramTest3_async(new IceAsync::Test::AMD_TestIntf_paramTest3(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest4(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->paramTest4_async(new IceAsync::Test::AMD_TestIntf_paramTest4(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->returnTest1_async(new IceAsync::Test::AMD_TestIntf_returnTest1(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->returnTest2_async(new IceAsync::Test::AMD_TestIntf_returnTest2(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest3(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    BPtr iceP_p1;
    BPtr iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->returnTest3_async(new IceAsync::Test::AMD_TestIntf_returnTest3(inS), iceP_p1, iceP_p2, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_sequenceTest(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SS1Ptr iceP_p1;
    SS2Ptr iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->sequenceTest_async(new IceAsync::Test::AMD_TestIntf_sequenceTest(inS), iceP_p1, iceP_p2, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_dictionaryTest(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    BDict iceP_bin;
    istr->read(iceP_bin);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->dictionaryTest_async(new IceAsync::Test::AMD_TestIntf_dictionaryTest(inS), iceP_bin, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_exchangePBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PBasePtr iceP_pb;
    istr->read(iceP_pb);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->exchangePBase_async(new IceAsync::Test::AMD_TestIntf_exchangePBase(inS), iceP_pb, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknownAsPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->PBSUnknownAsPreserved_async(new IceAsync::Test::AMD_TestIntf_PBSUnknownAsPreserved(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PreservedPtr iceP_p;
    istr->read(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->checkPBSUnknown_async(new IceAsync::Test::AMD_TestIntf_checkPBSUnknown(inS), iceP_p, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknownAsPreservedWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->PBSUnknownAsPreservedWithGraph_async(new IceAsync::Test::AMD_TestIntf_PBSUnknownAsPreservedWithGraph(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknownWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PreservedPtr iceP_p;
    istr->read(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->checkPBSUnknownWithGraph_async(new IceAsync::Test::AMD_TestIntf_checkPBSUnknownWithGraph(inS), iceP_p, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknown2AsPreservedWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->PBSUnknown2AsPreservedWithGraph_async(new IceAsync::Test::AMD_TestIntf_PBSUnknown2AsPreservedWithGraph(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknown2WithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PreservedPtr iceP_p;
    istr->read(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->checkPBSUnknown2WithGraph_async(new IceAsync::Test::AMD_TestIntf_checkPBSUnknown2WithGraph(inS), iceP_p, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_exchangePNode(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PNodePtr iceP_pn;
    istr->read(iceP_pn);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->exchangePNode_async(new IceAsync::Test::AMD_TestIntf_exchangePNode(inS), iceP_pn, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwBaseAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->throwBaseAsBase_async(new IceAsync::Test::AMD_TestIntf_throwBaseAsBase(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->throwDerivedAsBase_async(new IceAsync::Test::AMD_TestIntf_throwDerivedAsBase(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwDerivedAsDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->throwDerivedAsDerived_async(new IceAsync::Test::AMD_TestIntf_throwDerivedAsDerived(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwUnknownDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->throwUnknownDerivedAsBase_async(new IceAsync::Test::AMD_TestIntf_throwUnknownDerivedAsBase(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwPreservedException(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->throwPreservedException_async(new IceAsync::Test::AMD_TestIntf_throwPreservedException(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_useForward(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->useForward_async(new IceAsync::Test::AMD_TestIntf_useForward(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->shutdown_async(new IceAsync::Test::AMD_TestIntf_shutdown(inS), current);
    return false;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_TestIntf_all[] =
{
    "D1AsB",
    "D1AsD1",
    "D2AsB",
    "PBSUnknown2AsPreservedWithGraph",
    "PBSUnknownAsPreserved",
    "PBSUnknownAsPreservedWithGraph",
    "SBSKnownDerivedAsSBSKnownDerived",
    "SBSKnownDerivedAsSBase",
    "SBSUnknownDerivedAsSBase",
    "SBSUnknownDerivedAsSBaseCompact",
    "SBaseAsObject",
    "SBaseAsSBase",
    "SUnknownAsObject",
    "checkPBSUnknown",
    "checkPBSUnknown2WithGraph",
    "checkPBSUnknownWithGraph",
    "checkSUnknown",
    "dictionaryTest",
    "exchangePBase",
    "exchangePNode",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "oneElementCycle",
    "paramTest1",
    "paramTest2",
    "paramTest3",
    "paramTest4",
    "returnTest1",
    "returnTest2",
    "returnTest3",
    "sequenceTest",
    "shutdown",
    "throwBaseAsBase",
    "throwDerivedAsBase",
    "throwDerivedAsDerived",
    "throwPreservedException",
    "throwUnknownDerivedAsBase",
    "twoElementCycle",
    "useForward"
};

}

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_TestIntf_all, iceC_Test_TestIntf_all + 41, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_TestIntf_all)
    {
        case 0:
        {
            return _iceD_D1AsB(in, current);
        }
        case 1:
        {
            return _iceD_D1AsD1(in, current);
        }
        case 2:
        {
            return _iceD_D2AsB(in, current);
        }
        case 3:
        {
            return _iceD_PBSUnknown2AsPreservedWithGraph(in, current);
        }
        case 4:
        {
            return _iceD_PBSUnknownAsPreserved(in, current);
        }
        case 5:
        {
            return _iceD_PBSUnknownAsPreservedWithGraph(in, current);
        }
        case 6:
        {
            return _iceD_SBSKnownDerivedAsSBSKnownDerived(in, current);
        }
        case 7:
        {
            return _iceD_SBSKnownDerivedAsSBase(in, current);
        }
        case 8:
        {
            return _iceD_SBSUnknownDerivedAsSBase(in, current);
        }
        case 9:
        {
            return _iceD_SBSUnknownDerivedAsSBaseCompact(in, current);
        }
        case 10:
        {
            return _iceD_SBaseAsObject(in, current);
        }
        case 11:
        {
            return _iceD_SBaseAsSBase(in, current);
        }
        case 12:
        {
            return _iceD_SUnknownAsObject(in, current);
        }
        case 13:
        {
            return _iceD_checkPBSUnknown(in, current);
        }
        case 14:
        {
            return _iceD_checkPBSUnknown2WithGraph(in, current);
        }
        case 15:
        {
            return _iceD_checkPBSUnknownWithGraph(in, current);
        }
        case 16:
        {
            return _iceD_checkSUnknown(in, current);
        }
        case 17:
        {
            return _iceD_dictionaryTest(in, current);
        }
        case 18:
        {
            return _iceD_exchangePBase(in, current);
        }
        case 19:
        {
            return _iceD_exchangePNode(in, current);
        }
        case 20:
        {
            return _iceD_ice_id(in, current);
        }
        case 21:
        {
            return _iceD_ice_ids(in, current);
        }
        case 22:
        {
            return _iceD_ice_isA(in, current);
        }
        case 23:
        {
            return _iceD_ice_ping(in, current);
        }
        case 24:
        {
            return _iceD_oneElementCycle(in, current);
        }
        case 25:
        {
            return _iceD_paramTest1(in, current);
        }
        case 26:
        {
            return _iceD_paramTest2(in, current);
        }
        case 27:
        {
            return _iceD_paramTest3(in, current);
        }
        case 28:
        {
            return _iceD_paramTest4(in, current);
        }
        case 29:
        {
            return _iceD_returnTest1(in, current);
        }
        case 30:
        {
            return _iceD_returnTest2(in, current);
        }
        case 31:
        {
            return _iceD_returnTest3(in, current);
        }
        case 32:
        {
            return _iceD_sequenceTest(in, current);
        }
        case 33:
        {
            return _iceD_shutdown(in, current);
        }
        case 34:
        {
            return _iceD_throwBaseAsBase(in, current);
        }
        case 35:
        {
            return _iceD_throwDerivedAsBase(in, current);
        }
        case 36:
        {
            return _iceD_throwDerivedAsDerived(in, current);
        }
        case 37:
        {
            return _iceD_throwPreservedException(in, current);
        }
        case 38:
        {
            return _iceD_throwUnknownDerivedAsBase(in, current);
        }
        case 39:
        {
            return _iceD_twoElementCycle(in, current);
        }
        case 40:
        {
            return _iceD_useForward(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::SBase::~SBase()
{
}
::Ice::ValuePtr
Test::SBase::ice_clone() const
{
    ::Ice::Value* p = new SBase(*this);
    return p;
}

std::string
Test::SBase::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::SBase::ice_staticId()
{
    static const ::std::string typeId = "::Test::SBase";
    return typeId;
}

/// \cond STREAM
void
Test::SBase::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< SBase, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::SBase::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SBase, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SBase> iceC_Test_SBase_init("::Test::SBase");
}

::Ice::ValueFactoryPtr
Test::SBase::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SBase::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(SBasePtr& handle, const ::Ice::ValuePtr& v)
{
    handle = SBasePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SBase::ice_staticId(), v);
    }
}
/// \endcond

Test::SBSKnownDerived::~SBSKnownDerived()
{
}
::Ice::ValuePtr
Test::SBSKnownDerived::ice_clone() const
{
    ::Ice::Value* p = new SBSKnownDerived(*this);
    return p;
}

std::string
Test::SBSKnownDerived::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::SBSKnownDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::SBSKnownDerived";
    return typeId;
}

/// \cond STREAM
void
Test::SBSKnownDerived::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< SBSKnownDerived, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    SBase::_iceWriteImpl(ostr);
}

void
Test::SBSKnownDerived::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SBSKnownDerived, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    SBase::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SBSKnownDerived> iceC_Test_SBSKnownDerived_init("::Test::SBSKnownDerived");
}

::Ice::ValueFactoryPtr
Test::SBSKnownDerived::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SBSKnownDerived::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(SBSKnownDerivedPtr& handle, const ::Ice::ValuePtr& v)
{
    handle = SBSKnownDerivedPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SBSKnownDerived::ice_staticId(), v);
    }
}
/// \endcond

Test::B::~B()
{
}
::Ice::ValuePtr
Test::B::ice_clone() const
{
    ::Ice::Value* p = new B(*this);
    return p;
}

std::string
Test::B::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::B::ice_staticId()
{
    static const ::std::string typeId = "::Test::B";
    return typeId;
}

/// \cond STREAM
void
Test::B::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< B, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::B::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< B, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::B> iceC_Test_B_init("::Test::B");
}

::Ice::ValueFactoryPtr
Test::B::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::B::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(BPtr& handle, const ::Ice::ValuePtr& v)
{
    handle = BPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(B::ice_staticId(), v);
    }
}
/// \endcond

Test::D1::~D1()
{
}
::Ice::ValuePtr
Test::D1::ice_clone() const
{
    ::Ice::Value* p = new D1(*this);
    return p;
}

std::string
Test::D1::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::D1::ice_staticId()
{
    static const ::std::string typeId = "::Test::D1";
    return typeId;
}

/// \cond STREAM
void
Test::D1::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< D1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    B::_iceWriteImpl(ostr);
}

void
Test::D1::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< D1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    B::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::D1> iceC_Test_D1_init("::Test::D1");
}

::Ice::ValueFactoryPtr
Test::D1::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::D1::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(D1Ptr& handle, const ::Ice::ValuePtr& v)
{
    handle = D1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(D1::ice_staticId(), v);
    }
}
/// \endcond

Test::SS1::~SS1()
{
}
::Ice::ValuePtr
Test::SS1::ice_clone() const
{
    ::Ice::Value* p = new SS1(*this);
    return p;
}

std::string
Test::SS1::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::SS1::ice_staticId()
{
    static const ::std::string typeId = "::Test::SS1";
    return typeId;
}

/// \cond STREAM
void
Test::SS1::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< SS1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::SS1::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SS1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SS1> iceC_Test_SS1_init("::Test::SS1");
}

::Ice::ValueFactoryPtr
Test::SS1::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SS1::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(SS1Ptr& handle, const ::Ice::ValuePtr& v)
{
    handle = SS1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SS1::ice_staticId(), v);
    }
}
/// \endcond

Test::SS2::~SS2()
{
}
::Ice::ValuePtr
Test::SS2::ice_clone() const
{
    ::Ice::Value* p = new SS2(*this);
    return p;
}

std::string
Test::SS2::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::SS2::ice_staticId()
{
    static const ::std::string typeId = "::Test::SS2";
    return typeId;
}

/// \cond STREAM
void
Test::SS2::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< SS2, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::SS2::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SS2, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SS2> iceC_Test_SS2_init("::Test::SS2");
}

::Ice::ValueFactoryPtr
Test::SS2::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SS2::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(SS2Ptr& handle, const ::Ice::ValuePtr& v)
{
    handle = SS2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SS2::ice_staticId(), v);
    }
}
/// \endcond

Test::PBase::~PBase()
{
}
::Ice::ValuePtr
Test::PBase::ice_clone() const
{
    ::Ice::Value* p = new PBase(*this);
    return p;
}

std::string
Test::PBase::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::PBase::ice_staticId()
{
    static const ::std::string typeId = "::Test::PBase";
    return typeId;
}

/// \cond STREAM
void
Test::PBase::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< PBase, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::PBase::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< PBase, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::PBase> iceC_Test_PBase_init("::Test::PBase");
}

::Ice::ValueFactoryPtr
Test::PBase::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::PBase::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(PBasePtr& handle, const ::Ice::ValuePtr& v)
{
    handle = PBasePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(PBase::ice_staticId(), v);
    }
}
/// \endcond

Test::Preserved::~Preserved()
{
}
::Ice::ValuePtr
Test::Preserved::ice_clone() const
{
    ::Ice::Value* p = new Preserved(*this);
    return p;
}

std::string
Test::Preserved::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::Preserved::ice_staticId()
{
    static const ::std::string typeId = "::Test::Preserved";
    return typeId;
}

::Ice::SlicedDataPtr
Test::Preserved::ice_getSlicedData() const
{
    return _iceSlicedData;
}

void
Test::Preserved::_iceWrite(::Ice::OutputStream*ostr) const
{
    ostr->startValue(_iceSlicedData);
    _iceWriteImpl(ostr);
    ostr->endValue();
}

void
Test::Preserved::_iceRead(::Ice::InputStream* istr)
{
    istr->startValue();
    _iceReadImpl(istr);
    _iceSlicedData = istr->endValue(true);
}

/// \cond STREAM
void
Test::Preserved::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< Preserved, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    PBase::_iceWriteImpl(ostr);
}

void
Test::Preserved::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Preserved, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    PBase::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Preserved> iceC_Test_Preserved_init("::Test::Preserved");
}

::Ice::ValueFactoryPtr
Test::Preserved::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Preserved::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(PreservedPtr& handle, const ::Ice::ValuePtr& v)
{
    handle = PreservedPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Preserved::ice_staticId(), v);
    }
}
/// \endcond

Test::PDerived::~PDerived()
{
}
::Ice::ValuePtr
Test::PDerived::ice_clone() const
{
    ::Ice::Value* p = new PDerived(*this);
    return p;
}

std::string
Test::PDerived::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::PDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::PDerived";
    return typeId;
}

/// \cond STREAM
void
Test::PDerived::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< PDerived, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    Preserved::_iceWriteImpl(ostr);
}

void
Test::PDerived::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< PDerived, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    Preserved::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::PDerived> iceC_Test_PDerived_init("::Test::PDerived");
}

::Ice::ValueFactoryPtr
Test::PDerived::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::PDerived::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(PDerivedPtr& handle, const ::Ice::ValuePtr& v)
{
    handle = PDerivedPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(PDerived::ice_staticId(), v);
    }
}
/// \endcond

Test::PNode::~PNode()
{
}
::Ice::ValuePtr
Test::PNode::ice_clone() const
{
    ::Ice::Value* p = new PNode(*this);
    return p;
}

std::string
Test::PNode::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::PNode::ice_staticId()
{
    static const ::std::string typeId = "::Test::PNode";
    return typeId;
}

::Ice::SlicedDataPtr
Test::PNode::ice_getSlicedData() const
{
    return _iceSlicedData;
}

void
Test::PNode::_iceWrite(::Ice::OutputStream*ostr) const
{
    ostr->startValue(_iceSlicedData);
    _iceWriteImpl(ostr);
    ostr->endValue();
}

void
Test::PNode::_iceRead(::Ice::InputStream* istr)
{
    istr->startValue();
    _iceReadImpl(istr);
    _iceSlicedData = istr->endValue(true);
}

/// \cond STREAM
void
Test::PNode::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< PNode, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::PNode::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< PNode, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::PNode> iceC_Test_PNode_init("::Test::PNode");
}

::Ice::ValueFactoryPtr
Test::PNode::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::PNode::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(PNodePtr& handle, const ::Ice::ValuePtr& v)
{
    handle = PNodePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(PNode::ice_staticId(), v);
    }
}
/// \endcond

Test::Hidden::~Hidden()
{
}
::Ice::ValuePtr
Test::Hidden::ice_clone() const
{
    ::Ice::Value* p = new Hidden(*this);
    return p;
}

std::string
Test::Hidden::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::Hidden::ice_staticId()
{
    static const ::std::string typeId = "::Test::Hidden";
    return typeId;
}

/// \cond STREAM
void
Test::Hidden::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Hidden, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Hidden::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Hidden, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Hidden> iceC_Test_Hidden_init("::Test::Hidden");
}

::Ice::ValueFactoryPtr
Test::Hidden::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Hidden::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(HiddenPtr& handle, const ::Ice::ValuePtr& v)
{
    handle = HiddenPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Hidden::ice_staticId(), v);
    }
}
/// \endcond

Test::Forward::~Forward()
{
}
::Ice::ValuePtr
Test::Forward::ice_clone() const
{
    ::Ice::Value* p = new Forward(*this);
    return p;
}

std::string
Test::Forward::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::Forward::ice_staticId()
{
    static const ::std::string typeId = "::Test::Forward";
    return typeId;
}

/// \cond STREAM
void
Test::Forward::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Forward, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Forward::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Forward, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Forward> iceC_Test_Forward_init("::Test::Forward");
}

::Ice::ValueFactoryPtr
Test::Forward::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Forward::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(ForwardPtr& handle, const ::Ice::ValuePtr& v)
{
    handle = ForwardPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Forward::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
