//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `ServerPrivateAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __ServerPrivateAMD_h__
#define __ServerPrivateAMD_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include <Ice/SlicedDataF.h>
#include <TestAMD.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class SBSUnknownDerived;
class SUnknown;
class D2;
class D4;
class MyClass;
class PSUnknown;
class PSUnknown2;

}

namespace Test
{

class UnknownDerivedException : public ::Ice::UserExceptionHelper<UnknownDerivedException, BaseException>
{
public:

    virtual ~UnknownDerivedException();

    UnknownDerivedException(const UnknownDerivedException&) = default;

    UnknownDerivedException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownDerivedException(const ::std::string& sbe, const ::std::shared_ptr<B>& pb, const ::std::string& sude, const ::std::shared_ptr<D2>& pd2) :
        ::Ice::UserExceptionHelper<UnknownDerivedException, BaseException>(sbe, pb),
        sude(sude),
        pd2(pd2)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::D2>&> ice_tuple() const
    {
        return std::tie(sbe, pb, sude, pd2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sude;
    ::std::shared_ptr<::Test::D2> pd2;
};

/// \cond INTERNAL
static UnknownDerivedException _iceS_UnknownDerivedException_init;
/// \endcond

class PSUnknownException : public ::Ice::UserExceptionHelper<PSUnknownException, PreservedException>
{
public:

    virtual ~PSUnknownException();

    PSUnknownException(const PSUnknownException&) = default;

    PSUnknownException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknownException(const ::std::shared_ptr<PSUnknown2>& p) :
        ::Ice::UserExceptionHelper<PSUnknownException, PreservedException>(),
        p(p)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::PSUnknown2>&> ice_tuple() const
    {
        return std::tie(p);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::shared_ptr<::Test::PSUnknown2> p;
};

}

namespace Test
{

class SBSUnknownDerived : public ::Ice::ValueHelper<SBSUnknownDerived, SBase>
{
public:

    virtual ~SBSUnknownDerived();

    SBSUnknownDerived() = default;

    SBSUnknownDerived(const SBSUnknownDerived&) = default;
    SBSUnknownDerived(SBSUnknownDerived&&) = default;
    SBSUnknownDerived& operator=(const SBSUnknownDerived&) = default;
    SBSUnknownDerived& operator=(SBSUnknownDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SBSUnknownDerived(const ::std::string& sb, const ::std::string& sbsud) :
        Ice::ValueHelper<SBSUnknownDerived, SBase>(sb),
        sbsud(sbsud)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(sb, sbsud);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sbsud;
};

/// \cond INTERNAL
static SBSUnknownDerived _iceS_SBSUnknownDerived_init;
/// \endcond

class SUnknown : public ::Ice::ValueHelper<SUnknown, ::Ice::Value>
{
public:

    virtual ~SUnknown();

    SUnknown() = default;

    SUnknown(const SUnknown&) = default;
    SUnknown(SUnknown&&) = default;
    SUnknown& operator=(const SUnknown&) = default;
    SUnknown& operator=(SUnknown&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SUnknown(const ::std::string& su, const ::std::shared_ptr<::Test::SUnknown>& cycle) :
        su(su),
        cycle(cycle)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::SUnknown>&> ice_tuple() const
    {
        return std::tie(su, cycle);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string su;
    ::std::shared_ptr<::Test::SUnknown> cycle;
};

class D2 : public ::Ice::ValueHelper<D2, B>
{
public:

    virtual ~D2();

    D2() = default;

    D2(const D2&) = default;
    D2(D2&&) = default;
    D2& operator=(const D2&) = default;
    D2& operator=(D2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D2(const ::std::string& sb, const ::std::shared_ptr<::Test::B>& pb, const ::std::string& sd2, const ::std::shared_ptr<::Test::B>& pd2) :
        Ice::ValueHelper<D2, B>(sb, pb),
        sd2(sd2),
        pd2(pd2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb, sd2, pd2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sd2;
    ::std::shared_ptr<::Test::B> pd2;
};

class D4 : public ::Ice::ValueHelper<D4, B>
{
public:

    virtual ~D4();

    D4() = default;

    D4(const D4&) = default;
    D4(D4&&) = default;
    D4& operator=(const D4&) = default;
    D4& operator=(D4&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D4(const ::std::string& sb, const ::std::shared_ptr<::Test::B>& pb, const ::std::shared_ptr<::Test::B>& p1, const ::std::shared_ptr<::Test::B>& p2) :
        Ice::ValueHelper<D4, B>(sb, pb),
        p1(p1),
        p2(p2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::shared_ptr<::Test::B>&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb, p1, p2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::B> p1;
    ::std::shared_ptr<::Test::B> p2;
};

class MyClass : public ::Ice::ValueHelper<MyClass, ::Ice::Value>
{
public:

    virtual ~MyClass();

    MyClass() = default;

    MyClass(const MyClass&) = default;
    MyClass(MyClass&&) = default;
    MyClass& operator=(const MyClass&) = default;
    MyClass& operator=(MyClass&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit MyClass(int i) :
        i(i)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(i);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int i;
};

class PSUnknown : public ::Ice::ValueHelper<PSUnknown, Preserved>
{
public:

    virtual ~PSUnknown();

    PSUnknown() = default;

    PSUnknown(const PSUnknown&) = default;
    PSUnknown(PSUnknown&&) = default;
    PSUnknown& operator=(const PSUnknown&) = default;
    PSUnknown& operator=(PSUnknown&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknown(int pi, const ::std::string& ps, const ::std::string& psu, const ::std::shared_ptr<::Test::PNode>& graph, const ::std::shared_ptr<::Test::MyClass>& cl) :
        Ice::ValueHelper<PSUnknown, Preserved>(pi, ps),
        psu(psu),
        graph(graph),
        cl(cl)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::string&, const ::std::shared_ptr<::Test::PNode>&, const ::std::shared_ptr<::Test::MyClass>&> ice_tuple() const
    {
        return std::tie(pi, ps, psu, graph, cl);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string psu;
    ::std::shared_ptr<::Test::PNode> graph;
    ::std::shared_ptr<::Test::MyClass> cl;
};

class PSUnknown2 : public ::Ice::ValueHelper<PSUnknown2, Preserved>
{
public:

    virtual ~PSUnknown2();

    PSUnknown2() = default;

    PSUnknown2(const PSUnknown2&) = default;
    PSUnknown2(PSUnknown2&&) = default;
    PSUnknown2& operator=(const PSUnknown2&) = default;
    PSUnknown2& operator=(PSUnknown2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknown2(int pi, const ::std::string& ps, const ::std::shared_ptr<::Test::PBase>& pb) :
        Ice::ValueHelper<PSUnknown2, Preserved>(pi, ps),
        pb(pb)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&> ice_tuple() const
    {
        return std::tie(pi, ps, pb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::PBase> pb;
};

}

namespace Test
{

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter<::Test::SBSUnknownDerived, S>
{
    static void write(S* ostr, const ::Test::SBSUnknownDerived& v)
    {
        ostr->writeAll(v.sbsud);
    }
};

template<typename S>
struct StreamReader<::Test::SBSUnknownDerived, S>
{
    static void read(S* istr, ::Test::SBSUnknownDerived& v)
    {
        istr->readAll(v.sbsud);
    }
};

template<typename S>
struct StreamReader<::Test::SUnknown, S>
{
    static void read(S* istr, ::Test::SUnknown& v)
    {
        istr->readAll(v.su, v.cycle);
    }
};

template<typename S>
struct StreamWriter<::Test::D2, S>
{
    static void write(S* ostr, const ::Test::D2& v)
    {
        ostr->writeAll(v.sd2, v.pd2);
    }
};

template<typename S>
struct StreamReader<::Test::D2, S>
{
    static void read(S* istr, ::Test::D2& v)
    {
        istr->readAll(v.sd2, v.pd2);
    }
};

template<typename S>
struct StreamWriter<::Test::D4, S>
{
    static void write(S* ostr, const ::Test::D4& v)
    {
        ostr->writeAll(v.p1, v.p2);
    }
};

template<typename S>
struct StreamReader<::Test::D4, S>
{
    static void read(S* istr, ::Test::D4& v)
    {
        istr->readAll(v.p1, v.p2);
    }
};

template<typename S>
struct StreamWriter<::Test::UnknownDerivedException, S>
{
    static void write(S* ostr, const ::Test::UnknownDerivedException& v)
    {
        ostr->writeAll(v.sude, v.pd2);
    }
};

template<typename S>
struct StreamReader<::Test::UnknownDerivedException, S>
{
    static void read(S* istr, ::Test::UnknownDerivedException& v)
    {
        istr->readAll(v.sude, v.pd2);
    }
};

template<typename S>
struct StreamReader<::Test::MyClass, S>
{
    static void read(S* istr, ::Test::MyClass& v)
    {
        istr->readAll(v.i);
    }
};

template<typename S>
struct StreamWriter<::Test::PSUnknown, S>
{
    static void write(S* ostr, const ::Test::PSUnknown& v)
    {
        ostr->writeAll(v.psu, v.graph, v.cl);
    }
};

template<typename S>
struct StreamReader<::Test::PSUnknown, S>
{
    static void read(S* istr, ::Test::PSUnknown& v)
    {
        istr->readAll(v.psu, v.graph, v.cl);
    }
};

template<typename S>
struct StreamWriter<::Test::PSUnknown2, S>
{
    static void write(S* ostr, const ::Test::PSUnknown2& v)
    {
        ostr->writeAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::PSUnknown2, S>
{
    static void read(S* istr, ::Test::PSUnknown2& v)
    {
        istr->readAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::PSUnknownException, S>
{
    static void read(S* istr, ::Test::PSUnknownException& v)
    {
        istr->readAll(v.p);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using SBSUnknownDerivedPtr = ::std::shared_ptr<SBSUnknownDerived>;

using SUnknownPtr = ::std::shared_ptr<SUnknown>;

using D2Ptr = ::std::shared_ptr<D2>;

using D4Ptr = ::std::shared_ptr<D4>;

using MyClassPtr = ::std::shared_ptr<MyClass>;

using PSUnknownPtr = ::std::shared_ptr<PSUnknown>;

using PSUnknown2Ptr = ::std::shared_ptr<PSUnknown2>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class SBSUnknownDerived;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SBSUnknownDerived>&);
::IceProxy::Ice::Object* upCast(SBSUnknownDerived*);
/// \endcond

class SUnknown;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SUnknown>&);
::IceProxy::Ice::Object* upCast(SUnknown*);
/// \endcond

class D2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< D2>&);
::IceProxy::Ice::Object* upCast(D2*);
/// \endcond

class D4;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< D4>&);
::IceProxy::Ice::Object* upCast(D4*);
/// \endcond

class MyClass;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< MyClass>&);
::IceProxy::Ice::Object* upCast(MyClass*);
/// \endcond

class PSUnknown;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< PSUnknown>&);
::IceProxy::Ice::Object* upCast(PSUnknown*);
/// \endcond

class PSUnknown2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< PSUnknown2>&);
::IceProxy::Ice::Object* upCast(PSUnknown2*);
/// \endcond

}

}

namespace Test
{

class SBSUnknownDerived;
/// \cond INTERNAL
::Ice::Object* upCast(SBSUnknownDerived*);
/// \endcond
typedef ::IceInternal::Handle< SBSUnknownDerived> SBSUnknownDerivedPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SBSUnknownDerived> SBSUnknownDerivedPrx;
typedef SBSUnknownDerivedPrx SBSUnknownDerivedPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SBSUnknownDerivedPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class SUnknown;
/// \cond INTERNAL
::Ice::Object* upCast(SUnknown*);
/// \endcond
typedef ::IceInternal::Handle< SUnknown> SUnknownPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SUnknown> SUnknownPrx;
typedef SUnknownPrx SUnknownPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SUnknownPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class D2;
/// \cond INTERNAL
::Ice::Object* upCast(D2*);
/// \endcond
typedef ::IceInternal::Handle< D2> D2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::D2> D2Prx;
typedef D2Prx D2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(D2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class D4;
/// \cond INTERNAL
::Ice::Object* upCast(D4*);
/// \endcond
typedef ::IceInternal::Handle< D4> D4Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::D4> D4Prx;
typedef D4Prx D4PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(D4Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class MyClass;
/// \cond INTERNAL
::Ice::Object* upCast(MyClass*);
/// \endcond
typedef ::IceInternal::Handle< MyClass> MyClassPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MyClass> MyClassPrx;
typedef MyClassPrx MyClassPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(MyClassPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class PSUnknown;
/// \cond INTERNAL
::Ice::Object* upCast(PSUnknown*);
/// \endcond
typedef ::IceInternal::Handle< PSUnknown> PSUnknownPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::PSUnknown> PSUnknownPrx;
typedef PSUnknownPrx PSUnknownPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(PSUnknownPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class PSUnknown2;
/// \cond INTERNAL
::Ice::Object* upCast(PSUnknown2*);
/// \endcond
typedef ::IceInternal::Handle< PSUnknown2> PSUnknown2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::PSUnknown2> PSUnknown2Prx;
typedef PSUnknown2Prx PSUnknown2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(PSUnknown2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Test
{

class UnknownDerivedException : public BaseException
{
public:

    UnknownDerivedException() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownDerivedException(const ::std::string& sbe, const BPtr& pb, const ::std::string& sude, const D2Ptr& pd2);

#ifdef ICE_CPP11_COMPILER
    UnknownDerivedException(const UnknownDerivedException&) = default;
    virtual ~UnknownDerivedException();
#else
    virtual ~UnknownDerivedException() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual UnknownDerivedException* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string sude;
    ::Test::D2Ptr pd2;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
static UnknownDerivedException _iceS_UnknownDerivedException_init;
/// \endcond

class PSUnknownException : public PreservedException
{
public:

    PSUnknownException() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    explicit PSUnknownException(const PSUnknown2Ptr& p);

#ifdef ICE_CPP11_COMPILER
    PSUnknownException(const PSUnknownException&) = default;
    virtual ~PSUnknownException();
#else
    virtual ~PSUnknownException() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual PSUnknownException* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    /// \cond STREAM
    virtual bool _usesClasses() const;
    /// \endcond

    ::Test::PSUnknown2Ptr p;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

}

/// \cond INTERNAL
namespace IceAsync
{

}
/// \endcond

namespace Test
{

}

namespace IceProxy
{

namespace Test
{

class SBSUnknownDerived : public virtual ::Ice::Proxy<SBSUnknownDerived, ::IceProxy::Test::SBase>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class SUnknown : public virtual ::Ice::Proxy<SUnknown, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class D2 : public virtual ::Ice::Proxy<D2, ::IceProxy::Test::B>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class D4 : public virtual ::Ice::Proxy<D4, ::IceProxy::Test::B>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class MyClass : public virtual ::Ice::Proxy<MyClass, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class PSUnknown : public virtual ::Ice::Proxy<PSUnknown, ::IceProxy::Test::Preserved>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class PSUnknown2 : public virtual ::Ice::Proxy<PSUnknown2, ::IceProxy::Test::Preserved>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class SBSUnknownDerived : public SBase
{
public:

    typedef SBSUnknownDerivedPrx ProxyType;
    typedef SBSUnknownDerivedPtr PointerType;

    virtual ~SBSUnknownDerived();

    SBSUnknownDerived()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    SBSUnknownDerived(const ::std::string& sb, const ::std::string& sbsud) :
        ::Test::SBase(sb),
        sbsud(sbsud)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SBSUnknownDerived(const SBSUnknownDerived&) = default;
    SBSUnknownDerived& operator=(const SBSUnknownDerived&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string sbsud;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SBSUnknownDerived_init = ::Test::SBSUnknownDerived::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SBSUnknownDerived& lhs, const SBSUnknownDerived& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SBSUnknownDerived& lhs, const SBSUnknownDerived& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SUnknown : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef SUnknownPrx ProxyType;
    typedef SUnknownPtr PointerType;

    virtual ~SUnknown();

    SUnknown()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    SUnknown(const ::std::string& su, const ::Test::SUnknownPtr& cycle) :
        su(su),
        cycle(cycle)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SUnknown(const SUnknown&) = default;
    SUnknown& operator=(const SUnknown&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string su;
    ::Test::SUnknownPtr cycle;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SUnknown_init = ::Test::SUnknown::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SUnknown& lhs, const SUnknown& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SUnknown& lhs, const SUnknown& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class D2 : public B
{
public:

    typedef D2Prx ProxyType;
    typedef D2Ptr PointerType;

    virtual ~D2();

    D2()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    D2(const ::std::string& sb, const ::Test::BPtr& pb, const ::std::string& sd2, const ::Test::BPtr& pd2) :
        ::Test::B(sb, pb),
        sd2(sd2),
        pd2(pd2)
    {
    }

#ifdef ICE_CPP11_COMPILER
    D2(const D2&) = default;
    D2& operator=(const D2&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string sd2;
    ::Test::BPtr pd2;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_D2_init = ::Test::D2::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const D2& lhs, const D2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const D2& lhs, const D2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class D4 : public B
{
public:

    typedef D4Prx ProxyType;
    typedef D4Ptr PointerType;

    virtual ~D4();

    D4()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    D4(const ::std::string& sb, const ::Test::BPtr& pb, const ::Test::BPtr& p1, const ::Test::BPtr& p2) :
        ::Test::B(sb, pb),
        p1(p1),
        p2(p2)
    {
    }

#ifdef ICE_CPP11_COMPILER
    D4(const D4&) = default;
    D4& operator=(const D4&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::BPtr p1;
    ::Test::BPtr p2;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_D4_init = ::Test::D4::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const D4& lhs, const D4& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const D4& lhs, const D4& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class MyClass : public virtual ::Ice::Object
{
public:

    typedef MyClassPrx ProxyType;
    typedef MyClassPtr PointerType;

    virtual ~MyClass();

    MyClass()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit MyClass(::Ice::Int i) :
        i(i)
    {
    }

#ifdef ICE_CPP11_COMPILER
    MyClass(const MyClass&) = default;
    MyClass& operator=(const MyClass&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int i;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_MyClass_init = ::Test::MyClass::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const MyClass& lhs, const MyClass& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const MyClass& lhs, const MyClass& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class PSUnknown : public Preserved
{
public:

    typedef PSUnknownPrx ProxyType;
    typedef PSUnknownPtr PointerType;

    virtual ~PSUnknown();

    PSUnknown()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknown(::Ice::Int pi, const ::std::string& ps, const ::std::string& psu, const ::Test::PNodePtr& graph, const ::Test::MyClassPtr& cl) :
        ::Test::Preserved(pi, ps),
        psu(psu),
        graph(graph),
        cl(cl)
    {
    }

#ifdef ICE_CPP11_COMPILER
    PSUnknown(const PSUnknown&) = default;
    PSUnknown& operator=(const PSUnknown&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string psu;
    ::Test::PNodePtr graph;
    ::Test::MyClassPtr cl;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_PSUnknown_init = ::Test::PSUnknown::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const PSUnknown& lhs, const PSUnknown& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const PSUnknown& lhs, const PSUnknown& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class PSUnknown2 : public Preserved
{
public:

    typedef PSUnknown2Prx ProxyType;
    typedef PSUnknown2Ptr PointerType;

    virtual ~PSUnknown2();

    PSUnknown2()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknown2(::Ice::Int pi, const ::std::string& ps, const ::Test::PBasePtr& pb) :
        ::Test::Preserved(pi, ps),
        pb(pb)
    {
    }

#ifdef ICE_CPP11_COMPILER
    PSUnknown2(const PSUnknown2&) = default;
    PSUnknown2& operator=(const PSUnknown2&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::PBasePtr pb;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_PSUnknown2_init = ::Test::PSUnknown2::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const PSUnknown2& lhs, const PSUnknown2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const PSUnknown2& lhs, const PSUnknown2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter< ::Test::SBSUnknownDerived, S>
{
    static void write(S* ostr, const ::Test::SBSUnknownDerived& v)
    {
        ostr->write(v.sbsud);
    }
};

template<typename S>
struct StreamReader< ::Test::SBSUnknownDerived, S>
{
    static void read(S* istr, ::Test::SBSUnknownDerived& v)
    {
        istr->read(v.sbsud);
    }
};

template<typename S>
struct StreamWriter< ::Test::SUnknown, S>
{
    static void write(S* ostr, const ::Test::SUnknown& v)
    {
        ostr->write(v.su);
        ostr->write(v.cycle);
    }
};

template<typename S>
struct StreamReader< ::Test::SUnknown, S>
{
    static void read(S* istr, ::Test::SUnknown& v)
    {
        istr->read(v.su);
        istr->read(v.cycle);
    }
};

template<typename S>
struct StreamWriter< ::Test::D2, S>
{
    static void write(S* ostr, const ::Test::D2& v)
    {
        ostr->write(v.sd2);
        ostr->write(v.pd2);
    }
};

template<typename S>
struct StreamReader< ::Test::D2, S>
{
    static void read(S* istr, ::Test::D2& v)
    {
        istr->read(v.sd2);
        istr->read(v.pd2);
    }
};

template<typename S>
struct StreamWriter< ::Test::D4, S>
{
    static void write(S* ostr, const ::Test::D4& v)
    {
        ostr->write(v.p1);
        ostr->write(v.p2);
    }
};

template<typename S>
struct StreamReader< ::Test::D4, S>
{
    static void read(S* istr, ::Test::D4& v)
    {
        istr->read(v.p1);
        istr->read(v.p2);
    }
};

template<>
struct StreamableTraits< ::Test::UnknownDerivedException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::UnknownDerivedException, S>
{
    static void write(S* ostr, const ::Test::UnknownDerivedException& v)
    {
        ostr->write(v.sude);
        ostr->write(v.pd2);
    }
};

template<typename S>
struct StreamReader< ::Test::UnknownDerivedException, S>
{
    static void read(S* istr, ::Test::UnknownDerivedException& v)
    {
        istr->read(v.sude);
        istr->read(v.pd2);
    }
};

template<typename S>
struct StreamWriter< ::Test::MyClass, S>
{
    static void write(S* ostr, const ::Test::MyClass& v)
    {
        ostr->write(v.i);
    }
};

template<typename S>
struct StreamReader< ::Test::MyClass, S>
{
    static void read(S* istr, ::Test::MyClass& v)
    {
        istr->read(v.i);
    }
};

template<typename S>
struct StreamWriter< ::Test::PSUnknown, S>
{
    static void write(S* ostr, const ::Test::PSUnknown& v)
    {
        ostr->write(v.psu);
        ostr->write(v.graph);
        ostr->write(v.cl);
    }
};

template<typename S>
struct StreamReader< ::Test::PSUnknown, S>
{
    static void read(S* istr, ::Test::PSUnknown& v)
    {
        istr->read(v.psu);
        istr->read(v.graph);
        istr->read(v.cl);
    }
};

template<typename S>
struct StreamWriter< ::Test::PSUnknown2, S>
{
    static void write(S* ostr, const ::Test::PSUnknown2& v)
    {
        ostr->write(v.pb);
    }
};

template<typename S>
struct StreamReader< ::Test::PSUnknown2, S>
{
    static void read(S* istr, ::Test::PSUnknown2& v)
    {
        istr->read(v.pb);
    }
};

template<>
struct StreamableTraits< ::Test::PSUnknownException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::PSUnknownException, S>
{
    static void write(S* ostr, const ::Test::PSUnknownException& v)
    {
        ostr->write(v.p);
    }
};

template<typename S>
struct StreamReader< ::Test::PSUnknownException, S>
{
    static void read(S* istr, ::Test::PSUnknownException& v)
    {
        istr->read(v.p);
    }
};

}
/// \endcond

namespace Test
{

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
