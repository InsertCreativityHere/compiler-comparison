//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/BuiltinSequences.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class C;
class TestIntf;
class TestIntfPrx;

}

namespace Test
{

using CSeq = ::std::vector<::std::shared_ptr<C>>;

using CArray = ::std::vector<::std::shared_ptr<C>>;

using CList = ::std::vector<::std::shared_ptr<C>>;

using BoolSeq = ::std::vector<bool>;

using ByteSeq = ::std::vector<::Ice::Byte>;

using ShortSeq = ::std::vector<short>;

using IntSeq = ::std::vector<int>;

using LongSeq = ::std::vector<long long int>;

using FloatSeq = ::std::vector<float>;

using DoubleSeq = ::std::vector<double>;

using StringSeq = ::std::vector<::std::string>;

using ByteBuffer = ::std::vector<::Ice::Byte>;

using ShortBuffer = ::std::vector<short>;

using IntBuffer = ::std::vector<int>;

using LongBuffer = ::std::vector<long long int>;

using FloatBuffer = ::std::vector<float>;

using DoubleBuffer = ::std::vector<double>;

enum class E : unsigned char
{
    E1,
    E2,
    E3
};

using ESeq = ::std::vector<E>;

struct S
{
    ::Test::E en;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::E&> ice_tuple() const
    {
        return std::tie(en);
    }
};

using SSeq = ::std::vector<S>;

using D = ::std::map<int, ::std::string>;

using DSeq = ::std::vector<D>;

using StringSeqSeq = ::std::vector<StringSeq>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class TestIntf : public virtual ::Ice::Object
{
public:

    using ProxyType = TestIntfPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Encapsulates the results of a call to opCSeq.
     */
    struct OpCSeqResult
    {
        CSeq returnValue;
        CSeq outSeq;
    };

    virtual CSeq opCSeq(CSeq inSeq, CSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCArray.
     */
    struct OpCArrayResult
    {
        CArray returnValue;
        CArray outSeq;
    };

    virtual CArray opCArray(CArray inSeq, CArray& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCList.
     */
    struct OpCListResult
    {
        CList returnValue;
        CList outSeq;
    };

    virtual CList opCList(CList inSeq, CList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolSeq.
     */
    struct OpBoolSeqResult
    {
        BoolSeq returnValue;
        BoolSeq outSeq;
    };

    virtual BoolSeq opBoolSeq(BoolSeq inSeq, BoolSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteSeq.
     */
    struct OpByteSeqResult
    {
        ByteSeq returnValue;
        ByteSeq outSeq;
    };

    virtual ByteSeq opByteSeq(ByteSeq inSeq, ByteSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortSeq.
     */
    struct OpShortSeqResult
    {
        ShortSeq returnValue;
        ShortSeq outSeq;
    };

    virtual ShortSeq opShortSeq(ShortSeq inSeq, ShortSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntSeq.
     */
    struct OpIntSeqResult
    {
        IntSeq returnValue;
        IntSeq outSeq;
    };

    virtual IntSeq opIntSeq(IntSeq inSeq, IntSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongSeq.
     */
    struct OpLongSeqResult
    {
        LongSeq returnValue;
        LongSeq outSeq;
    };

    virtual LongSeq opLongSeq(LongSeq inSeq, LongSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatSeq.
     */
    struct OpFloatSeqResult
    {
        FloatSeq returnValue;
        FloatSeq outSeq;
    };

    virtual FloatSeq opFloatSeq(FloatSeq inSeq, FloatSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDoubleSeq.
     */
    struct OpDoubleSeqResult
    {
        DoubleSeq returnValue;
        DoubleSeq outSeq;
    };

    virtual DoubleSeq opDoubleSeq(DoubleSeq inSeq, DoubleSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSeq.
     */
    struct OpStringSeqResult
    {
        StringSeq returnValue;
        StringSeq outSeq;
    };

    virtual StringSeq opStringSeq(StringSeq inSeq, StringSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opESeq.
     */
    struct OpESeqResult
    {
        ESeq returnValue;
        ESeq outSeq;
    };

    virtual ESeq opESeq(ESeq inSeq, ESeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opESeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSSeq.
     */
    struct OpSSeqResult
    {
        SSeq returnValue;
        SSeq outSeq;
    };

    virtual SSeq opSSeq(SSeq inSeq, SSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDSeq.
     */
    struct OpDSeqResult
    {
        DSeq returnValue;
        DSeq outSeq;
    };

    virtual DSeq opDSeq(DSeq inSeq, DSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSeqSeq.
     */
    struct OpStringSeqSeqResult
    {
        StringSeqSeq returnValue;
        StringSeqSeq outSeq;
    };

    virtual StringSeqSeq opStringSeqSeq(StringSeqSeq inSeq, StringSeqSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeqSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteBufferSeq.
     */
    struct OpByteBufferSeqResult
    {
        ByteBuffer returnValue;
        ByteBuffer outSeq;
    };

    virtual ByteBuffer opByteBufferSeq(ByteBuffer inSeq, ByteBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortBufferSeq.
     */
    struct OpShortBufferSeqResult
    {
        ShortBuffer returnValue;
        ShortBuffer outSeq;
    };

    virtual ShortBuffer opShortBufferSeq(ShortBuffer inSeq, ShortBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntBufferSeq.
     */
    struct OpIntBufferSeqResult
    {
        IntBuffer returnValue;
        IntBuffer outSeq;
    };

    virtual IntBuffer opIntBufferSeq(IntBuffer inSeq, IntBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongBufferSeq.
     */
    struct OpLongBufferSeqResult
    {
        LongBuffer returnValue;
        LongBuffer outSeq;
    };

    virtual LongBuffer opLongBufferSeq(LongBuffer inSeq, LongBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatBufferSeq.
     */
    struct OpFloatBufferSeqResult
    {
        FloatBuffer returnValue;
        FloatBuffer outSeq;
    };

    virtual FloatBuffer opFloatBufferSeq(FloatBuffer inSeq, FloatBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDoubleBufferSeq.
     */
    struct OpDoubleBufferSeqResult
    {
        DoubleBuffer returnValue;
        DoubleBuffer outSeq;
    };

    virtual DoubleBuffer opDoubleBufferSeq(DoubleBuffer inSeq, DoubleBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class C : public ::Ice::ValueHelper<C, ::Ice::Value>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

/// \cond INTERNAL
static C _iceS_C_init;
/// \endcond

}

namespace Test
{

class TestIntfPrx : public virtual ::Ice::Proxy<TestIntfPrx, ::Ice::ObjectPrx>
{
public:

    CSeq opCSeq(const CSeq& inSeq, CSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCSeqResult>(true, this, &TestIntfPrx::_iceI_opCSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCSeqAsync(const CSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCSeqResult, P>(false, this, &TestIntfPrx::_iceI_opCSeq, inSeq, context);
    }

    ::std::function<void()>
    opCSeqAsync(const CSeq& inSeq,
                ::std::function<void(::Test::CSeq, ::Test::CSeq)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpCSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpCSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCSeqResult>>&, const CSeq&, const ::Ice::Context&);
    /// \endcond

    CArray opCArray(const CArray& inSeq, CArray& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCArrayResult>(true, this, &TestIntfPrx::_iceI_opCArray, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCArrayAsync(const CArray& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCArrayResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCArrayResult, P>(false, this, &TestIntfPrx::_iceI_opCArray, inSeq, context);
    }

    ::std::function<void()>
    opCArrayAsync(const CArray& inSeq,
                  ::std::function<void(::Test::CArray, ::Test::CArray)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpCArrayResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpCArrayResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCArray, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opCArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCArrayResult>>&, const CArray&, const ::Ice::Context&);
    /// \endcond

    CList opCList(const CList& inSeq, CList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCListResult>(true, this, &TestIntfPrx::_iceI_opCList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCListAsync(const CList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCListResult, P>(false, this, &TestIntfPrx::_iceI_opCList, inSeq, context);
    }

    ::std::function<void()>
    opCListAsync(const CList& inSeq,
                 ::std::function<void(::Test::CList, ::Test::CList)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpCListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpCListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCListResult>>&, const CList&, const ::Ice::Context&);
    /// \endcond

    BoolSeq opBoolSeq(const BoolSeq& inSeq, BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolSeqResult>(true, this, &TestIntfPrx::_iceI_opBoolSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolSeqAsync(const BoolSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolSeqResult, P>(false, this, &TestIntfPrx::_iceI_opBoolSeq, inSeq, context);
    }

    ::std::function<void()>
    opBoolSeqAsync(const BoolSeq& inSeq,
                   ::std::function<void(::Test::BoolSeq, ::Test::BoolSeq)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpBoolSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpBoolSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolSeqResult>>&, const BoolSeq&, const ::Ice::Context&);
    /// \endcond

    ByteSeq opByteSeq(const ByteSeq& inSeq, ByteSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteSeqResult>(true, this, &TestIntfPrx::_iceI_opByteSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteSeqAsync(const ByteSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteSeqResult, P>(false, this, &TestIntfPrx::_iceI_opByteSeq, inSeq, context);
    }

    ::std::function<void()>
    opByteSeqAsync(const ByteSeq& inSeq,
                   ::std::function<void(::Test::ByteSeq, ::Test::ByteSeq)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpByteSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpByteSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteSeqResult>>&, const ByteSeq&, const ::Ice::Context&);
    /// \endcond

    ShortSeq opShortSeq(const ShortSeq& inSeq, ShortSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpShortSeqResult>(true, this, &TestIntfPrx::_iceI_opShortSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortSeqAsync(const ShortSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpShortSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpShortSeqResult, P>(false, this, &TestIntfPrx::_iceI_opShortSeq, inSeq, context);
    }

    ::std::function<void()>
    opShortSeqAsync(const ShortSeq& inSeq,
                    ::std::function<void(::Test::ShortSeq, ::Test::ShortSeq)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpShortSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpShortSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpShortSeqResult>>&, const ShortSeq&, const ::Ice::Context&);
    /// \endcond

    IntSeq opIntSeq(const IntSeq& inSeq, IntSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpIntSeqResult>(true, this, &TestIntfPrx::_iceI_opIntSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntSeqAsync(const IntSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpIntSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpIntSeqResult, P>(false, this, &TestIntfPrx::_iceI_opIntSeq, inSeq, context);
    }

    ::std::function<void()>
    opIntSeqAsync(const IntSeq& inSeq,
                  ::std::function<void(::Test::IntSeq, ::Test::IntSeq)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpIntSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpIntSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpIntSeqResult>>&, const IntSeq&, const ::Ice::Context&);
    /// \endcond

    LongSeq opLongSeq(const LongSeq& inSeq, LongSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpLongSeqResult>(true, this, &TestIntfPrx::_iceI_opLongSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLongSeqAsync(const LongSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpLongSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpLongSeqResult, P>(false, this, &TestIntfPrx::_iceI_opLongSeq, inSeq, context);
    }

    ::std::function<void()>
    opLongSeqAsync(const LongSeq& inSeq,
                   ::std::function<void(::Test::LongSeq, ::Test::LongSeq)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpLongSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpLongSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opLongSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpLongSeqResult>>&, const LongSeq&, const ::Ice::Context&);
    /// \endcond

    FloatSeq opFloatSeq(const FloatSeq& inSeq, FloatSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpFloatSeqResult>(true, this, &TestIntfPrx::_iceI_opFloatSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatSeqAsync(const FloatSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpFloatSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpFloatSeqResult, P>(false, this, &TestIntfPrx::_iceI_opFloatSeq, inSeq, context);
    }

    ::std::function<void()>
    opFloatSeqAsync(const FloatSeq& inSeq,
                    ::std::function<void(::Test::FloatSeq, ::Test::FloatSeq)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpFloatSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpFloatSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFloatSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFloatSeqResult>>&, const FloatSeq&, const ::Ice::Context&);
    /// \endcond

    DoubleSeq opDoubleSeq(const DoubleSeq& inSeq, DoubleSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDoubleSeqResult>(true, this, &TestIntfPrx::_iceI_opDoubleSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleSeqAsync(const DoubleSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDoubleSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDoubleSeqResult, P>(false, this, &TestIntfPrx::_iceI_opDoubleSeq, inSeq, context);
    }

    ::std::function<void()>
    opDoubleSeqAsync(const DoubleSeq& inSeq,
                     ::std::function<void(::Test::DoubleSeq, ::Test::DoubleSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpDoubleSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpDoubleSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDoubleSeqResult>>&, const DoubleSeq&, const ::Ice::Context&);
    /// \endcond

    StringSeq opStringSeq(const StringSeq& inSeq, StringSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringSeqResult>(true, this, &TestIntfPrx::_iceI_opStringSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringSeqAsync(const StringSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringSeqResult, P>(false, this, &TestIntfPrx::_iceI_opStringSeq, inSeq, context);
    }

    ::std::function<void()>
    opStringSeqAsync(const StringSeq& inSeq,
                     ::std::function<void(::Test::StringSeq, ::Test::StringSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpStringSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpStringSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringSeqResult>>&, const StringSeq&, const ::Ice::Context&);
    /// \endcond

    ESeq opESeq(const ESeq& inSeq, ESeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpESeqResult>(true, this, &TestIntfPrx::_iceI_opESeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opESeqAsync(const ESeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpESeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpESeqResult, P>(false, this, &TestIntfPrx::_iceI_opESeq, inSeq, context);
    }

    ::std::function<void()>
    opESeqAsync(const ESeq& inSeq,
                ::std::function<void(::Test::ESeq, ::Test::ESeq)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpESeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpESeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opESeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpESeqResult>>&, const ESeq&, const ::Ice::Context&);
    /// \endcond

    SSeq opSSeq(const SSeq& inSeq, SSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpSSeqResult>(true, this, &TestIntfPrx::_iceI_opSSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSSeqAsync(const SSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpSSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpSSeqResult, P>(false, this, &TestIntfPrx::_iceI_opSSeq, inSeq, context);
    }

    ::std::function<void()>
    opSSeqAsync(const SSeq& inSeq,
                ::std::function<void(::Test::SSeq, ::Test::SSeq)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpSSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpSSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opSSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpSSeqResult>>&, const SSeq&, const ::Ice::Context&);
    /// \endcond

    DSeq opDSeq(const DSeq& inSeq, DSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDSeqResult>(true, this, &TestIntfPrx::_iceI_opDSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDSeqAsync(const DSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDSeqResult, P>(false, this, &TestIntfPrx::_iceI_opDSeq, inSeq, context);
    }

    ::std::function<void()>
    opDSeqAsync(const DSeq& inSeq,
                ::std::function<void(::Test::DSeq, ::Test::DSeq)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpDSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpDSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDSeqResult>>&, const DSeq&, const ::Ice::Context&);
    /// \endcond

    StringSeqSeq opStringSeqSeq(const StringSeqSeq& inSeq, StringSeqSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringSeqSeqResult>(true, this, &TestIntfPrx::_iceI_opStringSeqSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringSeqSeqAsync(const StringSeqSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringSeqSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringSeqSeqResult, P>(false, this, &TestIntfPrx::_iceI_opStringSeqSeq, inSeq, context);
    }

    ::std::function<void()>
    opStringSeqSeqAsync(const StringSeqSeq& inSeq,
                        ::std::function<void(::Test::StringSeqSeq, ::Test::StringSeqSeq)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpStringSeqSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpStringSeqSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeqSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringSeqSeqResult>>&, const StringSeqSeq&, const ::Ice::Context&);
    /// \endcond

    ByteBuffer opByteBufferSeq(const ByteBuffer& inSeq, ByteBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opByteBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteBufferSeqAsync(const ByteBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opByteBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opByteBufferSeqAsync(const ByteBuffer& inSeq,
                         ::std::function<void(::Test::ByteBuffer, ::Test::ByteBuffer)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpByteBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpByteBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteBufferSeqResult>>&, const ByteBuffer&, const ::Ice::Context&);
    /// \endcond

    ShortBuffer opShortBufferSeq(const ShortBuffer& inSeq, ShortBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpShortBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opShortBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortBufferSeqAsync(const ShortBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpShortBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpShortBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opShortBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opShortBufferSeqAsync(const ShortBuffer& inSeq,
                          ::std::function<void(::Test::ShortBuffer, ::Test::ShortBuffer)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpShortBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpShortBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpShortBufferSeqResult>>&, const ShortBuffer&, const ::Ice::Context&);
    /// \endcond

    IntBuffer opIntBufferSeq(const IntBuffer& inSeq, IntBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpIntBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opIntBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntBufferSeqAsync(const IntBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpIntBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpIntBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opIntBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opIntBufferSeqAsync(const IntBuffer& inSeq,
                        ::std::function<void(::Test::IntBuffer, ::Test::IntBuffer)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpIntBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpIntBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpIntBufferSeqResult>>&, const IntBuffer&, const ::Ice::Context&);
    /// \endcond

    LongBuffer opLongBufferSeq(const LongBuffer& inSeq, LongBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpLongBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opLongBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLongBufferSeqAsync(const LongBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpLongBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpLongBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opLongBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opLongBufferSeqAsync(const LongBuffer& inSeq,
                         ::std::function<void(::Test::LongBuffer, ::Test::LongBuffer)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpLongBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpLongBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opLongBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpLongBufferSeqResult>>&, const LongBuffer&, const ::Ice::Context&);
    /// \endcond

    FloatBuffer opFloatBufferSeq(const FloatBuffer& inSeq, FloatBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpFloatBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opFloatBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatBufferSeqAsync(const FloatBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpFloatBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpFloatBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opFloatBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opFloatBufferSeqAsync(const FloatBuffer& inSeq,
                          ::std::function<void(::Test::FloatBuffer, ::Test::FloatBuffer)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpFloatBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpFloatBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFloatBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFloatBufferSeqResult>>&, const FloatBuffer&, const ::Ice::Context&);
    /// \endcond

    DoubleBuffer opDoubleBufferSeq(const DoubleBuffer& inSeq, DoubleBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDoubleBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opDoubleBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleBufferSeqAsync(const DoubleBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDoubleBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDoubleBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opDoubleBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opDoubleBufferSeqAsync(const DoubleBuffer& inSeq,
                           ::std::function<void(::Test::DoubleBuffer, ::Test::DoubleBuffer)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpDoubleBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<TestIntf::OpDoubleBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDoubleBufferSeqResult>>&, const DoubleBuffer&, const ::Ice::Context&);
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    TestIntfPrx() = default;
    friend ::std::shared_ptr<TestIntfPrx> IceInternal::createProxy<TestIntfPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::E>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::S, S>
{
    static void read(S* istr, ::Test::S& v)
    {
        istr->readAll(v.en);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using CPtr = ::std::shared_ptr<C>;

using TestIntfPtr = ::std::shared_ptr<TestIntf>;
using TestIntfPrxPtr = ::std::shared_ptr<TestIntfPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class C;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< C>&);
::IceProxy::Ice::Object* upCast(C*);
/// \endcond

class TestIntf;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< TestIntf>&);
::IceProxy::Ice::Object* upCast(TestIntf*);
/// \endcond

}

}

namespace Test
{

class C;
/// \cond INTERNAL
::Ice::Object* upCast(C*);
/// \endcond
typedef ::IceInternal::Handle< C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::C> CPrx;
typedef CPrx CPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class TestIntf;
/// \cond INTERNAL
::Ice::Object* upCast(TestIntf*);
/// \endcond
typedef ::IceInternal::Handle< TestIntf> TestIntfPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::TestIntf> TestIntfPrx;
typedef TestIntfPrx TestIntfPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(TestIntfPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Test
{

typedef ::std::vector<CPtr> CSeq;

typedef ::std::vector<CPtr> CArray;

typedef ::std::vector<CPtr> CList;

typedef ::std::vector<bool> BoolSeq;

typedef ::std::vector< ::Ice::Byte> ByteSeq;

typedef ::std::vector< ::Ice::Short> ShortSeq;

typedef ::std::vector< ::Ice::Int> IntSeq;

typedef ::std::vector< ::Ice::Long> LongSeq;

typedef ::std::vector< ::Ice::Float> FloatSeq;

typedef ::std::vector< ::Ice::Double> DoubleSeq;

typedef ::std::vector< ::std::string> StringSeq;

typedef ::std::vector< ::Ice::Byte> ByteBuffer;

typedef ::std::vector< ::Ice::Short> ShortBuffer;

typedef ::std::vector< ::Ice::Int> IntBuffer;

typedef ::std::vector< ::Ice::Long> LongBuffer;

typedef ::std::vector< ::Ice::Float> FloatBuffer;

typedef ::std::vector< ::Ice::Double> DoubleBuffer;

enum E
{
    E1,
    E2,
    E3
};

typedef ::std::vector<E> ESeq;

struct S
{
    ::Test::E en;

    bool operator==(const S& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(en != rhs_.en)
        {
            return false;
        }
        return true;
    }

    bool operator<(const S& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(en < rhs_.en)
        {
            return true;
        }
        else if(rhs_.en < en)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const S& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const S& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const S& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const S& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<S> SSeq;

typedef ::std::map< ::Ice::Int, ::std::string> D;

typedef ::std::vector<D> DSeq;

typedef ::std::vector<StringSeq> StringSeqSeq;

}

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCSeq.
 */
class Callback_TestIntf_opCSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCSeq_Base> Callback_TestIntf_opCSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opCArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCArray.
 */
class Callback_TestIntf_opCArray_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCArray_Base> Callback_TestIntf_opCArrayPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCList.
 */
class Callback_TestIntf_opCList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCList_Base> Callback_TestIntf_opCListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolSeq.
 */
class Callback_TestIntf_opBoolSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolSeq_Base> Callback_TestIntf_opBoolSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteSeq.
 */
class Callback_TestIntf_opByteSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteSeq_Base> Callback_TestIntf_opByteSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opShortSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortSeq.
 */
class Callback_TestIntf_opShortSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opShortSeq_Base> Callback_TestIntf_opShortSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opIntSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntSeq.
 */
class Callback_TestIntf_opIntSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opIntSeq_Base> Callback_TestIntf_opIntSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opLongSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opLongSeq.
 */
class Callback_TestIntf_opLongSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opLongSeq_Base> Callback_TestIntf_opLongSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opFloatSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFloatSeq.
 */
class Callback_TestIntf_opFloatSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opFloatSeq_Base> Callback_TestIntf_opFloatSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleSeq.
 */
class Callback_TestIntf_opDoubleSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opDoubleSeq_Base> Callback_TestIntf_opDoubleSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeq.
 */
class Callback_TestIntf_opStringSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringSeq_Base> Callback_TestIntf_opStringSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opESeq.
 */
class Callback_TestIntf_opESeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opESeq_Base> Callback_TestIntf_opESeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opSSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opSSeq.
 */
class Callback_TestIntf_opSSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opSSeq_Base> Callback_TestIntf_opSSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opDSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDSeq.
 */
class Callback_TestIntf_opDSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opDSeq_Base> Callback_TestIntf_opDSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeqSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeqSeq.
 */
class Callback_TestIntf_opStringSeqSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringSeqSeq_Base> Callback_TestIntf_opStringSeqSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opByteBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteBufferSeq.
 */
class Callback_TestIntf_opByteBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteBufferSeq_Base> Callback_TestIntf_opByteBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opShortBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortBufferSeq.
 */
class Callback_TestIntf_opShortBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opShortBufferSeq_Base> Callback_TestIntf_opShortBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opIntBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntBufferSeq.
 */
class Callback_TestIntf_opIntBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opIntBufferSeq_Base> Callback_TestIntf_opIntBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opLongBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opLongBufferSeq.
 */
class Callback_TestIntf_opLongBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opLongBufferSeq_Base> Callback_TestIntf_opLongBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opFloatBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFloatBufferSeq.
 */
class Callback_TestIntf_opFloatBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opFloatBufferSeq_Base> Callback_TestIntf_opFloatBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleBufferSeq.
 */
class Callback_TestIntf_opDoubleBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opDoubleBufferSeq_Base> Callback_TestIntf_opDoubleBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
class Callback_TestIntf_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_shutdown_Base> Callback_TestIntf_shutdownPtr;

}

namespace IceProxy
{

namespace Test
{

class C : public virtual ::Ice::Proxy<C, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class TestIntf : public virtual ::Ice::Proxy<TestIntf, ::IceProxy::Ice::Object>
{
public:

    ::Test::CSeq opCSeq(const ::Test::CSeq& inSeq, ::Test::CSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCSeq(outSeq, _iceI_begin_opCSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const ::Test::CSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const ::Test::CSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const ::Test::CSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const ::Test::CSeq& inSeq, const ::Test::Callback_TestIntf_opCSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const ::Test::CSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opCSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, context, cb, cookie);
    }

    ::Test::CSeq end_opCSeq(::Test::CSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCSeq(::Test::CSeq& iceP_outSeq, ::Test::CSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCSeq(const ::Test::CSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CArray opCArray(const ::Test::CArray& inSeq, ::Test::CArray& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCArray(outSeq, _iceI_begin_opCArray(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCArray(const ::Test::CArray& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCArray(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCArray(const ::Test::CArray& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCArray(const ::Test::CArray& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCArray(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCArray(const ::Test::CArray& inSeq, const ::Test::Callback_TestIntf_opCArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCArray(const ::Test::CArray& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opCArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCArray(inSeq, context, cb, cookie);
    }

    ::Test::CArray end_opCArray(::Test::CArray& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCArray(::Test::CArray& iceP_outSeq, ::Test::CArray& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCArray(const ::Test::CArray&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CList opCList(const ::Test::CList& inSeq, ::Test::CList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCList(outSeq, _iceI_begin_opCList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Test::Callback_TestIntf_opCListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opCListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, context, cb, cookie);
    }

    ::Test::CList end_opCList(::Test::CList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCList(::Test::CList& iceP_outSeq, ::Test::CList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCList(const ::Test::CList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BoolSeq opBoolSeq(const ::Test::BoolSeq& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolSeq(outSeq, _iceI_begin_opBoolSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const ::Test::BoolSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const ::Test::BoolSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const ::Test::BoolSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const ::Test::BoolSeq& inSeq, const ::Test::Callback_TestIntf_opBoolSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const ::Test::BoolSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, context, cb, cookie);
    }

    ::Test::BoolSeq end_opBoolSeq(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolSeq(::Test::BoolSeq& iceP_outSeq, ::Test::BoolSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolSeq(const ::Test::BoolSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteSeq opByteSeq(const ::Test::ByteSeq& inSeq, ::Test::ByteSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteSeq(outSeq, _iceI_begin_opByteSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const ::Test::ByteSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const ::Test::ByteSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const ::Test::ByteSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const ::Test::ByteSeq& inSeq, const ::Test::Callback_TestIntf_opByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const ::Test::ByteSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, context, cb, cookie);
    }

    ::Test::ByteSeq end_opByteSeq(::Test::ByteSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteSeq(::Test::ByteSeq& iceP_outSeq, ::Test::ByteSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteSeq(const ::Test::ByteSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ShortSeq opShortSeq(const ::Test::ShortSeq& inSeq, ::Test::ShortSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortSeq(outSeq, _iceI_begin_opShortSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const ::Test::ShortSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const ::Test::ShortSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const ::Test::ShortSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const ::Test::ShortSeq& inSeq, const ::Test::Callback_TestIntf_opShortSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const ::Test::ShortSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opShortSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeq(inSeq, context, cb, cookie);
    }

    ::Test::ShortSeq end_opShortSeq(::Test::ShortSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortSeq(::Test::ShortSeq& iceP_outSeq, ::Test::ShortSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortSeq(const ::Test::ShortSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::IntSeq opIntSeq(const ::Test::IntSeq& inSeq, ::Test::IntSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntSeq(outSeq, _iceI_begin_opIntSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const ::Test::IntSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const ::Test::IntSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const ::Test::IntSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const ::Test::IntSeq& inSeq, const ::Test::Callback_TestIntf_opIntSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const ::Test::IntSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opIntSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeq(inSeq, context, cb, cookie);
    }

    ::Test::IntSeq end_opIntSeq(::Test::IntSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opIntSeq(::Test::IntSeq& iceP_outSeq, ::Test::IntSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntSeq(const ::Test::IntSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LongSeq opLongSeq(const ::Test::LongSeq& inSeq, ::Test::LongSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLongSeq(outSeq, _iceI_begin_opLongSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const ::Test::LongSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLongSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const ::Test::LongSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const ::Test::LongSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const ::Test::LongSeq& inSeq, const ::Test::Callback_TestIntf_opLongSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const ::Test::LongSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opLongSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeq(inSeq, context, cb, cookie);
    }

    ::Test::LongSeq end_opLongSeq(::Test::LongSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLongSeq(::Test::LongSeq& iceP_outSeq, ::Test::LongSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLongSeq(const ::Test::LongSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::FloatSeq opFloatSeq(const ::Test::FloatSeq& inSeq, ::Test::FloatSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFloatSeq(outSeq, _iceI_begin_opFloatSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const ::Test::FloatSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFloatSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const ::Test::FloatSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const ::Test::FloatSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const ::Test::FloatSeq& inSeq, const ::Test::Callback_TestIntf_opFloatSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const ::Test::FloatSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opFloatSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeq(inSeq, context, cb, cookie);
    }

    ::Test::FloatSeq end_opFloatSeq(::Test::FloatSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFloatSeq(::Test::FloatSeq& iceP_outSeq, ::Test::FloatSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFloatSeq(const ::Test::FloatSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::DoubleSeq opDoubleSeq(const ::Test::DoubleSeq& inSeq, ::Test::DoubleSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDoubleSeq(outSeq, _iceI_begin_opDoubleSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const ::Test::DoubleSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDoubleSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const ::Test::DoubleSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const ::Test::DoubleSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const ::Test::DoubleSeq& inSeq, const ::Test::Callback_TestIntf_opDoubleSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const ::Test::DoubleSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opDoubleSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeq(inSeq, context, cb, cookie);
    }

    ::Test::DoubleSeq end_opDoubleSeq(::Test::DoubleSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDoubleSeq(::Test::DoubleSeq& iceP_outSeq, ::Test::DoubleSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDoubleSeq(const ::Test::DoubleSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringSeq opStringSeq(const ::Test::StringSeq& inSeq, ::Test::StringSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringSeq(outSeq, _iceI_begin_opStringSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const ::Test::StringSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const ::Test::StringSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const ::Test::StringSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const ::Test::StringSeq& inSeq, const ::Test::Callback_TestIntf_opStringSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const ::Test::StringSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opStringSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, context, cb, cookie);
    }

    ::Test::StringSeq end_opStringSeq(::Test::StringSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringSeq(::Test::StringSeq& iceP_outSeq, ::Test::StringSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringSeq(const ::Test::StringSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ESeq opESeq(const ::Test::ESeq& inSeq, ::Test::ESeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opESeq(outSeq, _iceI_begin_opESeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opESeq(const ::Test::ESeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opESeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const ::Test::ESeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const ::Test::ESeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const ::Test::ESeq& inSeq, const ::Test::Callback_TestIntf_opESeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const ::Test::ESeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opESeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, context, cb, cookie);
    }

    ::Test::ESeq end_opESeq(::Test::ESeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opESeq(::Test::ESeq& iceP_outSeq, ::Test::ESeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opESeq(const ::Test::ESeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SSeq opSSeq(const ::Test::SSeq& inSeq, ::Test::SSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSSeq(outSeq, _iceI_begin_opSSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSSeq(const ::Test::SSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSSeq(const ::Test::SSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSSeq(const ::Test::SSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSSeq(const ::Test::SSeq& inSeq, const ::Test::Callback_TestIntf_opSSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSSeq(const ::Test::SSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opSSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSSeq(inSeq, context, cb, cookie);
    }

    ::Test::SSeq end_opSSeq(::Test::SSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSSeq(::Test::SSeq& iceP_outSeq, ::Test::SSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSSeq(const ::Test::SSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::DSeq opDSeq(const ::Test::DSeq& inSeq, ::Test::DSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDSeq(outSeq, _iceI_begin_opDSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDSeq(const ::Test::DSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDSeq(const ::Test::DSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDSeq(const ::Test::DSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDSeq(const ::Test::DSeq& inSeq, const ::Test::Callback_TestIntf_opDSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDSeq(const ::Test::DSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opDSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDSeq(inSeq, context, cb, cookie);
    }

    ::Test::DSeq end_opDSeq(::Test::DSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDSeq(::Test::DSeq& iceP_outSeq, ::Test::DSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDSeq(const ::Test::DSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringSeqSeq opStringSeqSeq(const ::Test::StringSeqSeq& inSeq, ::Test::StringSeqSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringSeqSeq(outSeq, _iceI_begin_opStringSeqSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringSeqSeq(const ::Test::StringSeqSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringSeqSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSeqSeq(const ::Test::StringSeqSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeqSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeqSeq(const ::Test::StringSeqSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeqSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeqSeq(const ::Test::StringSeqSeq& inSeq, const ::Test::Callback_TestIntf_opStringSeqSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeqSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeqSeq(const ::Test::StringSeqSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opStringSeqSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeqSeq(inSeq, context, cb, cookie);
    }

    ::Test::StringSeqSeq end_opStringSeqSeq(::Test::StringSeqSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringSeqSeq(::Test::StringSeqSeq& iceP_outSeq, ::Test::StringSeqSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringSeqSeq(const ::Test::StringSeqSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteBuffer opByteBufferSeq(const ::Test::ByteBuffer& inSeq, ::Test::ByteBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteBufferSeq(outSeq, _iceI_begin_opByteBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteBufferSeq(const ::Test::ByteBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteBufferSeq(const ::Test::ByteBuffer& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBufferSeq(const ::Test::ByteBuffer& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBufferSeq(const ::Test::ByteBuffer& inSeq, const ::Test::Callback_TestIntf_opByteBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBufferSeq(const ::Test::ByteBuffer& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opByteBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBufferSeq(inSeq, context, cb, cookie);
    }

    ::Test::ByteBuffer end_opByteBufferSeq(::Test::ByteBuffer& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteBufferSeq(::Test::ByteBuffer& iceP_outSeq, ::Test::ByteBuffer& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteBufferSeq(const ::Test::ByteBuffer&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ShortBuffer opShortBufferSeq(const ::Test::ShortBuffer& inSeq, ::Test::ShortBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortBufferSeq(outSeq, _iceI_begin_opShortBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortBufferSeq(const ::Test::ShortBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortBufferSeq(const ::Test::ShortBuffer& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBufferSeq(const ::Test::ShortBuffer& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBufferSeq(const ::Test::ShortBuffer& inSeq, const ::Test::Callback_TestIntf_opShortBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBufferSeq(const ::Test::ShortBuffer& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opShortBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBufferSeq(inSeq, context, cb, cookie);
    }

    ::Test::ShortBuffer end_opShortBufferSeq(::Test::ShortBuffer& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortBufferSeq(::Test::ShortBuffer& iceP_outSeq, ::Test::ShortBuffer& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortBufferSeq(const ::Test::ShortBuffer&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::IntBuffer opIntBufferSeq(const ::Test::IntBuffer& inSeq, ::Test::IntBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntBufferSeq(outSeq, _iceI_begin_opIntBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntBufferSeq(const ::Test::IntBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntBufferSeq(const ::Test::IntBuffer& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntBufferSeq(const ::Test::IntBuffer& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntBufferSeq(const ::Test::IntBuffer& inSeq, const ::Test::Callback_TestIntf_opIntBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntBufferSeq(const ::Test::IntBuffer& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opIntBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntBufferSeq(inSeq, context, cb, cookie);
    }

    ::Test::IntBuffer end_opIntBufferSeq(::Test::IntBuffer& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opIntBufferSeq(::Test::IntBuffer& iceP_outSeq, ::Test::IntBuffer& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntBufferSeq(const ::Test::IntBuffer&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LongBuffer opLongBufferSeq(const ::Test::LongBuffer& inSeq, ::Test::LongBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLongBufferSeq(outSeq, _iceI_begin_opLongBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLongBufferSeq(const ::Test::LongBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLongBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLongBufferSeq(const ::Test::LongBuffer& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongBufferSeq(const ::Test::LongBuffer& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongBufferSeq(const ::Test::LongBuffer& inSeq, const ::Test::Callback_TestIntf_opLongBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongBufferSeq(const ::Test::LongBuffer& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opLongBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongBufferSeq(inSeq, context, cb, cookie);
    }

    ::Test::LongBuffer end_opLongBufferSeq(::Test::LongBuffer& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLongBufferSeq(::Test::LongBuffer& iceP_outSeq, ::Test::LongBuffer& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLongBufferSeq(const ::Test::LongBuffer&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::FloatBuffer opFloatBufferSeq(const ::Test::FloatBuffer& inSeq, ::Test::FloatBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFloatBufferSeq(outSeq, _iceI_begin_opFloatBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFloatBufferSeq(const ::Test::FloatBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFloatBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatBufferSeq(const ::Test::FloatBuffer& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatBufferSeq(const ::Test::FloatBuffer& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatBufferSeq(const ::Test::FloatBuffer& inSeq, const ::Test::Callback_TestIntf_opFloatBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatBufferSeq(const ::Test::FloatBuffer& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opFloatBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatBufferSeq(inSeq, context, cb, cookie);
    }

    ::Test::FloatBuffer end_opFloatBufferSeq(::Test::FloatBuffer& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFloatBufferSeq(::Test::FloatBuffer& iceP_outSeq, ::Test::FloatBuffer& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFloatBufferSeq(const ::Test::FloatBuffer&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::DoubleBuffer opDoubleBufferSeq(const ::Test::DoubleBuffer& inSeq, ::Test::DoubleBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDoubleBufferSeq(outSeq, _iceI_begin_opDoubleBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDoubleBufferSeq(const ::Test::DoubleBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDoubleBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleBufferSeq(const ::Test::DoubleBuffer& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleBufferSeq(const ::Test::DoubleBuffer& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleBufferSeq(const ::Test::DoubleBuffer& inSeq, const ::Test::Callback_TestIntf_opDoubleBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleBufferSeq(const ::Test::DoubleBuffer& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opDoubleBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleBufferSeq(inSeq, context, cb, cookie);
    }

    ::Test::DoubleBuffer end_opDoubleBufferSeq(::Test::DoubleBuffer& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDoubleBufferSeq(::Test::DoubleBuffer& iceP_outSeq, ::Test::DoubleBuffer& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDoubleBufferSeq(const ::Test::DoubleBuffer&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_TestIntf_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_TestIntf_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class C : public virtual ::Ice::Object
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    virtual ~C();

    C()
    {
    }

#ifdef ICE_CPP11_COMPILER
    C(const C&) = default;
    C& operator=(const C&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_C_init = ::Test::C::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const C& lhs, const C& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const C& lhs, const C& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class TestIntf : public virtual ::Ice::Object
{
public:

    typedef TestIntfPrx ProxyType;
    typedef TestIntfPtr PointerType;

    virtual ~TestIntf();

#ifdef ICE_CPP11_COMPILER
    TestIntf() = default;
    TestIntf(const TestIntf&) = default;
    TestIntf& operator=(const TestIntf&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual CSeq opCSeq(const CSeq& inSeq, CSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual CArray opCArray(const CArray& inSeq, CArray& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual CList opCList(const CList& inSeq, CList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BoolSeq opBoolSeq(const BoolSeq& inSeq, BoolSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteSeq opByteSeq(const ByteSeq& inSeq, ByteSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ShortSeq opShortSeq(const ShortSeq& inSeq, ShortSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual IntSeq opIntSeq(const IntSeq& inSeq, IntSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LongSeq opLongSeq(const LongSeq& inSeq, LongSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual FloatSeq opFloatSeq(const FloatSeq& inSeq, FloatSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual DoubleSeq opDoubleSeq(const DoubleSeq& inSeq, DoubleSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringSeq opStringSeq(const StringSeq& inSeq, StringSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ESeq opESeq(const ESeq& inSeq, ESeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opESeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SSeq opSSeq(const SSeq& inSeq, SSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual DSeq opDSeq(const DSeq& inSeq, DSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringSeqSeq opStringSeqSeq(const StringSeqSeq& inSeq, StringSeqSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeqSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteBuffer opByteBufferSeq(const ByteBuffer& inSeq, ByteBuffer& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ShortBuffer opShortBufferSeq(const ShortBuffer& inSeq, ShortBuffer& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual IntBuffer opIntBufferSeq(const IntBuffer& inSeq, IntBuffer& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LongBuffer opLongBufferSeq(const LongBuffer& inSeq, LongBuffer& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual FloatBuffer opFloatBufferSeq(const FloatBuffer& inSeq, FloatBuffer& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual DoubleBuffer opDoubleBufferSeq(const DoubleBuffer& inSeq, DoubleBuffer& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const TestIntf& lhs, const TestIntf& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const TestIntf& lhs, const TestIntf& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::E>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::S, S>
{
    static void write(S* ostr, const ::Test::S& v)
    {
        ostr->write(v.en);
    }
};

template<typename S>
struct StreamReader< ::Test::S, S>
{
    static void read(S* istr, ::Test::S& v)
    {
        istr->read(v.en);
    }
};

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCSeq.
 */
template<class T>
class CallbackNC_TestIntf_opCSeq : public Callback_TestIntf_opCSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CSeq&, const CSeq&);

    CallbackNC_TestIntf_opCSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CSeq iceP_outSeq;
        CSeq ret;
        try
        {
            ret = proxy->end_opCSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const CSeq&, const CSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(T* instance, void (T::*cb)(const CSeq&, const CSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opCSeq : public Callback_TestIntf_opCSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CSeq&, const CSeq&, const CT&);

    Callback_TestIntf_opCSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CSeq iceP_outSeq;
        CSeq ret;
        try
        {
            ret = proxy->end_opCSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T, typename CT> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const CSeq&, const CSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T, typename CT> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(T* instance, void (T::*cb)(const CSeq&, const CSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opCArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCArray.
 */
template<class T>
class CallbackNC_TestIntf_opCArray : public Callback_TestIntf_opCArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CArray&, const CArray&);

    CallbackNC_TestIntf_opCArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CArray iceP_outSeq;
        CArray ret;
        try
        {
            ret = proxy->end_opCArray(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCArray.
 */
template<class T> Callback_TestIntf_opCArrayPtr
newCallback_TestIntf_opCArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const CArray&, const CArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCArray<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCArray.
 */
template<class T> Callback_TestIntf_opCArrayPtr
newCallback_TestIntf_opCArray(T* instance, void (T::*cb)(const CArray&, const CArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCArray<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opCArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCArray.
 */
template<class T, typename CT>
class Callback_TestIntf_opCArray : public Callback_TestIntf_opCArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CArray&, const CArray&, const CT&);

    Callback_TestIntf_opCArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CArray iceP_outSeq;
        CArray ret;
        try
        {
            ret = proxy->end_opCArray(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCArray.
 */
template<class T, typename CT> Callback_TestIntf_opCArrayPtr
newCallback_TestIntf_opCArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const CArray&, const CArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCArray.
 */
template<class T, typename CT> Callback_TestIntf_opCArrayPtr
newCallback_TestIntf_opCArray(T* instance, void (T::*cb)(const CArray&, const CArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCList.
 */
template<class T>
class CallbackNC_TestIntf_opCList : public Callback_TestIntf_opCList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CList&, const CList&);

    CallbackNC_TestIntf_opCList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CList iceP_outSeq;
        CList ret;
        try
        {
            ret = proxy->end_opCList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(const IceUtil::Handle<T>& instance, void (T::*cb)(const CList&, const CList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(T* instance, void (T::*cb)(const CList&, const CList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCList.
 */
template<class T, typename CT>
class Callback_TestIntf_opCList : public Callback_TestIntf_opCList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CList&, const CList&, const CT&);

    Callback_TestIntf_opCList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CList iceP_outSeq;
        CList ret;
        try
        {
            ret = proxy->end_opCList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T, typename CT> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(const IceUtil::Handle<T>& instance, void (T::*cb)(const CList&, const CList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T, typename CT> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(T* instance, void (T::*cb)(const CList&, const CList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolSeq.
 */
template<class T>
class CallbackNC_TestIntf_opBoolSeq : public Callback_TestIntf_opBoolSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BoolSeq&, const BoolSeq&);

    CallbackNC_TestIntf_opBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BoolSeq iceP_outSeq;
        BoolSeq ret;
        try
        {
            ret = proxy->end_opBoolSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolSeq&, const BoolSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(T* instance, void (T::*cb)(const BoolSeq&, const BoolSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolSeq : public Callback_TestIntf_opBoolSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BoolSeq&, const BoolSeq&, const CT&);

    Callback_TestIntf_opBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BoolSeq iceP_outSeq;
        BoolSeq ret;
        try
        {
            ret = proxy->end_opBoolSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T, typename CT> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolSeq&, const BoolSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T, typename CT> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(T* instance, void (T::*cb)(const BoolSeq&, const BoolSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteSeq.
 */
template<class T>
class CallbackNC_TestIntf_opByteSeq : public Callback_TestIntf_opByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ByteSeq&, const ByteSeq&);

    CallbackNC_TestIntf_opByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ByteSeq iceP_outSeq;
        ByteSeq ret;
        try
        {
            ret = proxy->end_opByteSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteSeq&, const ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(T* instance, void (T::*cb)(const ByteSeq&, const ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opByteSeq : public Callback_TestIntf_opByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ByteSeq&, const ByteSeq&, const CT&);

    Callback_TestIntf_opByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ByteSeq iceP_outSeq;
        ByteSeq ret;
        try
        {
            ret = proxy->end_opByteSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteSeq&, const ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(T* instance, void (T::*cb)(const ByteSeq&, const ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opShortSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortSeq.
 */
template<class T>
class CallbackNC_TestIntf_opShortSeq : public Callback_TestIntf_opShortSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ShortSeq&, const ShortSeq&);

    CallbackNC_TestIntf_opShortSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ShortSeq iceP_outSeq;
        ShortSeq ret;
        try
        {
            ret = proxy->end_opShortSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortSeq.
 */
template<class T> Callback_TestIntf_opShortSeqPtr
newCallback_TestIntf_opShortSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortSeq&, const ShortSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opShortSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortSeq.
 */
template<class T> Callback_TestIntf_opShortSeqPtr
newCallback_TestIntf_opShortSeq(T* instance, void (T::*cb)(const ShortSeq&, const ShortSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opShortSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opShortSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opShortSeq : public Callback_TestIntf_opShortSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ShortSeq&, const ShortSeq&, const CT&);

    Callback_TestIntf_opShortSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ShortSeq iceP_outSeq;
        ShortSeq ret;
        try
        {
            ret = proxy->end_opShortSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortSeq.
 */
template<class T, typename CT> Callback_TestIntf_opShortSeqPtr
newCallback_TestIntf_opShortSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortSeq&, const ShortSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opShortSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortSeq.
 */
template<class T, typename CT> Callback_TestIntf_opShortSeqPtr
newCallback_TestIntf_opShortSeq(T* instance, void (T::*cb)(const ShortSeq&, const ShortSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opShortSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opIntSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntSeq.
 */
template<class T>
class CallbackNC_TestIntf_opIntSeq : public Callback_TestIntf_opIntSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IntSeq&, const IntSeq&);

    CallbackNC_TestIntf_opIntSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        IntSeq iceP_outSeq;
        IntSeq ret;
        try
        {
            ret = proxy->end_opIntSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntSeq.
 */
template<class T> Callback_TestIntf_opIntSeqPtr
newCallback_TestIntf_opIntSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntSeq&, const IntSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opIntSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntSeq.
 */
template<class T> Callback_TestIntf_opIntSeqPtr
newCallback_TestIntf_opIntSeq(T* instance, void (T::*cb)(const IntSeq&, const IntSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opIntSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opIntSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opIntSeq : public Callback_TestIntf_opIntSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IntSeq&, const IntSeq&, const CT&);

    Callback_TestIntf_opIntSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        IntSeq iceP_outSeq;
        IntSeq ret;
        try
        {
            ret = proxy->end_opIntSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntSeq.
 */
template<class T, typename CT> Callback_TestIntf_opIntSeqPtr
newCallback_TestIntf_opIntSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntSeq&, const IntSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opIntSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntSeq.
 */
template<class T, typename CT> Callback_TestIntf_opIntSeqPtr
newCallback_TestIntf_opIntSeq(T* instance, void (T::*cb)(const IntSeq&, const IntSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opIntSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opLongSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opLongSeq.
 */
template<class T>
class CallbackNC_TestIntf_opLongSeq : public Callback_TestIntf_opLongSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LongSeq&, const LongSeq&);

    CallbackNC_TestIntf_opLongSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        LongSeq iceP_outSeq;
        LongSeq ret;
        try
        {
            ret = proxy->end_opLongSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongSeq.
 */
template<class T> Callback_TestIntf_opLongSeqPtr
newCallback_TestIntf_opLongSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongSeq&, const LongSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opLongSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongSeq.
 */
template<class T> Callback_TestIntf_opLongSeqPtr
newCallback_TestIntf_opLongSeq(T* instance, void (T::*cb)(const LongSeq&, const LongSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opLongSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opLongSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opLongSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opLongSeq : public Callback_TestIntf_opLongSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LongSeq&, const LongSeq&, const CT&);

    Callback_TestIntf_opLongSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        LongSeq iceP_outSeq;
        LongSeq ret;
        try
        {
            ret = proxy->end_opLongSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongSeq.
 */
template<class T, typename CT> Callback_TestIntf_opLongSeqPtr
newCallback_TestIntf_opLongSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongSeq&, const LongSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opLongSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongSeq.
 */
template<class T, typename CT> Callback_TestIntf_opLongSeqPtr
newCallback_TestIntf_opLongSeq(T* instance, void (T::*cb)(const LongSeq&, const LongSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opLongSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opFloatSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFloatSeq.
 */
template<class T>
class CallbackNC_TestIntf_opFloatSeq : public Callback_TestIntf_opFloatSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const FloatSeq&, const FloatSeq&);

    CallbackNC_TestIntf_opFloatSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        FloatSeq iceP_outSeq;
        FloatSeq ret;
        try
        {
            ret = proxy->end_opFloatSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatSeq.
 */
template<class T> Callback_TestIntf_opFloatSeqPtr
newCallback_TestIntf_opFloatSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const FloatSeq&, const FloatSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFloatSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatSeq.
 */
template<class T> Callback_TestIntf_opFloatSeqPtr
newCallback_TestIntf_opFloatSeq(T* instance, void (T::*cb)(const FloatSeq&, const FloatSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFloatSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opFloatSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFloatSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opFloatSeq : public Callback_TestIntf_opFloatSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const FloatSeq&, const FloatSeq&, const CT&);

    Callback_TestIntf_opFloatSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        FloatSeq iceP_outSeq;
        FloatSeq ret;
        try
        {
            ret = proxy->end_opFloatSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatSeq.
 */
template<class T, typename CT> Callback_TestIntf_opFloatSeqPtr
newCallback_TestIntf_opFloatSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const FloatSeq&, const FloatSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFloatSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatSeq.
 */
template<class T, typename CT> Callback_TestIntf_opFloatSeqPtr
newCallback_TestIntf_opFloatSeq(T* instance, void (T::*cb)(const FloatSeq&, const FloatSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFloatSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleSeq.
 */
template<class T>
class CallbackNC_TestIntf_opDoubleSeq : public Callback_TestIntf_opDoubleSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const DoubleSeq&, const DoubleSeq&);

    CallbackNC_TestIntf_opDoubleSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DoubleSeq iceP_outSeq;
        DoubleSeq ret;
        try
        {
            ret = proxy->end_opDoubleSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleSeq.
 */
template<class T> Callback_TestIntf_opDoubleSeqPtr
newCallback_TestIntf_opDoubleSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const DoubleSeq&, const DoubleSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDoubleSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleSeq.
 */
template<class T> Callback_TestIntf_opDoubleSeqPtr
newCallback_TestIntf_opDoubleSeq(T* instance, void (T::*cb)(const DoubleSeq&, const DoubleSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDoubleSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opDoubleSeq : public Callback_TestIntf_opDoubleSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const DoubleSeq&, const DoubleSeq&, const CT&);

    Callback_TestIntf_opDoubleSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DoubleSeq iceP_outSeq;
        DoubleSeq ret;
        try
        {
            ret = proxy->end_opDoubleSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDoubleSeqPtr
newCallback_TestIntf_opDoubleSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const DoubleSeq&, const DoubleSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDoubleSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDoubleSeqPtr
newCallback_TestIntf_opDoubleSeq(T* instance, void (T::*cb)(const DoubleSeq&, const DoubleSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDoubleSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeq.
 */
template<class T>
class CallbackNC_TestIntf_opStringSeq : public Callback_TestIntf_opStringSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringSeq&, const StringSeq&);

    CallbackNC_TestIntf_opStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringSeq iceP_outSeq;
        StringSeq ret;
        try
        {
            ret = proxy->end_opStringSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringSeq&, const StringSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(T* instance, void (T::*cb)(const StringSeq&, const StringSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opStringSeq : public Callback_TestIntf_opStringSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringSeq&, const StringSeq&, const CT&);

    Callback_TestIntf_opStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringSeq iceP_outSeq;
        StringSeq ret;
        try
        {
            ret = proxy->end_opStringSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringSeq&, const StringSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(T* instance, void (T::*cb)(const StringSeq&, const StringSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opESeq.
 */
template<class T>
class CallbackNC_TestIntf_opESeq : public Callback_TestIntf_opESeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ESeq&, const ESeq&);

    CallbackNC_TestIntf_opESeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ESeq iceP_outSeq;
        ESeq ret;
        try
        {
            ret = proxy->end_opESeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ESeq&, const ESeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opESeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(T* instance, void (T::*cb)(const ESeq&, const ESeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opESeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opESeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opESeq : public Callback_TestIntf_opESeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ESeq&, const ESeq&, const CT&);

    Callback_TestIntf_opESeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ESeq iceP_outSeq;
        ESeq ret;
        try
        {
            ret = proxy->end_opESeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T, typename CT> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ESeq&, const ESeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opESeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T, typename CT> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(T* instance, void (T::*cb)(const ESeq&, const ESeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opESeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opSSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opSSeq.
 */
template<class T>
class CallbackNC_TestIntf_opSSeq : public Callback_TestIntf_opSSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SSeq&, const SSeq&);

    CallbackNC_TestIntf_opSSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SSeq iceP_outSeq;
        SSeq ret;
        try
        {
            ret = proxy->end_opSSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opSSeq.
 */
template<class T> Callback_TestIntf_opSSeqPtr
newCallback_TestIntf_opSSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const SSeq&, const SSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opSSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opSSeq.
 */
template<class T> Callback_TestIntf_opSSeqPtr
newCallback_TestIntf_opSSeq(T* instance, void (T::*cb)(const SSeq&, const SSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opSSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opSSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opSSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opSSeq : public Callback_TestIntf_opSSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SSeq&, const SSeq&, const CT&);

    Callback_TestIntf_opSSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SSeq iceP_outSeq;
        SSeq ret;
        try
        {
            ret = proxy->end_opSSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opSSeq.
 */
template<class T, typename CT> Callback_TestIntf_opSSeqPtr
newCallback_TestIntf_opSSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const SSeq&, const SSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opSSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opSSeq.
 */
template<class T, typename CT> Callback_TestIntf_opSSeqPtr
newCallback_TestIntf_opSSeq(T* instance, void (T::*cb)(const SSeq&, const SSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opSSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opDSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDSeq.
 */
template<class T>
class CallbackNC_TestIntf_opDSeq : public Callback_TestIntf_opDSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const DSeq&, const DSeq&);

    CallbackNC_TestIntf_opDSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DSeq iceP_outSeq;
        DSeq ret;
        try
        {
            ret = proxy->end_opDSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDSeq.
 */
template<class T> Callback_TestIntf_opDSeqPtr
newCallback_TestIntf_opDSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const DSeq&, const DSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDSeq.
 */
template<class T> Callback_TestIntf_opDSeqPtr
newCallback_TestIntf_opDSeq(T* instance, void (T::*cb)(const DSeq&, const DSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opDSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opDSeq : public Callback_TestIntf_opDSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const DSeq&, const DSeq&, const CT&);

    Callback_TestIntf_opDSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DSeq iceP_outSeq;
        DSeq ret;
        try
        {
            ret = proxy->end_opDSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDSeqPtr
newCallback_TestIntf_opDSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const DSeq&, const DSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDSeqPtr
newCallback_TestIntf_opDSeq(T* instance, void (T::*cb)(const DSeq&, const DSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeqSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeqSeq.
 */
template<class T>
class CallbackNC_TestIntf_opStringSeqSeq : public Callback_TestIntf_opStringSeqSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringSeqSeq&, const StringSeqSeq&);

    CallbackNC_TestIntf_opStringSeqSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringSeqSeq iceP_outSeq;
        StringSeqSeq ret;
        try
        {
            ret = proxy->end_opStringSeqSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeqSeq.
 */
template<class T> Callback_TestIntf_opStringSeqSeqPtr
newCallback_TestIntf_opStringSeqSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringSeqSeq&, const StringSeqSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringSeqSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeqSeq.
 */
template<class T> Callback_TestIntf_opStringSeqSeqPtr
newCallback_TestIntf_opStringSeqSeq(T* instance, void (T::*cb)(const StringSeqSeq&, const StringSeqSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringSeqSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeqSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeqSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opStringSeqSeq : public Callback_TestIntf_opStringSeqSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringSeqSeq&, const StringSeqSeq&, const CT&);

    Callback_TestIntf_opStringSeqSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringSeqSeq iceP_outSeq;
        StringSeqSeq ret;
        try
        {
            ret = proxy->end_opStringSeqSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeqSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringSeqSeqPtr
newCallback_TestIntf_opStringSeqSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringSeqSeq&, const StringSeqSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringSeqSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeqSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringSeqSeqPtr
newCallback_TestIntf_opStringSeqSeq(T* instance, void (T::*cb)(const StringSeqSeq&, const StringSeqSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringSeqSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opByteBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opByteBufferSeq : public Callback_TestIntf_opByteBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ByteBuffer&, const ByteBuffer&);

    CallbackNC_TestIntf_opByteBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ByteBuffer iceP_outSeq;
        ByteBuffer ret;
        try
        {
            ret = proxy->end_opByteBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteBufferSeq.
 */
template<class T> Callback_TestIntf_opByteBufferSeqPtr
newCallback_TestIntf_opByteBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteBuffer&, const ByteBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteBufferSeq.
 */
template<class T> Callback_TestIntf_opByteBufferSeqPtr
newCallback_TestIntf_opByteBufferSeq(T* instance, void (T::*cb)(const ByteBuffer&, const ByteBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opByteBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opByteBufferSeq : public Callback_TestIntf_opByteBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ByteBuffer&, const ByteBuffer&, const CT&);

    Callback_TestIntf_opByteBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ByteBuffer iceP_outSeq;
        ByteBuffer ret;
        try
        {
            ret = proxy->end_opByteBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opByteBufferSeqPtr
newCallback_TestIntf_opByteBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteBuffer&, const ByteBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opByteBufferSeqPtr
newCallback_TestIntf_opByteBufferSeq(T* instance, void (T::*cb)(const ByteBuffer&, const ByteBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opShortBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opShortBufferSeq : public Callback_TestIntf_opShortBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ShortBuffer&, const ShortBuffer&);

    CallbackNC_TestIntf_opShortBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ShortBuffer iceP_outSeq;
        ShortBuffer ret;
        try
        {
            ret = proxy->end_opShortBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBufferSeq.
 */
template<class T> Callback_TestIntf_opShortBufferSeqPtr
newCallback_TestIntf_opShortBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opShortBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBufferSeq.
 */
template<class T> Callback_TestIntf_opShortBufferSeqPtr
newCallback_TestIntf_opShortBufferSeq(T* instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opShortBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opShortBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opShortBufferSeq : public Callback_TestIntf_opShortBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ShortBuffer&, const ShortBuffer&, const CT&);

    Callback_TestIntf_opShortBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ShortBuffer iceP_outSeq;
        ShortBuffer ret;
        try
        {
            ret = proxy->end_opShortBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opShortBufferSeqPtr
newCallback_TestIntf_opShortBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opShortBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opShortBufferSeqPtr
newCallback_TestIntf_opShortBufferSeq(T* instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opShortBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opIntBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opIntBufferSeq : public Callback_TestIntf_opIntBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IntBuffer&, const IntBuffer&);

    CallbackNC_TestIntf_opIntBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        IntBuffer iceP_outSeq;
        IntBuffer ret;
        try
        {
            ret = proxy->end_opIntBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntBufferSeq.
 */
template<class T> Callback_TestIntf_opIntBufferSeqPtr
newCallback_TestIntf_opIntBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntBuffer&, const IntBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opIntBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntBufferSeq.
 */
template<class T> Callback_TestIntf_opIntBufferSeqPtr
newCallback_TestIntf_opIntBufferSeq(T* instance, void (T::*cb)(const IntBuffer&, const IntBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opIntBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opIntBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opIntBufferSeq : public Callback_TestIntf_opIntBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IntBuffer&, const IntBuffer&, const CT&);

    Callback_TestIntf_opIntBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        IntBuffer iceP_outSeq;
        IntBuffer ret;
        try
        {
            ret = proxy->end_opIntBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opIntBufferSeqPtr
newCallback_TestIntf_opIntBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntBuffer&, const IntBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opIntBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opIntBufferSeqPtr
newCallback_TestIntf_opIntBufferSeq(T* instance, void (T::*cb)(const IntBuffer&, const IntBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opIntBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opLongBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opLongBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opLongBufferSeq : public Callback_TestIntf_opLongBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LongBuffer&, const LongBuffer&);

    CallbackNC_TestIntf_opLongBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        LongBuffer iceP_outSeq;
        LongBuffer ret;
        try
        {
            ret = proxy->end_opLongBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongBufferSeq.
 */
template<class T> Callback_TestIntf_opLongBufferSeqPtr
newCallback_TestIntf_opLongBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongBuffer&, const LongBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opLongBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongBufferSeq.
 */
template<class T> Callback_TestIntf_opLongBufferSeqPtr
newCallback_TestIntf_opLongBufferSeq(T* instance, void (T::*cb)(const LongBuffer&, const LongBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opLongBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opLongBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opLongBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opLongBufferSeq : public Callback_TestIntf_opLongBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LongBuffer&, const LongBuffer&, const CT&);

    Callback_TestIntf_opLongBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        LongBuffer iceP_outSeq;
        LongBuffer ret;
        try
        {
            ret = proxy->end_opLongBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opLongBufferSeqPtr
newCallback_TestIntf_opLongBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongBuffer&, const LongBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opLongBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opLongBufferSeqPtr
newCallback_TestIntf_opLongBufferSeq(T* instance, void (T::*cb)(const LongBuffer&, const LongBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opLongBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opFloatBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFloatBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opFloatBufferSeq : public Callback_TestIntf_opFloatBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const FloatBuffer&, const FloatBuffer&);

    CallbackNC_TestIntf_opFloatBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        FloatBuffer iceP_outSeq;
        FloatBuffer ret;
        try
        {
            ret = proxy->end_opFloatBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatBufferSeq.
 */
template<class T> Callback_TestIntf_opFloatBufferSeqPtr
newCallback_TestIntf_opFloatBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const FloatBuffer&, const FloatBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFloatBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatBufferSeq.
 */
template<class T> Callback_TestIntf_opFloatBufferSeqPtr
newCallback_TestIntf_opFloatBufferSeq(T* instance, void (T::*cb)(const FloatBuffer&, const FloatBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFloatBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opFloatBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFloatBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opFloatBufferSeq : public Callback_TestIntf_opFloatBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const FloatBuffer&, const FloatBuffer&, const CT&);

    Callback_TestIntf_opFloatBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        FloatBuffer iceP_outSeq;
        FloatBuffer ret;
        try
        {
            ret = proxy->end_opFloatBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opFloatBufferSeqPtr
newCallback_TestIntf_opFloatBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const FloatBuffer&, const FloatBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFloatBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opFloatBufferSeqPtr
newCallback_TestIntf_opFloatBufferSeq(T* instance, void (T::*cb)(const FloatBuffer&, const FloatBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFloatBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opDoubleBufferSeq : public Callback_TestIntf_opDoubleBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const DoubleBuffer&, const DoubleBuffer&);

    CallbackNC_TestIntf_opDoubleBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DoubleBuffer iceP_outSeq;
        DoubleBuffer ret;
        try
        {
            ret = proxy->end_opDoubleBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleBufferSeq.
 */
template<class T> Callback_TestIntf_opDoubleBufferSeqPtr
newCallback_TestIntf_opDoubleBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const DoubleBuffer&, const DoubleBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDoubleBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleBufferSeq.
 */
template<class T> Callback_TestIntf_opDoubleBufferSeqPtr
newCallback_TestIntf_opDoubleBufferSeq(T* instance, void (T::*cb)(const DoubleBuffer&, const DoubleBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDoubleBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opDoubleBufferSeq : public Callback_TestIntf_opDoubleBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const DoubleBuffer&, const DoubleBuffer&, const CT&);

    Callback_TestIntf_opDoubleBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DoubleBuffer iceP_outSeq;
        DoubleBuffer ret;
        try
        {
            ret = proxy->end_opDoubleBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDoubleBufferSeqPtr
newCallback_TestIntf_opDoubleBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const DoubleBuffer&, const DoubleBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDoubleBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDoubleBufferSeqPtr
newCallback_TestIntf_opDoubleBufferSeq(T* instance, void (T::*cb)(const DoubleBuffer&, const DoubleBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDoubleBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
template<class T>
class CallbackNC_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
template<class T, typename CT>
class Callback_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
