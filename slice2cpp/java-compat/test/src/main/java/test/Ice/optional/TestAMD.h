//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __TestAMD_h__
#define __TestAMD_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include <Ice/SlicedDataF.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class OneOptional;
class MultiOptional;
class A;
class B;
class C;
class WD;
class OptionalWithCustom;
class E;
class F;
class G1;
class G2;
class G;
class Recursive;
class Initial;
class InitialPrx;

}

namespace Test
{

enum class MyEnum : unsigned char
{
    MyEnumMember
};

struct SmallStruct
{
    ::Ice::Byte m;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Ice::Byte&> ice_tuple() const
    {
        return std::tie(m);
    }
};

struct FixedStruct
{
    int m;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(m);
    }
};

struct VarStruct
{
    ::std::string m;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(m);
    }
};

struct ClassVarStruct
{
    int a;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(a);
    }
};

using ByteSeq = ::std::vector<::Ice::Byte>;

using BoolSeq = ::std::vector<bool>;

using ShortSeq = ::std::vector<short>;

using IntSeq = ::std::vector<int>;

using LongSeq = ::std::vector<long long int>;

using FloatSeq = ::std::vector<float>;

using DoubleSeq = ::std::vector<double>;

using StringSeq = ::std::vector<::std::string>;

using MyEnumSeq = ::std::vector<MyEnum>;

using SmallStructSeq = ::std::vector<SmallStruct>;

using SmallStructList = ::std::vector<SmallStruct>;

using FixedStructSeq = ::std::vector<FixedStruct>;

using FixedStructList = ::std::vector<FixedStruct>;

using VarStructSeq = ::std::vector<VarStruct>;

using OneOptionalSeq = ::std::vector<::std::shared_ptr<OneOptional>>;

using OneOptionalPrxSeq = ::std::vector<::std::shared_ptr<::Ice::ObjectPrx>>;

using Serializable = ::std::vector<::Ice::Byte>;

using IntIntDict = ::std::map<int, int>;

using StringIntDict = ::std::map<::std::string, int>;

using IntEnumDict = ::std::map<int, MyEnum>;

using IntFixedStructDict = ::std::map<int, FixedStruct>;

using IntVarStructDict = ::std::map<int, VarStruct>;

using IntOneOptionalDict = ::std::map<int, ::std::shared_ptr<OneOptional>>;

using IntOneOptionalPrxDict = ::std::map<int, ::std::shared_ptr<::Ice::ObjectPrx>>;

class OptionalException : public ::Ice::UserExceptionHelper<OptionalException, ::Ice::UserException>
{
public:

    virtual ~OptionalException();

    OptionalException(const OptionalException&) = default;

    OptionalException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalException(bool req, const Ice::optional<int>& a, const Ice::optional<::std::string>& b, const Ice::optional<::std::shared_ptr<OneOptional>>& o) :
        req(req),
        a(a),
        b(b),
        o(o)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const Ice::optional<int>&, const Ice::optional<::std::string>&, const Ice::optional<::std::shared_ptr<::Test::OneOptional>>&> ice_tuple() const
    {
        return std::tie(req, a, b, o);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    bool req = false;
    Ice::optional<int> a = 5;
    Ice::optional<::std::string> b;
    Ice::optional<::std::shared_ptr<::Test::OneOptional>> o;
};

/// \cond INTERNAL
static OptionalException _iceS_OptionalException_init;
/// \endcond

class DerivedException : public ::Ice::UserExceptionHelper<DerivedException, OptionalException>
{
public:

    virtual ~DerivedException();

    DerivedException(const DerivedException&) = default;

    DerivedException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    DerivedException(bool req, const Ice::optional<int>& a, const Ice::optional<::std::string>& b, const Ice::optional<::std::shared_ptr<OneOptional>>& o, const ::std::string& d1, const Ice::optional<::std::string>& ss, const Ice::optional<::std::shared_ptr<OneOptional>>& o2, const ::std::string& d2) :
        ::Ice::UserExceptionHelper<DerivedException, OptionalException>(req, a, b, o),
        d1(d1),
        ss(ss),
        o2(o2),
        d2(d2)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const Ice::optional<int>&, const Ice::optional<::std::string>&, const Ice::optional<::std::shared_ptr<::Test::OneOptional>>&, const ::std::string&, const Ice::optional<::std::string>&, const Ice::optional<::std::shared_ptr<::Test::OneOptional>>&, const ::std::string&> ice_tuple() const
    {
        return std::tie(req, a, b, o, d1, ss, o2, d2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string d1;
    Ice::optional<::std::string> ss{"test"};
    Ice::optional<::std::shared_ptr<::Test::OneOptional>> o2;
    ::std::string d2;
};

class RequiredException : public ::Ice::UserExceptionHelper<RequiredException, OptionalException>
{
public:

    virtual ~RequiredException();

    RequiredException(const RequiredException&) = default;

    RequiredException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    RequiredException(bool req, const Ice::optional<int>& a, const Ice::optional<::std::string>& b, const Ice::optional<::std::shared_ptr<OneOptional>>& o, const ::std::string& ss, const ::std::shared_ptr<OneOptional>& o2) :
        ::Ice::UserExceptionHelper<RequiredException, OptionalException>(req, a, b, o),
        ss(ss),
        o2(o2)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const Ice::optional<int>&, const Ice::optional<::std::string>&, const Ice::optional<::std::shared_ptr<::Test::OneOptional>>&, const ::std::string&, const ::std::shared_ptr<::Test::OneOptional>&> ice_tuple() const
    {
        return std::tie(req, a, b, o, ss, o2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::string ss = "test";
    ::std::shared_ptr<::Test::OneOptional> o2;
};

using RecursiveSeq = ::std::vector<::std::shared_ptr<Recursive>>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class Initial : public virtual ::Ice::Object
{
public:

    using ProxyType = InitialPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pingPongAsync(::std::shared_ptr<::Ice::Value> o, ::std::function<void(const ::std::shared_ptr<::Ice::Value>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pingPong(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOptionalExceptionAsync(Ice::optional<int> a, Ice::optional<::std::string> b, Ice::optional<::std::shared_ptr<OneOptional>> o, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptionalException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opDerivedExceptionAsync(Ice::optional<int> a, Ice::optional<::std::string> b, Ice::optional<::std::shared_ptr<OneOptional>> o, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDerivedException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opRequiredExceptionAsync(Ice::optional<int> a, Ice::optional<::std::string> b, Ice::optional<::std::shared_ptr<OneOptional>> o, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opRequiredException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByte.
     */
    struct OpByteResult
    {
        Ice::optional<::Ice::Byte> returnValue;
        Ice::optional<::Ice::Byte> p3;
    };

    virtual void opByteAsync(Ice::optional<::Ice::Byte> p1, ::std::function<void(const Ice::optional<::Ice::Byte>& returnValue, const Ice::optional<::Ice::Byte>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByte(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteReq.
     */
    struct OpByteReqResult
    {
        Ice::optional<::Ice::Byte> returnValue;
        Ice::optional<::Ice::Byte> p3;
    };

    virtual void opByteReqAsync(Ice::optional<::Ice::Byte> p1, ::std::function<void(const Ice::optional<::Ice::Byte>& returnValue, const Ice::optional<::Ice::Byte>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBool.
     */
    struct OpBoolResult
    {
        Ice::optional<bool> returnValue;
        Ice::optional<bool> p3;
    };

    virtual void opBoolAsync(Ice::optional<bool> p1, ::std::function<void(const Ice::optional<bool>& returnValue, const Ice::optional<bool>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBool(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolReq.
     */
    struct OpBoolReqResult
    {
        Ice::optional<bool> returnValue;
        Ice::optional<bool> p3;
    };

    virtual void opBoolReqAsync(Ice::optional<bool> p1, ::std::function<void(const Ice::optional<bool>& returnValue, const Ice::optional<bool>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShort.
     */
    struct OpShortResult
    {
        Ice::optional<short> returnValue;
        Ice::optional<short> p3;
    };

    virtual void opShortAsync(Ice::optional<short> p1, ::std::function<void(const Ice::optional<short>& returnValue, const Ice::optional<short>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShort(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortReq.
     */
    struct OpShortReqResult
    {
        Ice::optional<short> returnValue;
        Ice::optional<short> p3;
    };

    virtual void opShortReqAsync(Ice::optional<short> p1, ::std::function<void(const Ice::optional<short>& returnValue, const Ice::optional<short>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opInt.
     */
    struct OpIntResult
    {
        Ice::optional<int> returnValue;
        Ice::optional<int> p3;
    };

    virtual void opIntAsync(Ice::optional<int> p1, ::std::function<void(const Ice::optional<int>& returnValue, const Ice::optional<int>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opInt(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntReq.
     */
    struct OpIntReqResult
    {
        Ice::optional<int> returnValue;
        Ice::optional<int> p3;
    };

    virtual void opIntReqAsync(Ice::optional<int> p1, ::std::function<void(const Ice::optional<int>& returnValue, const Ice::optional<int>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLong.
     */
    struct OpLongResult
    {
        Ice::optional<long long int> returnValue;
        Ice::optional<long long int> p3;
    };

    virtual void opLongAsync(Ice::optional<long long int> p1, ::std::function<void(const Ice::optional<long long int>& returnValue, const Ice::optional<long long int>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLong(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongReq.
     */
    struct OpLongReqResult
    {
        Ice::optional<long long int> returnValue;
        Ice::optional<long long int> p3;
    };

    virtual void opLongReqAsync(Ice::optional<long long int> p1, ::std::function<void(const Ice::optional<long long int>& returnValue, const Ice::optional<long long int>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloat.
     */
    struct OpFloatResult
    {
        Ice::optional<float> returnValue;
        Ice::optional<float> p3;
    };

    virtual void opFloatAsync(Ice::optional<float> p1, ::std::function<void(const Ice::optional<float>& returnValue, const Ice::optional<float>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloat(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatReq.
     */
    struct OpFloatReqResult
    {
        Ice::optional<float> returnValue;
        Ice::optional<float> p3;
    };

    virtual void opFloatReqAsync(Ice::optional<float> p1, ::std::function<void(const Ice::optional<float>& returnValue, const Ice::optional<float>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDouble.
     */
    struct OpDoubleResult
    {
        Ice::optional<double> returnValue;
        Ice::optional<double> p3;
    };

    virtual void opDoubleAsync(Ice::optional<double> p1, ::std::function<void(const Ice::optional<double>& returnValue, const Ice::optional<double>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDouble(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDoubleReq.
     */
    struct OpDoubleReqResult
    {
        Ice::optional<double> returnValue;
        Ice::optional<double> p3;
    };

    virtual void opDoubleReqAsync(Ice::optional<double> p1, ::std::function<void(const Ice::optional<double>& returnValue, const Ice::optional<double>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opString.
     */
    struct OpStringResult
    {
        Ice::optional<::std::string> returnValue;
        Ice::optional<::std::string> p3;
    };

    virtual void opStringAsync(Ice::optional<::std::string> p1, ::std::function<void(const Ice::optional<::std::string>& returnValue, const Ice::optional<::std::string>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opString(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringReq.
     */
    struct OpStringReqResult
    {
        Ice::optional<::std::string> returnValue;
        Ice::optional<::std::string> p3;
    };

    virtual void opStringReqAsync(Ice::optional<::std::string> p1, ::std::function<void(const Ice::optional<::std::string>& returnValue, const Ice::optional<::std::string>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyEnum.
     */
    struct OpMyEnumResult
    {
        Ice::optional<MyEnum> returnValue;
        Ice::optional<MyEnum> p3;
    };

    virtual void opMyEnumAsync(Ice::optional<MyEnum> p1, ::std::function<void(const Ice::optional<MyEnum>& returnValue, const Ice::optional<MyEnum>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnum(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyEnumReq.
     */
    struct OpMyEnumReqResult
    {
        Ice::optional<MyEnum> returnValue;
        Ice::optional<MyEnum> p3;
    };

    virtual void opMyEnumReqAsync(Ice::optional<MyEnum> p1, ::std::function<void(const Ice::optional<MyEnum>& returnValue, const Ice::optional<MyEnum>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnumReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSmallStruct.
     */
    struct OpSmallStructResult
    {
        Ice::optional<SmallStruct> returnValue;
        Ice::optional<SmallStruct> p3;
    };

    virtual void opSmallStructAsync(Ice::optional<SmallStruct> p1, ::std::function<void(const Ice::optional<SmallStruct>& returnValue, const Ice::optional<SmallStruct>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSmallStructReq.
     */
    struct OpSmallStructReqResult
    {
        Ice::optional<SmallStruct> returnValue;
        Ice::optional<SmallStruct> p3;
    };

    virtual void opSmallStructReqAsync(Ice::optional<SmallStruct> p1, ::std::function<void(const Ice::optional<SmallStruct>& returnValue, const Ice::optional<SmallStruct>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStructReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedStruct.
     */
    struct OpFixedStructResult
    {
        Ice::optional<FixedStruct> returnValue;
        Ice::optional<FixedStruct> p3;
    };

    virtual void opFixedStructAsync(Ice::optional<FixedStruct> p1, ::std::function<void(const Ice::optional<FixedStruct>& returnValue, const Ice::optional<FixedStruct>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedStructReq.
     */
    struct OpFixedStructReqResult
    {
        Ice::optional<FixedStruct> returnValue;
        Ice::optional<FixedStruct> p3;
    };

    virtual void opFixedStructReqAsync(Ice::optional<FixedStruct> p1, ::std::function<void(const Ice::optional<FixedStruct>& returnValue, const Ice::optional<FixedStruct>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStructReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVarStruct.
     */
    struct OpVarStructResult
    {
        Ice::optional<VarStruct> returnValue;
        Ice::optional<VarStruct> p3;
    };

    virtual void opVarStructAsync(Ice::optional<VarStruct> p1, ::std::function<void(const Ice::optional<VarStruct>& returnValue, const Ice::optional<VarStruct>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVarStructReq.
     */
    struct OpVarStructReqResult
    {
        Ice::optional<VarStruct> returnValue;
        Ice::optional<VarStruct> p3;
    };

    virtual void opVarStructReqAsync(Ice::optional<VarStruct> p1, ::std::function<void(const Ice::optional<VarStruct>& returnValue, const Ice::optional<VarStruct>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarStructReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOneOptional.
     */
    struct OpOneOptionalResult
    {
        Ice::optional<::std::shared_ptr<OneOptional>> returnValue;
        Ice::optional<::std::shared_ptr<OneOptional>> p3;
    };

    virtual void opOneOptionalAsync(Ice::optional<::std::shared_ptr<OneOptional>> p1, ::std::function<void(const Ice::optional<::std::shared_ptr<OneOptional>>& returnValue, const Ice::optional<::std::shared_ptr<OneOptional>>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOneOptional(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOneOptionalReq.
     */
    struct OpOneOptionalReqResult
    {
        Ice::optional<::std::shared_ptr<OneOptional>> returnValue;
        Ice::optional<::std::shared_ptr<OneOptional>> p3;
    };

    virtual void opOneOptionalReqAsync(Ice::optional<::std::shared_ptr<OneOptional>> p1, ::std::function<void(const Ice::optional<::std::shared_ptr<OneOptional>>& returnValue, const Ice::optional<::std::shared_ptr<OneOptional>>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOneOptionalReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOneOptionalProxy.
     */
    struct OpOneOptionalProxyResult
    {
        Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>> returnValue;
        Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>> p3;
    };

    virtual void opOneOptionalProxyAsync(Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>> p1, ::std::function<void(const Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>& returnValue, const Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOneOptionalProxy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOneOptionalProxyReq.
     */
    struct OpOneOptionalProxyReqResult
    {
        Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>> returnValue;
        Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>> p3;
    };

    virtual void opOneOptionalProxyReqAsync(Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>> p1, ::std::function<void(const Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>& returnValue, const Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOneOptionalProxyReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteSeq.
     */
    struct OpByteSeqResult
    {
        Ice::optional<ByteSeq> returnValue;
        Ice::optional<ByteSeq> p3;
    };

    virtual void opByteSeqAsync(Ice::optional<ByteSeq> p1, ::std::function<void(const Ice::optional<ByteSeq>& returnValue, const Ice::optional<ByteSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteSeqReq.
     */
    struct OpByteSeqReqResult
    {
        Ice::optional<ByteSeq> returnValue;
        Ice::optional<ByteSeq> p3;
    };

    virtual void opByteSeqReqAsync(Ice::optional<ByteSeq> p1, ::std::function<void(const Ice::optional<ByteSeq>& returnValue, const Ice::optional<ByteSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolSeq.
     */
    struct OpBoolSeqResult
    {
        Ice::optional<BoolSeq> returnValue;
        Ice::optional<BoolSeq> p3;
    };

    virtual void opBoolSeqAsync(Ice::optional<BoolSeq> p1, ::std::function<void(const Ice::optional<BoolSeq>& returnValue, const Ice::optional<BoolSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolSeqReq.
     */
    struct OpBoolSeqReqResult
    {
        Ice::optional<BoolSeq> returnValue;
        Ice::optional<BoolSeq> p3;
    };

    virtual void opBoolSeqReqAsync(Ice::optional<BoolSeq> p1, ::std::function<void(const Ice::optional<BoolSeq>& returnValue, const Ice::optional<BoolSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortSeq.
     */
    struct OpShortSeqResult
    {
        Ice::optional<ShortSeq> returnValue;
        Ice::optional<ShortSeq> p3;
    };

    virtual void opShortSeqAsync(Ice::optional<ShortSeq> p1, ::std::function<void(const Ice::optional<ShortSeq>& returnValue, const Ice::optional<ShortSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortSeqReq.
     */
    struct OpShortSeqReqResult
    {
        Ice::optional<ShortSeq> returnValue;
        Ice::optional<ShortSeq> p3;
    };

    virtual void opShortSeqReqAsync(Ice::optional<ShortSeq> p1, ::std::function<void(const Ice::optional<ShortSeq>& returnValue, const Ice::optional<ShortSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntSeq.
     */
    struct OpIntSeqResult
    {
        Ice::optional<IntSeq> returnValue;
        Ice::optional<IntSeq> p3;
    };

    virtual void opIntSeqAsync(Ice::optional<IntSeq> p1, ::std::function<void(const Ice::optional<IntSeq>& returnValue, const Ice::optional<IntSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntSeqReq.
     */
    struct OpIntSeqReqResult
    {
        Ice::optional<IntSeq> returnValue;
        Ice::optional<IntSeq> p3;
    };

    virtual void opIntSeqReqAsync(Ice::optional<IntSeq> p1, ::std::function<void(const Ice::optional<IntSeq>& returnValue, const Ice::optional<IntSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongSeq.
     */
    struct OpLongSeqResult
    {
        Ice::optional<LongSeq> returnValue;
        Ice::optional<LongSeq> p3;
    };

    virtual void opLongSeqAsync(Ice::optional<LongSeq> p1, ::std::function<void(const Ice::optional<LongSeq>& returnValue, const Ice::optional<LongSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongSeqReq.
     */
    struct OpLongSeqReqResult
    {
        Ice::optional<LongSeq> returnValue;
        Ice::optional<LongSeq> p3;
    };

    virtual void opLongSeqReqAsync(Ice::optional<LongSeq> p1, ::std::function<void(const Ice::optional<LongSeq>& returnValue, const Ice::optional<LongSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatSeq.
     */
    struct OpFloatSeqResult
    {
        Ice::optional<FloatSeq> returnValue;
        Ice::optional<FloatSeq> p3;
    };

    virtual void opFloatSeqAsync(Ice::optional<FloatSeq> p1, ::std::function<void(const Ice::optional<FloatSeq>& returnValue, const Ice::optional<FloatSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatSeqReq.
     */
    struct OpFloatSeqReqResult
    {
        Ice::optional<FloatSeq> returnValue;
        Ice::optional<FloatSeq> p3;
    };

    virtual void opFloatSeqReqAsync(Ice::optional<FloatSeq> p1, ::std::function<void(const Ice::optional<FloatSeq>& returnValue, const Ice::optional<FloatSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDoubleSeq.
     */
    struct OpDoubleSeqResult
    {
        Ice::optional<DoubleSeq> returnValue;
        Ice::optional<DoubleSeq> p3;
    };

    virtual void opDoubleSeqAsync(Ice::optional<DoubleSeq> p1, ::std::function<void(const Ice::optional<DoubleSeq>& returnValue, const Ice::optional<DoubleSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDoubleSeqReq.
     */
    struct OpDoubleSeqReqResult
    {
        Ice::optional<DoubleSeq> returnValue;
        Ice::optional<DoubleSeq> p3;
    };

    virtual void opDoubleSeqReqAsync(Ice::optional<DoubleSeq> p1, ::std::function<void(const Ice::optional<DoubleSeq>& returnValue, const Ice::optional<DoubleSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSeq.
     */
    struct OpStringSeqResult
    {
        Ice::optional<StringSeq> returnValue;
        Ice::optional<StringSeq> p3;
    };

    virtual void opStringSeqAsync(Ice::optional<StringSeq> p1, ::std::function<void(const Ice::optional<StringSeq>& returnValue, const Ice::optional<StringSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSeqReq.
     */
    struct OpStringSeqReqResult
    {
        Ice::optional<StringSeq> returnValue;
        Ice::optional<StringSeq> p3;
    };

    virtual void opStringSeqReqAsync(Ice::optional<StringSeq> p1, ::std::function<void(const Ice::optional<StringSeq>& returnValue, const Ice::optional<StringSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSmallStructSeq.
     */
    struct OpSmallStructSeqResult
    {
        Ice::optional<SmallStructSeq> returnValue;
        Ice::optional<SmallStructSeq> p3;
    };

    virtual void opSmallStructSeqAsync(Ice::optional<SmallStructSeq> p1, ::std::function<void(const Ice::optional<SmallStructSeq>& returnValue, const Ice::optional<SmallStructSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStructSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSmallStructSeqReq.
     */
    struct OpSmallStructSeqReqResult
    {
        Ice::optional<SmallStructSeq> returnValue;
        Ice::optional<SmallStructSeq> p3;
    };

    virtual void opSmallStructSeqReqAsync(Ice::optional<SmallStructSeq> p1, ::std::function<void(const Ice::optional<SmallStructSeq>& returnValue, const Ice::optional<SmallStructSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStructSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSmallStructList.
     */
    struct OpSmallStructListResult
    {
        Ice::optional<SmallStructList> returnValue;
        Ice::optional<SmallStructList> p3;
    };

    virtual void opSmallStructListAsync(Ice::optional<SmallStructList> p1, ::std::function<void(const Ice::optional<SmallStructList>& returnValue, const Ice::optional<SmallStructList>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStructList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSmallStructListReq.
     */
    struct OpSmallStructListReqResult
    {
        Ice::optional<SmallStructList> returnValue;
        Ice::optional<SmallStructList> p3;
    };

    virtual void opSmallStructListReqAsync(Ice::optional<SmallStructList> p1, ::std::function<void(const Ice::optional<SmallStructList>& returnValue, const Ice::optional<SmallStructList>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStructListReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedStructSeq.
     */
    struct OpFixedStructSeqResult
    {
        Ice::optional<FixedStructSeq> returnValue;
        Ice::optional<FixedStructSeq> p3;
    };

    virtual void opFixedStructSeqAsync(Ice::optional<FixedStructSeq> p1, ::std::function<void(const Ice::optional<FixedStructSeq>& returnValue, const Ice::optional<FixedStructSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStructSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedStructSeqReq.
     */
    struct OpFixedStructSeqReqResult
    {
        Ice::optional<FixedStructSeq> returnValue;
        Ice::optional<FixedStructSeq> p3;
    };

    virtual void opFixedStructSeqReqAsync(Ice::optional<FixedStructSeq> p1, ::std::function<void(const Ice::optional<FixedStructSeq>& returnValue, const Ice::optional<FixedStructSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStructSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedStructList.
     */
    struct OpFixedStructListResult
    {
        Ice::optional<FixedStructList> returnValue;
        Ice::optional<FixedStructList> p3;
    };

    virtual void opFixedStructListAsync(Ice::optional<FixedStructList> p1, ::std::function<void(const Ice::optional<FixedStructList>& returnValue, const Ice::optional<FixedStructList>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStructList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedStructListReq.
     */
    struct OpFixedStructListReqResult
    {
        Ice::optional<FixedStructList> returnValue;
        Ice::optional<FixedStructList> p3;
    };

    virtual void opFixedStructListReqAsync(Ice::optional<FixedStructList> p1, ::std::function<void(const Ice::optional<FixedStructList>& returnValue, const Ice::optional<FixedStructList>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStructListReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVarStructSeq.
     */
    struct OpVarStructSeqResult
    {
        Ice::optional<VarStructSeq> returnValue;
        Ice::optional<VarStructSeq> p3;
    };

    virtual void opVarStructSeqAsync(Ice::optional<VarStructSeq> p1, ::std::function<void(const Ice::optional<VarStructSeq>& returnValue, const Ice::optional<VarStructSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarStructSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVarStructSeqReq.
     */
    struct OpVarStructSeqReqResult
    {
        Ice::optional<VarStructSeq> returnValue;
        Ice::optional<VarStructSeq> p3;
    };

    virtual void opVarStructSeqReqAsync(Ice::optional<VarStructSeq> p1, ::std::function<void(const Ice::optional<VarStructSeq>& returnValue, const Ice::optional<VarStructSeq>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarStructSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSerializable.
     */
    struct OpSerializableResult
    {
        Ice::optional<Serializable> returnValue;
        Ice::optional<Serializable> p3;
    };

    virtual void opSerializableAsync(Ice::optional<Serializable> p1, ::std::function<void(const Ice::optional<Serializable>& returnValue, const Ice::optional<Serializable>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSerializable(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSerializableReq.
     */
    struct OpSerializableReqResult
    {
        Ice::optional<Serializable> returnValue;
        Ice::optional<Serializable> p3;
    };

    virtual void opSerializableReqAsync(Ice::optional<Serializable> p1, ::std::function<void(const Ice::optional<Serializable>& returnValue, const Ice::optional<Serializable>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSerializableReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntIntDict.
     */
    struct OpIntIntDictResult
    {
        Ice::optional<IntIntDict> returnValue;
        Ice::optional<IntIntDict> p3;
    };

    virtual void opIntIntDictAsync(Ice::optional<IntIntDict> p1, ::std::function<void(const Ice::optional<IntIntDict>& returnValue, const Ice::optional<IntIntDict>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntIntDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntIntDictReq.
     */
    struct OpIntIntDictReqResult
    {
        Ice::optional<IntIntDict> returnValue;
        Ice::optional<IntIntDict> p3;
    };

    virtual void opIntIntDictReqAsync(Ice::optional<IntIntDict> p1, ::std::function<void(const Ice::optional<IntIntDict>& returnValue, const Ice::optional<IntIntDict>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntIntDictReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringIntDict.
     */
    struct OpStringIntDictResult
    {
        Ice::optional<StringIntDict> returnValue;
        Ice::optional<StringIntDict> p3;
    };

    virtual void opStringIntDictAsync(Ice::optional<StringIntDict> p1, ::std::function<void(const Ice::optional<StringIntDict>& returnValue, const Ice::optional<StringIntDict>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringIntDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringIntDictReq.
     */
    struct OpStringIntDictReqResult
    {
        Ice::optional<StringIntDict> returnValue;
        Ice::optional<StringIntDict> p3;
    };

    virtual void opStringIntDictReqAsync(Ice::optional<StringIntDict> p1, ::std::function<void(const Ice::optional<StringIntDict>& returnValue, const Ice::optional<StringIntDict>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringIntDictReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntOneOptionalDict.
     */
    struct OpIntOneOptionalDictResult
    {
        Ice::optional<IntOneOptionalDict> returnValue;
        Ice::optional<IntOneOptionalDict> p3;
    };

    virtual void opIntOneOptionalDictAsync(Ice::optional<IntOneOptionalDict> p1, ::std::function<void(const Ice::optional<IntOneOptionalDict>& returnValue, const Ice::optional<IntOneOptionalDict>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntOneOptionalDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntOneOptionalDictReq.
     */
    struct OpIntOneOptionalDictReqResult
    {
        Ice::optional<IntOneOptionalDict> returnValue;
        Ice::optional<IntOneOptionalDict> p3;
    };

    virtual void opIntOneOptionalDictReqAsync(Ice::optional<IntOneOptionalDict> p1, ::std::function<void(const Ice::optional<IntOneOptionalDict>& returnValue, const Ice::optional<IntOneOptionalDict>& p3)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntOneOptionalDictReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opClassAndUnknownOptionalAsync(::std::shared_ptr<A> p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opClassAndUnknownOptional(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void sendOptionalClassAsync(bool req, Ice::optional<::std::shared_ptr<OneOptional>> o, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_sendOptionalClass(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void returnOptionalClassAsync(bool req, ::std::function<void(const Ice::optional<::std::shared_ptr<OneOptional>>& o)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_returnOptionalClass(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opGAsync(::std::shared_ptr<G> g, ::std::function<void(const ::std::shared_ptr<G>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opG(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVoidAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVoid(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMStruct1Async(::std::function<void(const Ice::optional<SmallStruct>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMStruct1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMStruct2.
     */
    struct OpMStruct2Result
    {
        Ice::optional<SmallStruct> returnValue;
        Ice::optional<SmallStruct> p2;
    };

    virtual void opMStruct2Async(Ice::optional<SmallStruct> p1, ::std::function<void(const Ice::optional<SmallStruct>& returnValue, const Ice::optional<SmallStruct>& p2)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMStruct2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMSeq1Async(::std::function<void(const Ice::optional<StringSeq>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMSeq1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMSeq2.
     */
    struct OpMSeq2Result
    {
        Ice::optional<StringSeq> returnValue;
        Ice::optional<StringSeq> p2;
    };

    virtual void opMSeq2Async(Ice::optional<StringSeq> p1, ::std::function<void(const Ice::optional<StringSeq>& returnValue, const Ice::optional<StringSeq>& p2)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMSeq2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMDict1Async(::std::function<void(const Ice::optional<StringIntDict>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMDict1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMDict2.
     */
    struct OpMDict2Result
    {
        Ice::optional<StringIntDict> returnValue;
        Ice::optional<StringIntDict> p2;
    };

    virtual void opMDict2Async(Ice::optional<StringIntDict> p1, ::std::function<void(const Ice::optional<StringIntDict>& returnValue, const Ice::optional<StringIntDict>& p2)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMDict2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMG1Async(::std::function<void(const Ice::optional<::std::shared_ptr<G>>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMG1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMG2.
     */
    struct OpMG2Result
    {
        Ice::optional<::std::shared_ptr<G>> returnValue;
        Ice::optional<::std::shared_ptr<G>> p2;
    };

    virtual void opMG2Async(Ice::optional<::std::shared_ptr<G>> p1, ::std::function<void(const Ice::optional<::std::shared_ptr<G>>& returnValue, const Ice::optional<::std::shared_ptr<G>>& p2)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMG2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void supportsRequiredParamsAsync(::std::function<void(bool returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsRequiredParams(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void supportsJavaSerializableAsync(::std::function<void(bool returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsJavaSerializable(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void supportsCsharpSerializableAsync(::std::function<void(bool returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsCsharpSerializable(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void supportsCppStringViewAsync(::std::function<void(bool returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsCppStringView(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void supportsNullOptionalAsync(::std::function<void(bool returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsNullOptional(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class OneOptional : public ::Ice::ValueHelper<OneOptional, ::Ice::Value>
{
public:

    virtual ~OneOptional();

    OneOptional() = default;

    OneOptional(const OneOptional&) = default;
    OneOptional(OneOptional&&) = default;
    OneOptional& operator=(const OneOptional&) = default;
    OneOptional& operator=(OneOptional&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit OneOptional(const Ice::optional<int>& a) :
        a(a)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const Ice::optional<int>&> ice_tuple() const
    {
        return std::tie(a);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    Ice::optional<int> a;
};

/// \cond INTERNAL
static OneOptional _iceS_OneOptional_init;
/// \endcond

class MultiOptional : public ::Ice::ValueHelper<MultiOptional, ::Ice::Value>
{
public:

    virtual ~MultiOptional();

    MultiOptional() = default;

    MultiOptional(const MultiOptional&) = default;
    MultiOptional(MultiOptional&&) = default;
    MultiOptional& operator=(const MultiOptional&) = default;
    MultiOptional& operator=(MultiOptional&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    MultiOptional(const Ice::optional<::Ice::Byte>& a, const Ice::optional<bool>& b, const Ice::optional<short>& c, const Ice::optional<int>& d, const Ice::optional<long long int>& e, const Ice::optional<float>& f, const Ice::optional<double>& g, const Ice::optional<::std::string>& h, const Ice::optional<::Test::MyEnum>& i, const Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>& j, const Ice::optional<::std::shared_ptr<::Test::MultiOptional>>& k, const Ice::optional<::Test::ByteSeq>& bs, const Ice::optional<::Test::StringSeq>& ss, const Ice::optional<::Test::IntIntDict>& iid, const Ice::optional<::Test::StringIntDict>& sid, const Ice::optional<::Test::FixedStruct>& fs, const Ice::optional<::Test::VarStruct>& vs, const Ice::optional<::Test::ShortSeq>& shs, const Ice::optional<::Test::MyEnumSeq>& es, const Ice::optional<::Test::FixedStructSeq>& fss, const Ice::optional<::Test::VarStructSeq>& vss, const Ice::optional<::Test::OneOptionalSeq>& oos, const Ice::optional<::Test::OneOptionalPrxSeq>& oops, const Ice::optional<::Test::IntEnumDict>& ied, const Ice::optional<::Test::IntFixedStructDict>& ifsd, const Ice::optional<::Test::IntVarStructDict>& ivsd, const Ice::optional<::Test::IntOneOptionalDict>& iood, const Ice::optional<::Test::IntOneOptionalPrxDict>& ioopd, const Ice::optional<::Test::BoolSeq>& bos, const Ice::optional<::Test::Serializable>& ser) :
        a(a),
        b(b),
        c(c),
        d(d),
        e(e),
        f(f),
        g(g),
        h(h),
        i(i),
        j(j),
        k(k),
        bs(bs),
        ss(ss),
        iid(iid),
        sid(sid),
        fs(fs),
        vs(vs),
        shs(shs),
        es(es),
        fss(fss),
        vss(vss),
        oos(oos),
        oops(oops),
        ied(ied),
        ifsd(ifsd),
        ivsd(ivsd),
        iood(iood),
        ioopd(ioopd),
        bos(bos),
        ser(ser)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const Ice::optional<::Ice::Byte>&, const Ice::optional<bool>&, const Ice::optional<short>&, const Ice::optional<int>&, const Ice::optional<long long int>&, const Ice::optional<float>&, const Ice::optional<double>&, const Ice::optional<::std::string>&, const Ice::optional<::Test::MyEnum>&, const Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>&, const Ice::optional<::std::shared_ptr<::Test::MultiOptional>>&, const Ice::optional<::Test::ByteSeq>&, const Ice::optional<::Test::StringSeq>&, const Ice::optional<::Test::IntIntDict>&, const Ice::optional<::Test::StringIntDict>&, const Ice::optional<::Test::FixedStruct>&, const Ice::optional<::Test::VarStruct>&, const Ice::optional<::Test::ShortSeq>&, const Ice::optional<::Test::MyEnumSeq>&, const Ice::optional<::Test::FixedStructSeq>&, const Ice::optional<::Test::VarStructSeq>&, const Ice::optional<::Test::OneOptionalSeq>&, const Ice::optional<::Test::OneOptionalPrxSeq>&, const Ice::optional<::Test::IntEnumDict>&, const Ice::optional<::Test::IntFixedStructDict>&, const Ice::optional<::Test::IntVarStructDict>&, const Ice::optional<::Test::IntOneOptionalDict>&, const Ice::optional<::Test::IntOneOptionalPrxDict>&, const Ice::optional<::Test::BoolSeq>&, const Ice::optional<::Test::Serializable>&> ice_tuple() const
    {
        return std::tie(a, b, c, d, e, f, g, h, i, j, k, bs, ss, iid, sid, fs, vs, shs, es, fss, vss, oos, oops, ied, ifsd, ivsd, iood, ioopd, bos, ser);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    Ice::optional<::Ice::Byte> a;
    Ice::optional<bool> b;
    Ice::optional<short> c;
    Ice::optional<int> d;
    Ice::optional<long long int> e;
    Ice::optional<float> f;
    Ice::optional<double> g;
    Ice::optional<::std::string> h;
    Ice::optional<::Test::MyEnum> i;
    Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>> j;
    Ice::optional<::std::shared_ptr<::Test::MultiOptional>> k;
    Ice::optional<::Test::ByteSeq> bs;
    Ice::optional<::Test::StringSeq> ss;
    Ice::optional<::Test::IntIntDict> iid;
    Ice::optional<::Test::StringIntDict> sid;
    Ice::optional<::Test::FixedStruct> fs;
    Ice::optional<::Test::VarStruct> vs;
    Ice::optional<::Test::ShortSeq> shs;
    Ice::optional<::Test::MyEnumSeq> es;
    Ice::optional<::Test::FixedStructSeq> fss;
    Ice::optional<::Test::VarStructSeq> vss;
    Ice::optional<::Test::OneOptionalSeq> oos;
    Ice::optional<::Test::OneOptionalPrxSeq> oops;
    Ice::optional<::Test::IntEnumDict> ied;
    Ice::optional<::Test::IntFixedStructDict> ifsd;
    Ice::optional<::Test::IntVarStructDict> ivsd;
    Ice::optional<::Test::IntOneOptionalDict> iood;
    Ice::optional<::Test::IntOneOptionalPrxDict> ioopd;
    Ice::optional<::Test::BoolSeq> bos;
    Ice::optional<::Test::Serializable> ser;
};

class A : public ::Ice::ValueHelper<A, ::Ice::Value>
{
public:

    virtual ~A();

    A() = default;

    A(const A&) = default;
    A(A&&) = default;
    A& operator=(const A&) = default;
    A& operator=(A&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    A(int requiredA, const Ice::optional<int>& ma, const Ice::optional<int>& mb, const Ice::optional<int>& mc) :
        requiredA(requiredA),
        ma(ma),
        mb(mb),
        mc(mc)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const Ice::optional<int>&, const Ice::optional<int>&, const Ice::optional<int>&> ice_tuple() const
    {
        return std::tie(requiredA, ma, mb, mc);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int requiredA;
    Ice::optional<int> ma;
    Ice::optional<int> mb;
    Ice::optional<int> mc;
};

class B : public ::Ice::ValueHelper<B, A>
{
public:

    virtual ~B();

    B() = default;

    B(const B&) = default;
    B(B&&) = default;
    B& operator=(const B&) = default;
    B& operator=(B&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    B(int requiredA, const Ice::optional<int>& ma, const Ice::optional<int>& mb, const Ice::optional<int>& mc, int requiredB, const Ice::optional<int>& md) :
        Ice::ValueHelper<B, A>(requiredA, ma, mb, mc),
        requiredB(requiredB),
        md(md)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const Ice::optional<int>&, const Ice::optional<int>&, const Ice::optional<int>&, const int&, const Ice::optional<int>&> ice_tuple() const
    {
        return std::tie(requiredA, ma, mb, mc, requiredB, md);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown value type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the value was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const override;
    virtual void _iceRead(::Ice::InputStream*) override;
    /// \endcond

    int requiredB;
    Ice::optional<int> md;

protected:

    /// \cond STREAM
    ::std::shared_ptr<::Ice::SlicedData> _iceSlicedData;
    /// \endcond
};

class C : public ::Ice::ValueHelper<C, B>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    C(int requiredA, const Ice::optional<int>& ma, const Ice::optional<int>& mb, const Ice::optional<int>& mc, int requiredB, const Ice::optional<int>& md, const ::std::string& ss, const Ice::optional<::std::string>& ms) :
        Ice::ValueHelper<C, B>(requiredA, ma, mb, mc, requiredB, md),
        ss(ss),
        ms(ms)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const Ice::optional<int>&, const Ice::optional<int>&, const Ice::optional<int>&, const int&, const Ice::optional<int>&, const ::std::string&, const Ice::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(requiredA, ma, mb, mc, requiredB, md, ss, ms);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string ss;
    Ice::optional<::std::string> ms;
};

class WD : public ::Ice::ValueHelper<WD, ::Ice::Value>
{
public:

    virtual ~WD();

    WD() = default;

    WD(const WD&) = default;
    WD(WD&&) = default;
    WD& operator=(const WD&) = default;
    WD& operator=(WD&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    WD(const Ice::optional<int>& a, const Ice::optional<::std::string>& s) :
        a(a),
        s(s)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const Ice::optional<int>&, const Ice::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(a, s);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    Ice::optional<int> a = 5;
    Ice::optional<::std::string> s{"test"};
};

class OptionalWithCustom : public ::Ice::ValueHelper<OptionalWithCustom, ::Ice::Value>
{
public:

    virtual ~OptionalWithCustom();

    OptionalWithCustom() = default;

    OptionalWithCustom(const OptionalWithCustom&) = default;
    OptionalWithCustom(OptionalWithCustom&&) = default;
    OptionalWithCustom& operator=(const OptionalWithCustom&) = default;
    OptionalWithCustom& operator=(OptionalWithCustom&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalWithCustom(const Ice::optional<::Test::SmallStructList>& l, const Ice::optional<::Test::SmallStructList>& lp, const Ice::optional<::Test::ClassVarStruct>& s) :
        l(l),
        lp(lp),
        s(s)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const Ice::optional<::Test::SmallStructList>&, const Ice::optional<::Test::SmallStructList>&, const Ice::optional<::Test::ClassVarStruct>&> ice_tuple() const
    {
        return std::tie(l, lp, s);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    Ice::optional<::Test::SmallStructList> l;

protected:

    Ice::optional<::Test::SmallStructList> lp;

public:

    Ice::optional<::Test::ClassVarStruct> s;

protected:

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};

class E : public ::Ice::ValueHelper<E, ::Ice::Value>
{
public:

    virtual ~E();

    E() = default;

    E(const E&) = default;
    E(E&&) = default;
    E& operator=(const E&) = default;
    E& operator=(E&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit E(const ::std::shared_ptr<::Test::A>& ae) :
        ae(ae)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A>&> ice_tuple() const
    {
        return std::tie(ae);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::A> ae;
};

class F : public ::Ice::ValueHelper<F, E>
{
public:

    virtual ~F();

    F() = default;

    F(const F&) = default;
    F(F&&) = default;
    F& operator=(const F&) = default;
    F& operator=(F&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    F(const ::std::shared_ptr<::Test::A>& ae, const Ice::optional<::std::shared_ptr<::Test::A>>& af) :
        Ice::ValueHelper<F, E>(ae),
        af(af)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A>&, const Ice::optional<::std::shared_ptr<::Test::A>>&> ice_tuple() const
    {
        return std::tie(ae, af);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    Ice::optional<::std::shared_ptr<::Test::A>> af;
};

class G1 : public ::Ice::ValueHelper<G1, ::Ice::Value>
{
public:

    virtual ~G1();

    G1() = default;

    G1(const G1&) = default;
    G1(G1&&) = default;
    G1& operator=(const G1&) = default;
    G1& operator=(G1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit G1(const ::std::string& a) :
        a(a)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(a);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string a;
};

class G2 : public ::Ice::ValueHelper<G2, ::Ice::Value>
{
public:

    virtual ~G2();

    G2() = default;

    G2(const G2&) = default;
    G2(G2&&) = default;
    G2& operator=(const G2&) = default;
    G2& operator=(G2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit G2(long long int a) :
        a(a)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const long long int&> ice_tuple() const
    {
        return std::tie(a);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    long long int a;
};

class G : public ::Ice::ValueHelper<G, ::Ice::Value>
{
public:

    virtual ~G();

    G() = default;

    G(const G&) = default;
    G(G&&) = default;
    G& operator=(const G&) = default;
    G& operator=(G&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    G(const Ice::optional<::std::shared_ptr<::Test::G1>>& gg1Opt, const ::std::shared_ptr<::Test::G2>& gg2, const Ice::optional<::std::shared_ptr<::Test::G2>>& gg2Opt, const ::std::shared_ptr<::Test::G1>& gg1) :
        gg1Opt(gg1Opt),
        gg2(gg2),
        gg2Opt(gg2Opt),
        gg1(gg1)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const Ice::optional<::std::shared_ptr<::Test::G1>>&, const ::std::shared_ptr<::Test::G2>&, const Ice::optional<::std::shared_ptr<::Test::G2>>&, const ::std::shared_ptr<::Test::G1>&> ice_tuple() const
    {
        return std::tie(gg1Opt, gg2, gg2Opt, gg1);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    Ice::optional<::std::shared_ptr<::Test::G1>> gg1Opt;
    ::std::shared_ptr<::Test::G2> gg2;
    Ice::optional<::std::shared_ptr<::Test::G2>> gg2Opt;
    ::std::shared_ptr<::Test::G1> gg1;
};

class Recursive : public ::Ice::ValueHelper<Recursive, ::Ice::Value>
{
public:

    virtual ~Recursive();

    Recursive() = default;

    Recursive(const Recursive&) = default;
    Recursive(Recursive&&) = default;
    Recursive& operator=(const Recursive&) = default;
    Recursive& operator=(Recursive&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Recursive(const Ice::optional<::Test::RecursiveSeq>& value) :
        value(value)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const Ice::optional<::Test::RecursiveSeq>&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    Ice::optional<::Test::RecursiveSeq> value;
};

}

namespace Test
{

class InitialPrx : public virtual ::Ice::Proxy<InitialPrx, ::Ice::ObjectPrx>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<::Ice::Value> pingPong(const ::std::shared_ptr<::Ice::Value>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>>(true, this, &InitialPrx::_iceI_pingPong, o, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pingPongAsync(const ::std::shared_ptr<::Ice::Value>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::Value>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>, P>(false, this, &InitialPrx::_iceI_pingPong, o, context);
    }

    ::std::function<void()>
    pingPongAsync(const ::std::shared_ptr<::Ice::Value>& o,
                  ::std::function<void(::std::shared_ptr<::Ice::Value>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Ice::Value>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_pingPong, o, context);
    }

    /// \cond INTERNAL
    void _iceI_pingPong(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>&, const ::std::shared_ptr<::Ice::Value>&, const ::Ice::Context&);
    /// \endcond

    void opOptionalException(const Ice::optional<int>& a, const Ice::optional<::std::string>& b, const Ice::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_opOptionalException, a, b, o, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opOptionalExceptionAsync(const Ice::optional<int>& a, const Ice::optional<::std::string>& b, const Ice::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_opOptionalException, a, b, o, context);
    }

    ::std::function<void()>
    opOptionalExceptionAsync(const Ice::optional<int>& a, const Ice::optional<::std::string>& b, const Ice::optional<::std::shared_ptr<OneOptional>>& o,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opOptionalException, a, b, o, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptionalException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const Ice::optional<int>&, const Ice::optional<::std::string>&, const Ice::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&);
    /// \endcond

    void opDerivedException(const Ice::optional<int>& a, const Ice::optional<::std::string>& b, const Ice::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_opDerivedException, a, b, o, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opDerivedExceptionAsync(const Ice::optional<int>& a, const Ice::optional<::std::string>& b, const Ice::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_opDerivedException, a, b, o, context);
    }

    ::std::function<void()>
    opDerivedExceptionAsync(const Ice::optional<int>& a, const Ice::optional<::std::string>& b, const Ice::optional<::std::shared_ptr<OneOptional>>& o,
                            ::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opDerivedException, a, b, o, context);
    }

    /// \cond INTERNAL
    void _iceI_opDerivedException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const Ice::optional<int>&, const Ice::optional<::std::string>&, const Ice::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&);
    /// \endcond

    void opRequiredException(const Ice::optional<int>& a, const Ice::optional<::std::string>& b, const Ice::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_opRequiredException, a, b, o, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opRequiredExceptionAsync(const Ice::optional<int>& a, const Ice::optional<::std::string>& b, const Ice::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_opRequiredException, a, b, o, context);
    }

    ::std::function<void()>
    opRequiredExceptionAsync(const Ice::optional<int>& a, const Ice::optional<::std::string>& b, const Ice::optional<::std::shared_ptr<OneOptional>>& o,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opRequiredException, a, b, o, context);
    }

    /// \cond INTERNAL
    void _iceI_opRequiredException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const Ice::optional<int>&, const Ice::optional<::std::string>&, const Ice::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<::Ice::Byte> opByte(const Ice::optional<::Ice::Byte>& p1, Ice::optional<::Ice::Byte>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpByteResult>(true, this, &InitialPrx::_iceI_opByte, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opByteAsync(const Ice::optional<::Ice::Byte>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpByteResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpByteResult, P>(false, this, &InitialPrx::_iceI_opByte, p1, context);
    }

    ::std::function<void()>
    opByteAsync(const Ice::optional<::Ice::Byte>& p1,
                ::std::function<void(Ice::optional<::Ice::Byte>, Ice::optional<::Ice::Byte>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpByteResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpByteResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opByte, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opByte(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpByteResult>>&, const Ice::optional<::Ice::Byte>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<::Ice::Byte> opByteReq(const Ice::optional<::Ice::Byte>& p1, Ice::optional<::Ice::Byte>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpByteReqResult>(true, this, &InitialPrx::_iceI_opByteReq, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opByteReqAsync(const Ice::optional<::Ice::Byte>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpByteReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpByteReqResult, P>(false, this, &InitialPrx::_iceI_opByteReq, p1, context);
    }

    ::std::function<void()>
    opByteReqAsync(const Ice::optional<::Ice::Byte>& p1,
                   ::std::function<void(Ice::optional<::Ice::Byte>, Ice::optional<::Ice::Byte>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpByteReqResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpByteReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opByteReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpByteReqResult>>&, const Ice::optional<::Ice::Byte>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<bool> opBool(const Ice::optional<bool>& p1, Ice::optional<bool>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpBoolResult>(true, this, &InitialPrx::_iceI_opBool, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolAsync(const Ice::optional<bool>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpBoolResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpBoolResult, P>(false, this, &InitialPrx::_iceI_opBool, p1, context);
    }

    ::std::function<void()>
    opBoolAsync(const Ice::optional<bool>& p1,
                ::std::function<void(Ice::optional<bool>, Ice::optional<bool>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpBoolResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpBoolResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opBool, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opBool(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpBoolResult>>&, const Ice::optional<bool>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<bool> opBoolReq(const Ice::optional<bool>& p1, Ice::optional<bool>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpBoolReqResult>(true, this, &InitialPrx::_iceI_opBoolReq, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolReqAsync(const Ice::optional<bool>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpBoolReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpBoolReqResult, P>(false, this, &InitialPrx::_iceI_opBoolReq, p1, context);
    }

    ::std::function<void()>
    opBoolReqAsync(const Ice::optional<bool>& p1,
                   ::std::function<void(Ice::optional<bool>, Ice::optional<bool>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpBoolReqResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpBoolReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opBoolReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpBoolReqResult>>&, const Ice::optional<bool>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<short> opShort(const Ice::optional<short>& p1, Ice::optional<short>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpShortResult>(true, this, &InitialPrx::_iceI_opShort, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opShortAsync(const Ice::optional<short>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpShortResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpShortResult, P>(false, this, &InitialPrx::_iceI_opShort, p1, context);
    }

    ::std::function<void()>
    opShortAsync(const Ice::optional<short>& p1,
                 ::std::function<void(Ice::optional<short>, Ice::optional<short>)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpShortResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpShortResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opShort, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opShort(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpShortResult>>&, const Ice::optional<short>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<short> opShortReq(const Ice::optional<short>& p1, Ice::optional<short>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpShortReqResult>(true, this, &InitialPrx::_iceI_opShortReq, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opShortReqAsync(const Ice::optional<short>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpShortReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpShortReqResult, P>(false, this, &InitialPrx::_iceI_opShortReq, p1, context);
    }

    ::std::function<void()>
    opShortReqAsync(const Ice::optional<short>& p1,
                    ::std::function<void(Ice::optional<short>, Ice::optional<short>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpShortReqResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpShortReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opShortReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpShortReqResult>>&, const Ice::optional<short>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<int> opInt(const Ice::optional<int>& p1, Ice::optional<int>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpIntResult>(true, this, &InitialPrx::_iceI_opInt, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opIntAsync(const Ice::optional<int>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpIntResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpIntResult, P>(false, this, &InitialPrx::_iceI_opInt, p1, context);
    }

    ::std::function<void()>
    opIntAsync(const Ice::optional<int>& p1,
               ::std::function<void(Ice::optional<int>, Ice::optional<int>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpIntResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpIntResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opInt, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opInt(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpIntResult>>&, const Ice::optional<int>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<int> opIntReq(const Ice::optional<int>& p1, Ice::optional<int>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpIntReqResult>(true, this, &InitialPrx::_iceI_opIntReq, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opIntReqAsync(const Ice::optional<int>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpIntReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpIntReqResult, P>(false, this, &InitialPrx::_iceI_opIntReq, p1, context);
    }

    ::std::function<void()>
    opIntReqAsync(const Ice::optional<int>& p1,
                  ::std::function<void(Ice::optional<int>, Ice::optional<int>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpIntReqResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpIntReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opIntReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpIntReqResult>>&, const Ice::optional<int>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<long long int> opLong(const Ice::optional<long long int>& p1, Ice::optional<long long int>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpLongResult>(true, this, &InitialPrx::_iceI_opLong, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opLongAsync(const Ice::optional<long long int>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpLongResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpLongResult, P>(false, this, &InitialPrx::_iceI_opLong, p1, context);
    }

    ::std::function<void()>
    opLongAsync(const Ice::optional<long long int>& p1,
                ::std::function<void(Ice::optional<long long int>, Ice::optional<long long int>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpLongResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpLongResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opLong, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opLong(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpLongResult>>&, const Ice::optional<long long int>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<long long int> opLongReq(const Ice::optional<long long int>& p1, Ice::optional<long long int>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpLongReqResult>(true, this, &InitialPrx::_iceI_opLongReq, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opLongReqAsync(const Ice::optional<long long int>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpLongReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpLongReqResult, P>(false, this, &InitialPrx::_iceI_opLongReq, p1, context);
    }

    ::std::function<void()>
    opLongReqAsync(const Ice::optional<long long int>& p1,
                   ::std::function<void(Ice::optional<long long int>, Ice::optional<long long int>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpLongReqResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpLongReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opLongReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opLongReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpLongReqResult>>&, const Ice::optional<long long int>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<float> opFloat(const Ice::optional<float>& p1, Ice::optional<float>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFloatResult>(true, this, &InitialPrx::_iceI_opFloat, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatAsync(const Ice::optional<float>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFloatResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFloatResult, P>(false, this, &InitialPrx::_iceI_opFloat, p1, context);
    }

    ::std::function<void()>
    opFloatAsync(const Ice::optional<float>& p1,
                 ::std::function<void(Ice::optional<float>, Ice::optional<float>)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpFloatResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpFloatResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opFloat, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloat(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFloatResult>>&, const Ice::optional<float>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<float> opFloatReq(const Ice::optional<float>& p1, Ice::optional<float>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFloatReqResult>(true, this, &InitialPrx::_iceI_opFloatReq, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatReqAsync(const Ice::optional<float>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFloatReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFloatReqResult, P>(false, this, &InitialPrx::_iceI_opFloatReq, p1, context);
    }

    ::std::function<void()>
    opFloatReqAsync(const Ice::optional<float>& p1,
                    ::std::function<void(Ice::optional<float>, Ice::optional<float>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpFloatReqResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpFloatReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opFloatReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloatReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFloatReqResult>>&, const Ice::optional<float>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<double> opDouble(const Ice::optional<double>& p1, Ice::optional<double>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpDoubleResult>(true, this, &InitialPrx::_iceI_opDouble, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleAsync(const Ice::optional<double>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpDoubleResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpDoubleResult, P>(false, this, &InitialPrx::_iceI_opDouble, p1, context);
    }

    ::std::function<void()>
    opDoubleAsync(const Ice::optional<double>& p1,
                  ::std::function<void(Ice::optional<double>, Ice::optional<double>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpDoubleResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpDoubleResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opDouble, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opDouble(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpDoubleResult>>&, const Ice::optional<double>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<double> opDoubleReq(const Ice::optional<double>& p1, Ice::optional<double>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpDoubleReqResult>(true, this, &InitialPrx::_iceI_opDoubleReq, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleReqAsync(const Ice::optional<double>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpDoubleReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpDoubleReqResult, P>(false, this, &InitialPrx::_iceI_opDoubleReq, p1, context);
    }

    ::std::function<void()>
    opDoubleReqAsync(const Ice::optional<double>& p1,
                     ::std::function<void(Ice::optional<double>, Ice::optional<double>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpDoubleReqResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpDoubleReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opDoubleReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opDoubleReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpDoubleReqResult>>&, const Ice::optional<double>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<::std::string> opString(const Ice::optional<::std::string>& p1, Ice::optional<::std::string>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpStringResult>(true, this, &InitialPrx::_iceI_opString, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringAsync(const Ice::optional<::std::string>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpStringResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpStringResult, P>(false, this, &InitialPrx::_iceI_opString, p1, context);
    }

    ::std::function<void()>
    opStringAsync(const Ice::optional<::std::string>& p1,
                  ::std::function<void(Ice::optional<::std::string>, Ice::optional<::std::string>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpStringResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpStringResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opString, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpStringResult>>&, const Ice::optional<::std::string>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<::std::string> opStringReq(const Ice::optional<::std::string>& p1, Ice::optional<::std::string>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpStringReqResult>(true, this, &InitialPrx::_iceI_opStringReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringReqAsync(const Ice::optional<::std::string>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpStringReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpStringReqResult, P>(false, this, &InitialPrx::_iceI_opStringReq, p1, context);
    }

    ::std::function<void()>
    opStringReqAsync(const Ice::optional<::std::string>& p1,
                     ::std::function<void(Ice::optional<::std::string>, Ice::optional<::std::string>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpStringReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpStringReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opStringReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpStringReqResult>>&, const Ice::optional<::std::string>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<MyEnum> opMyEnum(const Ice::optional<MyEnum>& p1, Ice::optional<MyEnum>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpMyEnumResult>(true, this, &InitialPrx::_iceI_opMyEnum, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opMyEnumAsync(const Ice::optional<MyEnum>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpMyEnumResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpMyEnumResult, P>(false, this, &InitialPrx::_iceI_opMyEnum, p1, context);
    }

    ::std::function<void()>
    opMyEnumAsync(const Ice::optional<MyEnum>& p1,
                  ::std::function<void(Ice::optional<::Test::MyEnum>, Ice::optional<::Test::MyEnum>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpMyEnumResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpMyEnumResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMyEnum, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyEnum(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpMyEnumResult>>&, const Ice::optional<MyEnum>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<MyEnum> opMyEnumReq(const Ice::optional<MyEnum>& p1, Ice::optional<MyEnum>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpMyEnumReqResult>(true, this, &InitialPrx::_iceI_opMyEnumReq, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opMyEnumReqAsync(const Ice::optional<MyEnum>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpMyEnumReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpMyEnumReqResult, P>(false, this, &InitialPrx::_iceI_opMyEnumReq, p1, context);
    }

    ::std::function<void()>
    opMyEnumReqAsync(const Ice::optional<MyEnum>& p1,
                     ::std::function<void(Ice::optional<::Test::MyEnum>, Ice::optional<::Test::MyEnum>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpMyEnumReqResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpMyEnumReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMyEnumReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyEnumReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpMyEnumReqResult>>&, const Ice::optional<MyEnum>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<SmallStruct> opSmallStruct(const Ice::optional<SmallStruct>& p1, Ice::optional<SmallStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpSmallStructResult>(true, this, &InitialPrx::_iceI_opSmallStruct, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSmallStructAsync(const Ice::optional<SmallStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpSmallStructResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpSmallStructResult, P>(false, this, &InitialPrx::_iceI_opSmallStruct, p1, context);
    }

    ::std::function<void()>
    opSmallStructAsync(const Ice::optional<SmallStruct>& p1,
                       ::std::function<void(Ice::optional<::Test::SmallStruct>, Ice::optional<::Test::SmallStruct>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpSmallStructResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpSmallStructResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opSmallStruct, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opSmallStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpSmallStructResult>>&, const Ice::optional<SmallStruct>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<SmallStruct> opSmallStructReq(const Ice::optional<SmallStruct>& p1, Ice::optional<SmallStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpSmallStructReqResult>(true, this, &InitialPrx::_iceI_opSmallStructReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSmallStructReqAsync(const Ice::optional<SmallStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpSmallStructReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpSmallStructReqResult, P>(false, this, &InitialPrx::_iceI_opSmallStructReq, p1, context);
    }

    ::std::function<void()>
    opSmallStructReqAsync(const Ice::optional<SmallStruct>& p1,
                          ::std::function<void(Ice::optional<::Test::SmallStruct>, Ice::optional<::Test::SmallStruct>)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpSmallStructReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpSmallStructReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opSmallStructReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opSmallStructReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpSmallStructReqResult>>&, const Ice::optional<SmallStruct>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<FixedStruct> opFixedStruct(const Ice::optional<FixedStruct>& p1, Ice::optional<FixedStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFixedStructResult>(true, this, &InitialPrx::_iceI_opFixedStruct, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFixedStructAsync(const Ice::optional<FixedStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFixedStructResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFixedStructResult, P>(false, this, &InitialPrx::_iceI_opFixedStruct, p1, context);
    }

    ::std::function<void()>
    opFixedStructAsync(const Ice::optional<FixedStruct>& p1,
                       ::std::function<void(Ice::optional<::Test::FixedStruct>, Ice::optional<::Test::FixedStruct>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpFixedStructResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpFixedStructResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opFixedStruct, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opFixedStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFixedStructResult>>&, const Ice::optional<FixedStruct>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<FixedStruct> opFixedStructReq(const Ice::optional<FixedStruct>& p1, Ice::optional<FixedStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFixedStructReqResult>(true, this, &InitialPrx::_iceI_opFixedStructReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFixedStructReqAsync(const Ice::optional<FixedStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFixedStructReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFixedStructReqResult, P>(false, this, &InitialPrx::_iceI_opFixedStructReq, p1, context);
    }

    ::std::function<void()>
    opFixedStructReqAsync(const Ice::optional<FixedStruct>& p1,
                          ::std::function<void(Ice::optional<::Test::FixedStruct>, Ice::optional<::Test::FixedStruct>)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpFixedStructReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpFixedStructReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opFixedStructReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opFixedStructReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFixedStructReqResult>>&, const Ice::optional<FixedStruct>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<VarStruct> opVarStruct(const Ice::optional<VarStruct>& p1, Ice::optional<VarStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpVarStructResult>(true, this, &InitialPrx::_iceI_opVarStruct, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVarStructAsync(const Ice::optional<VarStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpVarStructResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpVarStructResult, P>(false, this, &InitialPrx::_iceI_opVarStruct, p1, context);
    }

    ::std::function<void()>
    opVarStructAsync(const Ice::optional<VarStruct>& p1,
                     ::std::function<void(Ice::optional<::Test::VarStruct>, Ice::optional<::Test::VarStruct>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpVarStructResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpVarStructResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opVarStruct, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opVarStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpVarStructResult>>&, const Ice::optional<VarStruct>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<VarStruct> opVarStructReq(const Ice::optional<VarStruct>& p1, Ice::optional<VarStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpVarStructReqResult>(true, this, &InitialPrx::_iceI_opVarStructReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVarStructReqAsync(const Ice::optional<VarStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpVarStructReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpVarStructReqResult, P>(false, this, &InitialPrx::_iceI_opVarStructReq, p1, context);
    }

    ::std::function<void()>
    opVarStructReqAsync(const Ice::optional<VarStruct>& p1,
                        ::std::function<void(Ice::optional<::Test::VarStruct>, Ice::optional<::Test::VarStruct>)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpVarStructReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpVarStructReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opVarStructReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opVarStructReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpVarStructReqResult>>&, const Ice::optional<VarStruct>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<::std::shared_ptr<OneOptional>> opOneOptional(const Ice::optional<::std::shared_ptr<OneOptional>>& p1, Ice::optional<::std::shared_ptr<OneOptional>>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpOneOptionalResult>(true, this, &InitialPrx::_iceI_opOneOptional, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOneOptionalAsync(const Ice::optional<::std::shared_ptr<OneOptional>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpOneOptionalResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpOneOptionalResult, P>(false, this, &InitialPrx::_iceI_opOneOptional, p1, context);
    }

    ::std::function<void()>
    opOneOptionalAsync(const Ice::optional<::std::shared_ptr<OneOptional>>& p1,
                       ::std::function<void(Ice::optional<::std::shared_ptr<::Test::OneOptional>>, Ice::optional<::std::shared_ptr<::Test::OneOptional>>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpOneOptionalResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpOneOptionalResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opOneOptional, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opOneOptional(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpOneOptionalResult>>&, const Ice::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<::std::shared_ptr<OneOptional>> opOneOptionalReq(const Ice::optional<::std::shared_ptr<OneOptional>>& p1, Ice::optional<::std::shared_ptr<OneOptional>>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpOneOptionalReqResult>(true, this, &InitialPrx::_iceI_opOneOptionalReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOneOptionalReqAsync(const Ice::optional<::std::shared_ptr<OneOptional>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpOneOptionalReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpOneOptionalReqResult, P>(false, this, &InitialPrx::_iceI_opOneOptionalReq, p1, context);
    }

    ::std::function<void()>
    opOneOptionalReqAsync(const Ice::optional<::std::shared_ptr<OneOptional>>& p1,
                          ::std::function<void(Ice::optional<::std::shared_ptr<::Test::OneOptional>>, Ice::optional<::std::shared_ptr<::Test::OneOptional>>)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpOneOptionalReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpOneOptionalReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opOneOptionalReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opOneOptionalReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpOneOptionalReqResult>>&, const Ice::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>> opOneOptionalProxy(const Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>& p1, Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpOneOptionalProxyResult>(true, this, &InitialPrx::_iceI_opOneOptionalProxy, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOneOptionalProxyAsync(const Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpOneOptionalProxyResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpOneOptionalProxyResult, P>(false, this, &InitialPrx::_iceI_opOneOptionalProxy, p1, context);
    }

    ::std::function<void()>
    opOneOptionalProxyAsync(const Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>& p1,
                            ::std::function<void(Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>, Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpOneOptionalProxyResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpOneOptionalProxyResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opOneOptionalProxy, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opOneOptionalProxy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpOneOptionalProxyResult>>&, const Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>> opOneOptionalProxyReq(const Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>& p1, Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpOneOptionalProxyReqResult>(true, this, &InitialPrx::_iceI_opOneOptionalProxyReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOneOptionalProxyReqAsync(const Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpOneOptionalProxyReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpOneOptionalProxyReqResult, P>(false, this, &InitialPrx::_iceI_opOneOptionalProxyReq, p1, context);
    }

    ::std::function<void()>
    opOneOptionalProxyReqAsync(const Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>& p1,
                               ::std::function<void(Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>, Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpOneOptionalProxyReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpOneOptionalProxyReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opOneOptionalProxyReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opOneOptionalProxyReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpOneOptionalProxyReqResult>>&, const Ice::optional<::std::shared_ptr<::Ice::ObjectPrx>>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<ByteSeq> opByteSeq(const Ice::optional<ByteSeq>& p1, Ice::optional<ByteSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpByteSeqResult>(true, this, &InitialPrx::_iceI_opByteSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteSeqAsync(const Ice::optional<ByteSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpByteSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpByteSeqResult, P>(false, this, &InitialPrx::_iceI_opByteSeq, p1, context);
    }

    ::std::function<void()>
    opByteSeqAsync(const Ice::optional<ByteSeq>& p1,
                   ::std::function<void(Ice::optional<::Test::ByteSeq>, Ice::optional<::Test::ByteSeq>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpByteSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpByteSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opByteSeq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpByteSeqResult>>&, const Ice::optional<ByteSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<ByteSeq> opByteSeqReq(const Ice::optional<ByteSeq>& p1, Ice::optional<ByteSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpByteSeqReqResult>(true, this, &InitialPrx::_iceI_opByteSeqReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteSeqReqAsync(const Ice::optional<ByteSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpByteSeqReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpByteSeqReqResult, P>(false, this, &InitialPrx::_iceI_opByteSeqReq, p1, context);
    }

    ::std::function<void()>
    opByteSeqReqAsync(const Ice::optional<ByteSeq>& p1,
                      ::std::function<void(Ice::optional<::Test::ByteSeq>, Ice::optional<::Test::ByteSeq>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpByteSeqReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpByteSeqReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opByteSeqReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteSeqReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpByteSeqReqResult>>&, const Ice::optional<ByteSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<BoolSeq> opBoolSeq(const Ice::optional<BoolSeq>& p1, Ice::optional<BoolSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpBoolSeqResult>(true, this, &InitialPrx::_iceI_opBoolSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolSeqAsync(const Ice::optional<BoolSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpBoolSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpBoolSeqResult, P>(false, this, &InitialPrx::_iceI_opBoolSeq, p1, context);
    }

    ::std::function<void()>
    opBoolSeqAsync(const Ice::optional<BoolSeq>& p1,
                   ::std::function<void(Ice::optional<::Test::BoolSeq>, Ice::optional<::Test::BoolSeq>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpBoolSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpBoolSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opBoolSeq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpBoolSeqResult>>&, const Ice::optional<BoolSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<BoolSeq> opBoolSeqReq(const Ice::optional<BoolSeq>& p1, Ice::optional<BoolSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpBoolSeqReqResult>(true, this, &InitialPrx::_iceI_opBoolSeqReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolSeqReqAsync(const Ice::optional<BoolSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpBoolSeqReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpBoolSeqReqResult, P>(false, this, &InitialPrx::_iceI_opBoolSeqReq, p1, context);
    }

    ::std::function<void()>
    opBoolSeqReqAsync(const Ice::optional<BoolSeq>& p1,
                      ::std::function<void(Ice::optional<::Test::BoolSeq>, Ice::optional<::Test::BoolSeq>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpBoolSeqReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpBoolSeqReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opBoolSeqReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolSeqReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpBoolSeqReqResult>>&, const Ice::optional<BoolSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<ShortSeq> opShortSeq(const Ice::optional<ShortSeq>& p1, Ice::optional<ShortSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpShortSeqResult>(true, this, &InitialPrx::_iceI_opShortSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortSeqAsync(const Ice::optional<ShortSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpShortSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpShortSeqResult, P>(false, this, &InitialPrx::_iceI_opShortSeq, p1, context);
    }

    ::std::function<void()>
    opShortSeqAsync(const Ice::optional<ShortSeq>& p1,
                    ::std::function<void(Ice::optional<::Test::ShortSeq>, Ice::optional<::Test::ShortSeq>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpShortSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpShortSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opShortSeq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpShortSeqResult>>&, const Ice::optional<ShortSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<ShortSeq> opShortSeqReq(const Ice::optional<ShortSeq>& p1, Ice::optional<ShortSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpShortSeqReqResult>(true, this, &InitialPrx::_iceI_opShortSeqReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortSeqReqAsync(const Ice::optional<ShortSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpShortSeqReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpShortSeqReqResult, P>(false, this, &InitialPrx::_iceI_opShortSeqReq, p1, context);
    }

    ::std::function<void()>
    opShortSeqReqAsync(const Ice::optional<ShortSeq>& p1,
                       ::std::function<void(Ice::optional<::Test::ShortSeq>, Ice::optional<::Test::ShortSeq>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpShortSeqReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpShortSeqReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opShortSeqReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortSeqReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpShortSeqReqResult>>&, const Ice::optional<ShortSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<IntSeq> opIntSeq(const Ice::optional<IntSeq>& p1, Ice::optional<IntSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpIntSeqResult>(true, this, &InitialPrx::_iceI_opIntSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntSeqAsync(const Ice::optional<IntSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpIntSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpIntSeqResult, P>(false, this, &InitialPrx::_iceI_opIntSeq, p1, context);
    }

    ::std::function<void()>
    opIntSeqAsync(const Ice::optional<IntSeq>& p1,
                  ::std::function<void(Ice::optional<::Test::IntSeq>, Ice::optional<::Test::IntSeq>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpIntSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpIntSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opIntSeq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpIntSeqResult>>&, const Ice::optional<IntSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<IntSeq> opIntSeqReq(const Ice::optional<IntSeq>& p1, Ice::optional<IntSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpIntSeqReqResult>(true, this, &InitialPrx::_iceI_opIntSeqReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntSeqReqAsync(const Ice::optional<IntSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpIntSeqReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpIntSeqReqResult, P>(false, this, &InitialPrx::_iceI_opIntSeqReq, p1, context);
    }

    ::std::function<void()>
    opIntSeqReqAsync(const Ice::optional<IntSeq>& p1,
                     ::std::function<void(Ice::optional<::Test::IntSeq>, Ice::optional<::Test::IntSeq>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpIntSeqReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpIntSeqReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opIntSeqReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntSeqReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpIntSeqReqResult>>&, const Ice::optional<IntSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<LongSeq> opLongSeq(const Ice::optional<LongSeq>& p1, Ice::optional<LongSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpLongSeqResult>(true, this, &InitialPrx::_iceI_opLongSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLongSeqAsync(const Ice::optional<LongSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpLongSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpLongSeqResult, P>(false, this, &InitialPrx::_iceI_opLongSeq, p1, context);
    }

    ::std::function<void()>
    opLongSeqAsync(const Ice::optional<LongSeq>& p1,
                   ::std::function<void(Ice::optional<::Test::LongSeq>, Ice::optional<::Test::LongSeq>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpLongSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpLongSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opLongSeq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpLongSeqResult>>&, const Ice::optional<LongSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<LongSeq> opLongSeqReq(const Ice::optional<LongSeq>& p1, Ice::optional<LongSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpLongSeqReqResult>(true, this, &InitialPrx::_iceI_opLongSeqReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLongSeqReqAsync(const Ice::optional<LongSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpLongSeqReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpLongSeqReqResult, P>(false, this, &InitialPrx::_iceI_opLongSeqReq, p1, context);
    }

    ::std::function<void()>
    opLongSeqReqAsync(const Ice::optional<LongSeq>& p1,
                      ::std::function<void(Ice::optional<::Test::LongSeq>, Ice::optional<::Test::LongSeq>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpLongSeqReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpLongSeqReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opLongSeqReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opLongSeqReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpLongSeqReqResult>>&, const Ice::optional<LongSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<FloatSeq> opFloatSeq(const Ice::optional<FloatSeq>& p1, Ice::optional<FloatSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFloatSeqResult>(true, this, &InitialPrx::_iceI_opFloatSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatSeqAsync(const Ice::optional<FloatSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFloatSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFloatSeqResult, P>(false, this, &InitialPrx::_iceI_opFloatSeq, p1, context);
    }

    ::std::function<void()>
    opFloatSeqAsync(const Ice::optional<FloatSeq>& p1,
                    ::std::function<void(Ice::optional<::Test::FloatSeq>, Ice::optional<::Test::FloatSeq>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpFloatSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpFloatSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opFloatSeq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFloatSeqResult>>&, const Ice::optional<FloatSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<FloatSeq> opFloatSeqReq(const Ice::optional<FloatSeq>& p1, Ice::optional<FloatSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFloatSeqReqResult>(true, this, &InitialPrx::_iceI_opFloatSeqReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatSeqReqAsync(const Ice::optional<FloatSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFloatSeqReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFloatSeqReqResult, P>(false, this, &InitialPrx::_iceI_opFloatSeqReq, p1, context);
    }

    ::std::function<void()>
    opFloatSeqReqAsync(const Ice::optional<FloatSeq>& p1,
                       ::std::function<void(Ice::optional<::Test::FloatSeq>, Ice::optional<::Test::FloatSeq>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpFloatSeqReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpFloatSeqReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opFloatSeqReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloatSeqReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFloatSeqReqResult>>&, const Ice::optional<FloatSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<DoubleSeq> opDoubleSeq(const Ice::optional<DoubleSeq>& p1, Ice::optional<DoubleSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpDoubleSeqResult>(true, this, &InitialPrx::_iceI_opDoubleSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleSeqAsync(const Ice::optional<DoubleSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpDoubleSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpDoubleSeqResult, P>(false, this, &InitialPrx::_iceI_opDoubleSeq, p1, context);
    }

    ::std::function<void()>
    opDoubleSeqAsync(const Ice::optional<DoubleSeq>& p1,
                     ::std::function<void(Ice::optional<::Test::DoubleSeq>, Ice::optional<::Test::DoubleSeq>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpDoubleSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpDoubleSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opDoubleSeq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpDoubleSeqResult>>&, const Ice::optional<DoubleSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<DoubleSeq> opDoubleSeqReq(const Ice::optional<DoubleSeq>& p1, Ice::optional<DoubleSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpDoubleSeqReqResult>(true, this, &InitialPrx::_iceI_opDoubleSeqReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleSeqReqAsync(const Ice::optional<DoubleSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpDoubleSeqReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpDoubleSeqReqResult, P>(false, this, &InitialPrx::_iceI_opDoubleSeqReq, p1, context);
    }

    ::std::function<void()>
    opDoubleSeqReqAsync(const Ice::optional<DoubleSeq>& p1,
                        ::std::function<void(Ice::optional<::Test::DoubleSeq>, Ice::optional<::Test::DoubleSeq>)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpDoubleSeqReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpDoubleSeqReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opDoubleSeqReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opDoubleSeqReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpDoubleSeqReqResult>>&, const Ice::optional<DoubleSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<StringSeq> opStringSeq(const Ice::optional<StringSeq>& p1, Ice::optional<StringSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpStringSeqResult>(true, this, &InitialPrx::_iceI_opStringSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringSeqAsync(const Ice::optional<StringSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpStringSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpStringSeqResult, P>(false, this, &InitialPrx::_iceI_opStringSeq, p1, context);
    }

    ::std::function<void()>
    opStringSeqAsync(const Ice::optional<StringSeq>& p1,
                     ::std::function<void(Ice::optional<::Test::StringSeq>, Ice::optional<::Test::StringSeq>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpStringSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpStringSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opStringSeq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpStringSeqResult>>&, const Ice::optional<StringSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<StringSeq> opStringSeqReq(const Ice::optional<StringSeq>& p1, Ice::optional<StringSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpStringSeqReqResult>(true, this, &InitialPrx::_iceI_opStringSeqReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringSeqReqAsync(const Ice::optional<StringSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpStringSeqReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpStringSeqReqResult, P>(false, this, &InitialPrx::_iceI_opStringSeqReq, p1, context);
    }

    ::std::function<void()>
    opStringSeqReqAsync(const Ice::optional<StringSeq>& p1,
                        ::std::function<void(Ice::optional<::Test::StringSeq>, Ice::optional<::Test::StringSeq>)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpStringSeqReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpStringSeqReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opStringSeqReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringSeqReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpStringSeqReqResult>>&, const Ice::optional<StringSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<SmallStructSeq> opSmallStructSeq(const Ice::optional<SmallStructSeq>& p1, Ice::optional<SmallStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpSmallStructSeqResult>(true, this, &InitialPrx::_iceI_opSmallStructSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSmallStructSeqAsync(const Ice::optional<SmallStructSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpSmallStructSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpSmallStructSeqResult, P>(false, this, &InitialPrx::_iceI_opSmallStructSeq, p1, context);
    }

    ::std::function<void()>
    opSmallStructSeqAsync(const Ice::optional<SmallStructSeq>& p1,
                          ::std::function<void(Ice::optional<::Test::SmallStructSeq>, Ice::optional<::Test::SmallStructSeq>)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpSmallStructSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpSmallStructSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opSmallStructSeq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opSmallStructSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpSmallStructSeqResult>>&, const Ice::optional<SmallStructSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<SmallStructSeq> opSmallStructSeqReq(const Ice::optional<SmallStructSeq>& p1, Ice::optional<SmallStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpSmallStructSeqReqResult>(true, this, &InitialPrx::_iceI_opSmallStructSeqReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSmallStructSeqReqAsync(const Ice::optional<SmallStructSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpSmallStructSeqReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpSmallStructSeqReqResult, P>(false, this, &InitialPrx::_iceI_opSmallStructSeqReq, p1, context);
    }

    ::std::function<void()>
    opSmallStructSeqReqAsync(const Ice::optional<SmallStructSeq>& p1,
                             ::std::function<void(Ice::optional<::Test::SmallStructSeq>, Ice::optional<::Test::SmallStructSeq>)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpSmallStructSeqReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpSmallStructSeqReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opSmallStructSeqReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opSmallStructSeqReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpSmallStructSeqReqResult>>&, const Ice::optional<SmallStructSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<SmallStructList> opSmallStructList(const Ice::optional<SmallStructList>& p1, Ice::optional<SmallStructList>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpSmallStructListResult>(true, this, &InitialPrx::_iceI_opSmallStructList, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSmallStructListAsync(const Ice::optional<SmallStructList>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpSmallStructListResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpSmallStructListResult, P>(false, this, &InitialPrx::_iceI_opSmallStructList, p1, context);
    }

    ::std::function<void()>
    opSmallStructListAsync(const Ice::optional<SmallStructList>& p1,
                           ::std::function<void(Ice::optional<::Test::SmallStructList>, Ice::optional<::Test::SmallStructList>)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpSmallStructListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpSmallStructListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opSmallStructList, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opSmallStructList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpSmallStructListResult>>&, const Ice::optional<SmallStructList>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<SmallStructList> opSmallStructListReq(const Ice::optional<SmallStructList>& p1, Ice::optional<SmallStructList>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpSmallStructListReqResult>(true, this, &InitialPrx::_iceI_opSmallStructListReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSmallStructListReqAsync(const Ice::optional<SmallStructList>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpSmallStructListReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpSmallStructListReqResult, P>(false, this, &InitialPrx::_iceI_opSmallStructListReq, p1, context);
    }

    ::std::function<void()>
    opSmallStructListReqAsync(const Ice::optional<SmallStructList>& p1,
                              ::std::function<void(Ice::optional<::Test::SmallStructList>, Ice::optional<::Test::SmallStructList>)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpSmallStructListReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpSmallStructListReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opSmallStructListReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opSmallStructListReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpSmallStructListReqResult>>&, const Ice::optional<SmallStructList>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<FixedStructSeq> opFixedStructSeq(const Ice::optional<FixedStructSeq>& p1, Ice::optional<FixedStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFixedStructSeqResult>(true, this, &InitialPrx::_iceI_opFixedStructSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFixedStructSeqAsync(const Ice::optional<FixedStructSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFixedStructSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFixedStructSeqResult, P>(false, this, &InitialPrx::_iceI_opFixedStructSeq, p1, context);
    }

    ::std::function<void()>
    opFixedStructSeqAsync(const Ice::optional<FixedStructSeq>& p1,
                          ::std::function<void(Ice::optional<::Test::FixedStructSeq>, Ice::optional<::Test::FixedStructSeq>)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpFixedStructSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpFixedStructSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opFixedStructSeq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opFixedStructSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFixedStructSeqResult>>&, const Ice::optional<FixedStructSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<FixedStructSeq> opFixedStructSeqReq(const Ice::optional<FixedStructSeq>& p1, Ice::optional<FixedStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFixedStructSeqReqResult>(true, this, &InitialPrx::_iceI_opFixedStructSeqReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFixedStructSeqReqAsync(const Ice::optional<FixedStructSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFixedStructSeqReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFixedStructSeqReqResult, P>(false, this, &InitialPrx::_iceI_opFixedStructSeqReq, p1, context);
    }

    ::std::function<void()>
    opFixedStructSeqReqAsync(const Ice::optional<FixedStructSeq>& p1,
                             ::std::function<void(Ice::optional<::Test::FixedStructSeq>, Ice::optional<::Test::FixedStructSeq>)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpFixedStructSeqReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpFixedStructSeqReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opFixedStructSeqReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opFixedStructSeqReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFixedStructSeqReqResult>>&, const Ice::optional<FixedStructSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<FixedStructList> opFixedStructList(const Ice::optional<FixedStructList>& p1, Ice::optional<FixedStructList>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFixedStructListResult>(true, this, &InitialPrx::_iceI_opFixedStructList, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFixedStructListAsync(const Ice::optional<FixedStructList>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFixedStructListResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFixedStructListResult, P>(false, this, &InitialPrx::_iceI_opFixedStructList, p1, context);
    }

    ::std::function<void()>
    opFixedStructListAsync(const Ice::optional<FixedStructList>& p1,
                           ::std::function<void(Ice::optional<::Test::FixedStructList>, Ice::optional<::Test::FixedStructList>)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpFixedStructListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpFixedStructListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opFixedStructList, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opFixedStructList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFixedStructListResult>>&, const Ice::optional<FixedStructList>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<FixedStructList> opFixedStructListReq(const Ice::optional<FixedStructList>& p1, Ice::optional<FixedStructList>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFixedStructListReqResult>(true, this, &InitialPrx::_iceI_opFixedStructListReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFixedStructListReqAsync(const Ice::optional<FixedStructList>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFixedStructListReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFixedStructListReqResult, P>(false, this, &InitialPrx::_iceI_opFixedStructListReq, p1, context);
    }

    ::std::function<void()>
    opFixedStructListReqAsync(const Ice::optional<FixedStructList>& p1,
                              ::std::function<void(Ice::optional<::Test::FixedStructList>, Ice::optional<::Test::FixedStructList>)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpFixedStructListReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpFixedStructListReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opFixedStructListReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opFixedStructListReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFixedStructListReqResult>>&, const Ice::optional<FixedStructList>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<VarStructSeq> opVarStructSeq(const Ice::optional<VarStructSeq>& p1, Ice::optional<VarStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpVarStructSeqResult>(true, this, &InitialPrx::_iceI_opVarStructSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVarStructSeqAsync(const Ice::optional<VarStructSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpVarStructSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpVarStructSeqResult, P>(false, this, &InitialPrx::_iceI_opVarStructSeq, p1, context);
    }

    ::std::function<void()>
    opVarStructSeqAsync(const Ice::optional<VarStructSeq>& p1,
                        ::std::function<void(Ice::optional<::Test::VarStructSeq>, Ice::optional<::Test::VarStructSeq>)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpVarStructSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpVarStructSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opVarStructSeq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opVarStructSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpVarStructSeqResult>>&, const Ice::optional<VarStructSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<VarStructSeq> opVarStructSeqReq(const Ice::optional<VarStructSeq>& p1, Ice::optional<VarStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpVarStructSeqReqResult>(true, this, &InitialPrx::_iceI_opVarStructSeqReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVarStructSeqReqAsync(const Ice::optional<VarStructSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpVarStructSeqReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpVarStructSeqReqResult, P>(false, this, &InitialPrx::_iceI_opVarStructSeqReq, p1, context);
    }

    ::std::function<void()>
    opVarStructSeqReqAsync(const Ice::optional<VarStructSeq>& p1,
                           ::std::function<void(Ice::optional<::Test::VarStructSeq>, Ice::optional<::Test::VarStructSeq>)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpVarStructSeqReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpVarStructSeqReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opVarStructSeqReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opVarStructSeqReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpVarStructSeqReqResult>>&, const Ice::optional<VarStructSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<Serializable> opSerializable(const Ice::optional<Serializable>& p1, Ice::optional<Serializable>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpSerializableResult>(true, this, &InitialPrx::_iceI_opSerializable, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSerializableAsync(const Ice::optional<Serializable>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpSerializableResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpSerializableResult, P>(false, this, &InitialPrx::_iceI_opSerializable, p1, context);
    }

    ::std::function<void()>
    opSerializableAsync(const Ice::optional<Serializable>& p1,
                        ::std::function<void(Ice::optional<::Test::Serializable>, Ice::optional<::Test::Serializable>)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpSerializableResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpSerializableResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opSerializable, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opSerializable(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpSerializableResult>>&, const Ice::optional<Serializable>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<Serializable> opSerializableReq(const Ice::optional<Serializable>& p1, Ice::optional<Serializable>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpSerializableReqResult>(true, this, &InitialPrx::_iceI_opSerializableReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSerializableReqAsync(const Ice::optional<Serializable>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpSerializableReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpSerializableReqResult, P>(false, this, &InitialPrx::_iceI_opSerializableReq, p1, context);
    }

    ::std::function<void()>
    opSerializableReqAsync(const Ice::optional<Serializable>& p1,
                           ::std::function<void(Ice::optional<::Test::Serializable>, Ice::optional<::Test::Serializable>)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpSerializableReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpSerializableReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opSerializableReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opSerializableReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpSerializableReqResult>>&, const Ice::optional<Serializable>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<IntIntDict> opIntIntDict(const Ice::optional<IntIntDict>& p1, Ice::optional<IntIntDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpIntIntDictResult>(true, this, &InitialPrx::_iceI_opIntIntDict, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntIntDictAsync(const Ice::optional<IntIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpIntIntDictResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpIntIntDictResult, P>(false, this, &InitialPrx::_iceI_opIntIntDict, p1, context);
    }

    ::std::function<void()>
    opIntIntDictAsync(const Ice::optional<IntIntDict>& p1,
                      ::std::function<void(Ice::optional<::Test::IntIntDict>, Ice::optional<::Test::IntIntDict>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpIntIntDictResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpIntIntDictResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opIntIntDict, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntIntDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpIntIntDictResult>>&, const Ice::optional<IntIntDict>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<IntIntDict> opIntIntDictReq(const Ice::optional<IntIntDict>& p1, Ice::optional<IntIntDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpIntIntDictReqResult>(true, this, &InitialPrx::_iceI_opIntIntDictReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntIntDictReqAsync(const Ice::optional<IntIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpIntIntDictReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpIntIntDictReqResult, P>(false, this, &InitialPrx::_iceI_opIntIntDictReq, p1, context);
    }

    ::std::function<void()>
    opIntIntDictReqAsync(const Ice::optional<IntIntDict>& p1,
                         ::std::function<void(Ice::optional<::Test::IntIntDict>, Ice::optional<::Test::IntIntDict>)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpIntIntDictReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpIntIntDictReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opIntIntDictReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntIntDictReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpIntIntDictReqResult>>&, const Ice::optional<IntIntDict>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<StringIntDict> opStringIntDict(const Ice::optional<StringIntDict>& p1, Ice::optional<StringIntDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpStringIntDictResult>(true, this, &InitialPrx::_iceI_opStringIntDict, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringIntDictAsync(const Ice::optional<StringIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpStringIntDictResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpStringIntDictResult, P>(false, this, &InitialPrx::_iceI_opStringIntDict, p1, context);
    }

    ::std::function<void()>
    opStringIntDictAsync(const Ice::optional<StringIntDict>& p1,
                         ::std::function<void(Ice::optional<::Test::StringIntDict>, Ice::optional<::Test::StringIntDict>)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpStringIntDictResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpStringIntDictResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opStringIntDict, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringIntDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpStringIntDictResult>>&, const Ice::optional<StringIntDict>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<StringIntDict> opStringIntDictReq(const Ice::optional<StringIntDict>& p1, Ice::optional<StringIntDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpStringIntDictReqResult>(true, this, &InitialPrx::_iceI_opStringIntDictReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringIntDictReqAsync(const Ice::optional<StringIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpStringIntDictReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpStringIntDictReqResult, P>(false, this, &InitialPrx::_iceI_opStringIntDictReq, p1, context);
    }

    ::std::function<void()>
    opStringIntDictReqAsync(const Ice::optional<StringIntDict>& p1,
                            ::std::function<void(Ice::optional<::Test::StringIntDict>, Ice::optional<::Test::StringIntDict>)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpStringIntDictReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpStringIntDictReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opStringIntDictReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringIntDictReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpStringIntDictReqResult>>&, const Ice::optional<StringIntDict>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<IntOneOptionalDict> opIntOneOptionalDict(const Ice::optional<IntOneOptionalDict>& p1, Ice::optional<IntOneOptionalDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpIntOneOptionalDictResult>(true, this, &InitialPrx::_iceI_opIntOneOptionalDict, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntOneOptionalDictAsync(const Ice::optional<IntOneOptionalDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpIntOneOptionalDictResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpIntOneOptionalDictResult, P>(false, this, &InitialPrx::_iceI_opIntOneOptionalDict, p1, context);
    }

    ::std::function<void()>
    opIntOneOptionalDictAsync(const Ice::optional<IntOneOptionalDict>& p1,
                              ::std::function<void(Ice::optional<::Test::IntOneOptionalDict>, Ice::optional<::Test::IntOneOptionalDict>)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpIntOneOptionalDictResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpIntOneOptionalDictResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opIntOneOptionalDict, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntOneOptionalDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpIntOneOptionalDictResult>>&, const Ice::optional<IntOneOptionalDict>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<IntOneOptionalDict> opIntOneOptionalDictReq(const Ice::optional<IntOneOptionalDict>& p1, Ice::optional<IntOneOptionalDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpIntOneOptionalDictReqResult>(true, this, &InitialPrx::_iceI_opIntOneOptionalDictReq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntOneOptionalDictReqAsync(const Ice::optional<IntOneOptionalDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpIntOneOptionalDictReqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpIntOneOptionalDictReqResult, P>(false, this, &InitialPrx::_iceI_opIntOneOptionalDictReq, p1, context);
    }

    ::std::function<void()>
    opIntOneOptionalDictReqAsync(const Ice::optional<IntOneOptionalDict>& p1,
                                 ::std::function<void(Ice::optional<::Test::IntOneOptionalDict>, Ice::optional<::Test::IntOneOptionalDict>)> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpIntOneOptionalDictReqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpIntOneOptionalDictReqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opIntOneOptionalDictReq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntOneOptionalDictReq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpIntOneOptionalDictReqResult>>&, const Ice::optional<IntOneOptionalDict>&, const ::Ice::Context&);
    /// \endcond

    void opClassAndUnknownOptional(const ::std::shared_ptr<A>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_opClassAndUnknownOptional, p, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opClassAndUnknownOptionalAsync(const ::std::shared_ptr<A>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_opClassAndUnknownOptional, p, context);
    }

    ::std::function<void()>
    opClassAndUnknownOptionalAsync(const ::std::shared_ptr<A>& p,
                                   ::std::function<void()> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opClassAndUnknownOptional, p, context);
    }

    /// \cond INTERNAL
    void _iceI_opClassAndUnknownOptional(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<A>&, const ::Ice::Context&);
    /// \endcond

    void sendOptionalClass(bool req, const Ice::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_sendOptionalClass, req, o, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto sendOptionalClassAsync(bool req, const Ice::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_sendOptionalClass, req, o, context);
    }

    ::std::function<void()>
    sendOptionalClassAsync(bool req, const Ice::optional<::std::shared_ptr<OneOptional>>& o,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_sendOptionalClass, req, o, context);
    }

    /// \cond INTERNAL
    void _iceI_sendOptionalClass(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, bool, const Ice::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&);
    /// \endcond

    void returnOptionalClass(bool req, Ice::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        o = _makePromiseOutgoing<Ice::optional<::std::shared_ptr<::Test::OneOptional>>>(true, this, &InitialPrx::_iceI_returnOptionalClass, req, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto returnOptionalClassAsync(bool req, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Ice::optional<::std::shared_ptr<::Test::OneOptional>>>>().get_future())
    {
        return _makePromiseOutgoing<Ice::optional<::std::shared_ptr<::Test::OneOptional>>, P>(false, this, &InitialPrx::_iceI_returnOptionalClass, req, context);
    }

    ::std::function<void()>
    returnOptionalClassAsync(bool req,
                             ::std::function<void(Ice::optional<::std::shared_ptr<::Test::OneOptional>>)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<Ice::optional<::std::shared_ptr<::Test::OneOptional>>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_returnOptionalClass, req, context);
    }

    /// \cond INTERNAL
    void _iceI_returnOptionalClass(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Ice::optional<::std::shared_ptr<::Test::OneOptional>>>>&, bool, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<G> opG(const ::std::shared_ptr<G>& g, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::G>>(true, this, &InitialPrx::_iceI_opG, g, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opGAsync(const ::std::shared_ptr<G>& g, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::G>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::G>, P>(false, this, &InitialPrx::_iceI_opG, g, context);
    }

    ::std::function<void()>
    opGAsync(const ::std::shared_ptr<G>& g,
             ::std::function<void(::std::shared_ptr<::Test::G>)> response,
             ::std::function<void(::std::exception_ptr)> ex = nullptr,
             ::std::function<void(bool)> sent = nullptr,
             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::G>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opG, g, context);
    }

    /// \cond INTERNAL
    void _iceI_opG(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::G>>>&, const ::std::shared_ptr<G>&, const ::Ice::Context&);
    /// \endcond

    void opVoid(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_opVoid, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opVoidAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_opVoid, context);
    }

    ::std::function<void()>
    opVoidAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opVoid, context);
    }

    /// \cond INTERNAL
    void _iceI_opVoid(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<SmallStruct> opMStruct1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<Ice::optional<::Test::SmallStruct>>(true, this, &InitialPrx::_iceI_opMStruct1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opMStruct1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Ice::optional<::Test::SmallStruct>>>().get_future())
    {
        return _makePromiseOutgoing<Ice::optional<::Test::SmallStruct>, P>(false, this, &InitialPrx::_iceI_opMStruct1, context);
    }

    ::std::function<void()>
    opMStruct1Async(::std::function<void(Ice::optional<::Test::SmallStruct>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<Ice::optional<::Test::SmallStruct>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMStruct1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMStruct1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Ice::optional<::Test::SmallStruct>>>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<SmallStruct> opMStruct2(const Ice::optional<SmallStruct>& p1, Ice::optional<SmallStruct>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpMStruct2Result>(true, this, &InitialPrx::_iceI_opMStruct2, p1, context).get();
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMStruct2Async(const Ice::optional<SmallStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpMStruct2Result>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpMStruct2Result, P>(false, this, &InitialPrx::_iceI_opMStruct2, p1, context);
    }

    ::std::function<void()>
    opMStruct2Async(const Ice::optional<SmallStruct>& p1,
                    ::std::function<void(Ice::optional<::Test::SmallStruct>, Ice::optional<::Test::SmallStruct>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpMStruct2Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p2));
        };
        return _makeLambdaOutgoing<Initial::OpMStruct2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMStruct2, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMStruct2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpMStruct2Result>>&, const Ice::optional<SmallStruct>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<StringSeq> opMSeq1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<Ice::optional<::Test::StringSeq>>(true, this, &InitialPrx::_iceI_opMSeq1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opMSeq1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Ice::optional<::Test::StringSeq>>>().get_future())
    {
        return _makePromiseOutgoing<Ice::optional<::Test::StringSeq>, P>(false, this, &InitialPrx::_iceI_opMSeq1, context);
    }

    ::std::function<void()>
    opMSeq1Async(::std::function<void(Ice::optional<::Test::StringSeq>)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<Ice::optional<::Test::StringSeq>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMSeq1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMSeq1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Ice::optional<::Test::StringSeq>>>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<StringSeq> opMSeq2(const Ice::optional<StringSeq>& p1, Ice::optional<StringSeq>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpMSeq2Result>(true, this, &InitialPrx::_iceI_opMSeq2, p1, context).get();
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMSeq2Async(const Ice::optional<StringSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpMSeq2Result>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpMSeq2Result, P>(false, this, &InitialPrx::_iceI_opMSeq2, p1, context);
    }

    ::std::function<void()>
    opMSeq2Async(const Ice::optional<StringSeq>& p1,
                 ::std::function<void(Ice::optional<::Test::StringSeq>, Ice::optional<::Test::StringSeq>)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpMSeq2Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p2));
        };
        return _makeLambdaOutgoing<Initial::OpMSeq2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMSeq2, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMSeq2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpMSeq2Result>>&, const Ice::optional<StringSeq>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<StringIntDict> opMDict1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<Ice::optional<::Test::StringIntDict>>(true, this, &InitialPrx::_iceI_opMDict1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opMDict1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Ice::optional<::Test::StringIntDict>>>().get_future())
    {
        return _makePromiseOutgoing<Ice::optional<::Test::StringIntDict>, P>(false, this, &InitialPrx::_iceI_opMDict1, context);
    }

    ::std::function<void()>
    opMDict1Async(::std::function<void(Ice::optional<::Test::StringIntDict>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<Ice::optional<::Test::StringIntDict>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMDict1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMDict1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Ice::optional<::Test::StringIntDict>>>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<StringIntDict> opMDict2(const Ice::optional<StringIntDict>& p1, Ice::optional<StringIntDict>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpMDict2Result>(true, this, &InitialPrx::_iceI_opMDict2, p1, context).get();
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMDict2Async(const Ice::optional<StringIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpMDict2Result>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpMDict2Result, P>(false, this, &InitialPrx::_iceI_opMDict2, p1, context);
    }

    ::std::function<void()>
    opMDict2Async(const Ice::optional<StringIntDict>& p1,
                  ::std::function<void(Ice::optional<::Test::StringIntDict>, Ice::optional<::Test::StringIntDict>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpMDict2Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p2));
        };
        return _makeLambdaOutgoing<Initial::OpMDict2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMDict2, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMDict2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpMDict2Result>>&, const Ice::optional<StringIntDict>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<::std::shared_ptr<G>> opMG1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<Ice::optional<::std::shared_ptr<::Test::G>>>(true, this, &InitialPrx::_iceI_opMG1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opMG1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Ice::optional<::std::shared_ptr<::Test::G>>>>().get_future())
    {
        return _makePromiseOutgoing<Ice::optional<::std::shared_ptr<::Test::G>>, P>(false, this, &InitialPrx::_iceI_opMG1, context);
    }

    ::std::function<void()>
    opMG1Async(::std::function<void(Ice::optional<::std::shared_ptr<::Test::G>>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<Ice::optional<::std::shared_ptr<::Test::G>>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMG1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMG1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Ice::optional<::std::shared_ptr<::Test::G>>>>&, const ::Ice::Context&);
    /// \endcond

    Ice::optional<::std::shared_ptr<G>> opMG2(const Ice::optional<::std::shared_ptr<G>>& p1, Ice::optional<::std::shared_ptr<G>>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpMG2Result>(true, this, &InitialPrx::_iceI_opMG2, p1, context).get();
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMG2Async(const Ice::optional<::std::shared_ptr<G>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpMG2Result>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpMG2Result, P>(false, this, &InitialPrx::_iceI_opMG2, p1, context);
    }

    ::std::function<void()>
    opMG2Async(const Ice::optional<::std::shared_ptr<G>>& p1,
               ::std::function<void(Ice::optional<::std::shared_ptr<::Test::G>>, Ice::optional<::std::shared_ptr<::Test::G>>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpMG2Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p2));
        };
        return _makeLambdaOutgoing<Initial::OpMG2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMG2, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMG2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpMG2Result>>&, const Ice::optional<::std::shared_ptr<G>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsRequiredParams(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_supportsRequiredParams, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsRequiredParamsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InitialPrx::_iceI_supportsRequiredParams, context);
    }

    ::std::function<void()>
    supportsRequiredParamsAsync(::std::function<void(bool)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_supportsRequiredParams, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsRequiredParams(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsJavaSerializable(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_supportsJavaSerializable, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsJavaSerializableAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InitialPrx::_iceI_supportsJavaSerializable, context);
    }

    ::std::function<void()>
    supportsJavaSerializableAsync(::std::function<void(bool)> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_supportsJavaSerializable, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsJavaSerializable(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsCsharpSerializable(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_supportsCsharpSerializable, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsCsharpSerializableAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InitialPrx::_iceI_supportsCsharpSerializable, context);
    }

    ::std::function<void()>
    supportsCsharpSerializableAsync(::std::function<void(bool)> response,
                                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                    ::std::function<void(bool)> sent = nullptr,
                                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_supportsCsharpSerializable, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsCsharpSerializable(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsCppStringView(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_supportsCppStringView, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsCppStringViewAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InitialPrx::_iceI_supportsCppStringView, context);
    }

    ::std::function<void()>
    supportsCppStringViewAsync(::std::function<void(bool)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_supportsCppStringView, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsCppStringView(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsNullOptional(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_supportsNullOptional, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsNullOptionalAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InitialPrx::_iceI_supportsNullOptional, context);
    }

    ::std::function<void()>
    supportsNullOptionalAsync(::std::function<void(bool)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_supportsNullOptional, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsNullOptional(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    InitialPrx() = default;
    friend ::std::shared_ptr<InitialPrx> IceInternal::createProxy<InitialPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter<::Test::OneOptional, S>
{
    static void write(S* ostr, const ::Test::OneOptional& v)
    {
        ostr->writeAll({1}, v.a);
    }
};

template<typename S>
struct StreamReader<::Test::OneOptional, S>
{
    static void read(S* istr, ::Test::OneOptional& v)
    {
        istr->readAll({1}, v.a);
    }
};

template<>
struct StreamableTraits< ::Test::MyEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 0;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::SmallStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::SmallStruct, S>
{
    static void read(S* istr, ::Test::SmallStruct& v)
    {
        istr->readAll(v.m);
    }
};

template<>
struct StreamableTraits<::Test::FixedStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::FixedStruct, S>
{
    static void read(S* istr, ::Test::FixedStruct& v)
    {
        istr->readAll(v.m);
    }
};

template<>
struct StreamableTraits<::Test::VarStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::VarStruct, S>
{
    static void read(S* istr, ::Test::VarStruct& v)
    {
        istr->readAll(v.m);
    }
};

template<>
struct StreamableTraits<::Test::ClassVarStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::ClassVarStruct, S>
{
    static void read(S* istr, ::Test::ClassVarStruct& v)
    {
        istr->readAll(v.a);
    }
};

template<typename S>
struct StreamWriter<::Test::MultiOptional, S>
{
    static void write(S* ostr, const ::Test::MultiOptional& v)
    {
        ostr->writeAll({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}, v.a, v.b, v.c, v.d, v.e, v.f, v.g, v.h, v.i, v.j, v.k, v.bs, v.ss, v.iid, v.sid, v.fs, v.vs, v.shs, v.es, v.fss, v.vss, v.oos, v.oops, v.ied, v.ifsd, v.ivsd, v.iood, v.ioopd, v.bos, v.ser);
    }
};

template<typename S>
struct StreamReader<::Test::MultiOptional, S>
{
    static void read(S* istr, ::Test::MultiOptional& v)
    {
        istr->readAll({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}, v.a, v.b, v.c, v.d, v.e, v.f, v.g, v.h, v.i, v.j, v.k, v.bs, v.ss, v.iid, v.sid, v.fs, v.vs, v.shs, v.es, v.fss, v.vss, v.oos, v.oops, v.ied, v.ifsd, v.ivsd, v.iood, v.ioopd, v.bos, v.ser);
    }
};

template<typename S>
struct StreamWriter<::Test::A, S>
{
    static void write(S* ostr, const ::Test::A& v)
    {
        ostr->writeAll(v.requiredA);
        ostr->writeAll({1, 50, 500}, v.ma, v.mb, v.mc);
    }
};

template<typename S>
struct StreamReader<::Test::A, S>
{
    static void read(S* istr, ::Test::A& v)
    {
        istr->readAll(v.requiredA);
        istr->readAll({1, 50, 500}, v.ma, v.mb, v.mc);
    }
};

template<typename S>
struct StreamWriter<::Test::B, S>
{
    static void write(S* ostr, const ::Test::B& v)
    {
        ostr->writeAll(v.requiredB);
        ostr->writeAll({10}, v.md);
    }
};

template<typename S>
struct StreamReader<::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->readAll(v.requiredB);
        istr->readAll({10}, v.md);
    }
};

template<typename S>
struct StreamWriter<::Test::C, S>
{
    static void write(S* ostr, const ::Test::C& v)
    {
        ostr->writeAll(v.ss);
        ostr->writeAll({890}, v.ms);
    }
};

template<typename S>
struct StreamReader<::Test::C, S>
{
    static void read(S* istr, ::Test::C& v)
    {
        istr->readAll(v.ss);
        istr->readAll({890}, v.ms);
    }
};

template<typename S>
struct StreamWriter<::Test::WD, S>
{
    static void write(S* ostr, const ::Test::WD& v)
    {
        ostr->writeAll({1, 2}, v.a, v.s);
    }
};

template<typename S>
struct StreamReader<::Test::WD, S>
{
    static void read(S* istr, ::Test::WD& v)
    {
        istr->readAll({1, 2}, v.a, v.s);
    }
};

template<typename S>
struct StreamWriter<::Test::OptionalException, S>
{
    static void write(S* ostr, const ::Test::OptionalException& v)
    {
        ostr->writeAll(v.req);
        ostr->writeAll({1, 2, 50}, v.a, v.b, v.o);
    }
};

template<typename S>
struct StreamReader<::Test::OptionalException, S>
{
    static void read(S* istr, ::Test::OptionalException& v)
    {
        istr->readAll(v.req);
        istr->readAll({1, 2, 50}, v.a, v.b, v.o);
    }
};

template<typename S>
struct StreamWriter<::Test::DerivedException, S>
{
    static void write(S* ostr, const ::Test::DerivedException& v)
    {
        ostr->writeAll(v.d1, v.d2);
        ostr->writeAll({600, 601}, v.ss, v.o2);
    }
};

template<typename S>
struct StreamReader<::Test::DerivedException, S>
{
    static void read(S* istr, ::Test::DerivedException& v)
    {
        istr->readAll(v.d1, v.d2);
        istr->readAll({600, 601}, v.ss, v.o2);
    }
};

template<typename S>
struct StreamWriter<::Test::RequiredException, S>
{
    static void write(S* ostr, const ::Test::RequiredException& v)
    {
        ostr->writeAll(v.ss, v.o2);
    }
};

template<typename S>
struct StreamReader<::Test::RequiredException, S>
{
    static void read(S* istr, ::Test::RequiredException& v)
    {
        istr->readAll(v.ss, v.o2);
    }
};

template<typename S>
struct StreamWriter<::Test::OptionalWithCustom, S>
{
    static void write(S* ostr, const ::Test::OptionalWithCustom& v)
    {
        ostr->writeAll({1, 2, 3}, v.l, v.lp, v.s);
    }
};

template<typename S>
struct StreamReader<::Test::OptionalWithCustom, S>
{
    static void read(S* istr, ::Test::OptionalWithCustom& v)
    {
        istr->readAll({1, 2, 3}, v.l, v.lp, v.s);
    }
};

template<typename S>
struct StreamReader<::Test::E, S>
{
    static void read(S* istr, ::Test::E& v)
    {
        istr->readAll(v.ae);
    }
};

template<typename S>
struct StreamWriter<::Test::F, S>
{
    static void write(S* ostr, const ::Test::F& v)
    {
        ostr->writeAll({1}, v.af);
    }
};

template<typename S>
struct StreamReader<::Test::F, S>
{
    static void read(S* istr, ::Test::F& v)
    {
        istr->readAll({1}, v.af);
    }
};

template<typename S>
struct StreamReader<::Test::G1, S>
{
    static void read(S* istr, ::Test::G1& v)
    {
        istr->readAll(v.a);
    }
};

template<typename S>
struct StreamReader<::Test::G2, S>
{
    static void read(S* istr, ::Test::G2& v)
    {
        istr->readAll(v.a);
    }
};

template<typename S>
struct StreamWriter<::Test::G, S>
{
    static void write(S* ostr, const ::Test::G& v)
    {
        ostr->writeAll(v.gg2, v.gg1);
        ostr->writeAll({0, 1}, v.gg2Opt, v.gg1Opt);
    }
};

template<typename S>
struct StreamReader<::Test::G, S>
{
    static void read(S* istr, ::Test::G& v)
    {
        istr->readAll(v.gg2, v.gg1);
        istr->readAll({0, 1}, v.gg2Opt, v.gg1Opt);
    }
};

template<typename S>
struct StreamWriter<::Test::Recursive, S>
{
    static void write(S* ostr, const ::Test::Recursive& v)
    {
        ostr->writeAll({0}, v.value);
    }
};

template<typename S>
struct StreamReader<::Test::Recursive, S>
{
    static void read(S* istr, ::Test::Recursive& v)
    {
        istr->readAll({0}, v.value);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using OneOptionalPtr = ::std::shared_ptr<OneOptional>;

using MultiOptionalPtr = ::std::shared_ptr<MultiOptional>;

using APtr = ::std::shared_ptr<A>;

using BPtr = ::std::shared_ptr<B>;

using CPtr = ::std::shared_ptr<C>;

using WDPtr = ::std::shared_ptr<WD>;

using OptionalWithCustomPtr = ::std::shared_ptr<OptionalWithCustom>;

using EPtr = ::std::shared_ptr<E>;

using FPtr = ::std::shared_ptr<F>;

using G1Ptr = ::std::shared_ptr<G1>;

using G2Ptr = ::std::shared_ptr<G2>;

using GPtr = ::std::shared_ptr<G>;

using RecursivePtr = ::std::shared_ptr<Recursive>;

using InitialPtr = ::std::shared_ptr<Initial>;
using InitialPrxPtr = ::std::shared_ptr<InitialPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class OneOptional;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< OneOptional>&);
::IceProxy::Ice::Object* upCast(OneOptional*);
/// \endcond

class MultiOptional;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< MultiOptional>&);
::IceProxy::Ice::Object* upCast(MultiOptional*);
/// \endcond

class A;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< A>&);
::IceProxy::Ice::Object* upCast(A*);
/// \endcond

class B;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< B>&);
::IceProxy::Ice::Object* upCast(B*);
/// \endcond

class C;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< C>&);
::IceProxy::Ice::Object* upCast(C*);
/// \endcond

class WD;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< WD>&);
::IceProxy::Ice::Object* upCast(WD*);
/// \endcond

class OptionalWithCustom;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< OptionalWithCustom>&);
::IceProxy::Ice::Object* upCast(OptionalWithCustom*);
/// \endcond

class E;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< E>&);
::IceProxy::Ice::Object* upCast(E*);
/// \endcond

class F;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< F>&);
::IceProxy::Ice::Object* upCast(F*);
/// \endcond

class G1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< G1>&);
::IceProxy::Ice::Object* upCast(G1*);
/// \endcond

class G2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< G2>&);
::IceProxy::Ice::Object* upCast(G2*);
/// \endcond

class G;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< G>&);
::IceProxy::Ice::Object* upCast(G*);
/// \endcond

class Recursive;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Recursive>&);
::IceProxy::Ice::Object* upCast(Recursive*);
/// \endcond

class Initial;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Initial>&);
::IceProxy::Ice::Object* upCast(Initial*);
/// \endcond

}

}

namespace Test
{

class OneOptional;
/// \cond INTERNAL
::Ice::Object* upCast(OneOptional*);
/// \endcond
typedef ::IceInternal::Handle< OneOptional> OneOptionalPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OneOptional> OneOptionalPrx;
typedef OneOptionalPrx OneOptionalPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(OneOptionalPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class MultiOptional;
/// \cond INTERNAL
::Ice::Object* upCast(MultiOptional*);
/// \endcond
typedef ::IceInternal::Handle< MultiOptional> MultiOptionalPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MultiOptional> MultiOptionalPrx;
typedef MultiOptionalPrx MultiOptionalPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(MultiOptionalPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class A;
/// \cond INTERNAL
::Ice::Object* upCast(A*);
/// \endcond
typedef ::IceInternal::Handle< A> APtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::A> APrx;
typedef APrx APrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(APtr&, const ::Ice::ObjectPtr&);
/// \endcond

class B;
/// \cond INTERNAL
::Ice::Object* upCast(B*);
/// \endcond
typedef ::IceInternal::Handle< B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::B> BPrx;
typedef BPrx BPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class C;
/// \cond INTERNAL
::Ice::Object* upCast(C*);
/// \endcond
typedef ::IceInternal::Handle< C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::C> CPrx;
typedef CPrx CPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class WD;
/// \cond INTERNAL
::Ice::Object* upCast(WD*);
/// \endcond
typedef ::IceInternal::Handle< WD> WDPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::WD> WDPrx;
typedef WDPrx WDPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(WDPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class OptionalWithCustom;
/// \cond INTERNAL
::Ice::Object* upCast(OptionalWithCustom*);
/// \endcond
typedef ::IceInternal::Handle< OptionalWithCustom> OptionalWithCustomPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalWithCustom> OptionalWithCustomPrx;
typedef OptionalWithCustomPrx OptionalWithCustomPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(OptionalWithCustomPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class E;
/// \cond INTERNAL
::Ice::Object* upCast(E*);
/// \endcond
typedef ::IceInternal::Handle< E> EPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::E> EPrx;
typedef EPrx EPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(EPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class F;
/// \cond INTERNAL
::Ice::Object* upCast(F*);
/// \endcond
typedef ::IceInternal::Handle< F> FPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::F> FPrx;
typedef FPrx FPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(FPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class G1;
/// \cond INTERNAL
::Ice::Object* upCast(G1*);
/// \endcond
typedef ::IceInternal::Handle< G1> G1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::G1> G1Prx;
typedef G1Prx G1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(G1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class G2;
/// \cond INTERNAL
::Ice::Object* upCast(G2*);
/// \endcond
typedef ::IceInternal::Handle< G2> G2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::G2> G2Prx;
typedef G2Prx G2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(G2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class G;
/// \cond INTERNAL
::Ice::Object* upCast(G*);
/// \endcond
typedef ::IceInternal::Handle< G> GPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::G> GPrx;
typedef GPrx GPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(GPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Recursive;
/// \cond INTERNAL
::Ice::Object* upCast(Recursive*);
/// \endcond
typedef ::IceInternal::Handle< Recursive> RecursivePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Recursive> RecursivePrx;
typedef RecursivePrx RecursivePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(RecursivePtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Initial;
/// \cond INTERNAL
::Ice::Object* upCast(Initial*);
/// \endcond
typedef ::IceInternal::Handle< Initial> InitialPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Initial> InitialPrx;
typedef InitialPrx InitialPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(InitialPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Test
{

enum MyEnum
{
    MyEnumMember
};

struct SmallStruct
{
    ::Ice::Byte m;

    bool operator==(const SmallStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(m != rhs_.m)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SmallStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(m < rhs_.m)
        {
            return true;
        }
        else if(rhs_.m < m)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SmallStruct& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const SmallStruct& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const SmallStruct& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const SmallStruct& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct FixedStruct
{
    ::Ice::Int m;

    bool operator==(const FixedStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(m != rhs_.m)
        {
            return false;
        }
        return true;
    }

    bool operator<(const FixedStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(m < rhs_.m)
        {
            return true;
        }
        else if(rhs_.m < m)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const FixedStruct& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const FixedStruct& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const FixedStruct& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const FixedStruct& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct VarStruct
{
    ::std::string m;

    bool operator==(const VarStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(m != rhs_.m)
        {
            return false;
        }
        return true;
    }

    bool operator<(const VarStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(m < rhs_.m)
        {
            return true;
        }
        else if(rhs_.m < m)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const VarStruct& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const VarStruct& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const VarStruct& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const VarStruct& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct ClassVarStruct
{
    ::Ice::Int a;

    bool operator==(const ClassVarStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(a != rhs_.a)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ClassVarStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(a < rhs_.a)
        {
            return true;
        }
        else if(rhs_.a < a)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ClassVarStruct& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ClassVarStruct& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ClassVarStruct& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ClassVarStruct& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector< ::Ice::Byte> ByteSeq;

typedef ::std::vector<bool> BoolSeq;

typedef ::std::vector< ::Ice::Short> ShortSeq;

typedef ::std::vector< ::Ice::Int> IntSeq;

typedef ::std::vector< ::Ice::Long> LongSeq;

typedef ::std::vector< ::Ice::Float> FloatSeq;

typedef ::std::vector< ::Ice::Double> DoubleSeq;

typedef ::std::vector< ::std::string> StringSeq;

typedef ::std::vector<MyEnum> MyEnumSeq;

typedef ::std::vector<SmallStruct> SmallStructSeq;

typedef ::std::vector<SmallStruct> SmallStructList;

typedef ::std::vector<FixedStruct> FixedStructSeq;

typedef ::std::vector<FixedStruct> FixedStructList;

typedef ::std::vector<VarStruct> VarStructSeq;

typedef ::std::vector<OneOptionalPtr> OneOptionalSeq;

typedef ::std::vector<OneOptionalPrx> OneOptionalPrxSeq;

typedef ::std::vector< ::Ice::Byte> Serializable;

typedef ::std::map< ::Ice::Int, ::Ice::Int> IntIntDict;

typedef ::std::map< ::std::string, ::Ice::Int> StringIntDict;

typedef ::std::map< ::Ice::Int, MyEnum> IntEnumDict;

typedef ::std::map< ::Ice::Int, FixedStruct> IntFixedStructDict;

typedef ::std::map< ::Ice::Int, VarStruct> IntVarStructDict;

typedef ::std::map< ::Ice::Int, OneOptionalPtr> IntOneOptionalDict;

typedef ::std::map< ::Ice::Int, OneOptionalPrx> IntOneOptionalPrxDict;

class OptionalException : public ::Ice::UserException
{
public:

    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    OptionalException();
    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalException(bool req, const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional<OneOptionalPtr>& o);

#ifdef ICE_CPP11_COMPILER
    OptionalException(const OptionalException&) = default;
    virtual ~OptionalException();
#else
    virtual ~OptionalException() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual OptionalException* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    bool req;
    IceUtil::Optional< ::Ice::Int> a;
    IceUtil::Optional< ::std::string> b;
    IceUtil::Optional< ::Test::OneOptionalPtr> o;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
static OptionalException _iceS_OptionalException_init;
/// \endcond

class DerivedException : public OptionalException
{
public:

    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    DerivedException();
    /**
     * One-shot constructor to initialize all data members.
     */
    DerivedException(bool req, const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional<OneOptionalPtr>& o, const ::std::string& d1, const IceUtil::Optional< ::std::string>& ss, const IceUtil::Optional<OneOptionalPtr>& o2, const ::std::string& d2);

#ifdef ICE_CPP11_COMPILER
    DerivedException(const DerivedException&) = default;
    virtual ~DerivedException();
#else
    virtual ~DerivedException() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual DerivedException* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string d1;
    IceUtil::Optional< ::std::string> ss;
    IceUtil::Optional< ::Test::OneOptionalPtr> o2;
    ::std::string d2;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class RequiredException : public OptionalException
{
public:

    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    RequiredException();
    /**
     * One-shot constructor to initialize all data members.
     */
    RequiredException(bool req, const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional<OneOptionalPtr>& o, const ::std::string& ss, const OneOptionalPtr& o2);

#ifdef ICE_CPP11_COMPILER
    RequiredException(const RequiredException&) = default;
    virtual ~RequiredException();
#else
    virtual ~RequiredException() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual RequiredException* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    /// \cond STREAM
    virtual bool _usesClasses() const;
    /// \endcond

    ::std::string ss;
    ::Test::OneOptionalPtr o2;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

typedef ::std::vector<RecursivePtr> RecursiveSeq;

}

namespace Test
{

/**
 * AMD callback class for Test::Initial::shutdown_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_shutdown : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_shutdown();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_shutdown> AMD_Initial_shutdownPtr;

/**
 * AMD callback class for Test::Initial::pingPong_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_pingPong : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_pingPong();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ::Ice::ObjectPtr& result) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_pingPong> AMD_Initial_pingPongPtr;

/**
 * AMD callback class for Test::Initial::opOptionalException_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opOptionalException : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opOptionalException();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opOptionalException> AMD_Initial_opOptionalExceptionPtr;

/**
 * AMD callback class for Test::Initial::opDerivedException_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opDerivedException : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opDerivedException();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opDerivedException> AMD_Initial_opDerivedExceptionPtr;

/**
 * AMD callback class for Test::Initial::opRequiredException_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opRequiredException : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opRequiredException();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opRequiredException> AMD_Initial_opRequiredExceptionPtr;

/**
 * AMD callback class for Test::Initial::opByte_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opByte : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opByte();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional< ::Ice::Byte>& result, const IceUtil::Optional< ::Ice::Byte>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opByte> AMD_Initial_opBytePtr;

/**
 * AMD callback class for Test::Initial::opByteReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opByteReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opByteReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional< ::Ice::Byte>& result, const IceUtil::Optional< ::Ice::Byte>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opByteReq> AMD_Initial_opByteReqPtr;

/**
 * AMD callback class for Test::Initial::opBool_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opBool : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opBool();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<bool>& result, const IceUtil::Optional<bool>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opBool> AMD_Initial_opBoolPtr;

/**
 * AMD callback class for Test::Initial::opBoolReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opBoolReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opBoolReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<bool>& result, const IceUtil::Optional<bool>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opBoolReq> AMD_Initial_opBoolReqPtr;

/**
 * AMD callback class for Test::Initial::opShort_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opShort : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opShort();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional< ::Ice::Short>& result, const IceUtil::Optional< ::Ice::Short>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opShort> AMD_Initial_opShortPtr;

/**
 * AMD callback class for Test::Initial::opShortReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opShortReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opShortReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional< ::Ice::Short>& result, const IceUtil::Optional< ::Ice::Short>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opShortReq> AMD_Initial_opShortReqPtr;

/**
 * AMD callback class for Test::Initial::opInt_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opInt : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opInt();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional< ::Ice::Int>& result, const IceUtil::Optional< ::Ice::Int>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opInt> AMD_Initial_opIntPtr;

/**
 * AMD callback class for Test::Initial::opIntReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opIntReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opIntReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional< ::Ice::Int>& result, const IceUtil::Optional< ::Ice::Int>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opIntReq> AMD_Initial_opIntReqPtr;

/**
 * AMD callback class for Test::Initial::opLong_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opLong : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opLong();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional< ::Ice::Long>& result, const IceUtil::Optional< ::Ice::Long>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opLong> AMD_Initial_opLongPtr;

/**
 * AMD callback class for Test::Initial::opLongReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opLongReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opLongReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional< ::Ice::Long>& result, const IceUtil::Optional< ::Ice::Long>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opLongReq> AMD_Initial_opLongReqPtr;

/**
 * AMD callback class for Test::Initial::opFloat_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opFloat : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opFloat();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional< ::Ice::Float>& result, const IceUtil::Optional< ::Ice::Float>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFloat> AMD_Initial_opFloatPtr;

/**
 * AMD callback class for Test::Initial::opFloatReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opFloatReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opFloatReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional< ::Ice::Float>& result, const IceUtil::Optional< ::Ice::Float>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFloatReq> AMD_Initial_opFloatReqPtr;

/**
 * AMD callback class for Test::Initial::opDouble_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opDouble : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opDouble();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional< ::Ice::Double>& result, const IceUtil::Optional< ::Ice::Double>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opDouble> AMD_Initial_opDoublePtr;

/**
 * AMD callback class for Test::Initial::opDoubleReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opDoubleReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opDoubleReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional< ::Ice::Double>& result, const IceUtil::Optional< ::Ice::Double>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opDoubleReq> AMD_Initial_opDoubleReqPtr;

/**
 * AMD callback class for Test::Initial::opString_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opString : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opString();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional< ::std::string>& result, const IceUtil::Optional< ::std::string>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opString> AMD_Initial_opStringPtr;

/**
 * AMD callback class for Test::Initial::opStringReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opStringReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opStringReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional< ::std::string>& result, const IceUtil::Optional< ::std::string>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opStringReq> AMD_Initial_opStringReqPtr;

/**
 * AMD callback class for Test::Initial::opMyEnum_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opMyEnum : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opMyEnum();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<MyEnum>& result, const IceUtil::Optional<MyEnum>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opMyEnum> AMD_Initial_opMyEnumPtr;

/**
 * AMD callback class for Test::Initial::opMyEnumReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opMyEnumReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opMyEnumReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<MyEnum>& result, const IceUtil::Optional<MyEnum>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opMyEnumReq> AMD_Initial_opMyEnumReqPtr;

/**
 * AMD callback class for Test::Initial::opSmallStruct_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opSmallStruct : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opSmallStruct();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<SmallStruct>& result, const IceUtil::Optional<SmallStruct>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opSmallStruct> AMD_Initial_opSmallStructPtr;

/**
 * AMD callback class for Test::Initial::opSmallStructReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opSmallStructReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opSmallStructReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<SmallStruct>& result, const IceUtil::Optional<SmallStruct>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opSmallStructReq> AMD_Initial_opSmallStructReqPtr;

/**
 * AMD callback class for Test::Initial::opFixedStruct_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opFixedStruct : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opFixedStruct();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<FixedStruct>& result, const IceUtil::Optional<FixedStruct>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFixedStruct> AMD_Initial_opFixedStructPtr;

/**
 * AMD callback class for Test::Initial::opFixedStructReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opFixedStructReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opFixedStructReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<FixedStruct>& result, const IceUtil::Optional<FixedStruct>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFixedStructReq> AMD_Initial_opFixedStructReqPtr;

/**
 * AMD callback class for Test::Initial::opVarStruct_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opVarStruct : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opVarStruct();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<VarStruct>& result, const IceUtil::Optional<VarStruct>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opVarStruct> AMD_Initial_opVarStructPtr;

/**
 * AMD callback class for Test::Initial::opVarStructReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opVarStructReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opVarStructReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<VarStruct>& result, const IceUtil::Optional<VarStruct>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opVarStructReq> AMD_Initial_opVarStructReqPtr;

/**
 * AMD callback class for Test::Initial::opOneOptional_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opOneOptional : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opOneOptional();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<OneOptionalPtr>& result, const IceUtil::Optional<OneOptionalPtr>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opOneOptional> AMD_Initial_opOneOptionalPtr;

/**
 * AMD callback class for Test::Initial::opOneOptionalReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opOneOptionalReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opOneOptionalReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<OneOptionalPtr>& result, const IceUtil::Optional<OneOptionalPtr>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opOneOptionalReq> AMD_Initial_opOneOptionalReqPtr;

/**
 * AMD callback class for Test::Initial::opOneOptionalProxy_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opOneOptionalProxy : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opOneOptionalProxy();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<OneOptionalPrx>& result, const IceUtil::Optional<OneOptionalPrx>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opOneOptionalProxy> AMD_Initial_opOneOptionalProxyPtr;

/**
 * AMD callback class for Test::Initial::opOneOptionalProxyReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opOneOptionalProxyReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opOneOptionalProxyReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<OneOptionalPrx>& result, const IceUtil::Optional<OneOptionalPrx>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opOneOptionalProxyReq> AMD_Initial_opOneOptionalProxyReqPtr;

/**
 * AMD callback class for Test::Initial::opByteSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opByteSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opByteSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<ByteSeq>& result, const IceUtil::Optional<ByteSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opByteSeq> AMD_Initial_opByteSeqPtr;

/**
 * AMD callback class for Test::Initial::opByteSeqReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opByteSeqReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opByteSeqReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<ByteSeq>& result, const IceUtil::Optional<ByteSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opByteSeqReq> AMD_Initial_opByteSeqReqPtr;

/**
 * AMD callback class for Test::Initial::opBoolSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opBoolSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opBoolSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<BoolSeq>& result, const IceUtil::Optional<BoolSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opBoolSeq> AMD_Initial_opBoolSeqPtr;

/**
 * AMD callback class for Test::Initial::opBoolSeqReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opBoolSeqReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opBoolSeqReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<BoolSeq>& result, const IceUtil::Optional<BoolSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opBoolSeqReq> AMD_Initial_opBoolSeqReqPtr;

/**
 * AMD callback class for Test::Initial::opShortSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opShortSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opShortSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<ShortSeq>& result, const IceUtil::Optional<ShortSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opShortSeq> AMD_Initial_opShortSeqPtr;

/**
 * AMD callback class for Test::Initial::opShortSeqReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opShortSeqReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opShortSeqReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<ShortSeq>& result, const IceUtil::Optional<ShortSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opShortSeqReq> AMD_Initial_opShortSeqReqPtr;

/**
 * AMD callback class for Test::Initial::opIntSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opIntSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opIntSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<IntSeq>& result, const IceUtil::Optional<IntSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opIntSeq> AMD_Initial_opIntSeqPtr;

/**
 * AMD callback class for Test::Initial::opIntSeqReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opIntSeqReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opIntSeqReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<IntSeq>& result, const IceUtil::Optional<IntSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opIntSeqReq> AMD_Initial_opIntSeqReqPtr;

/**
 * AMD callback class for Test::Initial::opLongSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opLongSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opLongSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<LongSeq>& result, const IceUtil::Optional<LongSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opLongSeq> AMD_Initial_opLongSeqPtr;

/**
 * AMD callback class for Test::Initial::opLongSeqReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opLongSeqReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opLongSeqReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<LongSeq>& result, const IceUtil::Optional<LongSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opLongSeqReq> AMD_Initial_opLongSeqReqPtr;

/**
 * AMD callback class for Test::Initial::opFloatSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opFloatSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opFloatSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<FloatSeq>& result, const IceUtil::Optional<FloatSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFloatSeq> AMD_Initial_opFloatSeqPtr;

/**
 * AMD callback class for Test::Initial::opFloatSeqReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opFloatSeqReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opFloatSeqReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<FloatSeq>& result, const IceUtil::Optional<FloatSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFloatSeqReq> AMD_Initial_opFloatSeqReqPtr;

/**
 * AMD callback class for Test::Initial::opDoubleSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opDoubleSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opDoubleSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<DoubleSeq>& result, const IceUtil::Optional<DoubleSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opDoubleSeq> AMD_Initial_opDoubleSeqPtr;

/**
 * AMD callback class for Test::Initial::opDoubleSeqReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opDoubleSeqReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opDoubleSeqReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<DoubleSeq>& result, const IceUtil::Optional<DoubleSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opDoubleSeqReq> AMD_Initial_opDoubleSeqReqPtr;

/**
 * AMD callback class for Test::Initial::opStringSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opStringSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opStringSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<StringSeq>& result, const IceUtil::Optional<StringSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opStringSeq> AMD_Initial_opStringSeqPtr;

/**
 * AMD callback class for Test::Initial::opStringSeqReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opStringSeqReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opStringSeqReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<StringSeq>& result, const IceUtil::Optional<StringSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opStringSeqReq> AMD_Initial_opStringSeqReqPtr;

/**
 * AMD callback class for Test::Initial::opSmallStructSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opSmallStructSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opSmallStructSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<SmallStructSeq>& result, const IceUtil::Optional<SmallStructSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opSmallStructSeq> AMD_Initial_opSmallStructSeqPtr;

/**
 * AMD callback class for Test::Initial::opSmallStructSeqReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opSmallStructSeqReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opSmallStructSeqReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<SmallStructSeq>& result, const IceUtil::Optional<SmallStructSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opSmallStructSeqReq> AMD_Initial_opSmallStructSeqReqPtr;

/**
 * AMD callback class for Test::Initial::opSmallStructList_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opSmallStructList : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opSmallStructList();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<SmallStructList>& result, const IceUtil::Optional<SmallStructList>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opSmallStructList> AMD_Initial_opSmallStructListPtr;

/**
 * AMD callback class for Test::Initial::opSmallStructListReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opSmallStructListReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opSmallStructListReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<SmallStructList>& result, const IceUtil::Optional<SmallStructList>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opSmallStructListReq> AMD_Initial_opSmallStructListReqPtr;

/**
 * AMD callback class for Test::Initial::opFixedStructSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opFixedStructSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opFixedStructSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<FixedStructSeq>& result, const IceUtil::Optional<FixedStructSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFixedStructSeq> AMD_Initial_opFixedStructSeqPtr;

/**
 * AMD callback class for Test::Initial::opFixedStructSeqReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opFixedStructSeqReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opFixedStructSeqReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<FixedStructSeq>& result, const IceUtil::Optional<FixedStructSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFixedStructSeqReq> AMD_Initial_opFixedStructSeqReqPtr;

/**
 * AMD callback class for Test::Initial::opFixedStructList_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opFixedStructList : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opFixedStructList();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<FixedStructList>& result, const IceUtil::Optional<FixedStructList>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFixedStructList> AMD_Initial_opFixedStructListPtr;

/**
 * AMD callback class for Test::Initial::opFixedStructListReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opFixedStructListReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opFixedStructListReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<FixedStructList>& result, const IceUtil::Optional<FixedStructList>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opFixedStructListReq> AMD_Initial_opFixedStructListReqPtr;

/**
 * AMD callback class for Test::Initial::opVarStructSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opVarStructSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opVarStructSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<VarStructSeq>& result, const IceUtil::Optional<VarStructSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opVarStructSeq> AMD_Initial_opVarStructSeqPtr;

/**
 * AMD callback class for Test::Initial::opVarStructSeqReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opVarStructSeqReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opVarStructSeqReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<VarStructSeq>& result, const IceUtil::Optional<VarStructSeq>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opVarStructSeqReq> AMD_Initial_opVarStructSeqReqPtr;

/**
 * AMD callback class for Test::Initial::opSerializable_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opSerializable : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opSerializable();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<Serializable>& result, const IceUtil::Optional<Serializable>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opSerializable> AMD_Initial_opSerializablePtr;

/**
 * AMD callback class for Test::Initial::opSerializableReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opSerializableReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opSerializableReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<Serializable>& result, const IceUtil::Optional<Serializable>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opSerializableReq> AMD_Initial_opSerializableReqPtr;

/**
 * AMD callback class for Test::Initial::opIntIntDict_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opIntIntDict : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opIntIntDict();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<IntIntDict>& result, const IceUtil::Optional<IntIntDict>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opIntIntDict> AMD_Initial_opIntIntDictPtr;

/**
 * AMD callback class for Test::Initial::opIntIntDictReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opIntIntDictReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opIntIntDictReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<IntIntDict>& result, const IceUtil::Optional<IntIntDict>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opIntIntDictReq> AMD_Initial_opIntIntDictReqPtr;

/**
 * AMD callback class for Test::Initial::opStringIntDict_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opStringIntDict : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opStringIntDict();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<StringIntDict>& result, const IceUtil::Optional<StringIntDict>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opStringIntDict> AMD_Initial_opStringIntDictPtr;

/**
 * AMD callback class for Test::Initial::opStringIntDictReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opStringIntDictReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opStringIntDictReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<StringIntDict>& result, const IceUtil::Optional<StringIntDict>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opStringIntDictReq> AMD_Initial_opStringIntDictReqPtr;

/**
 * AMD callback class for Test::Initial::opIntOneOptionalDict_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opIntOneOptionalDict : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opIntOneOptionalDict();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<IntOneOptionalDict>& result, const IceUtil::Optional<IntOneOptionalDict>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opIntOneOptionalDict> AMD_Initial_opIntOneOptionalDictPtr;

/**
 * AMD callback class for Test::Initial::opIntOneOptionalDictReq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opIntOneOptionalDictReq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opIntOneOptionalDictReq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<IntOneOptionalDict>& result, const IceUtil::Optional<IntOneOptionalDict>& p3) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opIntOneOptionalDictReq> AMD_Initial_opIntOneOptionalDictReqPtr;

/**
 * AMD callback class for Test::Initial::opClassAndUnknownOptional_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opClassAndUnknownOptional : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opClassAndUnknownOptional();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opClassAndUnknownOptional> AMD_Initial_opClassAndUnknownOptionalPtr;

/**
 * AMD callback class for Test::Initial::sendOptionalClass_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_sendOptionalClass : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_sendOptionalClass();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_sendOptionalClass> AMD_Initial_sendOptionalClassPtr;

/**
 * AMD callback class for Test::Initial::returnOptionalClass_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_returnOptionalClass : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_returnOptionalClass();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<OneOptionalPtr>& o) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_returnOptionalClass> AMD_Initial_returnOptionalClassPtr;

/**
 * AMD callback class for Test::Initial::opG_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opG : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opG();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const GPtr& result) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opG> AMD_Initial_opGPtr;

/**
 * AMD callback class for Test::Initial::opVoid_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opVoid : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opVoid();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opVoid> AMD_Initial_opVoidPtr;

/**
 * AMD callback class for Test::Initial::opMStruct1_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opMStruct1 : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opMStruct1();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<SmallStruct>& result) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opMStruct1> AMD_Initial_opMStruct1Ptr;

/**
 * AMD callback class for Test::Initial::opMStruct2_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opMStruct2 : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opMStruct2();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<SmallStruct>& result, const IceUtil::Optional<SmallStruct>& p2) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opMStruct2> AMD_Initial_opMStruct2Ptr;

/**
 * AMD callback class for Test::Initial::opMSeq1_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opMSeq1 : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opMSeq1();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<StringSeq>& result) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opMSeq1> AMD_Initial_opMSeq1Ptr;

/**
 * AMD callback class for Test::Initial::opMSeq2_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opMSeq2 : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opMSeq2();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<StringSeq>& result, const IceUtil::Optional<StringSeq>& p2) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opMSeq2> AMD_Initial_opMSeq2Ptr;

/**
 * AMD callback class for Test::Initial::opMDict1_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opMDict1 : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opMDict1();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<StringIntDict>& result) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opMDict1> AMD_Initial_opMDict1Ptr;

/**
 * AMD callback class for Test::Initial::opMDict2_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opMDict2 : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opMDict2();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<StringIntDict>& result, const IceUtil::Optional<StringIntDict>& p2) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opMDict2> AMD_Initial_opMDict2Ptr;

/**
 * AMD callback class for Test::Initial::opMG1_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opMG1 : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opMG1();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<GPtr>& result) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opMG1> AMD_Initial_opMG1Ptr;

/**
 * AMD callback class for Test::Initial::opMG2_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_opMG2 : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_opMG2();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IceUtil::Optional<GPtr>& result, const IceUtil::Optional<GPtr>& p2) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_opMG2> AMD_Initial_opMG2Ptr;

/**
 * AMD callback class for Test::Initial::supportsRequiredParams_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_supportsRequiredParams : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_supportsRequiredParams();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(bool result) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_supportsRequiredParams> AMD_Initial_supportsRequiredParamsPtr;

/**
 * AMD callback class for Test::Initial::supportsJavaSerializable_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_supportsJavaSerializable : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_supportsJavaSerializable();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(bool result) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_supportsJavaSerializable> AMD_Initial_supportsJavaSerializablePtr;

/**
 * AMD callback class for Test::Initial::supportsCsharpSerializable_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_supportsCsharpSerializable : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_supportsCsharpSerializable();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(bool result) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_supportsCsharpSerializable> AMD_Initial_supportsCsharpSerializablePtr;

/**
 * AMD callback class for Test::Initial::supportsCppStringView_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_supportsCppStringView : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_supportsCppStringView();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(bool result) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_supportsCppStringView> AMD_Initial_supportsCppStringViewPtr;

/**
 * AMD callback class for Test::Initial::supportsNullOptional_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_supportsNullOptional : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_supportsNullOptional();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(bool result) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_supportsNullOptional> AMD_Initial_supportsNullOptionalPtr;

}

/// \cond INTERNAL
namespace IceAsync
{

namespace Test
{

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_shutdown : public ::Test::AMD_Initial_shutdown, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_shutdown(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_pingPong : public ::Test::AMD_Initial_pingPong, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_pingPong(::IceInternal::Incoming&);

    virtual void ice_response(const ::Ice::ObjectPtr&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opOptionalException : public ::Test::AMD_Initial_opOptionalException, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opOptionalException(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opDerivedException : public ::Test::AMD_Initial_opDerivedException, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opDerivedException(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opRequiredException : public ::Test::AMD_Initial_opRequiredException, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opRequiredException(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opByte : public ::Test::AMD_Initial_opByte, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opByte(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opByteReq : public ::Test::AMD_Initial_opByteReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opByteReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opBool : public ::Test::AMD_Initial_opBool, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opBool(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opBoolReq : public ::Test::AMD_Initial_opBoolReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opBoolReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opShort : public ::Test::AMD_Initial_opShort, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opShort(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opShortReq : public ::Test::AMD_Initial_opShortReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opShortReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opInt : public ::Test::AMD_Initial_opInt, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opInt(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opIntReq : public ::Test::AMD_Initial_opIntReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opIntReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opLong : public ::Test::AMD_Initial_opLong, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opLong(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opLongReq : public ::Test::AMD_Initial_opLongReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opLongReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opFloat : public ::Test::AMD_Initial_opFloat, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFloat(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opFloatReq : public ::Test::AMD_Initial_opFloatReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFloatReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opDouble : public ::Test::AMD_Initial_opDouble, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opDouble(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opDoubleReq : public ::Test::AMD_Initial_opDoubleReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opDoubleReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opString : public ::Test::AMD_Initial_opString, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opString(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opStringReq : public ::Test::AMD_Initial_opStringReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opStringReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opMyEnum : public ::Test::AMD_Initial_opMyEnum, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opMyEnum(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::MyEnum>&, const IceUtil::Optional< ::Test::MyEnum>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opMyEnumReq : public ::Test::AMD_Initial_opMyEnumReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opMyEnumReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::MyEnum>&, const IceUtil::Optional< ::Test::MyEnum>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opSmallStruct : public ::Test::AMD_Initial_opSmallStruct, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opSmallStruct(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::SmallStruct>&, const IceUtil::Optional< ::Test::SmallStruct>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opSmallStructReq : public ::Test::AMD_Initial_opSmallStructReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opSmallStructReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::SmallStruct>&, const IceUtil::Optional< ::Test::SmallStruct>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opFixedStruct : public ::Test::AMD_Initial_opFixedStruct, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFixedStruct(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::FixedStruct>&, const IceUtil::Optional< ::Test::FixedStruct>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opFixedStructReq : public ::Test::AMD_Initial_opFixedStructReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFixedStructReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::FixedStruct>&, const IceUtil::Optional< ::Test::FixedStruct>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opVarStruct : public ::Test::AMD_Initial_opVarStruct, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opVarStruct(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::VarStruct>&, const IceUtil::Optional< ::Test::VarStruct>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opVarStructReq : public ::Test::AMD_Initial_opVarStructReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opVarStructReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::VarStruct>&, const IceUtil::Optional< ::Test::VarStruct>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opOneOptional : public ::Test::AMD_Initial_opOneOptional, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opOneOptional(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opOneOptionalReq : public ::Test::AMD_Initial_opOneOptionalReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opOneOptionalReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opOneOptionalProxy : public ::Test::AMD_Initial_opOneOptionalProxy, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opOneOptionalProxy(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::OneOptionalPrx>&, const IceUtil::Optional< ::Test::OneOptionalPrx>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opOneOptionalProxyReq : public ::Test::AMD_Initial_opOneOptionalProxyReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opOneOptionalProxyReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::OneOptionalPrx>&, const IceUtil::Optional< ::Test::OneOptionalPrx>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opByteSeq : public ::Test::AMD_Initial_opByteSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opByteSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::ByteSeq>&, const IceUtil::Optional< ::Test::ByteSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opByteSeqReq : public ::Test::AMD_Initial_opByteSeqReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opByteSeqReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::ByteSeq>&, const IceUtil::Optional< ::Test::ByteSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opBoolSeq : public ::Test::AMD_Initial_opBoolSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opBoolSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::BoolSeq>&, const IceUtil::Optional< ::Test::BoolSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opBoolSeqReq : public ::Test::AMD_Initial_opBoolSeqReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opBoolSeqReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::BoolSeq>&, const IceUtil::Optional< ::Test::BoolSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opShortSeq : public ::Test::AMD_Initial_opShortSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opShortSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::ShortSeq>&, const IceUtil::Optional< ::Test::ShortSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opShortSeqReq : public ::Test::AMD_Initial_opShortSeqReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opShortSeqReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::ShortSeq>&, const IceUtil::Optional< ::Test::ShortSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opIntSeq : public ::Test::AMD_Initial_opIntSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opIntSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::IntSeq>&, const IceUtil::Optional< ::Test::IntSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opIntSeqReq : public ::Test::AMD_Initial_opIntSeqReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opIntSeqReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::IntSeq>&, const IceUtil::Optional< ::Test::IntSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opLongSeq : public ::Test::AMD_Initial_opLongSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opLongSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::LongSeq>&, const IceUtil::Optional< ::Test::LongSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opLongSeqReq : public ::Test::AMD_Initial_opLongSeqReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opLongSeqReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::LongSeq>&, const IceUtil::Optional< ::Test::LongSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opFloatSeq : public ::Test::AMD_Initial_opFloatSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFloatSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::FloatSeq>&, const IceUtil::Optional< ::Test::FloatSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opFloatSeqReq : public ::Test::AMD_Initial_opFloatSeqReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFloatSeqReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::FloatSeq>&, const IceUtil::Optional< ::Test::FloatSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opDoubleSeq : public ::Test::AMD_Initial_opDoubleSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opDoubleSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::DoubleSeq>&, const IceUtil::Optional< ::Test::DoubleSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opDoubleSeqReq : public ::Test::AMD_Initial_opDoubleSeqReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opDoubleSeqReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::DoubleSeq>&, const IceUtil::Optional< ::Test::DoubleSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opStringSeq : public ::Test::AMD_Initial_opStringSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opStringSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::StringSeq>&, const IceUtil::Optional< ::Test::StringSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opStringSeqReq : public ::Test::AMD_Initial_opStringSeqReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opStringSeqReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::StringSeq>&, const IceUtil::Optional< ::Test::StringSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opSmallStructSeq : public ::Test::AMD_Initial_opSmallStructSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opSmallStructSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::SmallStructSeq>&, const IceUtil::Optional< ::Test::SmallStructSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opSmallStructSeqReq : public ::Test::AMD_Initial_opSmallStructSeqReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opSmallStructSeqReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::SmallStructSeq>&, const IceUtil::Optional< ::Test::SmallStructSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opSmallStructList : public ::Test::AMD_Initial_opSmallStructList, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opSmallStructList(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::SmallStructList>&, const IceUtil::Optional< ::Test::SmallStructList>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opSmallStructListReq : public ::Test::AMD_Initial_opSmallStructListReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opSmallStructListReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::SmallStructList>&, const IceUtil::Optional< ::Test::SmallStructList>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opFixedStructSeq : public ::Test::AMD_Initial_opFixedStructSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFixedStructSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::FixedStructSeq>&, const IceUtil::Optional< ::Test::FixedStructSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opFixedStructSeqReq : public ::Test::AMD_Initial_opFixedStructSeqReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFixedStructSeqReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::FixedStructSeq>&, const IceUtil::Optional< ::Test::FixedStructSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opFixedStructList : public ::Test::AMD_Initial_opFixedStructList, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFixedStructList(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::FixedStructList>&, const IceUtil::Optional< ::Test::FixedStructList>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opFixedStructListReq : public ::Test::AMD_Initial_opFixedStructListReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opFixedStructListReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::FixedStructList>&, const IceUtil::Optional< ::Test::FixedStructList>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opVarStructSeq : public ::Test::AMD_Initial_opVarStructSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opVarStructSeq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::VarStructSeq>&, const IceUtil::Optional< ::Test::VarStructSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opVarStructSeqReq : public ::Test::AMD_Initial_opVarStructSeqReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opVarStructSeqReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::VarStructSeq>&, const IceUtil::Optional< ::Test::VarStructSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opSerializable : public ::Test::AMD_Initial_opSerializable, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opSerializable(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::Serializable>&, const IceUtil::Optional< ::Test::Serializable>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opSerializableReq : public ::Test::AMD_Initial_opSerializableReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opSerializableReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::Serializable>&, const IceUtil::Optional< ::Test::Serializable>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opIntIntDict : public ::Test::AMD_Initial_opIntIntDict, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opIntIntDict(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::IntIntDict>&, const IceUtil::Optional< ::Test::IntIntDict>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opIntIntDictReq : public ::Test::AMD_Initial_opIntIntDictReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opIntIntDictReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::IntIntDict>&, const IceUtil::Optional< ::Test::IntIntDict>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opStringIntDict : public ::Test::AMD_Initial_opStringIntDict, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opStringIntDict(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::StringIntDict>&, const IceUtil::Optional< ::Test::StringIntDict>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opStringIntDictReq : public ::Test::AMD_Initial_opStringIntDictReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opStringIntDictReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::StringIntDict>&, const IceUtil::Optional< ::Test::StringIntDict>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opIntOneOptionalDict : public ::Test::AMD_Initial_opIntOneOptionalDict, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opIntOneOptionalDict(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::IntOneOptionalDict>&, const IceUtil::Optional< ::Test::IntOneOptionalDict>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opIntOneOptionalDictReq : public ::Test::AMD_Initial_opIntOneOptionalDictReq, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opIntOneOptionalDictReq(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::IntOneOptionalDict>&, const IceUtil::Optional< ::Test::IntOneOptionalDict>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opClassAndUnknownOptional : public ::Test::AMD_Initial_opClassAndUnknownOptional, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opClassAndUnknownOptional(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_sendOptionalClass : public ::Test::AMD_Initial_sendOptionalClass, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_sendOptionalClass(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_returnOptionalClass : public ::Test::AMD_Initial_returnOptionalClass, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_returnOptionalClass(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::OneOptionalPtr>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opG : public ::Test::AMD_Initial_opG, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opG(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::GPtr&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opVoid : public ::Test::AMD_Initial_opVoid, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opVoid(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opMStruct1 : public ::Test::AMD_Initial_opMStruct1, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opMStruct1(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::SmallStruct>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opMStruct2 : public ::Test::AMD_Initial_opMStruct2, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opMStruct2(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::SmallStruct>&, const IceUtil::Optional< ::Test::SmallStruct>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opMSeq1 : public ::Test::AMD_Initial_opMSeq1, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opMSeq1(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::StringSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opMSeq2 : public ::Test::AMD_Initial_opMSeq2, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opMSeq2(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::StringSeq>&, const IceUtil::Optional< ::Test::StringSeq>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opMDict1 : public ::Test::AMD_Initial_opMDict1, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opMDict1(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::StringIntDict>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opMDict2 : public ::Test::AMD_Initial_opMDict2, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opMDict2(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::StringIntDict>&, const IceUtil::Optional< ::Test::StringIntDict>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opMG1 : public ::Test::AMD_Initial_opMG1, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opMG1(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::GPtr>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_opMG2 : public ::Test::AMD_Initial_opMG2, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_opMG2(::IceInternal::Incoming&);

    virtual void ice_response(const IceUtil::Optional< ::Test::GPtr>&, const IceUtil::Optional< ::Test::GPtr>&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_supportsRequiredParams : public ::Test::AMD_Initial_supportsRequiredParams, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_supportsRequiredParams(::IceInternal::Incoming&);

    virtual void ice_response(bool);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_supportsJavaSerializable : public ::Test::AMD_Initial_supportsJavaSerializable, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_supportsJavaSerializable(::IceInternal::Incoming&);

    virtual void ice_response(bool);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_supportsCsharpSerializable : public ::Test::AMD_Initial_supportsCsharpSerializable, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_supportsCsharpSerializable(::IceInternal::Incoming&);

    virtual void ice_response(bool);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_supportsCppStringView : public ::Test::AMD_Initial_supportsCppStringView, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_supportsCppStringView(::IceInternal::Incoming&);

    virtual void ice_response(bool);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_supportsNullOptional : public ::Test::AMD_Initial_supportsNullOptional, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_supportsNullOptional(::IceInternal::Incoming&);

    virtual void ice_response(bool);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

}

}
/// \endcond

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_shutdown.
 */
class Callback_Initial_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_shutdown_Base> Callback_Initial_shutdownPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_pingPong.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_pingPong.
 */
class Callback_Initial_pingPong_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_pingPong_Base> Callback_Initial_pingPongPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opOptionalException.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOptionalException.
 */
class Callback_Initial_opOptionalException_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opOptionalException_Base> Callback_Initial_opOptionalExceptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opDerivedException.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDerivedException.
 */
class Callback_Initial_opDerivedException_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opDerivedException_Base> Callback_Initial_opDerivedExceptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opRequiredException.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opRequiredException.
 */
class Callback_Initial_opRequiredException_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opRequiredException_Base> Callback_Initial_opRequiredExceptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opByte.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opByte.
 */
class Callback_Initial_opByte_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opByte_Base> Callback_Initial_opBytePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opByteReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opByteReq.
 */
class Callback_Initial_opByteReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opByteReq_Base> Callback_Initial_opByteReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opBool.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBool.
 */
class Callback_Initial_opBool_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opBool_Base> Callback_Initial_opBoolPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opBoolReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBoolReq.
 */
class Callback_Initial_opBoolReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opBoolReq_Base> Callback_Initial_opBoolReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opShort.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opShort.
 */
class Callback_Initial_opShort_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opShort_Base> Callback_Initial_opShortPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opShortReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opShortReq.
 */
class Callback_Initial_opShortReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opShortReq_Base> Callback_Initial_opShortReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opInt.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opInt.
 */
class Callback_Initial_opInt_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opInt_Base> Callback_Initial_opIntPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opIntReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntReq.
 */
class Callback_Initial_opIntReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opIntReq_Base> Callback_Initial_opIntReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opLong.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opLong.
 */
class Callback_Initial_opLong_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opLong_Base> Callback_Initial_opLongPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opLongReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opLongReq.
 */
class Callback_Initial_opLongReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opLongReq_Base> Callback_Initial_opLongReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opFloat.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFloat.
 */
class Callback_Initial_opFloat_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFloat_Base> Callback_Initial_opFloatPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opFloatReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFloatReq.
 */
class Callback_Initial_opFloatReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFloatReq_Base> Callback_Initial_opFloatReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opDouble.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDouble.
 */
class Callback_Initial_opDouble_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opDouble_Base> Callback_Initial_opDoublePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opDoubleReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDoubleReq.
 */
class Callback_Initial_opDoubleReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opDoubleReq_Base> Callback_Initial_opDoubleReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opString.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opString.
 */
class Callback_Initial_opString_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opString_Base> Callback_Initial_opStringPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opStringReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringReq.
 */
class Callback_Initial_opStringReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opStringReq_Base> Callback_Initial_opStringReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opMyEnum.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMyEnum.
 */
class Callback_Initial_opMyEnum_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opMyEnum_Base> Callback_Initial_opMyEnumPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opMyEnumReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMyEnumReq.
 */
class Callback_Initial_opMyEnumReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opMyEnumReq_Base> Callback_Initial_opMyEnumReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opSmallStruct.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStruct.
 */
class Callback_Initial_opSmallStruct_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opSmallStruct_Base> Callback_Initial_opSmallStructPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructReq.
 */
class Callback_Initial_opSmallStructReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opSmallStructReq_Base> Callback_Initial_opSmallStructReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opFixedStruct.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStruct.
 */
class Callback_Initial_opFixedStruct_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFixedStruct_Base> Callback_Initial_opFixedStructPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructReq.
 */
class Callback_Initial_opFixedStructReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFixedStructReq_Base> Callback_Initial_opFixedStructReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opVarStruct.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVarStruct.
 */
class Callback_Initial_opVarStruct_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opVarStruct_Base> Callback_Initial_opVarStructPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opVarStructReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVarStructReq.
 */
class Callback_Initial_opVarStructReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opVarStructReq_Base> Callback_Initial_opVarStructReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opOneOptional.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOneOptional.
 */
class Callback_Initial_opOneOptional_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opOneOptional_Base> Callback_Initial_opOneOptionalPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opOneOptionalReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOneOptionalReq.
 */
class Callback_Initial_opOneOptionalReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opOneOptionalReq_Base> Callback_Initial_opOneOptionalReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opOneOptionalProxy.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOneOptionalProxy.
 */
class Callback_Initial_opOneOptionalProxy_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opOneOptionalProxy_Base> Callback_Initial_opOneOptionalProxyPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opOneOptionalProxyReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOneOptionalProxyReq.
 */
class Callback_Initial_opOneOptionalProxyReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opOneOptionalProxyReq_Base> Callback_Initial_opOneOptionalProxyReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opByteSeq.
 */
class Callback_Initial_opByteSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opByteSeq_Base> Callback_Initial_opByteSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opByteSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opByteSeqReq.
 */
class Callback_Initial_opByteSeqReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opByteSeqReq_Base> Callback_Initial_opByteSeqReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBoolSeq.
 */
class Callback_Initial_opBoolSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opBoolSeq_Base> Callback_Initial_opBoolSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opBoolSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBoolSeqReq.
 */
class Callback_Initial_opBoolSeqReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opBoolSeqReq_Base> Callback_Initial_opBoolSeqReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opShortSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opShortSeq.
 */
class Callback_Initial_opShortSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opShortSeq_Base> Callback_Initial_opShortSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opShortSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opShortSeqReq.
 */
class Callback_Initial_opShortSeqReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opShortSeqReq_Base> Callback_Initial_opShortSeqReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opIntSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntSeq.
 */
class Callback_Initial_opIntSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opIntSeq_Base> Callback_Initial_opIntSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opIntSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntSeqReq.
 */
class Callback_Initial_opIntSeqReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opIntSeqReq_Base> Callback_Initial_opIntSeqReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opLongSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opLongSeq.
 */
class Callback_Initial_opLongSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opLongSeq_Base> Callback_Initial_opLongSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opLongSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opLongSeqReq.
 */
class Callback_Initial_opLongSeqReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opLongSeqReq_Base> Callback_Initial_opLongSeqReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opFloatSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFloatSeq.
 */
class Callback_Initial_opFloatSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFloatSeq_Base> Callback_Initial_opFloatSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opFloatSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFloatSeqReq.
 */
class Callback_Initial_opFloatSeqReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFloatSeqReq_Base> Callback_Initial_opFloatSeqReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opDoubleSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDoubleSeq.
 */
class Callback_Initial_opDoubleSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opDoubleSeq_Base> Callback_Initial_opDoubleSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opDoubleSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDoubleSeqReq.
 */
class Callback_Initial_opDoubleSeqReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opDoubleSeqReq_Base> Callback_Initial_opDoubleSeqReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringSeq.
 */
class Callback_Initial_opStringSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opStringSeq_Base> Callback_Initial_opStringSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opStringSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringSeqReq.
 */
class Callback_Initial_opStringSeqReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opStringSeqReq_Base> Callback_Initial_opStringSeqReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructSeq.
 */
class Callback_Initial_opSmallStructSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opSmallStructSeq_Base> Callback_Initial_opSmallStructSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructSeqReq.
 */
class Callback_Initial_opSmallStructSeqReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opSmallStructSeqReq_Base> Callback_Initial_opSmallStructSeqReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructList.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructList.
 */
class Callback_Initial_opSmallStructList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opSmallStructList_Base> Callback_Initial_opSmallStructListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructListReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructListReq.
 */
class Callback_Initial_opSmallStructListReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opSmallStructListReq_Base> Callback_Initial_opSmallStructListReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructSeq.
 */
class Callback_Initial_opFixedStructSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFixedStructSeq_Base> Callback_Initial_opFixedStructSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructSeqReq.
 */
class Callback_Initial_opFixedStructSeqReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFixedStructSeqReq_Base> Callback_Initial_opFixedStructSeqReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructList.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructList.
 */
class Callback_Initial_opFixedStructList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFixedStructList_Base> Callback_Initial_opFixedStructListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructListReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructListReq.
 */
class Callback_Initial_opFixedStructListReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opFixedStructListReq_Base> Callback_Initial_opFixedStructListReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opVarStructSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVarStructSeq.
 */
class Callback_Initial_opVarStructSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opVarStructSeq_Base> Callback_Initial_opVarStructSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opVarStructSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVarStructSeqReq.
 */
class Callback_Initial_opVarStructSeqReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opVarStructSeqReq_Base> Callback_Initial_opVarStructSeqReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opSerializable.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSerializable.
 */
class Callback_Initial_opSerializable_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opSerializable_Base> Callback_Initial_opSerializablePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opSerializableReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSerializableReq.
 */
class Callback_Initial_opSerializableReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opSerializableReq_Base> Callback_Initial_opSerializableReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opIntIntDict.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntIntDict.
 */
class Callback_Initial_opIntIntDict_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opIntIntDict_Base> Callback_Initial_opIntIntDictPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opIntIntDictReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntIntDictReq.
 */
class Callback_Initial_opIntIntDictReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opIntIntDictReq_Base> Callback_Initial_opIntIntDictReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opStringIntDict.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringIntDict.
 */
class Callback_Initial_opStringIntDict_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opStringIntDict_Base> Callback_Initial_opStringIntDictPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opStringIntDictReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringIntDictReq.
 */
class Callback_Initial_opStringIntDictReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opStringIntDictReq_Base> Callback_Initial_opStringIntDictReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opIntOneOptionalDict.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntOneOptionalDict.
 */
class Callback_Initial_opIntOneOptionalDict_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opIntOneOptionalDict_Base> Callback_Initial_opIntOneOptionalDictPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opIntOneOptionalDictReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntOneOptionalDictReq.
 */
class Callback_Initial_opIntOneOptionalDictReq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opIntOneOptionalDictReq_Base> Callback_Initial_opIntOneOptionalDictReqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opClassAndUnknownOptional.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opClassAndUnknownOptional.
 */
class Callback_Initial_opClassAndUnknownOptional_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opClassAndUnknownOptional_Base> Callback_Initial_opClassAndUnknownOptionalPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_sendOptionalClass.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_sendOptionalClass.
 */
class Callback_Initial_sendOptionalClass_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_sendOptionalClass_Base> Callback_Initial_sendOptionalClassPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_returnOptionalClass.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_returnOptionalClass.
 */
class Callback_Initial_returnOptionalClass_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_returnOptionalClass_Base> Callback_Initial_returnOptionalClassPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opG.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opG.
 */
class Callback_Initial_opG_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opG_Base> Callback_Initial_opGPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opVoid.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVoid.
 */
class Callback_Initial_opVoid_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opVoid_Base> Callback_Initial_opVoidPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opMStruct1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMStruct1.
 */
class Callback_Initial_opMStruct1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opMStruct1_Base> Callback_Initial_opMStruct1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opMStruct2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMStruct2.
 */
class Callback_Initial_opMStruct2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opMStruct2_Base> Callback_Initial_opMStruct2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opMSeq1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMSeq1.
 */
class Callback_Initial_opMSeq1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opMSeq1_Base> Callback_Initial_opMSeq1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opMSeq2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMSeq2.
 */
class Callback_Initial_opMSeq2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opMSeq2_Base> Callback_Initial_opMSeq2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opMDict1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMDict1.
 */
class Callback_Initial_opMDict1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opMDict1_Base> Callback_Initial_opMDict1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opMDict2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMDict2.
 */
class Callback_Initial_opMDict2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opMDict2_Base> Callback_Initial_opMDict2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opMG1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMG1.
 */
class Callback_Initial_opMG1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opMG1_Base> Callback_Initial_opMG1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opMG2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMG2.
 */
class Callback_Initial_opMG2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opMG2_Base> Callback_Initial_opMG2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_supportsRequiredParams.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsRequiredParams.
 */
class Callback_Initial_supportsRequiredParams_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_supportsRequiredParams_Base> Callback_Initial_supportsRequiredParamsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_supportsJavaSerializable.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsJavaSerializable.
 */
class Callback_Initial_supportsJavaSerializable_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_supportsJavaSerializable_Base> Callback_Initial_supportsJavaSerializablePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_supportsCsharpSerializable.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsCsharpSerializable.
 */
class Callback_Initial_supportsCsharpSerializable_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_supportsCsharpSerializable_Base> Callback_Initial_supportsCsharpSerializablePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_supportsCppStringView.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsCppStringView.
 */
class Callback_Initial_supportsCppStringView_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_supportsCppStringView_Base> Callback_Initial_supportsCppStringViewPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_supportsNullOptional.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsNullOptional.
 */
class Callback_Initial_supportsNullOptional_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_supportsNullOptional_Base> Callback_Initial_supportsNullOptionalPtr;

}

namespace IceProxy
{

namespace Test
{

class OneOptional : public virtual ::Ice::Proxy<OneOptional, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class MultiOptional : public virtual ::Ice::Proxy<MultiOptional, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class A : public virtual ::Ice::Proxy<A, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class B : public virtual ::Ice::Proxy<B, ::IceProxy::Test::A>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class C : public virtual ::Ice::Proxy<C, ::IceProxy::Test::B>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class WD : public virtual ::Ice::Proxy<WD, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class OptionalWithCustom : public virtual ::Ice::Proxy<OptionalWithCustom, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class E : public virtual ::Ice::Proxy<E, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class F : public virtual ::Ice::Proxy<F, ::IceProxy::Test::E>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class G1 : public virtual ::Ice::Proxy<G1, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class G2 : public virtual ::Ice::Proxy<G2, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class G : public virtual ::Ice::Proxy<G, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Recursive : public virtual ::Ice::Proxy<Recursive, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Initial : public virtual ::Ice::Proxy<Initial, ::IceProxy::Ice::Object>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_Initial_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_Initial_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::ObjectPtr pingPong(const ::Ice::ObjectPtr& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_pingPong(_iceI_begin_pingPong(o, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_pingPong(const ::Ice::ObjectPtr& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_pingPong(o, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pingPong(const ::Ice::ObjectPtr& o, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pingPong(o, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pingPong(const ::Ice::ObjectPtr& o, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pingPong(o, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pingPong(const ::Ice::ObjectPtr& o, const ::Test::Callback_Initial_pingPongPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pingPong(o, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_pingPong(const ::Ice::ObjectPtr& o, const ::Ice::Context& context, const ::Test::Callback_Initial_pingPongPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_pingPong(o, context, cb, cookie);
    }

    ::Ice::ObjectPtr end_pingPong(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_pingPong(const ::Ice::ObjectPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opOptionalException(_iceI_begin_opOptionalException(a, b, o, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptionalException(a, b, o, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptionalException(a, b, o, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptionalException(a, b, o, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Test::Callback_Initial_opOptionalExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptionalException(a, b, o, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context, const ::Test::Callback_Initial_opOptionalExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptionalException(a, b, o, context, cb, cookie);
    }

    void end_opOptionalException(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptionalException(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opDerivedException(_iceI_begin_opDerivedException(a, b, o, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDerivedException(a, b, o, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDerivedException(a, b, o, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDerivedException(a, b, o, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Test::Callback_Initial_opDerivedExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDerivedException(a, b, o, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context, const ::Test::Callback_Initial_opDerivedExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDerivedException(a, b, o, context, cb, cookie);
    }

    void end_opDerivedException(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDerivedException(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opRequiredException(_iceI_begin_opRequiredException(a, b, o, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opRequiredException(a, b, o, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opRequiredException(a, b, o, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opRequiredException(a, b, o, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Test::Callback_Initial_opRequiredExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opRequiredException(a, b, o, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context, const ::Test::Callback_Initial_opRequiredExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opRequiredException(a, b, o, context, cb, cookie);
    }

    void end_opRequiredException(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opRequiredException(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Ice::Byte> opByte(const IceUtil::Optional< ::Ice::Byte>& p1, IceUtil::Optional< ::Ice::Byte>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByte(p3, _iceI_begin_opByte(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByte(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByte(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByte(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Test::Callback_Initial_opBytePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByte(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opBytePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByte(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Ice::Byte> end_opByte(IceUtil::Optional< ::Ice::Byte>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByte(IceUtil::Optional< ::Ice::Byte>& iceP_p3, IceUtil::Optional< ::Ice::Byte>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByte(const IceUtil::Optional< ::Ice::Byte>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Ice::Byte> opByteReq(const IceUtil::Optional< ::Ice::Byte>& p1, IceUtil::Optional< ::Ice::Byte>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteReq(p3, _iceI_begin_opByteReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteReq(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteReq(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteReq(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteReq(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Test::Callback_Initial_opByteReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteReq(const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opByteReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Ice::Byte> end_opByteReq(IceUtil::Optional< ::Ice::Byte>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteReq(IceUtil::Optional< ::Ice::Byte>& iceP_p3, IceUtil::Optional< ::Ice::Byte>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteReq(const IceUtil::Optional< ::Ice::Byte>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional<bool> opBool(const IceUtil::Optional<bool>& p1, IceUtil::Optional<bool>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBool(p3, _iceI_begin_opBool(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBool(const IceUtil::Optional<bool>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBool(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBool(const IceUtil::Optional<bool>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBool(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBool(const IceUtil::Optional<bool>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBool(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBool(const IceUtil::Optional<bool>& p1, const ::Test::Callback_Initial_opBoolPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBool(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBool(const IceUtil::Optional<bool>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opBoolPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBool(p1, context, cb, cookie);
    }

    IceUtil::Optional<bool> end_opBool(IceUtil::Optional<bool>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBool(IceUtil::Optional<bool>& iceP_p3, IceUtil::Optional<bool>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBool(const IceUtil::Optional<bool>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional<bool> opBoolReq(const IceUtil::Optional<bool>& p1, IceUtil::Optional<bool>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolReq(p3, _iceI_begin_opBoolReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolReq(const IceUtil::Optional<bool>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolReq(const IceUtil::Optional<bool>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolReq(const IceUtil::Optional<bool>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolReq(const IceUtil::Optional<bool>& p1, const ::Test::Callback_Initial_opBoolReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolReq(const IceUtil::Optional<bool>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opBoolReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolReq(p1, context, cb, cookie);
    }

    IceUtil::Optional<bool> end_opBoolReq(IceUtil::Optional<bool>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolReq(IceUtil::Optional<bool>& iceP_p3, IceUtil::Optional<bool>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolReq(const IceUtil::Optional<bool>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Ice::Short> opShort(const IceUtil::Optional< ::Ice::Short>& p1, IceUtil::Optional< ::Ice::Short>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShort(p3, _iceI_begin_opShort(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShort(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShort(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShort(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::Test::Callback_Initial_opShortPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShort(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShort(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opShortPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShort(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Ice::Short> end_opShort(IceUtil::Optional< ::Ice::Short>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShort(IceUtil::Optional< ::Ice::Short>& iceP_p3, IceUtil::Optional< ::Ice::Short>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShort(const IceUtil::Optional< ::Ice::Short>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Ice::Short> opShortReq(const IceUtil::Optional< ::Ice::Short>& p1, IceUtil::Optional< ::Ice::Short>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortReq(p3, _iceI_begin_opShortReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortReq(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortReq(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortReq(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortReq(const IceUtil::Optional< ::Ice::Short>& p1, const ::Test::Callback_Initial_opShortReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortReq(const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opShortReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Ice::Short> end_opShortReq(IceUtil::Optional< ::Ice::Short>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortReq(IceUtil::Optional< ::Ice::Short>& iceP_p3, IceUtil::Optional< ::Ice::Short>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortReq(const IceUtil::Optional< ::Ice::Short>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Ice::Int> opInt(const IceUtil::Optional< ::Ice::Int>& p1, IceUtil::Optional< ::Ice::Int>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opInt(p3, _iceI_begin_opInt(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opInt(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opInt(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opInt(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::Test::Callback_Initial_opIntPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opInt(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opInt(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opIntPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opInt(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Ice::Int> end_opInt(IceUtil::Optional< ::Ice::Int>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opInt(IceUtil::Optional< ::Ice::Int>& iceP_p3, IceUtil::Optional< ::Ice::Int>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opInt(const IceUtil::Optional< ::Ice::Int>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Ice::Int> opIntReq(const IceUtil::Optional< ::Ice::Int>& p1, IceUtil::Optional< ::Ice::Int>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntReq(p3, _iceI_begin_opIntReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntReq(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntReq(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntReq(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntReq(const IceUtil::Optional< ::Ice::Int>& p1, const ::Test::Callback_Initial_opIntReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntReq(const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opIntReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Ice::Int> end_opIntReq(IceUtil::Optional< ::Ice::Int>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opIntReq(IceUtil::Optional< ::Ice::Int>& iceP_p3, IceUtil::Optional< ::Ice::Int>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntReq(const IceUtil::Optional< ::Ice::Int>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Ice::Long> opLong(const IceUtil::Optional< ::Ice::Long>& p1, IceUtil::Optional< ::Ice::Long>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLong(p3, _iceI_begin_opLong(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLong(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLong(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLong(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::Test::Callback_Initial_opLongPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLong(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLong(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opLongPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLong(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Ice::Long> end_opLong(IceUtil::Optional< ::Ice::Long>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLong(IceUtil::Optional< ::Ice::Long>& iceP_p3, IceUtil::Optional< ::Ice::Long>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLong(const IceUtil::Optional< ::Ice::Long>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Ice::Long> opLongReq(const IceUtil::Optional< ::Ice::Long>& p1, IceUtil::Optional< ::Ice::Long>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLongReq(p3, _iceI_begin_opLongReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLongReq(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLongReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLongReq(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongReq(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongReq(const IceUtil::Optional< ::Ice::Long>& p1, const ::Test::Callback_Initial_opLongReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongReq(const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opLongReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Ice::Long> end_opLongReq(IceUtil::Optional< ::Ice::Long>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLongReq(IceUtil::Optional< ::Ice::Long>& iceP_p3, IceUtil::Optional< ::Ice::Long>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLongReq(const IceUtil::Optional< ::Ice::Long>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Ice::Float> opFloat(const IceUtil::Optional< ::Ice::Float>& p1, IceUtil::Optional< ::Ice::Float>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFloat(p3, _iceI_begin_opFloat(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFloat(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloat(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloat(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::Test::Callback_Initial_opFloatPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloat(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloat(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opFloatPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloat(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Ice::Float> end_opFloat(IceUtil::Optional< ::Ice::Float>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFloat(IceUtil::Optional< ::Ice::Float>& iceP_p3, IceUtil::Optional< ::Ice::Float>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFloat(const IceUtil::Optional< ::Ice::Float>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Ice::Float> opFloatReq(const IceUtil::Optional< ::Ice::Float>& p1, IceUtil::Optional< ::Ice::Float>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFloatReq(p3, _iceI_begin_opFloatReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFloatReq(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFloatReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatReq(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatReq(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatReq(const IceUtil::Optional< ::Ice::Float>& p1, const ::Test::Callback_Initial_opFloatReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatReq(const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opFloatReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Ice::Float> end_opFloatReq(IceUtil::Optional< ::Ice::Float>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFloatReq(IceUtil::Optional< ::Ice::Float>& iceP_p3, IceUtil::Optional< ::Ice::Float>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFloatReq(const IceUtil::Optional< ::Ice::Float>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Ice::Double> opDouble(const IceUtil::Optional< ::Ice::Double>& p1, IceUtil::Optional< ::Ice::Double>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDouble(p3, _iceI_begin_opDouble(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDouble(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDouble(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDouble(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::Test::Callback_Initial_opDoublePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDouble(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDouble(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opDoublePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDouble(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Ice::Double> end_opDouble(IceUtil::Optional< ::Ice::Double>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDouble(IceUtil::Optional< ::Ice::Double>& iceP_p3, IceUtil::Optional< ::Ice::Double>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDouble(const IceUtil::Optional< ::Ice::Double>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Ice::Double> opDoubleReq(const IceUtil::Optional< ::Ice::Double>& p1, IceUtil::Optional< ::Ice::Double>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDoubleReq(p3, _iceI_begin_opDoubleReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDoubleReq(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDoubleReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleReq(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleReq(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleReq(const IceUtil::Optional< ::Ice::Double>& p1, const ::Test::Callback_Initial_opDoubleReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleReq(const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opDoubleReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Ice::Double> end_opDoubleReq(IceUtil::Optional< ::Ice::Double>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDoubleReq(IceUtil::Optional< ::Ice::Double>& iceP_p3, IceUtil::Optional< ::Ice::Double>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDoubleReq(const IceUtil::Optional< ::Ice::Double>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::std::string> opString(const IceUtil::Optional< ::std::string>& p1, IceUtil::Optional< ::std::string>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opString(p3, _iceI_begin_opString(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opString(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::Test::Callback_Initial_opStringPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const IceUtil::Optional< ::std::string>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opStringPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::std::string> end_opString(IceUtil::Optional< ::std::string>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opString(IceUtil::Optional< ::std::string>& iceP_p3, IceUtil::Optional< ::std::string>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opString(const IceUtil::Optional< ::std::string>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::std::string> opStringReq(const IceUtil::Optional< ::std::string>& p1, IceUtil::Optional< ::std::string>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringReq(p3, _iceI_begin_opStringReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringReq(const IceUtil::Optional< ::std::string>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringReq(const IceUtil::Optional< ::std::string>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringReq(const IceUtil::Optional< ::std::string>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringReq(const IceUtil::Optional< ::std::string>& p1, const ::Test::Callback_Initial_opStringReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringReq(const IceUtil::Optional< ::std::string>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opStringReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::std::string> end_opStringReq(IceUtil::Optional< ::std::string>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringReq(IceUtil::Optional< ::std::string>& iceP_p3, IceUtil::Optional< ::std::string>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringReq(const IceUtil::Optional< ::std::string>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::MyEnum> opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, IceUtil::Optional< ::Test::MyEnum>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMyEnum(p3, _iceI_begin_opMyEnum(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMyEnum(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnum(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnum(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Test::Callback_Initial_opMyEnumPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnum(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opMyEnumPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnum(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::MyEnum> end_opMyEnum(IceUtil::Optional< ::Test::MyEnum>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMyEnum(IceUtil::Optional< ::Test::MyEnum>& iceP_p3, IceUtil::Optional< ::Test::MyEnum>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMyEnum(const IceUtil::Optional< ::Test::MyEnum>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::MyEnum> opMyEnumReq(const IceUtil::Optional< ::Test::MyEnum>& p1, IceUtil::Optional< ::Test::MyEnum>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMyEnumReq(p3, _iceI_begin_opMyEnumReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMyEnumReq(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMyEnumReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumReq(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumReq(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumReq(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Test::Callback_Initial_opMyEnumReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumReq(const IceUtil::Optional< ::Test::MyEnum>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opMyEnumReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::MyEnum> end_opMyEnumReq(IceUtil::Optional< ::Test::MyEnum>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMyEnumReq(IceUtil::Optional< ::Test::MyEnum>& iceP_p3, IceUtil::Optional< ::Test::MyEnum>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMyEnumReq(const IceUtil::Optional< ::Test::MyEnum>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::SmallStruct> opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, IceUtil::Optional< ::Test::SmallStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSmallStruct(p3, _iceI_begin_opSmallStruct(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSmallStruct(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStruct(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStruct(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Test::Callback_Initial_opSmallStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStruct(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opSmallStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStruct(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::SmallStruct> end_opSmallStruct(IceUtil::Optional< ::Test::SmallStruct>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSmallStruct(IceUtil::Optional< ::Test::SmallStruct>& iceP_p3, IceUtil::Optional< ::Test::SmallStruct>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSmallStruct(const IceUtil::Optional< ::Test::SmallStruct>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::SmallStruct> opSmallStructReq(const IceUtil::Optional< ::Test::SmallStruct>& p1, IceUtil::Optional< ::Test::SmallStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSmallStructReq(p3, _iceI_begin_opSmallStructReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSmallStructReq(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSmallStructReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructReq(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructReq(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructReq(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Test::Callback_Initial_opSmallStructReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructReq(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opSmallStructReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::SmallStruct> end_opSmallStructReq(IceUtil::Optional< ::Test::SmallStruct>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSmallStructReq(IceUtil::Optional< ::Test::SmallStruct>& iceP_p3, IceUtil::Optional< ::Test::SmallStruct>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSmallStructReq(const IceUtil::Optional< ::Test::SmallStruct>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::FixedStruct> opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, IceUtil::Optional< ::Test::FixedStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFixedStruct(p3, _iceI_begin_opFixedStruct(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFixedStruct(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStruct(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStruct(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Test::Callback_Initial_opFixedStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStruct(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opFixedStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStruct(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::FixedStruct> end_opFixedStruct(IceUtil::Optional< ::Test::FixedStruct>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFixedStruct(IceUtil::Optional< ::Test::FixedStruct>& iceP_p3, IceUtil::Optional< ::Test::FixedStruct>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFixedStruct(const IceUtil::Optional< ::Test::FixedStruct>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::FixedStruct> opFixedStructReq(const IceUtil::Optional< ::Test::FixedStruct>& p1, IceUtil::Optional< ::Test::FixedStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFixedStructReq(p3, _iceI_begin_opFixedStructReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFixedStructReq(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFixedStructReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructReq(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructReq(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructReq(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Test::Callback_Initial_opFixedStructReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructReq(const IceUtil::Optional< ::Test::FixedStruct>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opFixedStructReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::FixedStruct> end_opFixedStructReq(IceUtil::Optional< ::Test::FixedStruct>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFixedStructReq(IceUtil::Optional< ::Test::FixedStruct>& iceP_p3, IceUtil::Optional< ::Test::FixedStruct>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFixedStructReq(const IceUtil::Optional< ::Test::FixedStruct>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::VarStruct> opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, IceUtil::Optional< ::Test::VarStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVarStruct(p3, _iceI_begin_opVarStruct(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVarStruct(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStruct(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStruct(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Test::Callback_Initial_opVarStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStruct(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opVarStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStruct(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::VarStruct> end_opVarStruct(IceUtil::Optional< ::Test::VarStruct>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVarStruct(IceUtil::Optional< ::Test::VarStruct>& iceP_p3, IceUtil::Optional< ::Test::VarStruct>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVarStruct(const IceUtil::Optional< ::Test::VarStruct>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::VarStruct> opVarStructReq(const IceUtil::Optional< ::Test::VarStruct>& p1, IceUtil::Optional< ::Test::VarStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVarStructReq(p3, _iceI_begin_opVarStructReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVarStructReq(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVarStructReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVarStructReq(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStructReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStructReq(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStructReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStructReq(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Test::Callback_Initial_opVarStructReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStructReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStructReq(const IceUtil::Optional< ::Test::VarStruct>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opVarStructReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStructReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::VarStruct> end_opVarStructReq(IceUtil::Optional< ::Test::VarStruct>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVarStructReq(IceUtil::Optional< ::Test::VarStruct>& iceP_p3, IceUtil::Optional< ::Test::VarStruct>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVarStructReq(const IceUtil::Optional< ::Test::VarStruct>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::OneOptionalPtr> opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, IceUtil::Optional< ::Test::OneOptionalPtr>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOneOptional(p3, _iceI_begin_opOneOptional(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOneOptional(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptional(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptional(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Test::Callback_Initial_opOneOptionalPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptional(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opOneOptionalPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptional(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::OneOptionalPtr> end_opOneOptional(IceUtil::Optional< ::Test::OneOptionalPtr>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOneOptional(IceUtil::Optional< ::Test::OneOptionalPtr>& iceP_p3, IceUtil::Optional< ::Test::OneOptionalPtr>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOneOptional(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::OneOptionalPtr> opOneOptionalReq(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, IceUtil::Optional< ::Test::OneOptionalPtr>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOneOptionalReq(p3, _iceI_begin_opOneOptionalReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalReq(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOneOptionalReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalReq(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptionalReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalReq(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptionalReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalReq(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Test::Callback_Initial_opOneOptionalReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptionalReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalReq(const IceUtil::Optional< ::Test::OneOptionalPtr>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opOneOptionalReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptionalReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::OneOptionalPtr> end_opOneOptionalReq(IceUtil::Optional< ::Test::OneOptionalPtr>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOneOptionalReq(IceUtil::Optional< ::Test::OneOptionalPtr>& iceP_p3, IceUtil::Optional< ::Test::OneOptionalPtr>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOneOptionalReq(const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::OneOptionalPrx> opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, IceUtil::Optional< ::Test::OneOptionalPrx>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOneOptionalProxy(p3, _iceI_begin_opOneOptionalProxy(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOneOptionalProxy(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptionalProxy(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptionalProxy(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Test::Callback_Initial_opOneOptionalProxyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptionalProxy(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opOneOptionalProxyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptionalProxy(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::OneOptionalPrx> end_opOneOptionalProxy(IceUtil::Optional< ::Test::OneOptionalPrx>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOneOptionalProxy(IceUtil::Optional< ::Test::OneOptionalPrx>& iceP_p3, IceUtil::Optional< ::Test::OneOptionalPrx>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOneOptionalProxy(const IceUtil::Optional< ::Test::OneOptionalPrx>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::OneOptionalPrx> opOneOptionalProxyReq(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, IceUtil::Optional< ::Test::OneOptionalPrx>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOneOptionalProxyReq(p3, _iceI_begin_opOneOptionalProxyReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxyReq(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOneOptionalProxyReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxyReq(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptionalProxyReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxyReq(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptionalProxyReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxyReq(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Test::Callback_Initial_opOneOptionalProxyReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptionalProxyReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOneOptionalProxyReq(const IceUtil::Optional< ::Test::OneOptionalPrx>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opOneOptionalProxyReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOneOptionalProxyReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::OneOptionalPrx> end_opOneOptionalProxyReq(IceUtil::Optional< ::Test::OneOptionalPrx>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOneOptionalProxyReq(IceUtil::Optional< ::Test::OneOptionalPrx>& iceP_p3, IceUtil::Optional< ::Test::OneOptionalPrx>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOneOptionalProxyReq(const IceUtil::Optional< ::Test::OneOptionalPrx>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::ByteSeq> opByteSeq(const IceUtil::Optional< ::Test::ByteSeq>& p1, IceUtil::Optional< ::Test::ByteSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteSeq(p3, _iceI_begin_opByteSeq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const IceUtil::Optional< ::Test::ByteSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteSeq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const IceUtil::Optional< ::Test::ByteSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const IceUtil::Optional< ::Test::ByteSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const IceUtil::Optional< ::Test::ByteSeq>& p1, const ::Test::Callback_Initial_opByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const IceUtil::Optional< ::Test::ByteSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::ByteSeq> end_opByteSeq(IceUtil::Optional< ::Test::ByteSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteSeq(IceUtil::Optional< ::Test::ByteSeq>& iceP_p3, IceUtil::Optional< ::Test::ByteSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteSeq(const IceUtil::Optional< ::Test::ByteSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::ByteSeq> opByteSeqReq(const IceUtil::Optional< ::Test::ByteSeq>& p1, IceUtil::Optional< ::Test::ByteSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteSeqReq(p3, _iceI_begin_opByteSeqReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteSeqReq(const IceUtil::Optional< ::Test::ByteSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteSeqReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSeqReq(const IceUtil::Optional< ::Test::ByteSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeqReq(const IceUtil::Optional< ::Test::ByteSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeqReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeqReq(const IceUtil::Optional< ::Test::ByteSeq>& p1, const ::Test::Callback_Initial_opByteSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeqReq(const IceUtil::Optional< ::Test::ByteSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opByteSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeqReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::ByteSeq> end_opByteSeqReq(IceUtil::Optional< ::Test::ByteSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteSeqReq(IceUtil::Optional< ::Test::ByteSeq>& iceP_p3, IceUtil::Optional< ::Test::ByteSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteSeqReq(const IceUtil::Optional< ::Test::ByteSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::BoolSeq> opBoolSeq(const IceUtil::Optional< ::Test::BoolSeq>& p1, IceUtil::Optional< ::Test::BoolSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolSeq(p3, _iceI_begin_opBoolSeq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const IceUtil::Optional< ::Test::BoolSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolSeq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const IceUtil::Optional< ::Test::BoolSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const IceUtil::Optional< ::Test::BoolSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const IceUtil::Optional< ::Test::BoolSeq>& p1, const ::Test::Callback_Initial_opBoolSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const IceUtil::Optional< ::Test::BoolSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opBoolSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::BoolSeq> end_opBoolSeq(IceUtil::Optional< ::Test::BoolSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolSeq(IceUtil::Optional< ::Test::BoolSeq>& iceP_p3, IceUtil::Optional< ::Test::BoolSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolSeq(const IceUtil::Optional< ::Test::BoolSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::BoolSeq> opBoolSeqReq(const IceUtil::Optional< ::Test::BoolSeq>& p1, IceUtil::Optional< ::Test::BoolSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolSeqReq(p3, _iceI_begin_opBoolSeqReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolSeqReq(const IceUtil::Optional< ::Test::BoolSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolSeqReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeqReq(const IceUtil::Optional< ::Test::BoolSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeqReq(const IceUtil::Optional< ::Test::BoolSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeqReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeqReq(const IceUtil::Optional< ::Test::BoolSeq>& p1, const ::Test::Callback_Initial_opBoolSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeqReq(const IceUtil::Optional< ::Test::BoolSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opBoolSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeqReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::BoolSeq> end_opBoolSeqReq(IceUtil::Optional< ::Test::BoolSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolSeqReq(IceUtil::Optional< ::Test::BoolSeq>& iceP_p3, IceUtil::Optional< ::Test::BoolSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolSeqReq(const IceUtil::Optional< ::Test::BoolSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::ShortSeq> opShortSeq(const IceUtil::Optional< ::Test::ShortSeq>& p1, IceUtil::Optional< ::Test::ShortSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortSeq(p3, _iceI_begin_opShortSeq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const IceUtil::Optional< ::Test::ShortSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortSeq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const IceUtil::Optional< ::Test::ShortSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const IceUtil::Optional< ::Test::ShortSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const IceUtil::Optional< ::Test::ShortSeq>& p1, const ::Test::Callback_Initial_opShortSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const IceUtil::Optional< ::Test::ShortSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opShortSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::ShortSeq> end_opShortSeq(IceUtil::Optional< ::Test::ShortSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortSeq(IceUtil::Optional< ::Test::ShortSeq>& iceP_p3, IceUtil::Optional< ::Test::ShortSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortSeq(const IceUtil::Optional< ::Test::ShortSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::ShortSeq> opShortSeqReq(const IceUtil::Optional< ::Test::ShortSeq>& p1, IceUtil::Optional< ::Test::ShortSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortSeqReq(p3, _iceI_begin_opShortSeqReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortSeqReq(const IceUtil::Optional< ::Test::ShortSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortSeqReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortSeqReq(const IceUtil::Optional< ::Test::ShortSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeqReq(const IceUtil::Optional< ::Test::ShortSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeqReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeqReq(const IceUtil::Optional< ::Test::ShortSeq>& p1, const ::Test::Callback_Initial_opShortSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeqReq(const IceUtil::Optional< ::Test::ShortSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opShortSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeqReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::ShortSeq> end_opShortSeqReq(IceUtil::Optional< ::Test::ShortSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortSeqReq(IceUtil::Optional< ::Test::ShortSeq>& iceP_p3, IceUtil::Optional< ::Test::ShortSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortSeqReq(const IceUtil::Optional< ::Test::ShortSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::IntSeq> opIntSeq(const IceUtil::Optional< ::Test::IntSeq>& p1, IceUtil::Optional< ::Test::IntSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntSeq(p3, _iceI_begin_opIntSeq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const IceUtil::Optional< ::Test::IntSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntSeq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const IceUtil::Optional< ::Test::IntSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const IceUtil::Optional< ::Test::IntSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const IceUtil::Optional< ::Test::IntSeq>& p1, const ::Test::Callback_Initial_opIntSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const IceUtil::Optional< ::Test::IntSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opIntSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::IntSeq> end_opIntSeq(IceUtil::Optional< ::Test::IntSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opIntSeq(IceUtil::Optional< ::Test::IntSeq>& iceP_p3, IceUtil::Optional< ::Test::IntSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntSeq(const IceUtil::Optional< ::Test::IntSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::IntSeq> opIntSeqReq(const IceUtil::Optional< ::Test::IntSeq>& p1, IceUtil::Optional< ::Test::IntSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntSeqReq(p3, _iceI_begin_opIntSeqReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntSeqReq(const IceUtil::Optional< ::Test::IntSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntSeqReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntSeqReq(const IceUtil::Optional< ::Test::IntSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeqReq(const IceUtil::Optional< ::Test::IntSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeqReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeqReq(const IceUtil::Optional< ::Test::IntSeq>& p1, const ::Test::Callback_Initial_opIntSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeqReq(const IceUtil::Optional< ::Test::IntSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opIntSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeqReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::IntSeq> end_opIntSeqReq(IceUtil::Optional< ::Test::IntSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opIntSeqReq(IceUtil::Optional< ::Test::IntSeq>& iceP_p3, IceUtil::Optional< ::Test::IntSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntSeqReq(const IceUtil::Optional< ::Test::IntSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::LongSeq> opLongSeq(const IceUtil::Optional< ::Test::LongSeq>& p1, IceUtil::Optional< ::Test::LongSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLongSeq(p3, _iceI_begin_opLongSeq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const IceUtil::Optional< ::Test::LongSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLongSeq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const IceUtil::Optional< ::Test::LongSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const IceUtil::Optional< ::Test::LongSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const IceUtil::Optional< ::Test::LongSeq>& p1, const ::Test::Callback_Initial_opLongSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const IceUtil::Optional< ::Test::LongSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opLongSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::LongSeq> end_opLongSeq(IceUtil::Optional< ::Test::LongSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLongSeq(IceUtil::Optional< ::Test::LongSeq>& iceP_p3, IceUtil::Optional< ::Test::LongSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLongSeq(const IceUtil::Optional< ::Test::LongSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::LongSeq> opLongSeqReq(const IceUtil::Optional< ::Test::LongSeq>& p1, IceUtil::Optional< ::Test::LongSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLongSeqReq(p3, _iceI_begin_opLongSeqReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLongSeqReq(const IceUtil::Optional< ::Test::LongSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLongSeqReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLongSeqReq(const IceUtil::Optional< ::Test::LongSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeqReq(const IceUtil::Optional< ::Test::LongSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeqReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeqReq(const IceUtil::Optional< ::Test::LongSeq>& p1, const ::Test::Callback_Initial_opLongSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeqReq(const IceUtil::Optional< ::Test::LongSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opLongSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeqReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::LongSeq> end_opLongSeqReq(IceUtil::Optional< ::Test::LongSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLongSeqReq(IceUtil::Optional< ::Test::LongSeq>& iceP_p3, IceUtil::Optional< ::Test::LongSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLongSeqReq(const IceUtil::Optional< ::Test::LongSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::FloatSeq> opFloatSeq(const IceUtil::Optional< ::Test::FloatSeq>& p1, IceUtil::Optional< ::Test::FloatSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFloatSeq(p3, _iceI_begin_opFloatSeq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const IceUtil::Optional< ::Test::FloatSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFloatSeq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const IceUtil::Optional< ::Test::FloatSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const IceUtil::Optional< ::Test::FloatSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const IceUtil::Optional< ::Test::FloatSeq>& p1, const ::Test::Callback_Initial_opFloatSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const IceUtil::Optional< ::Test::FloatSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opFloatSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::FloatSeq> end_opFloatSeq(IceUtil::Optional< ::Test::FloatSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFloatSeq(IceUtil::Optional< ::Test::FloatSeq>& iceP_p3, IceUtil::Optional< ::Test::FloatSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFloatSeq(const IceUtil::Optional< ::Test::FloatSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::FloatSeq> opFloatSeqReq(const IceUtil::Optional< ::Test::FloatSeq>& p1, IceUtil::Optional< ::Test::FloatSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFloatSeqReq(p3, _iceI_begin_opFloatSeqReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFloatSeqReq(const IceUtil::Optional< ::Test::FloatSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFloatSeqReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeqReq(const IceUtil::Optional< ::Test::FloatSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeqReq(const IceUtil::Optional< ::Test::FloatSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeqReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeqReq(const IceUtil::Optional< ::Test::FloatSeq>& p1, const ::Test::Callback_Initial_opFloatSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeqReq(const IceUtil::Optional< ::Test::FloatSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opFloatSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeqReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::FloatSeq> end_opFloatSeqReq(IceUtil::Optional< ::Test::FloatSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFloatSeqReq(IceUtil::Optional< ::Test::FloatSeq>& iceP_p3, IceUtil::Optional< ::Test::FloatSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFloatSeqReq(const IceUtil::Optional< ::Test::FloatSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::DoubleSeq> opDoubleSeq(const IceUtil::Optional< ::Test::DoubleSeq>& p1, IceUtil::Optional< ::Test::DoubleSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDoubleSeq(p3, _iceI_begin_opDoubleSeq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const IceUtil::Optional< ::Test::DoubleSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDoubleSeq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const IceUtil::Optional< ::Test::DoubleSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const IceUtil::Optional< ::Test::DoubleSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const IceUtil::Optional< ::Test::DoubleSeq>& p1, const ::Test::Callback_Initial_opDoubleSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const IceUtil::Optional< ::Test::DoubleSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opDoubleSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::DoubleSeq> end_opDoubleSeq(IceUtil::Optional< ::Test::DoubleSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDoubleSeq(IceUtil::Optional< ::Test::DoubleSeq>& iceP_p3, IceUtil::Optional< ::Test::DoubleSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDoubleSeq(const IceUtil::Optional< ::Test::DoubleSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::DoubleSeq> opDoubleSeqReq(const IceUtil::Optional< ::Test::DoubleSeq>& p1, IceUtil::Optional< ::Test::DoubleSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDoubleSeqReq(p3, _iceI_begin_opDoubleSeqReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeqReq(const IceUtil::Optional< ::Test::DoubleSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDoubleSeqReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeqReq(const IceUtil::Optional< ::Test::DoubleSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeqReq(const IceUtil::Optional< ::Test::DoubleSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeqReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeqReq(const IceUtil::Optional< ::Test::DoubleSeq>& p1, const ::Test::Callback_Initial_opDoubleSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeqReq(const IceUtil::Optional< ::Test::DoubleSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opDoubleSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeqReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::DoubleSeq> end_opDoubleSeqReq(IceUtil::Optional< ::Test::DoubleSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDoubleSeqReq(IceUtil::Optional< ::Test::DoubleSeq>& iceP_p3, IceUtil::Optional< ::Test::DoubleSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDoubleSeqReq(const IceUtil::Optional< ::Test::DoubleSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::StringSeq> opStringSeq(const IceUtil::Optional< ::Test::StringSeq>& p1, IceUtil::Optional< ::Test::StringSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringSeq(p3, _iceI_begin_opStringSeq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringSeq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Test::Callback_Initial_opStringSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opStringSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::StringSeq> end_opStringSeq(IceUtil::Optional< ::Test::StringSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringSeq(IceUtil::Optional< ::Test::StringSeq>& iceP_p3, IceUtil::Optional< ::Test::StringSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringSeq(const IceUtil::Optional< ::Test::StringSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::StringSeq> opStringSeqReq(const IceUtil::Optional< ::Test::StringSeq>& p1, IceUtil::Optional< ::Test::StringSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringSeqReq(p3, _iceI_begin_opStringSeqReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringSeqReq(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringSeqReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSeqReq(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeqReq(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeqReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeqReq(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Test::Callback_Initial_opStringSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeqReq(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opStringSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeqReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::StringSeq> end_opStringSeqReq(IceUtil::Optional< ::Test::StringSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringSeqReq(IceUtil::Optional< ::Test::StringSeq>& iceP_p3, IceUtil::Optional< ::Test::StringSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringSeqReq(const IceUtil::Optional< ::Test::StringSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::SmallStructSeq> opSmallStructSeq(const IceUtil::Optional< ::Test::SmallStructSeq>& p1, IceUtil::Optional< ::Test::SmallStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSmallStructSeq(p3, _iceI_begin_opSmallStructSeq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeq(const IceUtil::Optional< ::Test::SmallStructSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSmallStructSeq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeq(const IceUtil::Optional< ::Test::SmallStructSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeq(const IceUtil::Optional< ::Test::SmallStructSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructSeq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeq(const IceUtil::Optional< ::Test::SmallStructSeq>& p1, const ::Test::Callback_Initial_opSmallStructSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeq(const IceUtil::Optional< ::Test::SmallStructSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opSmallStructSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructSeq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::SmallStructSeq> end_opSmallStructSeq(IceUtil::Optional< ::Test::SmallStructSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSmallStructSeq(IceUtil::Optional< ::Test::SmallStructSeq>& iceP_p3, IceUtil::Optional< ::Test::SmallStructSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSmallStructSeq(const IceUtil::Optional< ::Test::SmallStructSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::SmallStructSeq> opSmallStructSeqReq(const IceUtil::Optional< ::Test::SmallStructSeq>& p1, IceUtil::Optional< ::Test::SmallStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSmallStructSeqReq(p3, _iceI_begin_opSmallStructSeqReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeqReq(const IceUtil::Optional< ::Test::SmallStructSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSmallStructSeqReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeqReq(const IceUtil::Optional< ::Test::SmallStructSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeqReq(const IceUtil::Optional< ::Test::SmallStructSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructSeqReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeqReq(const IceUtil::Optional< ::Test::SmallStructSeq>& p1, const ::Test::Callback_Initial_opSmallStructSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructSeqReq(const IceUtil::Optional< ::Test::SmallStructSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opSmallStructSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructSeqReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::SmallStructSeq> end_opSmallStructSeqReq(IceUtil::Optional< ::Test::SmallStructSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSmallStructSeqReq(IceUtil::Optional< ::Test::SmallStructSeq>& iceP_p3, IceUtil::Optional< ::Test::SmallStructSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSmallStructSeqReq(const IceUtil::Optional< ::Test::SmallStructSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::SmallStructList> opSmallStructList(const IceUtil::Optional< ::Test::SmallStructList>& p1, IceUtil::Optional< ::Test::SmallStructList>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSmallStructList(p3, _iceI_begin_opSmallStructList(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSmallStructList(const IceUtil::Optional< ::Test::SmallStructList>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSmallStructList(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructList(const IceUtil::Optional< ::Test::SmallStructList>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructList(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructList(const IceUtil::Optional< ::Test::SmallStructList>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructList(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructList(const IceUtil::Optional< ::Test::SmallStructList>& p1, const ::Test::Callback_Initial_opSmallStructListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructList(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructList(const IceUtil::Optional< ::Test::SmallStructList>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opSmallStructListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructList(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::SmallStructList> end_opSmallStructList(IceUtil::Optional< ::Test::SmallStructList>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSmallStructList(IceUtil::Optional< ::Test::SmallStructList>& iceP_p3, IceUtil::Optional< ::Test::SmallStructList>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSmallStructList(const IceUtil::Optional< ::Test::SmallStructList>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::SmallStructList> opSmallStructListReq(const IceUtil::Optional< ::Test::SmallStructList>& p1, IceUtil::Optional< ::Test::SmallStructList>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSmallStructListReq(p3, _iceI_begin_opSmallStructListReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSmallStructListReq(const IceUtil::Optional< ::Test::SmallStructList>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSmallStructListReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructListReq(const IceUtil::Optional< ::Test::SmallStructList>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructListReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructListReq(const IceUtil::Optional< ::Test::SmallStructList>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructListReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructListReq(const IceUtil::Optional< ::Test::SmallStructList>& p1, const ::Test::Callback_Initial_opSmallStructListReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructListReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSmallStructListReq(const IceUtil::Optional< ::Test::SmallStructList>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opSmallStructListReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSmallStructListReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::SmallStructList> end_opSmallStructListReq(IceUtil::Optional< ::Test::SmallStructList>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSmallStructListReq(IceUtil::Optional< ::Test::SmallStructList>& iceP_p3, IceUtil::Optional< ::Test::SmallStructList>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSmallStructListReq(const IceUtil::Optional< ::Test::SmallStructList>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::FixedStructSeq> opFixedStructSeq(const IceUtil::Optional< ::Test::FixedStructSeq>& p1, IceUtil::Optional< ::Test::FixedStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFixedStructSeq(p3, _iceI_begin_opFixedStructSeq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeq(const IceUtil::Optional< ::Test::FixedStructSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFixedStructSeq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeq(const IceUtil::Optional< ::Test::FixedStructSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeq(const IceUtil::Optional< ::Test::FixedStructSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructSeq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeq(const IceUtil::Optional< ::Test::FixedStructSeq>& p1, const ::Test::Callback_Initial_opFixedStructSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeq(const IceUtil::Optional< ::Test::FixedStructSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opFixedStructSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructSeq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::FixedStructSeq> end_opFixedStructSeq(IceUtil::Optional< ::Test::FixedStructSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFixedStructSeq(IceUtil::Optional< ::Test::FixedStructSeq>& iceP_p3, IceUtil::Optional< ::Test::FixedStructSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFixedStructSeq(const IceUtil::Optional< ::Test::FixedStructSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::FixedStructSeq> opFixedStructSeqReq(const IceUtil::Optional< ::Test::FixedStructSeq>& p1, IceUtil::Optional< ::Test::FixedStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFixedStructSeqReq(p3, _iceI_begin_opFixedStructSeqReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeqReq(const IceUtil::Optional< ::Test::FixedStructSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFixedStructSeqReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeqReq(const IceUtil::Optional< ::Test::FixedStructSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeqReq(const IceUtil::Optional< ::Test::FixedStructSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructSeqReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeqReq(const IceUtil::Optional< ::Test::FixedStructSeq>& p1, const ::Test::Callback_Initial_opFixedStructSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructSeqReq(const IceUtil::Optional< ::Test::FixedStructSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opFixedStructSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructSeqReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::FixedStructSeq> end_opFixedStructSeqReq(IceUtil::Optional< ::Test::FixedStructSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFixedStructSeqReq(IceUtil::Optional< ::Test::FixedStructSeq>& iceP_p3, IceUtil::Optional< ::Test::FixedStructSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFixedStructSeqReq(const IceUtil::Optional< ::Test::FixedStructSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::FixedStructList> opFixedStructList(const IceUtil::Optional< ::Test::FixedStructList>& p1, IceUtil::Optional< ::Test::FixedStructList>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFixedStructList(p3, _iceI_begin_opFixedStructList(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFixedStructList(const IceUtil::Optional< ::Test::FixedStructList>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFixedStructList(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructList(const IceUtil::Optional< ::Test::FixedStructList>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructList(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructList(const IceUtil::Optional< ::Test::FixedStructList>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructList(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructList(const IceUtil::Optional< ::Test::FixedStructList>& p1, const ::Test::Callback_Initial_opFixedStructListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructList(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructList(const IceUtil::Optional< ::Test::FixedStructList>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opFixedStructListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructList(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::FixedStructList> end_opFixedStructList(IceUtil::Optional< ::Test::FixedStructList>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFixedStructList(IceUtil::Optional< ::Test::FixedStructList>& iceP_p3, IceUtil::Optional< ::Test::FixedStructList>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFixedStructList(const IceUtil::Optional< ::Test::FixedStructList>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::FixedStructList> opFixedStructListReq(const IceUtil::Optional< ::Test::FixedStructList>& p1, IceUtil::Optional< ::Test::FixedStructList>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFixedStructListReq(p3, _iceI_begin_opFixedStructListReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFixedStructListReq(const IceUtil::Optional< ::Test::FixedStructList>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFixedStructListReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructListReq(const IceUtil::Optional< ::Test::FixedStructList>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructListReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructListReq(const IceUtil::Optional< ::Test::FixedStructList>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructListReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructListReq(const IceUtil::Optional< ::Test::FixedStructList>& p1, const ::Test::Callback_Initial_opFixedStructListReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructListReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedStructListReq(const IceUtil::Optional< ::Test::FixedStructList>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opFixedStructListReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedStructListReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::FixedStructList> end_opFixedStructListReq(IceUtil::Optional< ::Test::FixedStructList>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFixedStructListReq(IceUtil::Optional< ::Test::FixedStructList>& iceP_p3, IceUtil::Optional< ::Test::FixedStructList>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFixedStructListReq(const IceUtil::Optional< ::Test::FixedStructList>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::VarStructSeq> opVarStructSeq(const IceUtil::Optional< ::Test::VarStructSeq>& p1, IceUtil::Optional< ::Test::VarStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVarStructSeq(p3, _iceI_begin_opVarStructSeq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeq(const IceUtil::Optional< ::Test::VarStructSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVarStructSeq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeq(const IceUtil::Optional< ::Test::VarStructSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStructSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeq(const IceUtil::Optional< ::Test::VarStructSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStructSeq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeq(const IceUtil::Optional< ::Test::VarStructSeq>& p1, const ::Test::Callback_Initial_opVarStructSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStructSeq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeq(const IceUtil::Optional< ::Test::VarStructSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opVarStructSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStructSeq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::VarStructSeq> end_opVarStructSeq(IceUtil::Optional< ::Test::VarStructSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVarStructSeq(IceUtil::Optional< ::Test::VarStructSeq>& iceP_p3, IceUtil::Optional< ::Test::VarStructSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVarStructSeq(const IceUtil::Optional< ::Test::VarStructSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::VarStructSeq> opVarStructSeqReq(const IceUtil::Optional< ::Test::VarStructSeq>& p1, IceUtil::Optional< ::Test::VarStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVarStructSeqReq(p3, _iceI_begin_opVarStructSeqReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeqReq(const IceUtil::Optional< ::Test::VarStructSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVarStructSeqReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeqReq(const IceUtil::Optional< ::Test::VarStructSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStructSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeqReq(const IceUtil::Optional< ::Test::VarStructSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStructSeqReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeqReq(const IceUtil::Optional< ::Test::VarStructSeq>& p1, const ::Test::Callback_Initial_opVarStructSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStructSeqReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarStructSeqReq(const IceUtil::Optional< ::Test::VarStructSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opVarStructSeqReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarStructSeqReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::VarStructSeq> end_opVarStructSeqReq(IceUtil::Optional< ::Test::VarStructSeq>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVarStructSeqReq(IceUtil::Optional< ::Test::VarStructSeq>& iceP_p3, IceUtil::Optional< ::Test::VarStructSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVarStructSeqReq(const IceUtil::Optional< ::Test::VarStructSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::Serializable> opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, IceUtil::Optional< ::Test::Serializable>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSerializable(p3, _iceI_begin_opSerializable(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSerializable(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerializable(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerializable(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Test::Callback_Initial_opSerializablePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerializable(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opSerializablePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerializable(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::Serializable> end_opSerializable(IceUtil::Optional< ::Test::Serializable>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSerializable(IceUtil::Optional< ::Test::Serializable>& iceP_p3, IceUtil::Optional< ::Test::Serializable>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSerializable(const IceUtil::Optional< ::Test::Serializable>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::Serializable> opSerializableReq(const IceUtil::Optional< ::Test::Serializable>& p1, IceUtil::Optional< ::Test::Serializable>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSerializableReq(p3, _iceI_begin_opSerializableReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSerializableReq(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSerializableReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSerializableReq(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerializableReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerializableReq(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerializableReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerializableReq(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Test::Callback_Initial_opSerializableReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerializableReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSerializableReq(const IceUtil::Optional< ::Test::Serializable>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opSerializableReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSerializableReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::Serializable> end_opSerializableReq(IceUtil::Optional< ::Test::Serializable>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSerializableReq(IceUtil::Optional< ::Test::Serializable>& iceP_p3, IceUtil::Optional< ::Test::Serializable>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSerializableReq(const IceUtil::Optional< ::Test::Serializable>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::IntIntDict> opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, IceUtil::Optional< ::Test::IntIntDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntIntDict(p3, _iceI_begin_opIntIntDict(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntIntDict(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntIntDict(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntIntDict(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Test::Callback_Initial_opIntIntDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntIntDict(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opIntIntDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntIntDict(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::IntIntDict> end_opIntIntDict(IceUtil::Optional< ::Test::IntIntDict>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opIntIntDict(IceUtil::Optional< ::Test::IntIntDict>& iceP_p3, IceUtil::Optional< ::Test::IntIntDict>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntIntDict(const IceUtil::Optional< ::Test::IntIntDict>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::IntIntDict> opIntIntDictReq(const IceUtil::Optional< ::Test::IntIntDict>& p1, IceUtil::Optional< ::Test::IntIntDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntIntDictReq(p3, _iceI_begin_opIntIntDictReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntIntDictReq(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntIntDictReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntIntDictReq(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntIntDictReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntIntDictReq(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntIntDictReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntIntDictReq(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Test::Callback_Initial_opIntIntDictReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntIntDictReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntIntDictReq(const IceUtil::Optional< ::Test::IntIntDict>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opIntIntDictReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntIntDictReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::IntIntDict> end_opIntIntDictReq(IceUtil::Optional< ::Test::IntIntDict>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opIntIntDictReq(IceUtil::Optional< ::Test::IntIntDict>& iceP_p3, IceUtil::Optional< ::Test::IntIntDict>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntIntDictReq(const IceUtil::Optional< ::Test::IntIntDict>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::StringIntDict> opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, IceUtil::Optional< ::Test::StringIntDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringIntDict(p3, _iceI_begin_opStringIntDict(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringIntDict(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringIntDict(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringIntDict(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Test::Callback_Initial_opStringIntDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringIntDict(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opStringIntDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringIntDict(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::StringIntDict> end_opStringIntDict(IceUtil::Optional< ::Test::StringIntDict>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringIntDict(IceUtil::Optional< ::Test::StringIntDict>& iceP_p3, IceUtil::Optional< ::Test::StringIntDict>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringIntDict(const IceUtil::Optional< ::Test::StringIntDict>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::StringIntDict> opStringIntDictReq(const IceUtil::Optional< ::Test::StringIntDict>& p1, IceUtil::Optional< ::Test::StringIntDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringIntDictReq(p3, _iceI_begin_opStringIntDictReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringIntDictReq(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringIntDictReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringIntDictReq(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringIntDictReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringIntDictReq(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringIntDictReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringIntDictReq(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Test::Callback_Initial_opStringIntDictReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringIntDictReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringIntDictReq(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opStringIntDictReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringIntDictReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::StringIntDict> end_opStringIntDictReq(IceUtil::Optional< ::Test::StringIntDict>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringIntDictReq(IceUtil::Optional< ::Test::StringIntDict>& iceP_p3, IceUtil::Optional< ::Test::StringIntDict>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringIntDictReq(const IceUtil::Optional< ::Test::StringIntDict>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::IntOneOptionalDict> opIntOneOptionalDict(const IceUtil::Optional< ::Test::IntOneOptionalDict>& p1, IceUtil::Optional< ::Test::IntOneOptionalDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntOneOptionalDict(p3, _iceI_begin_opIntOneOptionalDict(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntOneOptionalDict(const IceUtil::Optional< ::Test::IntOneOptionalDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntOneOptionalDict(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntOneOptionalDict(const IceUtil::Optional< ::Test::IntOneOptionalDict>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntOneOptionalDict(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntOneOptionalDict(const IceUtil::Optional< ::Test::IntOneOptionalDict>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntOneOptionalDict(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntOneOptionalDict(const IceUtil::Optional< ::Test::IntOneOptionalDict>& p1, const ::Test::Callback_Initial_opIntOneOptionalDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntOneOptionalDict(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntOneOptionalDict(const IceUtil::Optional< ::Test::IntOneOptionalDict>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opIntOneOptionalDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntOneOptionalDict(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::IntOneOptionalDict> end_opIntOneOptionalDict(IceUtil::Optional< ::Test::IntOneOptionalDict>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opIntOneOptionalDict(IceUtil::Optional< ::Test::IntOneOptionalDict>& iceP_p3, IceUtil::Optional< ::Test::IntOneOptionalDict>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntOneOptionalDict(const IceUtil::Optional< ::Test::IntOneOptionalDict>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::IntOneOptionalDict> opIntOneOptionalDictReq(const IceUtil::Optional< ::Test::IntOneOptionalDict>& p1, IceUtil::Optional< ::Test::IntOneOptionalDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntOneOptionalDictReq(p3, _iceI_begin_opIntOneOptionalDictReq(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntOneOptionalDictReq(const IceUtil::Optional< ::Test::IntOneOptionalDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntOneOptionalDictReq(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntOneOptionalDictReq(const IceUtil::Optional< ::Test::IntOneOptionalDict>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntOneOptionalDictReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntOneOptionalDictReq(const IceUtil::Optional< ::Test::IntOneOptionalDict>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntOneOptionalDictReq(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntOneOptionalDictReq(const IceUtil::Optional< ::Test::IntOneOptionalDict>& p1, const ::Test::Callback_Initial_opIntOneOptionalDictReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntOneOptionalDictReq(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntOneOptionalDictReq(const IceUtil::Optional< ::Test::IntOneOptionalDict>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opIntOneOptionalDictReqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntOneOptionalDictReq(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::IntOneOptionalDict> end_opIntOneOptionalDictReq(IceUtil::Optional< ::Test::IntOneOptionalDict>& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opIntOneOptionalDictReq(IceUtil::Optional< ::Test::IntOneOptionalDict>& iceP_p3, IceUtil::Optional< ::Test::IntOneOptionalDict>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntOneOptionalDictReq(const IceUtil::Optional< ::Test::IntOneOptionalDict>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void opClassAndUnknownOptional(const ::Test::APtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opClassAndUnknownOptional(_iceI_begin_opClassAndUnknownOptional(p, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opClassAndUnknownOptional(const ::Test::APtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opClassAndUnknownOptional(p, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opClassAndUnknownOptional(const ::Test::APtr& p, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opClassAndUnknownOptional(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassAndUnknownOptional(const ::Test::APtr& p, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opClassAndUnknownOptional(p, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassAndUnknownOptional(const ::Test::APtr& p, const ::Test::Callback_Initial_opClassAndUnknownOptionalPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opClassAndUnknownOptional(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassAndUnknownOptional(const ::Test::APtr& p, const ::Ice::Context& context, const ::Test::Callback_Initial_opClassAndUnknownOptionalPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opClassAndUnknownOptional(p, context, cb, cookie);
    }

    void end_opClassAndUnknownOptional(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opClassAndUnknownOptional(const ::Test::APtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_sendOptionalClass(_iceI_begin_sendOptionalClass(req, o, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_sendOptionalClass(req, o, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sendOptionalClass(req, o, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sendOptionalClass(req, o, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Test::Callback_Initial_sendOptionalClassPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sendOptionalClass(req, o, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_sendOptionalClass(bool req, const IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context, const ::Test::Callback_Initial_sendOptionalClassPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sendOptionalClass(req, o, context, cb, cookie);
    }

    void end_sendOptionalClass(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_sendOptionalClass(bool, const IceUtil::Optional< ::Test::OneOptionalPtr>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void returnOptionalClass(bool req, IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_returnOptionalClass(o, _iceI_begin_returnOptionalClass(req, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_returnOptionalClass(bool req, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_returnOptionalClass(req, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_returnOptionalClass(bool req, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnOptionalClass(req, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_returnOptionalClass(bool req, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnOptionalClass(req, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_returnOptionalClass(bool req, const ::Test::Callback_Initial_returnOptionalClassPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnOptionalClass(req, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_returnOptionalClass(bool req, const ::Ice::Context& context, const ::Test::Callback_Initial_returnOptionalClassPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnOptionalClass(req, context, cb, cookie);
    }

    void end_returnOptionalClass(IceUtil::Optional< ::Test::OneOptionalPtr>& o, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_returnOptionalClass(IceUtil::Optional< ::Test::OneOptionalPtr>& iceP_o, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_returnOptionalClass(bool, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::GPtr opG(const ::Test::GPtr& g, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opG(_iceI_begin_opG(g, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opG(const ::Test::GPtr& g, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opG(g, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opG(const ::Test::GPtr& g, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opG(g, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opG(const ::Test::GPtr& g, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opG(g, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opG(const ::Test::GPtr& g, const ::Test::Callback_Initial_opGPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opG(g, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opG(const ::Test::GPtr& g, const ::Ice::Context& context, const ::Test::Callback_Initial_opGPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opG(g, context, cb, cookie);
    }

    ::Test::GPtr end_opG(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opG(const ::Test::GPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void opVoid(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opVoid(_iceI_begin_opVoid(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVoid(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVoid(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVoid(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Test::Callback_Initial_opVoidPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVoid(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Ice::Context& context, const ::Test::Callback_Initial_opVoidPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVoid(context, cb, cookie);
    }

    void end_opVoid(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVoid(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::SmallStruct> opMStruct1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMStruct1(_iceI_begin_opMStruct1(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMStruct1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMStruct1(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMStruct1(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMStruct1(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct1(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMStruct1(const ::Test::Callback_Initial_opMStruct1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMStruct1(const ::Ice::Context& context, const ::Test::Callback_Initial_opMStruct1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct1(context, cb, cookie);
    }

    IceUtil::Optional< ::Test::SmallStruct> end_opMStruct1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMStruct1(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::SmallStruct> opMStruct2(const IceUtil::Optional< ::Test::SmallStruct>& p1, IceUtil::Optional< ::Test::SmallStruct>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMStruct2(p2, _iceI_begin_opMStruct2(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMStruct2(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMStruct2(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMStruct2(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct2(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMStruct2(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct2(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMStruct2(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Test::Callback_Initial_opMStruct2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct2(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMStruct2(const IceUtil::Optional< ::Test::SmallStruct>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opMStruct2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct2(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::SmallStruct> end_opMStruct2(IceUtil::Optional< ::Test::SmallStruct>& p2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMStruct2(IceUtil::Optional< ::Test::SmallStruct>& iceP_p2, IceUtil::Optional< ::Test::SmallStruct>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMStruct2(const IceUtil::Optional< ::Test::SmallStruct>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::StringSeq> opMSeq1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMSeq1(_iceI_begin_opMSeq1(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMSeq1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMSeq1(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMSeq1(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMSeq1(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq1(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMSeq1(const ::Test::Callback_Initial_opMSeq1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMSeq1(const ::Ice::Context& context, const ::Test::Callback_Initial_opMSeq1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq1(context, cb, cookie);
    }

    IceUtil::Optional< ::Test::StringSeq> end_opMSeq1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMSeq1(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::StringSeq> opMSeq2(const IceUtil::Optional< ::Test::StringSeq>& p1, IceUtil::Optional< ::Test::StringSeq>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMSeq2(p2, _iceI_begin_opMSeq2(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMSeq2(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMSeq2(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMSeq2(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq2(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMSeq2(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq2(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMSeq2(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Test::Callback_Initial_opMSeq2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq2(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMSeq2(const IceUtil::Optional< ::Test::StringSeq>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opMSeq2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq2(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::StringSeq> end_opMSeq2(IceUtil::Optional< ::Test::StringSeq>& p2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMSeq2(IceUtil::Optional< ::Test::StringSeq>& iceP_p2, IceUtil::Optional< ::Test::StringSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMSeq2(const IceUtil::Optional< ::Test::StringSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::StringIntDict> opMDict1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMDict1(_iceI_begin_opMDict1(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMDict1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMDict1(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMDict1(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMDict1(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict1(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMDict1(const ::Test::Callback_Initial_opMDict1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMDict1(const ::Ice::Context& context, const ::Test::Callback_Initial_opMDict1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict1(context, cb, cookie);
    }

    IceUtil::Optional< ::Test::StringIntDict> end_opMDict1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMDict1(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::StringIntDict> opMDict2(const IceUtil::Optional< ::Test::StringIntDict>& p1, IceUtil::Optional< ::Test::StringIntDict>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMDict2(p2, _iceI_begin_opMDict2(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMDict2(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMDict2(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMDict2(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict2(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMDict2(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict2(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMDict2(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Test::Callback_Initial_opMDict2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict2(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMDict2(const IceUtil::Optional< ::Test::StringIntDict>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opMDict2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict2(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::StringIntDict> end_opMDict2(IceUtil::Optional< ::Test::StringIntDict>& p2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMDict2(IceUtil::Optional< ::Test::StringIntDict>& iceP_p2, IceUtil::Optional< ::Test::StringIntDict>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMDict2(const IceUtil::Optional< ::Test::StringIntDict>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::GPtr> opMG1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMG1(_iceI_begin_opMG1(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMG1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMG1(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMG1(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMG1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMG1(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMG1(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMG1(const ::Test::Callback_Initial_opMG1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMG1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMG1(const ::Ice::Context& context, const ::Test::Callback_Initial_opMG1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMG1(context, cb, cookie);
    }

    IceUtil::Optional< ::Test::GPtr> end_opMG1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMG1(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    IceUtil::Optional< ::Test::GPtr> opMG2(const IceUtil::Optional< ::Test::GPtr>& p1, IceUtil::Optional< ::Test::GPtr>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMG2(p2, _iceI_begin_opMG2(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMG2(const IceUtil::Optional< ::Test::GPtr>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMG2(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMG2(const IceUtil::Optional< ::Test::GPtr>& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMG2(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMG2(const IceUtil::Optional< ::Test::GPtr>& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMG2(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMG2(const IceUtil::Optional< ::Test::GPtr>& p1, const ::Test::Callback_Initial_opMG2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMG2(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMG2(const IceUtil::Optional< ::Test::GPtr>& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opMG2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMG2(p1, context, cb, cookie);
    }

    IceUtil::Optional< ::Test::GPtr> end_opMG2(IceUtil::Optional< ::Test::GPtr>& p2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMG2(IceUtil::Optional< ::Test::GPtr>& iceP_p2, IceUtil::Optional< ::Test::GPtr>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMG2(const IceUtil::Optional< ::Test::GPtr>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool supportsRequiredParams(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_supportsRequiredParams(_iceI_begin_supportsRequiredParams(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_supportsRequiredParams(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_supportsRequiredParams(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsRequiredParams(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsRequiredParams(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsRequiredParams(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsRequiredParams(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsRequiredParams(const ::Test::Callback_Initial_supportsRequiredParamsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsRequiredParams(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsRequiredParams(const ::Ice::Context& context, const ::Test::Callback_Initial_supportsRequiredParamsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsRequiredParams(context, cb, cookie);
    }

    bool end_supportsRequiredParams(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_supportsRequiredParams(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool supportsJavaSerializable(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_supportsJavaSerializable(_iceI_begin_supportsJavaSerializable(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_supportsJavaSerializable(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_supportsJavaSerializable(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsJavaSerializable(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsJavaSerializable(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsJavaSerializable(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsJavaSerializable(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsJavaSerializable(const ::Test::Callback_Initial_supportsJavaSerializablePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsJavaSerializable(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsJavaSerializable(const ::Ice::Context& context, const ::Test::Callback_Initial_supportsJavaSerializablePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsJavaSerializable(context, cb, cookie);
    }

    bool end_supportsJavaSerializable(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_supportsJavaSerializable(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool supportsCsharpSerializable(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_supportsCsharpSerializable(_iceI_begin_supportsCsharpSerializable(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_supportsCsharpSerializable(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_supportsCsharpSerializable(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsCsharpSerializable(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsCsharpSerializable(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCsharpSerializable(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsCsharpSerializable(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCsharpSerializable(const ::Test::Callback_Initial_supportsCsharpSerializablePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsCsharpSerializable(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCsharpSerializable(const ::Ice::Context& context, const ::Test::Callback_Initial_supportsCsharpSerializablePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsCsharpSerializable(context, cb, cookie);
    }

    bool end_supportsCsharpSerializable(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_supportsCsharpSerializable(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool supportsCppStringView(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_supportsCppStringView(_iceI_begin_supportsCppStringView(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_supportsCppStringView(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_supportsCppStringView(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsCppStringView(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsCppStringView(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCppStringView(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsCppStringView(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCppStringView(const ::Test::Callback_Initial_supportsCppStringViewPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsCppStringView(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCppStringView(const ::Ice::Context& context, const ::Test::Callback_Initial_supportsCppStringViewPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsCppStringView(context, cb, cookie);
    }

    bool end_supportsCppStringView(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_supportsCppStringView(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool supportsNullOptional(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_supportsNullOptional(_iceI_begin_supportsNullOptional(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_supportsNullOptional(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_supportsNullOptional(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsNullOptional(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsNullOptional(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsNullOptional(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsNullOptional(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsNullOptional(const ::Test::Callback_Initial_supportsNullOptionalPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsNullOptional(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsNullOptional(const ::Ice::Context& context, const ::Test::Callback_Initial_supportsNullOptionalPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsNullOptional(context, cb, cookie);
    }

    bool end_supportsNullOptional(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_supportsNullOptional(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class OneOptional : public virtual ::Ice::Object
{
public:

    typedef OneOptionalPrx ProxyType;
    typedef OneOptionalPtr PointerType;

    virtual ~OneOptional();

    OneOptional()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit OneOptional(const IceUtil::Optional< ::Ice::Int>& a) :
        a(a)
    {
    }

#ifdef ICE_CPP11_COMPILER
    OneOptional(const OneOptional&) = default;
    OneOptional& operator=(const OneOptional&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    IceUtil::Optional< ::Ice::Int> a;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_OneOptional_init = ::Test::OneOptional::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const OneOptional& lhs, const OneOptional& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const OneOptional& lhs, const OneOptional& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class MultiOptional : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef MultiOptionalPrx ProxyType;
    typedef MultiOptionalPtr PointerType;

    virtual ~MultiOptional();

    MultiOptional()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    MultiOptional(const IceUtil::Optional< ::Ice::Byte>& a, const IceUtil::Optional<bool>& b, const IceUtil::Optional< ::Ice::Short>& c, const IceUtil::Optional< ::Ice::Int>& d, const IceUtil::Optional< ::Ice::Long>& e, const IceUtil::Optional< ::Ice::Float>& f, const IceUtil::Optional< ::Ice::Double>& g, const IceUtil::Optional< ::std::string>& h, const IceUtil::Optional< ::Test::MyEnum>& i, const IceUtil::Optional< ::Test::MultiOptionalPrx>& j, const IceUtil::Optional< ::Test::MultiOptionalPtr>& k, const IceUtil::Optional< ::Test::ByteSeq>& bs, const IceUtil::Optional< ::Test::StringSeq>& ss, const IceUtil::Optional< ::Test::IntIntDict>& iid, const IceUtil::Optional< ::Test::StringIntDict>& sid, const IceUtil::Optional< ::Test::FixedStruct>& fs, const IceUtil::Optional< ::Test::VarStruct>& vs, const IceUtil::Optional< ::Test::ShortSeq>& shs, const IceUtil::Optional< ::Test::MyEnumSeq>& es, const IceUtil::Optional< ::Test::FixedStructSeq>& fss, const IceUtil::Optional< ::Test::VarStructSeq>& vss, const IceUtil::Optional< ::Test::OneOptionalSeq>& oos, const IceUtil::Optional< ::Test::OneOptionalPrxSeq>& oops, const IceUtil::Optional< ::Test::IntEnumDict>& ied, const IceUtil::Optional< ::Test::IntFixedStructDict>& ifsd, const IceUtil::Optional< ::Test::IntVarStructDict>& ivsd, const IceUtil::Optional< ::Test::IntOneOptionalDict>& iood, const IceUtil::Optional< ::Test::IntOneOptionalPrxDict>& ioopd, const IceUtil::Optional< ::Test::BoolSeq>& bos, const IceUtil::Optional< ::Test::Serializable>& ser) :
        a(a),
        b(b),
        c(c),
        d(d),
        e(e),
        f(f),
        g(g),
        h(h),
        i(i),
        j(j),
        k(k),
        bs(bs),
        ss(ss),
        iid(iid),
        sid(sid),
        fs(fs),
        vs(vs),
        shs(shs),
        es(es),
        fss(fss),
        vss(vss),
        oos(oos),
        oops(oops),
        ied(ied),
        ifsd(ifsd),
        ivsd(ivsd),
        iood(iood),
        ioopd(ioopd),
        bos(bos),
        ser(ser)
    {
    }

#ifdef ICE_CPP11_COMPILER
    MultiOptional(const MultiOptional&) = default;
    MultiOptional& operator=(const MultiOptional&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    IceUtil::Optional< ::Ice::Byte> a;
    IceUtil::Optional<bool> b;
    IceUtil::Optional< ::Ice::Short> c;
    IceUtil::Optional< ::Ice::Int> d;
    IceUtil::Optional< ::Ice::Long> e;
    IceUtil::Optional< ::Ice::Float> f;
    IceUtil::Optional< ::Ice::Double> g;
    IceUtil::Optional< ::std::string> h;
    IceUtil::Optional< ::Test::MyEnum> i;
    IceUtil::Optional< ::Test::MultiOptionalPrx> j;
    IceUtil::Optional< ::Test::MultiOptionalPtr> k;
    IceUtil::Optional< ::Test::ByteSeq> bs;
    IceUtil::Optional< ::Test::StringSeq> ss;
    IceUtil::Optional< ::Test::IntIntDict> iid;
    IceUtil::Optional< ::Test::StringIntDict> sid;
    IceUtil::Optional< ::Test::FixedStruct> fs;
    IceUtil::Optional< ::Test::VarStruct> vs;
    IceUtil::Optional< ::Test::ShortSeq> shs;
    IceUtil::Optional< ::Test::MyEnumSeq> es;
    IceUtil::Optional< ::Test::FixedStructSeq> fss;
    IceUtil::Optional< ::Test::VarStructSeq> vss;
    IceUtil::Optional< ::Test::OneOptionalSeq> oos;
    IceUtil::Optional< ::Test::OneOptionalPrxSeq> oops;
    IceUtil::Optional< ::Test::IntEnumDict> ied;
    IceUtil::Optional< ::Test::IntFixedStructDict> ifsd;
    IceUtil::Optional< ::Test::IntVarStructDict> ivsd;
    IceUtil::Optional< ::Test::IntOneOptionalDict> iood;
    IceUtil::Optional< ::Test::IntOneOptionalPrxDict> ioopd;
    IceUtil::Optional< ::Test::BoolSeq> bos;
    IceUtil::Optional< ::Test::Serializable> ser;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_MultiOptional_init = ::Test::MultiOptional::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const MultiOptional& lhs, const MultiOptional& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const MultiOptional& lhs, const MultiOptional& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class A : public virtual ::Ice::Object
{
public:

    typedef APrx ProxyType;
    typedef APtr PointerType;

    virtual ~A();

    A()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    A(::Ice::Int requiredA, const IceUtil::Optional< ::Ice::Int>& ma, const IceUtil::Optional< ::Ice::Int>& mb, const IceUtil::Optional< ::Ice::Int>& mc) :
        requiredA(requiredA),
        ma(ma),
        mb(mb),
        mc(mc)
    {
    }

#ifdef ICE_CPP11_COMPILER
    A(const A&) = default;
    A& operator=(const A&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int requiredA;
    IceUtil::Optional< ::Ice::Int> ma;
    IceUtil::Optional< ::Ice::Int> mb;
    IceUtil::Optional< ::Ice::Int> mc;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_A_init = ::Test::A::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const A& lhs, const A& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const A& lhs, const A& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class B : public A, public ::IceInternal::GCObject
{
public:

    typedef BPrx ProxyType;
    typedef BPtr PointerType;

    virtual ~B();

    B()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    B(::Ice::Int requiredA, const IceUtil::Optional< ::Ice::Int>& ma, const IceUtil::Optional< ::Ice::Int>& mb, const IceUtil::Optional< ::Ice::Int>& mc, ::Ice::Int requiredB, const IceUtil::Optional< ::Ice::Int>& md) :
        ::Test::A(requiredA, ma, mb, mc),
        requiredB(requiredB),
        md(md)
    {
    }

#ifdef ICE_CPP11_COMPILER
    B(const B&) = default;
    B& operator=(const B&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

    /**
     * Obtains the SlicedData object created when an unknown class type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the class was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::Ice::SlicedDataPtr ice_getSlicedData() const;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const;
    virtual void _iceRead(::Ice::InputStream*);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int requiredB;
    IceUtil::Optional< ::Ice::Int> md;

protected:

    /// \cond STREAM
    ::Ice::SlicedDataPtr _iceSlicedData;
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_B_init = ::Test::B::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const B& lhs, const B& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const B& lhs, const B& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class C : public B
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    virtual ~C();

    C()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    C(::Ice::Int requiredA, const IceUtil::Optional< ::Ice::Int>& ma, const IceUtil::Optional< ::Ice::Int>& mb, const IceUtil::Optional< ::Ice::Int>& mc, ::Ice::Int requiredB, const IceUtil::Optional< ::Ice::Int>& md, const ::std::string& ss, const IceUtil::Optional< ::std::string>& ms) :
        ::Test::B(requiredA, ma, mb, mc, requiredB, md),
        ss(ss),
        ms(ms)
    {
    }

#ifdef ICE_CPP11_COMPILER
    C(const C&) = default;
    C& operator=(const C&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string ss;
    IceUtil::Optional< ::std::string> ms;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_C_init = ::Test::C::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const C& lhs, const C& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const C& lhs, const C& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class WD : public virtual ::Ice::Object
{
public:

    typedef WDPrx ProxyType;
    typedef WDPtr PointerType;

    virtual ~WD();

    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    WD() :
        a(5),
        s("test")
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    WD(const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& s) :
        a(a),
        s(s)
    {
    }

#ifdef ICE_CPP11_COMPILER
    WD(const WD&) = default;
    WD& operator=(const WD&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    IceUtil::Optional< ::Ice::Int> a;
    IceUtil::Optional< ::std::string> s;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_WD_init = ::Test::WD::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const WD& lhs, const WD& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const WD& lhs, const WD& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class OptionalWithCustom : public virtual ::Ice::Object
{
public:

    typedef OptionalWithCustomPrx ProxyType;
    typedef OptionalWithCustomPtr PointerType;

    virtual ~OptionalWithCustom();

    OptionalWithCustom()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalWithCustom(const IceUtil::Optional< ::Test::SmallStructList>& l, const IceUtil::Optional< ::Test::SmallStructList>& lp, const IceUtil::Optional< ::Test::ClassVarStruct>& s) :
        l(l),
        lp(lp),
        s(s)
    {
    }

#ifdef ICE_CPP11_COMPILER
    OptionalWithCustom(const OptionalWithCustom&) = default;
    OptionalWithCustom& operator=(const OptionalWithCustom&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    IceUtil::Optional< ::Test::SmallStructList> l;

protected:

    IceUtil::Optional< ::Test::SmallStructList> lp;

public:

    IceUtil::Optional< ::Test::ClassVarStruct> s;

protected:

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_OptionalWithCustom_init = ::Test::OptionalWithCustom::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const OptionalWithCustom& lhs, const OptionalWithCustom& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const OptionalWithCustom& lhs, const OptionalWithCustom& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class E : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef EPrx ProxyType;
    typedef EPtr PointerType;

    virtual ~E();

    E()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit E(const ::Test::APtr& ae) :
        ae(ae)
    {
    }

#ifdef ICE_CPP11_COMPILER
    E(const E&) = default;
    E& operator=(const E&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::APtr ae;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_E_init = ::Test::E::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const E& lhs, const E& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const E& lhs, const E& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class F : public E
{
public:

    typedef FPrx ProxyType;
    typedef FPtr PointerType;

    virtual ~F();

    F()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    F(const ::Test::APtr& ae, const IceUtil::Optional< ::Test::APtr>& af) :
        ::Test::E(ae),
        af(af)
    {
    }

#ifdef ICE_CPP11_COMPILER
    F(const F&) = default;
    F& operator=(const F&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    IceUtil::Optional< ::Test::APtr> af;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_F_init = ::Test::F::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const F& lhs, const F& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const F& lhs, const F& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class G1 : public virtual ::Ice::Object
{
public:

    typedef G1Prx ProxyType;
    typedef G1Ptr PointerType;

    virtual ~G1();

    G1()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit G1(const ::std::string& a) :
        a(a)
    {
    }

#ifdef ICE_CPP11_COMPILER
    G1(const G1&) = default;
    G1& operator=(const G1&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string a;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_G1_init = ::Test::G1::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const G1& lhs, const G1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const G1& lhs, const G1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class G2 : public virtual ::Ice::Object
{
public:

    typedef G2Prx ProxyType;
    typedef G2Ptr PointerType;

    virtual ~G2();

    G2()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit G2(::Ice::Long a) :
        a(a)
    {
    }

#ifdef ICE_CPP11_COMPILER
    G2(const G2&) = default;
    G2& operator=(const G2&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Long a;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_G2_init = ::Test::G2::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const G2& lhs, const G2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const G2& lhs, const G2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class G : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef GPrx ProxyType;
    typedef GPtr PointerType;

    virtual ~G();

    G()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    G(const IceUtil::Optional< ::Test::G1Ptr>& gg1Opt, const ::Test::G2Ptr& gg2, const IceUtil::Optional< ::Test::G2Ptr>& gg2Opt, const ::Test::G1Ptr& gg1) :
        gg1Opt(gg1Opt),
        gg2(gg2),
        gg2Opt(gg2Opt),
        gg1(gg1)
    {
    }

#ifdef ICE_CPP11_COMPILER
    G(const G&) = default;
    G& operator=(const G&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    IceUtil::Optional< ::Test::G1Ptr> gg1Opt;
    ::Test::G2Ptr gg2;
    IceUtil::Optional< ::Test::G2Ptr> gg2Opt;
    ::Test::G1Ptr gg1;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_G_init = ::Test::G::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const G& lhs, const G& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const G& lhs, const G& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Recursive : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef RecursivePrx ProxyType;
    typedef RecursivePtr PointerType;

    virtual ~Recursive();

    Recursive()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Recursive(const IceUtil::Optional< ::Test::RecursiveSeq>& value) :
        value(value)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Recursive(const Recursive&) = default;
    Recursive& operator=(const Recursive&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    IceUtil::Optional< ::Test::RecursiveSeq> value;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Recursive_init = ::Test::Recursive::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Recursive& lhs, const Recursive& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Recursive& lhs, const Recursive& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Initial : public virtual ::Ice::Object
{
public:

    typedef InitialPrx ProxyType;
    typedef InitialPtr PointerType;

    virtual ~Initial();

#ifdef ICE_CPP11_COMPILER
    Initial() = default;
    Initial(const Initial&) = default;
    Initial& operator=(const Initial&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void shutdown_async(const ::Test::AMD_Initial_shutdownPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void pingPong_async(const ::Test::AMD_Initial_pingPongPtr& cb, const ::Ice::ObjectPtr& o, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_pingPong(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOptionalException_async(const ::Test::AMD_Initial_opOptionalExceptionPtr& cb, const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional<OneOptionalPtr>& o, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptionalException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opDerivedException_async(const ::Test::AMD_Initial_opDerivedExceptionPtr& cb, const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional<OneOptionalPtr>& o, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDerivedException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opRequiredException_async(const ::Test::AMD_Initial_opRequiredExceptionPtr& cb, const IceUtil::Optional< ::Ice::Int>& a, const IceUtil::Optional< ::std::string>& b, const IceUtil::Optional<OneOptionalPtr>& o, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opRequiredException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByte_async(const ::Test::AMD_Initial_opBytePtr& cb, const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByte(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteReq_async(const ::Test::AMD_Initial_opByteReqPtr& cb, const IceUtil::Optional< ::Ice::Byte>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBool_async(const ::Test::AMD_Initial_opBoolPtr& cb, const IceUtil::Optional<bool>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBool(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBoolReq_async(const ::Test::AMD_Initial_opBoolReqPtr& cb, const IceUtil::Optional<bool>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opShort_async(const ::Test::AMD_Initial_opShortPtr& cb, const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShort(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opShortReq_async(const ::Test::AMD_Initial_opShortReqPtr& cb, const IceUtil::Optional< ::Ice::Short>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opInt_async(const ::Test::AMD_Initial_opIntPtr& cb, const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opInt(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opIntReq_async(const ::Test::AMD_Initial_opIntReqPtr& cb, const IceUtil::Optional< ::Ice::Int>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLong_async(const ::Test::AMD_Initial_opLongPtr& cb, const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLong(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLongReq_async(const ::Test::AMD_Initial_opLongReqPtr& cb, const IceUtil::Optional< ::Ice::Long>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opFloat_async(const ::Test::AMD_Initial_opFloatPtr& cb, const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloat(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opFloatReq_async(const ::Test::AMD_Initial_opFloatReqPtr& cb, const IceUtil::Optional< ::Ice::Float>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opDouble_async(const ::Test::AMD_Initial_opDoublePtr& cb, const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDouble(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opDoubleReq_async(const ::Test::AMD_Initial_opDoubleReqPtr& cb, const IceUtil::Optional< ::Ice::Double>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opString_async(const ::Test::AMD_Initial_opStringPtr& cb, const IceUtil::Optional< ::std::string>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opString(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opStringReq_async(const ::Test::AMD_Initial_opStringReqPtr& cb, const IceUtil::Optional< ::std::string>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMyEnum_async(const ::Test::AMD_Initial_opMyEnumPtr& cb, const IceUtil::Optional<MyEnum>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnum(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMyEnumReq_async(const ::Test::AMD_Initial_opMyEnumReqPtr& cb, const IceUtil::Optional<MyEnum>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnumReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSmallStruct_async(const ::Test::AMD_Initial_opSmallStructPtr& cb, const IceUtil::Optional<SmallStruct>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSmallStructReq_async(const ::Test::AMD_Initial_opSmallStructReqPtr& cb, const IceUtil::Optional<SmallStruct>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStructReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opFixedStruct_async(const ::Test::AMD_Initial_opFixedStructPtr& cb, const IceUtil::Optional<FixedStruct>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opFixedStructReq_async(const ::Test::AMD_Initial_opFixedStructReqPtr& cb, const IceUtil::Optional<FixedStruct>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStructReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVarStruct_async(const ::Test::AMD_Initial_opVarStructPtr& cb, const IceUtil::Optional<VarStruct>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVarStructReq_async(const ::Test::AMD_Initial_opVarStructReqPtr& cb, const IceUtil::Optional<VarStruct>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarStructReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOneOptional_async(const ::Test::AMD_Initial_opOneOptionalPtr& cb, const IceUtil::Optional<OneOptionalPtr>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOneOptional(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOneOptionalReq_async(const ::Test::AMD_Initial_opOneOptionalReqPtr& cb, const IceUtil::Optional<OneOptionalPtr>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOneOptionalReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOneOptionalProxy_async(const ::Test::AMD_Initial_opOneOptionalProxyPtr& cb, const IceUtil::Optional<OneOptionalPrx>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOneOptionalProxy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOneOptionalProxyReq_async(const ::Test::AMD_Initial_opOneOptionalProxyReqPtr& cb, const IceUtil::Optional<OneOptionalPrx>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOneOptionalProxyReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteSeq_async(const ::Test::AMD_Initial_opByteSeqPtr& cb, const IceUtil::Optional<ByteSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteSeqReq_async(const ::Test::AMD_Initial_opByteSeqReqPtr& cb, const IceUtil::Optional<ByteSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBoolSeq_async(const ::Test::AMD_Initial_opBoolSeqPtr& cb, const IceUtil::Optional<BoolSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBoolSeqReq_async(const ::Test::AMD_Initial_opBoolSeqReqPtr& cb, const IceUtil::Optional<BoolSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opShortSeq_async(const ::Test::AMD_Initial_opShortSeqPtr& cb, const IceUtil::Optional<ShortSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opShortSeqReq_async(const ::Test::AMD_Initial_opShortSeqReqPtr& cb, const IceUtil::Optional<ShortSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opIntSeq_async(const ::Test::AMD_Initial_opIntSeqPtr& cb, const IceUtil::Optional<IntSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opIntSeqReq_async(const ::Test::AMD_Initial_opIntSeqReqPtr& cb, const IceUtil::Optional<IntSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLongSeq_async(const ::Test::AMD_Initial_opLongSeqPtr& cb, const IceUtil::Optional<LongSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opLongSeqReq_async(const ::Test::AMD_Initial_opLongSeqReqPtr& cb, const IceUtil::Optional<LongSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opFloatSeq_async(const ::Test::AMD_Initial_opFloatSeqPtr& cb, const IceUtil::Optional<FloatSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opFloatSeqReq_async(const ::Test::AMD_Initial_opFloatSeqReqPtr& cb, const IceUtil::Optional<FloatSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opDoubleSeq_async(const ::Test::AMD_Initial_opDoubleSeqPtr& cb, const IceUtil::Optional<DoubleSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opDoubleSeqReq_async(const ::Test::AMD_Initial_opDoubleSeqReqPtr& cb, const IceUtil::Optional<DoubleSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opStringSeq_async(const ::Test::AMD_Initial_opStringSeqPtr& cb, const IceUtil::Optional<StringSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opStringSeqReq_async(const ::Test::AMD_Initial_opStringSeqReqPtr& cb, const IceUtil::Optional<StringSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSmallStructSeq_async(const ::Test::AMD_Initial_opSmallStructSeqPtr& cb, const IceUtil::Optional<SmallStructSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStructSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSmallStructSeqReq_async(const ::Test::AMD_Initial_opSmallStructSeqReqPtr& cb, const IceUtil::Optional<SmallStructSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStructSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSmallStructList_async(const ::Test::AMD_Initial_opSmallStructListPtr& cb, const IceUtil::Optional<SmallStructList>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStructList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSmallStructListReq_async(const ::Test::AMD_Initial_opSmallStructListReqPtr& cb, const IceUtil::Optional<SmallStructList>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStructListReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opFixedStructSeq_async(const ::Test::AMD_Initial_opFixedStructSeqPtr& cb, const IceUtil::Optional<FixedStructSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStructSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opFixedStructSeqReq_async(const ::Test::AMD_Initial_opFixedStructSeqReqPtr& cb, const IceUtil::Optional<FixedStructSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStructSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opFixedStructList_async(const ::Test::AMD_Initial_opFixedStructListPtr& cb, const IceUtil::Optional<FixedStructList>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStructList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opFixedStructListReq_async(const ::Test::AMD_Initial_opFixedStructListReqPtr& cb, const IceUtil::Optional<FixedStructList>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStructListReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVarStructSeq_async(const ::Test::AMD_Initial_opVarStructSeqPtr& cb, const IceUtil::Optional<VarStructSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarStructSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVarStructSeqReq_async(const ::Test::AMD_Initial_opVarStructSeqReqPtr& cb, const IceUtil::Optional<VarStructSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarStructSeqReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSerializable_async(const ::Test::AMD_Initial_opSerializablePtr& cb, const IceUtil::Optional<Serializable>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSerializable(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opSerializableReq_async(const ::Test::AMD_Initial_opSerializableReqPtr& cb, const IceUtil::Optional<Serializable>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSerializableReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opIntIntDict_async(const ::Test::AMD_Initial_opIntIntDictPtr& cb, const IceUtil::Optional<IntIntDict>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntIntDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opIntIntDictReq_async(const ::Test::AMD_Initial_opIntIntDictReqPtr& cb, const IceUtil::Optional<IntIntDict>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntIntDictReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opStringIntDict_async(const ::Test::AMD_Initial_opStringIntDictPtr& cb, const IceUtil::Optional<StringIntDict>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringIntDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opStringIntDictReq_async(const ::Test::AMD_Initial_opStringIntDictReqPtr& cb, const IceUtil::Optional<StringIntDict>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringIntDictReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opIntOneOptionalDict_async(const ::Test::AMD_Initial_opIntOneOptionalDictPtr& cb, const IceUtil::Optional<IntOneOptionalDict>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntOneOptionalDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opIntOneOptionalDictReq_async(const ::Test::AMD_Initial_opIntOneOptionalDictReqPtr& cb, const IceUtil::Optional<IntOneOptionalDict>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntOneOptionalDictReq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opClassAndUnknownOptional_async(const ::Test::AMD_Initial_opClassAndUnknownOptionalPtr& cb, const APtr& p, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opClassAndUnknownOptional(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void sendOptionalClass_async(const ::Test::AMD_Initial_sendOptionalClassPtr& cb, bool req, const IceUtil::Optional<OneOptionalPtr>& o, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_sendOptionalClass(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void returnOptionalClass_async(const ::Test::AMD_Initial_returnOptionalClassPtr& cb, bool req, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_returnOptionalClass(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opG_async(const ::Test::AMD_Initial_opGPtr& cb, const GPtr& g, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opG(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVoid_async(const ::Test::AMD_Initial_opVoidPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVoid(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMStruct1_async(const ::Test::AMD_Initial_opMStruct1Ptr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMStruct1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMStruct2_async(const ::Test::AMD_Initial_opMStruct2Ptr& cb, const IceUtil::Optional<SmallStruct>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMStruct2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMSeq1_async(const ::Test::AMD_Initial_opMSeq1Ptr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMSeq1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMSeq2_async(const ::Test::AMD_Initial_opMSeq2Ptr& cb, const IceUtil::Optional<StringSeq>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMSeq2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMDict1_async(const ::Test::AMD_Initial_opMDict1Ptr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMDict1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMDict2_async(const ::Test::AMD_Initial_opMDict2Ptr& cb, const IceUtil::Optional<StringIntDict>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMDict2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMG1_async(const ::Test::AMD_Initial_opMG1Ptr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMG1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMG2_async(const ::Test::AMD_Initial_opMG2Ptr& cb, const IceUtil::Optional<GPtr>& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMG2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void supportsRequiredParams_async(const ::Test::AMD_Initial_supportsRequiredParamsPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsRequiredParams(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void supportsJavaSerializable_async(const ::Test::AMD_Initial_supportsJavaSerializablePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsJavaSerializable(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void supportsCsharpSerializable_async(const ::Test::AMD_Initial_supportsCsharpSerializablePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsCsharpSerializable(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void supportsCppStringView_async(const ::Test::AMD_Initial_supportsCppStringViewPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsCppStringView(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void supportsNullOptional_async(const ::Test::AMD_Initial_supportsNullOptionalPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsNullOptional(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Initial& lhs, const Initial& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Initial& lhs, const Initial& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter< ::Test::OneOptional, S>
{
    static void write(S* ostr, const ::Test::OneOptional& v)
    {
        ostr->write(1, v.a);
    }
};

template<typename S>
struct StreamReader< ::Test::OneOptional, S>
{
    static void read(S* istr, ::Test::OneOptional& v)
    {
        istr->read(1, v.a);
    }
};

template<>
struct StreamableTraits< ::Test::MyEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 0;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::SmallStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Test::SmallStruct, S>
{
    static void write(S* ostr, const ::Test::SmallStruct& v)
    {
        ostr->write(v.m);
    }
};

template<typename S>
struct StreamReader< ::Test::SmallStruct, S>
{
    static void read(S* istr, ::Test::SmallStruct& v)
    {
        istr->read(v.m);
    }
};

template<>
struct StreamableTraits< ::Test::FixedStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Test::FixedStruct, S>
{
    static void write(S* ostr, const ::Test::FixedStruct& v)
    {
        ostr->write(v.m);
    }
};

template<typename S>
struct StreamReader< ::Test::FixedStruct, S>
{
    static void read(S* istr, ::Test::FixedStruct& v)
    {
        istr->read(v.m);
    }
};

template<>
struct StreamableTraits< ::Test::VarStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::VarStruct, S>
{
    static void write(S* ostr, const ::Test::VarStruct& v)
    {
        ostr->write(v.m);
    }
};

template<typename S>
struct StreamReader< ::Test::VarStruct, S>
{
    static void read(S* istr, ::Test::VarStruct& v)
    {
        istr->read(v.m);
    }
};

template<>
struct StreamableTraits< ::Test::ClassVarStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Test::ClassVarStruct, S>
{
    static void write(S* ostr, const ::Test::ClassVarStruct& v)
    {
        ostr->write(v.a);
    }
};

template<typename S>
struct StreamReader< ::Test::ClassVarStruct, S>
{
    static void read(S* istr, ::Test::ClassVarStruct& v)
    {
        istr->read(v.a);
    }
};

template<typename S>
struct StreamWriter< ::Test::MultiOptional, S>
{
    static void write(S* ostr, const ::Test::MultiOptional& v)
    {
        ostr->write(1, v.a);
        ostr->write(2, v.b);
        ostr->write(3, v.c);
        ostr->write(4, v.d);
        ostr->write(5, v.e);
        ostr->write(6, v.f);
        ostr->write(7, v.g);
        ostr->write(8, v.h);
        ostr->write(9, v.i);
        ostr->write(10, v.j);
        ostr->write(11, v.k);
        ostr->write(12, v.bs);
        ostr->write(13, v.ss);
        ostr->write(14, v.iid);
        ostr->write(15, v.sid);
        ostr->write(16, v.fs);
        ostr->write(17, v.vs);
        ostr->write(18, v.shs);
        ostr->write(19, v.es);
        ostr->write(20, v.fss);
        ostr->write(21, v.vss);
        ostr->write(22, v.oos);
        ostr->write(23, v.oops);
        ostr->write(24, v.ied);
        ostr->write(25, v.ifsd);
        ostr->write(26, v.ivsd);
        ostr->write(27, v.iood);
        ostr->write(28, v.ioopd);
        ostr->write(29, v.bos);
        ostr->write(30, v.ser);
    }
};

template<typename S>
struct StreamReader< ::Test::MultiOptional, S>
{
    static void read(S* istr, ::Test::MultiOptional& v)
    {
        istr->read(1, v.a);
        istr->read(2, v.b);
        istr->read(3, v.c);
        istr->read(4, v.d);
        istr->read(5, v.e);
        istr->read(6, v.f);
        istr->read(7, v.g);
        istr->read(8, v.h);
        istr->read(9, v.i);
        istr->read(10, v.j);
        istr->read(11, v.k);
        istr->read(12, v.bs);
        istr->read(13, v.ss);
        istr->read(14, v.iid);
        istr->read(15, v.sid);
        istr->read(16, v.fs);
        istr->read(17, v.vs);
        istr->read(18, v.shs);
        istr->read(19, v.es);
        istr->read(20, v.fss);
        istr->read(21, v.vss);
        istr->read(22, v.oos);
        istr->read(23, v.oops);
        istr->read(24, v.ied);
        istr->read(25, v.ifsd);
        istr->read(26, v.ivsd);
        istr->read(27, v.iood);
        istr->read(28, v.ioopd);
        istr->read(29, v.bos);
        istr->read(30, v.ser);
    }
};

template<typename S>
struct StreamWriter< ::Test::A, S>
{
    static void write(S* ostr, const ::Test::A& v)
    {
        ostr->write(v.requiredA);
        ostr->write(1, v.ma);
        ostr->write(50, v.mb);
        ostr->write(500, v.mc);
    }
};

template<typename S>
struct StreamReader< ::Test::A, S>
{
    static void read(S* istr, ::Test::A& v)
    {
        istr->read(v.requiredA);
        istr->read(1, v.ma);
        istr->read(50, v.mb);
        istr->read(500, v.mc);
    }
};

template<typename S>
struct StreamWriter< ::Test::B, S>
{
    static void write(S* ostr, const ::Test::B& v)
    {
        ostr->write(v.requiredB);
        ostr->write(10, v.md);
    }
};

template<typename S>
struct StreamReader< ::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->read(v.requiredB);
        istr->read(10, v.md);
    }
};

template<typename S>
struct StreamWriter< ::Test::C, S>
{
    static void write(S* ostr, const ::Test::C& v)
    {
        ostr->write(v.ss);
        ostr->write(890, v.ms);
    }
};

template<typename S>
struct StreamReader< ::Test::C, S>
{
    static void read(S* istr, ::Test::C& v)
    {
        istr->read(v.ss);
        istr->read(890, v.ms);
    }
};

template<typename S>
struct StreamWriter< ::Test::WD, S>
{
    static void write(S* ostr, const ::Test::WD& v)
    {
        ostr->write(1, v.a);
        ostr->write(2, v.s);
    }
};

template<typename S>
struct StreamReader< ::Test::WD, S>
{
    static void read(S* istr, ::Test::WD& v)
    {
        istr->read(1, v.a);
        istr->read(2, v.s);
    }
};

template<>
struct StreamableTraits< ::Test::OptionalException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::OptionalException, S>
{
    static void write(S* ostr, const ::Test::OptionalException& v)
    {
        ostr->write(v.req);
        ostr->write(1, v.a);
        ostr->write(2, v.b);
        ostr->write(50, v.o);
    }
};

template<typename S>
struct StreamReader< ::Test::OptionalException, S>
{
    static void read(S* istr, ::Test::OptionalException& v)
    {
        istr->read(v.req);
        istr->read(1, v.a);
        istr->read(2, v.b);
        istr->read(50, v.o);
    }
};

template<>
struct StreamableTraits< ::Test::DerivedException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::DerivedException, S>
{
    static void write(S* ostr, const ::Test::DerivedException& v)
    {
        ostr->write(v.d1);
        ostr->write(v.d2);
        ostr->write(600, v.ss);
        ostr->write(601, v.o2);
    }
};

template<typename S>
struct StreamReader< ::Test::DerivedException, S>
{
    static void read(S* istr, ::Test::DerivedException& v)
    {
        istr->read(v.d1);
        istr->read(v.d2);
        istr->read(600, v.ss);
        istr->read(601, v.o2);
    }
};

template<>
struct StreamableTraits< ::Test::RequiredException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::RequiredException, S>
{
    static void write(S* ostr, const ::Test::RequiredException& v)
    {
        ostr->write(v.ss);
        ostr->write(v.o2);
    }
};

template<typename S>
struct StreamReader< ::Test::RequiredException, S>
{
    static void read(S* istr, ::Test::RequiredException& v)
    {
        istr->read(v.ss);
        istr->read(v.o2);
    }
};

template<typename S>
struct StreamWriter< ::Test::OptionalWithCustom, S>
{
    static void write(S* ostr, const ::Test::OptionalWithCustom& v)
    {
        ostr->write(1, v.l);
        ostr->write(2, v.lp);
        ostr->write(3, v.s);
    }
};

template<typename S>
struct StreamReader< ::Test::OptionalWithCustom, S>
{
    static void read(S* istr, ::Test::OptionalWithCustom& v)
    {
        istr->read(1, v.l);
        istr->read(2, v.lp);
        istr->read(3, v.s);
    }
};

template<typename S>
struct StreamWriter< ::Test::E, S>
{
    static void write(S* ostr, const ::Test::E& v)
    {
        ostr->write(v.ae);
    }
};

template<typename S>
struct StreamReader< ::Test::E, S>
{
    static void read(S* istr, ::Test::E& v)
    {
        istr->read(v.ae);
    }
};

template<typename S>
struct StreamWriter< ::Test::F, S>
{
    static void write(S* ostr, const ::Test::F& v)
    {
        ostr->write(1, v.af);
    }
};

template<typename S>
struct StreamReader< ::Test::F, S>
{
    static void read(S* istr, ::Test::F& v)
    {
        istr->read(1, v.af);
    }
};

template<typename S>
struct StreamWriter< ::Test::G1, S>
{
    static void write(S* ostr, const ::Test::G1& v)
    {
        ostr->write(v.a);
    }
};

template<typename S>
struct StreamReader< ::Test::G1, S>
{
    static void read(S* istr, ::Test::G1& v)
    {
        istr->read(v.a);
    }
};

template<typename S>
struct StreamWriter< ::Test::G2, S>
{
    static void write(S* ostr, const ::Test::G2& v)
    {
        ostr->write(v.a);
    }
};

template<typename S>
struct StreamReader< ::Test::G2, S>
{
    static void read(S* istr, ::Test::G2& v)
    {
        istr->read(v.a);
    }
};

template<typename S>
struct StreamWriter< ::Test::G, S>
{
    static void write(S* ostr, const ::Test::G& v)
    {
        ostr->write(v.gg2);
        ostr->write(v.gg1);
        ostr->write(0, v.gg2Opt);
        ostr->write(1, v.gg1Opt);
    }
};

template<typename S>
struct StreamReader< ::Test::G, S>
{
    static void read(S* istr, ::Test::G& v)
    {
        istr->read(v.gg2);
        istr->read(v.gg1);
        istr->read(0, v.gg2Opt);
        istr->read(1, v.gg1Opt);
    }
};

template<typename S>
struct StreamWriter< ::Test::Recursive, S>
{
    static void write(S* ostr, const ::Test::Recursive& v)
    {
        ostr->write(0, v.value);
    }
};

template<typename S>
struct StreamReader< ::Test::Recursive, S>
{
    static void read(S* istr, ::Test::Recursive& v)
    {
        istr->read(0, v.value);
    }
};

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_shutdown.
 */
template<class T>
class CallbackNC_Initial_shutdown : public Callback_Initial_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_shutdown.
 */
template<class T, typename CT>
class Callback_Initial_shutdown : public Callback_Initial_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_pingPong.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_pingPong.
 */
template<class T>
class CallbackNC_Initial_pingPong : public Callback_Initial_pingPong_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ObjectPtr&);

    CallbackNC_Initial_pingPong(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        ::Ice::ObjectPtr ret;
        try
        {
            ret = proxy->end_pingPong(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_pingPong.
 */
template<class T> Callback_Initial_pingPongPtr
newCallback_Initial_pingPong(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_pingPong<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_pingPong.
 */
template<class T> Callback_Initial_pingPongPtr
newCallback_Initial_pingPong(T* instance, void (T::*cb)(const ::Ice::ObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_pingPong<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_pingPong.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_pingPong.
 */
template<class T, typename CT>
class Callback_Initial_pingPong : public Callback_Initial_pingPong_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ObjectPtr&, const CT&);

    Callback_Initial_pingPong(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        ::Ice::ObjectPtr ret;
        try
        {
            ret = proxy->end_pingPong(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_pingPong.
 */
template<class T, typename CT> Callback_Initial_pingPongPtr
newCallback_Initial_pingPong(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_pingPong<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_pingPong.
 */
template<class T, typename CT> Callback_Initial_pingPongPtr
newCallback_Initial_pingPong(T* instance, void (T::*cb)(const ::Ice::ObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_pingPong<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opOptionalException.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOptionalException.
 */
template<class T>
class CallbackNC_Initial_opOptionalException : public Callback_Initial_opOptionalException_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_opOptionalException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_opOptionalException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOptionalException.
 */
template<class T> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOptionalException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOptionalException.
 */
template<class T> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOptionalException<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOptionalException.
 */
template<class T> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOptionalException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOptionalException.
 */
template<class T> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOptionalException<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opOptionalException.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOptionalException.
 */
template<class T, typename CT>
class Callback_Initial_opOptionalException : public Callback_Initial_opOptionalException_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_opOptionalException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_opOptionalException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOptionalException.
 */
template<class T, typename CT> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOptionalException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOptionalException.
 */
template<class T, typename CT> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOptionalException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOptionalException.
 */
template<class T, typename CT> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOptionalException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOptionalException.
 */
template<class T, typename CT> Callback_Initial_opOptionalExceptionPtr
newCallback_Initial_opOptionalException(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOptionalException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opDerivedException.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDerivedException.
 */
template<class T>
class CallbackNC_Initial_opDerivedException : public Callback_Initial_opDerivedException_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_opDerivedException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_opDerivedException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDerivedException.
 */
template<class T> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDerivedException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDerivedException.
 */
template<class T> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDerivedException<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDerivedException.
 */
template<class T> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDerivedException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDerivedException.
 */
template<class T> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDerivedException<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opDerivedException.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDerivedException.
 */
template<class T, typename CT>
class Callback_Initial_opDerivedException : public Callback_Initial_opDerivedException_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_opDerivedException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_opDerivedException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDerivedException.
 */
template<class T, typename CT> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDerivedException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDerivedException.
 */
template<class T, typename CT> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDerivedException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDerivedException.
 */
template<class T, typename CT> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDerivedException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDerivedException.
 */
template<class T, typename CT> Callback_Initial_opDerivedExceptionPtr
newCallback_Initial_opDerivedException(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDerivedException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opRequiredException.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opRequiredException.
 */
template<class T>
class CallbackNC_Initial_opRequiredException : public Callback_Initial_opRequiredException_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_opRequiredException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_opRequiredException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opRequiredException.
 */
template<class T> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opRequiredException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opRequiredException.
 */
template<class T> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opRequiredException<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opRequiredException.
 */
template<class T> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opRequiredException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opRequiredException.
 */
template<class T> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opRequiredException<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opRequiredException.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opRequiredException.
 */
template<class T, typename CT>
class Callback_Initial_opRequiredException : public Callback_Initial_opRequiredException_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_opRequiredException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_opRequiredException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opRequiredException.
 */
template<class T, typename CT> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opRequiredException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opRequiredException.
 */
template<class T, typename CT> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opRequiredException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opRequiredException.
 */
template<class T, typename CT> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opRequiredException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opRequiredException.
 */
template<class T, typename CT> Callback_Initial_opRequiredExceptionPtr
newCallback_Initial_opRequiredException(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opRequiredException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opByte.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opByte.
 */
template<class T>
class CallbackNC_Initial_opByte : public Callback_Initial_opByte_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&);

    CallbackNC_Initial_opByte(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Byte> iceP_p3;
        IceUtil::Optional< ::Ice::Byte> ret;
        try
        {
            ret = proxy->end_opByte(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByte.
 */
template<class T> Callback_Initial_opBytePtr
newCallback_Initial_opByte(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opByte<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByte.
 */
template<class T> Callback_Initial_opBytePtr
newCallback_Initial_opByte(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opByte<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opByte.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opByte.
 */
template<class T, typename CT>
class Callback_Initial_opByte : public Callback_Initial_opByte_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&, const CT&);

    Callback_Initial_opByte(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Byte> iceP_p3;
        IceUtil::Optional< ::Ice::Byte> ret;
        try
        {
            ret = proxy->end_opByte(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByte.
 */
template<class T, typename CT> Callback_Initial_opBytePtr
newCallback_Initial_opByte(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opByte<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByte.
 */
template<class T, typename CT> Callback_Initial_opBytePtr
newCallback_Initial_opByte(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opByte<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opByteReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opByteReq.
 */
template<class T>
class CallbackNC_Initial_opByteReq : public Callback_Initial_opByteReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&);

    CallbackNC_Initial_opByteReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Byte> iceP_p3;
        IceUtil::Optional< ::Ice::Byte> ret;
        try
        {
            ret = proxy->end_opByteReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByteReq.
 */
template<class T> Callback_Initial_opByteReqPtr
newCallback_Initial_opByteReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opByteReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByteReq.
 */
template<class T> Callback_Initial_opByteReqPtr
newCallback_Initial_opByteReq(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opByteReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opByteReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opByteReq.
 */
template<class T, typename CT>
class Callback_Initial_opByteReq : public Callback_Initial_opByteReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&, const CT&);

    Callback_Initial_opByteReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Byte> iceP_p3;
        IceUtil::Optional< ::Ice::Byte> ret;
        try
        {
            ret = proxy->end_opByteReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByteReq.
 */
template<class T, typename CT> Callback_Initial_opByteReqPtr
newCallback_Initial_opByteReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opByteReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByteReq.
 */
template<class T, typename CT> Callback_Initial_opByteReqPtr
newCallback_Initial_opByteReq(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Byte>&, const IceUtil::Optional< ::Ice::Byte>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opByteReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opBool.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBool.
 */
template<class T>
class CallbackNC_Initial_opBool : public Callback_Initial_opBool_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&);

    CallbackNC_Initial_opBool(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<bool> iceP_p3;
        IceUtil::Optional<bool> ret;
        try
        {
            ret = proxy->end_opBool(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBool.
 */
template<class T> Callback_Initial_opBoolPtr
newCallback_Initial_opBool(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opBool<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBool.
 */
template<class T> Callback_Initial_opBoolPtr
newCallback_Initial_opBool(T* instance, void (T::*cb)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opBool<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opBool.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBool.
 */
template<class T, typename CT>
class Callback_Initial_opBool : public Callback_Initial_opBool_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&, const CT&);

    Callback_Initial_opBool(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<bool> iceP_p3;
        IceUtil::Optional<bool> ret;
        try
        {
            ret = proxy->end_opBool(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBool.
 */
template<class T, typename CT> Callback_Initial_opBoolPtr
newCallback_Initial_opBool(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opBool<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBool.
 */
template<class T, typename CT> Callback_Initial_opBoolPtr
newCallback_Initial_opBool(T* instance, void (T::*cb)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opBool<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opBoolReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBoolReq.
 */
template<class T>
class CallbackNC_Initial_opBoolReq : public Callback_Initial_opBoolReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&);

    CallbackNC_Initial_opBoolReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<bool> iceP_p3;
        IceUtil::Optional<bool> ret;
        try
        {
            ret = proxy->end_opBoolReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBoolReq.
 */
template<class T> Callback_Initial_opBoolReqPtr
newCallback_Initial_opBoolReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opBoolReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBoolReq.
 */
template<class T> Callback_Initial_opBoolReqPtr
newCallback_Initial_opBoolReq(T* instance, void (T::*cb)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opBoolReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opBoolReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBoolReq.
 */
template<class T, typename CT>
class Callback_Initial_opBoolReq : public Callback_Initial_opBoolReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&, const CT&);

    Callback_Initial_opBoolReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<bool> iceP_p3;
        IceUtil::Optional<bool> ret;
        try
        {
            ret = proxy->end_opBoolReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBoolReq.
 */
template<class T, typename CT> Callback_Initial_opBoolReqPtr
newCallback_Initial_opBoolReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opBoolReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBoolReq.
 */
template<class T, typename CT> Callback_Initial_opBoolReqPtr
newCallback_Initial_opBoolReq(T* instance, void (T::*cb)(const IceUtil::Optional<bool>&, const IceUtil::Optional<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opBoolReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opShort.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opShort.
 */
template<class T>
class CallbackNC_Initial_opShort : public Callback_Initial_opShort_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&);

    CallbackNC_Initial_opShort(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Short> iceP_p3;
        IceUtil::Optional< ::Ice::Short> ret;
        try
        {
            ret = proxy->end_opShort(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShort.
 */
template<class T> Callback_Initial_opShortPtr
newCallback_Initial_opShort(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opShort<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShort.
 */
template<class T> Callback_Initial_opShortPtr
newCallback_Initial_opShort(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opShort<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opShort.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opShort.
 */
template<class T, typename CT>
class Callback_Initial_opShort : public Callback_Initial_opShort_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&, const CT&);

    Callback_Initial_opShort(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Short> iceP_p3;
        IceUtil::Optional< ::Ice::Short> ret;
        try
        {
            ret = proxy->end_opShort(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShort.
 */
template<class T, typename CT> Callback_Initial_opShortPtr
newCallback_Initial_opShort(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opShort<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShort.
 */
template<class T, typename CT> Callback_Initial_opShortPtr
newCallback_Initial_opShort(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opShort<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opShortReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opShortReq.
 */
template<class T>
class CallbackNC_Initial_opShortReq : public Callback_Initial_opShortReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&);

    CallbackNC_Initial_opShortReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Short> iceP_p3;
        IceUtil::Optional< ::Ice::Short> ret;
        try
        {
            ret = proxy->end_opShortReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShortReq.
 */
template<class T> Callback_Initial_opShortReqPtr
newCallback_Initial_opShortReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opShortReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShortReq.
 */
template<class T> Callback_Initial_opShortReqPtr
newCallback_Initial_opShortReq(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opShortReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opShortReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opShortReq.
 */
template<class T, typename CT>
class Callback_Initial_opShortReq : public Callback_Initial_opShortReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&, const CT&);

    Callback_Initial_opShortReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Short> iceP_p3;
        IceUtil::Optional< ::Ice::Short> ret;
        try
        {
            ret = proxy->end_opShortReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShortReq.
 */
template<class T, typename CT> Callback_Initial_opShortReqPtr
newCallback_Initial_opShortReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opShortReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShortReq.
 */
template<class T, typename CT> Callback_Initial_opShortReqPtr
newCallback_Initial_opShortReq(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Short>&, const IceUtil::Optional< ::Ice::Short>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opShortReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opInt.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opInt.
 */
template<class T>
class CallbackNC_Initial_opInt : public Callback_Initial_opInt_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&);

    CallbackNC_Initial_opInt(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Int> iceP_p3;
        IceUtil::Optional< ::Ice::Int> ret;
        try
        {
            ret = proxy->end_opInt(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opInt.
 */
template<class T> Callback_Initial_opIntPtr
newCallback_Initial_opInt(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opInt<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opInt.
 */
template<class T> Callback_Initial_opIntPtr
newCallback_Initial_opInt(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opInt<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opInt.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opInt.
 */
template<class T, typename CT>
class Callback_Initial_opInt : public Callback_Initial_opInt_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&, const CT&);

    Callback_Initial_opInt(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Int> iceP_p3;
        IceUtil::Optional< ::Ice::Int> ret;
        try
        {
            ret = proxy->end_opInt(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opInt.
 */
template<class T, typename CT> Callback_Initial_opIntPtr
newCallback_Initial_opInt(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opInt<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opInt.
 */
template<class T, typename CT> Callback_Initial_opIntPtr
newCallback_Initial_opInt(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opInt<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opIntReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntReq.
 */
template<class T>
class CallbackNC_Initial_opIntReq : public Callback_Initial_opIntReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&);

    CallbackNC_Initial_opIntReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Int> iceP_p3;
        IceUtil::Optional< ::Ice::Int> ret;
        try
        {
            ret = proxy->end_opIntReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntReq.
 */
template<class T> Callback_Initial_opIntReqPtr
newCallback_Initial_opIntReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntReq.
 */
template<class T> Callback_Initial_opIntReqPtr
newCallback_Initial_opIntReq(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opIntReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntReq.
 */
template<class T, typename CT>
class Callback_Initial_opIntReq : public Callback_Initial_opIntReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&, const CT&);

    Callback_Initial_opIntReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Int> iceP_p3;
        IceUtil::Optional< ::Ice::Int> ret;
        try
        {
            ret = proxy->end_opIntReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntReq.
 */
template<class T, typename CT> Callback_Initial_opIntReqPtr
newCallback_Initial_opIntReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntReq.
 */
template<class T, typename CT> Callback_Initial_opIntReqPtr
newCallback_Initial_opIntReq(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const IceUtil::Optional< ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opLong.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opLong.
 */
template<class T>
class CallbackNC_Initial_opLong : public Callback_Initial_opLong_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&);

    CallbackNC_Initial_opLong(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Long> iceP_p3;
        IceUtil::Optional< ::Ice::Long> ret;
        try
        {
            ret = proxy->end_opLong(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLong.
 */
template<class T> Callback_Initial_opLongPtr
newCallback_Initial_opLong(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opLong<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLong.
 */
template<class T> Callback_Initial_opLongPtr
newCallback_Initial_opLong(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opLong<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opLong.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opLong.
 */
template<class T, typename CT>
class Callback_Initial_opLong : public Callback_Initial_opLong_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&, const CT&);

    Callback_Initial_opLong(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Long> iceP_p3;
        IceUtil::Optional< ::Ice::Long> ret;
        try
        {
            ret = proxy->end_opLong(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLong.
 */
template<class T, typename CT> Callback_Initial_opLongPtr
newCallback_Initial_opLong(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opLong<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLong.
 */
template<class T, typename CT> Callback_Initial_opLongPtr
newCallback_Initial_opLong(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opLong<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opLongReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opLongReq.
 */
template<class T>
class CallbackNC_Initial_opLongReq : public Callback_Initial_opLongReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&);

    CallbackNC_Initial_opLongReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Long> iceP_p3;
        IceUtil::Optional< ::Ice::Long> ret;
        try
        {
            ret = proxy->end_opLongReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLongReq.
 */
template<class T> Callback_Initial_opLongReqPtr
newCallback_Initial_opLongReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opLongReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLongReq.
 */
template<class T> Callback_Initial_opLongReqPtr
newCallback_Initial_opLongReq(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opLongReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opLongReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opLongReq.
 */
template<class T, typename CT>
class Callback_Initial_opLongReq : public Callback_Initial_opLongReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&, const CT&);

    Callback_Initial_opLongReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Long> iceP_p3;
        IceUtil::Optional< ::Ice::Long> ret;
        try
        {
            ret = proxy->end_opLongReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLongReq.
 */
template<class T, typename CT> Callback_Initial_opLongReqPtr
newCallback_Initial_opLongReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opLongReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLongReq.
 */
template<class T, typename CT> Callback_Initial_opLongReqPtr
newCallback_Initial_opLongReq(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Long>&, const IceUtil::Optional< ::Ice::Long>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opLongReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opFloat.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFloat.
 */
template<class T>
class CallbackNC_Initial_opFloat : public Callback_Initial_opFloat_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&);

    CallbackNC_Initial_opFloat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Float> iceP_p3;
        IceUtil::Optional< ::Ice::Float> ret;
        try
        {
            ret = proxy->end_opFloat(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloat.
 */
template<class T> Callback_Initial_opFloatPtr
newCallback_Initial_opFloat(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFloat<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloat.
 */
template<class T> Callback_Initial_opFloatPtr
newCallback_Initial_opFloat(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFloat<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opFloat.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFloat.
 */
template<class T, typename CT>
class Callback_Initial_opFloat : public Callback_Initial_opFloat_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&, const CT&);

    Callback_Initial_opFloat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Float> iceP_p3;
        IceUtil::Optional< ::Ice::Float> ret;
        try
        {
            ret = proxy->end_opFloat(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloat.
 */
template<class T, typename CT> Callback_Initial_opFloatPtr
newCallback_Initial_opFloat(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFloat<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloat.
 */
template<class T, typename CT> Callback_Initial_opFloatPtr
newCallback_Initial_opFloat(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFloat<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opFloatReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFloatReq.
 */
template<class T>
class CallbackNC_Initial_opFloatReq : public Callback_Initial_opFloatReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&);

    CallbackNC_Initial_opFloatReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Float> iceP_p3;
        IceUtil::Optional< ::Ice::Float> ret;
        try
        {
            ret = proxy->end_opFloatReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloatReq.
 */
template<class T> Callback_Initial_opFloatReqPtr
newCallback_Initial_opFloatReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFloatReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloatReq.
 */
template<class T> Callback_Initial_opFloatReqPtr
newCallback_Initial_opFloatReq(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFloatReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opFloatReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFloatReq.
 */
template<class T, typename CT>
class Callback_Initial_opFloatReq : public Callback_Initial_opFloatReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&, const CT&);

    Callback_Initial_opFloatReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Float> iceP_p3;
        IceUtil::Optional< ::Ice::Float> ret;
        try
        {
            ret = proxy->end_opFloatReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloatReq.
 */
template<class T, typename CT> Callback_Initial_opFloatReqPtr
newCallback_Initial_opFloatReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFloatReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloatReq.
 */
template<class T, typename CT> Callback_Initial_opFloatReqPtr
newCallback_Initial_opFloatReq(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Float>&, const IceUtil::Optional< ::Ice::Float>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFloatReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opDouble.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDouble.
 */
template<class T>
class CallbackNC_Initial_opDouble : public Callback_Initial_opDouble_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&);

    CallbackNC_Initial_opDouble(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Double> iceP_p3;
        IceUtil::Optional< ::Ice::Double> ret;
        try
        {
            ret = proxy->end_opDouble(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDouble.
 */
template<class T> Callback_Initial_opDoublePtr
newCallback_Initial_opDouble(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDouble<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDouble.
 */
template<class T> Callback_Initial_opDoublePtr
newCallback_Initial_opDouble(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDouble<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opDouble.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDouble.
 */
template<class T, typename CT>
class Callback_Initial_opDouble : public Callback_Initial_opDouble_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&, const CT&);

    Callback_Initial_opDouble(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Double> iceP_p3;
        IceUtil::Optional< ::Ice::Double> ret;
        try
        {
            ret = proxy->end_opDouble(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDouble.
 */
template<class T, typename CT> Callback_Initial_opDoublePtr
newCallback_Initial_opDouble(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDouble<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDouble.
 */
template<class T, typename CT> Callback_Initial_opDoublePtr
newCallback_Initial_opDouble(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDouble<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opDoubleReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDoubleReq.
 */
template<class T>
class CallbackNC_Initial_opDoubleReq : public Callback_Initial_opDoubleReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&);

    CallbackNC_Initial_opDoubleReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Double> iceP_p3;
        IceUtil::Optional< ::Ice::Double> ret;
        try
        {
            ret = proxy->end_opDoubleReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDoubleReq.
 */
template<class T> Callback_Initial_opDoubleReqPtr
newCallback_Initial_opDoubleReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDoubleReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDoubleReq.
 */
template<class T> Callback_Initial_opDoubleReqPtr
newCallback_Initial_opDoubleReq(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDoubleReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opDoubleReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDoubleReq.
 */
template<class T, typename CT>
class Callback_Initial_opDoubleReq : public Callback_Initial_opDoubleReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&, const CT&);

    Callback_Initial_opDoubleReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Double> iceP_p3;
        IceUtil::Optional< ::Ice::Double> ret;
        try
        {
            ret = proxy->end_opDoubleReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDoubleReq.
 */
template<class T, typename CT> Callback_Initial_opDoubleReqPtr
newCallback_Initial_opDoubleReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDoubleReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDoubleReq.
 */
template<class T, typename CT> Callback_Initial_opDoubleReqPtr
newCallback_Initial_opDoubleReq(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Double>&, const IceUtil::Optional< ::Ice::Double>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDoubleReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opString.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opString.
 */
template<class T>
class CallbackNC_Initial_opString : public Callback_Initial_opString_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&);

    CallbackNC_Initial_opString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::std::string> iceP_p3;
        IceUtil::Optional< ::std::string> ret;
        try
        {
            ret = proxy->end_opString(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opString.
 */
template<class T> Callback_Initial_opStringPtr
newCallback_Initial_opString(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opString<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opString.
 */
template<class T> Callback_Initial_opStringPtr
newCallback_Initial_opString(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opString<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opString.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opString.
 */
template<class T, typename CT>
class Callback_Initial_opString : public Callback_Initial_opString_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const CT&);

    Callback_Initial_opString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::std::string> iceP_p3;
        IceUtil::Optional< ::std::string> ret;
        try
        {
            ret = proxy->end_opString(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opString.
 */
template<class T, typename CT> Callback_Initial_opStringPtr
newCallback_Initial_opString(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opString<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opString.
 */
template<class T, typename CT> Callback_Initial_opStringPtr
newCallback_Initial_opString(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opString<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opStringReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringReq.
 */
template<class T>
class CallbackNC_Initial_opStringReq : public Callback_Initial_opStringReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&);

    CallbackNC_Initial_opStringReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::std::string> iceP_p3;
        IceUtil::Optional< ::std::string> ret;
        try
        {
            ret = proxy->end_opStringReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringReq.
 */
template<class T> Callback_Initial_opStringReqPtr
newCallback_Initial_opStringReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opStringReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringReq.
 */
template<class T> Callback_Initial_opStringReqPtr
newCallback_Initial_opStringReq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opStringReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opStringReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringReq.
 */
template<class T, typename CT>
class Callback_Initial_opStringReq : public Callback_Initial_opStringReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const CT&);

    Callback_Initial_opStringReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::std::string> iceP_p3;
        IceUtil::Optional< ::std::string> ret;
        try
        {
            ret = proxy->end_opStringReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringReq.
 */
template<class T, typename CT> Callback_Initial_opStringReqPtr
newCallback_Initial_opStringReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opStringReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringReq.
 */
template<class T, typename CT> Callback_Initial_opStringReqPtr
newCallback_Initial_opStringReq(T* instance, void (T::*cb)(const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opStringReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opMyEnum.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMyEnum.
 */
template<class T>
class CallbackNC_Initial_opMyEnum : public Callback_Initial_opMyEnum_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<MyEnum>&, const IceUtil::Optional<MyEnum>&);

    CallbackNC_Initial_opMyEnum(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<MyEnum> iceP_p3;
        IceUtil::Optional<MyEnum> ret;
        try
        {
            ret = proxy->end_opMyEnum(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMyEnum.
 */
template<class T> Callback_Initial_opMyEnumPtr
newCallback_Initial_opMyEnum(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<MyEnum>&, const IceUtil::Optional<MyEnum>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMyEnum<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMyEnum.
 */
template<class T> Callback_Initial_opMyEnumPtr
newCallback_Initial_opMyEnum(T* instance, void (T::*cb)(const IceUtil::Optional<MyEnum>&, const IceUtil::Optional<MyEnum>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMyEnum<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opMyEnum.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMyEnum.
 */
template<class T, typename CT>
class Callback_Initial_opMyEnum : public Callback_Initial_opMyEnum_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<MyEnum>&, const IceUtil::Optional<MyEnum>&, const CT&);

    Callback_Initial_opMyEnum(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<MyEnum> iceP_p3;
        IceUtil::Optional<MyEnum> ret;
        try
        {
            ret = proxy->end_opMyEnum(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMyEnum.
 */
template<class T, typename CT> Callback_Initial_opMyEnumPtr
newCallback_Initial_opMyEnum(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<MyEnum>&, const IceUtil::Optional<MyEnum>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMyEnum<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMyEnum.
 */
template<class T, typename CT> Callback_Initial_opMyEnumPtr
newCallback_Initial_opMyEnum(T* instance, void (T::*cb)(const IceUtil::Optional<MyEnum>&, const IceUtil::Optional<MyEnum>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMyEnum<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opMyEnumReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMyEnumReq.
 */
template<class T>
class CallbackNC_Initial_opMyEnumReq : public Callback_Initial_opMyEnumReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<MyEnum>&, const IceUtil::Optional<MyEnum>&);

    CallbackNC_Initial_opMyEnumReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<MyEnum> iceP_p3;
        IceUtil::Optional<MyEnum> ret;
        try
        {
            ret = proxy->end_opMyEnumReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMyEnumReq.
 */
template<class T> Callback_Initial_opMyEnumReqPtr
newCallback_Initial_opMyEnumReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<MyEnum>&, const IceUtil::Optional<MyEnum>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMyEnumReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMyEnumReq.
 */
template<class T> Callback_Initial_opMyEnumReqPtr
newCallback_Initial_opMyEnumReq(T* instance, void (T::*cb)(const IceUtil::Optional<MyEnum>&, const IceUtil::Optional<MyEnum>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMyEnumReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opMyEnumReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMyEnumReq.
 */
template<class T, typename CT>
class Callback_Initial_opMyEnumReq : public Callback_Initial_opMyEnumReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<MyEnum>&, const IceUtil::Optional<MyEnum>&, const CT&);

    Callback_Initial_opMyEnumReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<MyEnum> iceP_p3;
        IceUtil::Optional<MyEnum> ret;
        try
        {
            ret = proxy->end_opMyEnumReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMyEnumReq.
 */
template<class T, typename CT> Callback_Initial_opMyEnumReqPtr
newCallback_Initial_opMyEnumReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<MyEnum>&, const IceUtil::Optional<MyEnum>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMyEnumReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMyEnumReq.
 */
template<class T, typename CT> Callback_Initial_opMyEnumReqPtr
newCallback_Initial_opMyEnumReq(T* instance, void (T::*cb)(const IceUtil::Optional<MyEnum>&, const IceUtil::Optional<MyEnum>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMyEnumReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opSmallStruct.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStruct.
 */
template<class T>
class CallbackNC_Initial_opSmallStruct : public Callback_Initial_opSmallStruct_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&);

    CallbackNC_Initial_opSmallStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStruct> iceP_p3;
        IceUtil::Optional<SmallStruct> ret;
        try
        {
            ret = proxy->end_opSmallStruct(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStruct.
 */
template<class T> Callback_Initial_opSmallStructPtr
newCallback_Initial_opSmallStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStruct.
 */
template<class T> Callback_Initial_opSmallStructPtr
newCallback_Initial_opSmallStruct(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opSmallStruct.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStruct.
 */
template<class T, typename CT>
class Callback_Initial_opSmallStruct : public Callback_Initial_opSmallStruct_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&, const CT&);

    Callback_Initial_opSmallStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStruct> iceP_p3;
        IceUtil::Optional<SmallStruct> ret;
        try
        {
            ret = proxy->end_opSmallStruct(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStruct.
 */
template<class T, typename CT> Callback_Initial_opSmallStructPtr
newCallback_Initial_opSmallStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStruct.
 */
template<class T, typename CT> Callback_Initial_opSmallStructPtr
newCallback_Initial_opSmallStruct(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructReq.
 */
template<class T>
class CallbackNC_Initial_opSmallStructReq : public Callback_Initial_opSmallStructReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&);

    CallbackNC_Initial_opSmallStructReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStruct> iceP_p3;
        IceUtil::Optional<SmallStruct> ret;
        try
        {
            ret = proxy->end_opSmallStructReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructReq.
 */
template<class T> Callback_Initial_opSmallStructReqPtr
newCallback_Initial_opSmallStructReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStructReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructReq.
 */
template<class T> Callback_Initial_opSmallStructReqPtr
newCallback_Initial_opSmallStructReq(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStructReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructReq.
 */
template<class T, typename CT>
class Callback_Initial_opSmallStructReq : public Callback_Initial_opSmallStructReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&, const CT&);

    Callback_Initial_opSmallStructReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStruct> iceP_p3;
        IceUtil::Optional<SmallStruct> ret;
        try
        {
            ret = proxy->end_opSmallStructReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructReq.
 */
template<class T, typename CT> Callback_Initial_opSmallStructReqPtr
newCallback_Initial_opSmallStructReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStructReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructReq.
 */
template<class T, typename CT> Callback_Initial_opSmallStructReqPtr
newCallback_Initial_opSmallStructReq(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStructReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opFixedStruct.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStruct.
 */
template<class T>
class CallbackNC_Initial_opFixedStruct : public Callback_Initial_opFixedStruct_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<FixedStruct>&, const IceUtil::Optional<FixedStruct>&);

    CallbackNC_Initial_opFixedStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FixedStruct> iceP_p3;
        IceUtil::Optional<FixedStruct> ret;
        try
        {
            ret = proxy->end_opFixedStruct(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStruct.
 */
template<class T> Callback_Initial_opFixedStructPtr
newCallback_Initial_opFixedStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FixedStruct>&, const IceUtil::Optional<FixedStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStruct.
 */
template<class T> Callback_Initial_opFixedStructPtr
newCallback_Initial_opFixedStruct(T* instance, void (T::*cb)(const IceUtil::Optional<FixedStruct>&, const IceUtil::Optional<FixedStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opFixedStruct.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStruct.
 */
template<class T, typename CT>
class Callback_Initial_opFixedStruct : public Callback_Initial_opFixedStruct_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<FixedStruct>&, const IceUtil::Optional<FixedStruct>&, const CT&);

    Callback_Initial_opFixedStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FixedStruct> iceP_p3;
        IceUtil::Optional<FixedStruct> ret;
        try
        {
            ret = proxy->end_opFixedStruct(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStruct.
 */
template<class T, typename CT> Callback_Initial_opFixedStructPtr
newCallback_Initial_opFixedStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FixedStruct>&, const IceUtil::Optional<FixedStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStruct.
 */
template<class T, typename CT> Callback_Initial_opFixedStructPtr
newCallback_Initial_opFixedStruct(T* instance, void (T::*cb)(const IceUtil::Optional<FixedStruct>&, const IceUtil::Optional<FixedStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructReq.
 */
template<class T>
class CallbackNC_Initial_opFixedStructReq : public Callback_Initial_opFixedStructReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<FixedStruct>&, const IceUtil::Optional<FixedStruct>&);

    CallbackNC_Initial_opFixedStructReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FixedStruct> iceP_p3;
        IceUtil::Optional<FixedStruct> ret;
        try
        {
            ret = proxy->end_opFixedStructReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructReq.
 */
template<class T> Callback_Initial_opFixedStructReqPtr
newCallback_Initial_opFixedStructReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FixedStruct>&, const IceUtil::Optional<FixedStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStructReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructReq.
 */
template<class T> Callback_Initial_opFixedStructReqPtr
newCallback_Initial_opFixedStructReq(T* instance, void (T::*cb)(const IceUtil::Optional<FixedStruct>&, const IceUtil::Optional<FixedStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStructReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructReq.
 */
template<class T, typename CT>
class Callback_Initial_opFixedStructReq : public Callback_Initial_opFixedStructReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<FixedStruct>&, const IceUtil::Optional<FixedStruct>&, const CT&);

    Callback_Initial_opFixedStructReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FixedStruct> iceP_p3;
        IceUtil::Optional<FixedStruct> ret;
        try
        {
            ret = proxy->end_opFixedStructReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructReq.
 */
template<class T, typename CT> Callback_Initial_opFixedStructReqPtr
newCallback_Initial_opFixedStructReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FixedStruct>&, const IceUtil::Optional<FixedStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStructReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructReq.
 */
template<class T, typename CT> Callback_Initial_opFixedStructReqPtr
newCallback_Initial_opFixedStructReq(T* instance, void (T::*cb)(const IceUtil::Optional<FixedStruct>&, const IceUtil::Optional<FixedStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStructReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opVarStruct.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVarStruct.
 */
template<class T>
class CallbackNC_Initial_opVarStruct : public Callback_Initial_opVarStruct_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<VarStruct>&, const IceUtil::Optional<VarStruct>&);

    CallbackNC_Initial_opVarStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<VarStruct> iceP_p3;
        IceUtil::Optional<VarStruct> ret;
        try
        {
            ret = proxy->end_opVarStruct(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStruct.
 */
template<class T> Callback_Initial_opVarStructPtr
newCallback_Initial_opVarStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<VarStruct>&, const IceUtil::Optional<VarStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVarStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStruct.
 */
template<class T> Callback_Initial_opVarStructPtr
newCallback_Initial_opVarStruct(T* instance, void (T::*cb)(const IceUtil::Optional<VarStruct>&, const IceUtil::Optional<VarStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVarStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opVarStruct.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVarStruct.
 */
template<class T, typename CT>
class Callback_Initial_opVarStruct : public Callback_Initial_opVarStruct_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<VarStruct>&, const IceUtil::Optional<VarStruct>&, const CT&);

    Callback_Initial_opVarStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<VarStruct> iceP_p3;
        IceUtil::Optional<VarStruct> ret;
        try
        {
            ret = proxy->end_opVarStruct(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStruct.
 */
template<class T, typename CT> Callback_Initial_opVarStructPtr
newCallback_Initial_opVarStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<VarStruct>&, const IceUtil::Optional<VarStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVarStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStruct.
 */
template<class T, typename CT> Callback_Initial_opVarStructPtr
newCallback_Initial_opVarStruct(T* instance, void (T::*cb)(const IceUtil::Optional<VarStruct>&, const IceUtil::Optional<VarStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVarStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opVarStructReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVarStructReq.
 */
template<class T>
class CallbackNC_Initial_opVarStructReq : public Callback_Initial_opVarStructReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<VarStruct>&, const IceUtil::Optional<VarStruct>&);

    CallbackNC_Initial_opVarStructReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<VarStruct> iceP_p3;
        IceUtil::Optional<VarStruct> ret;
        try
        {
            ret = proxy->end_opVarStructReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStructReq.
 */
template<class T> Callback_Initial_opVarStructReqPtr
newCallback_Initial_opVarStructReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<VarStruct>&, const IceUtil::Optional<VarStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVarStructReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStructReq.
 */
template<class T> Callback_Initial_opVarStructReqPtr
newCallback_Initial_opVarStructReq(T* instance, void (T::*cb)(const IceUtil::Optional<VarStruct>&, const IceUtil::Optional<VarStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVarStructReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opVarStructReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVarStructReq.
 */
template<class T, typename CT>
class Callback_Initial_opVarStructReq : public Callback_Initial_opVarStructReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<VarStruct>&, const IceUtil::Optional<VarStruct>&, const CT&);

    Callback_Initial_opVarStructReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<VarStruct> iceP_p3;
        IceUtil::Optional<VarStruct> ret;
        try
        {
            ret = proxy->end_opVarStructReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStructReq.
 */
template<class T, typename CT> Callback_Initial_opVarStructReqPtr
newCallback_Initial_opVarStructReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<VarStruct>&, const IceUtil::Optional<VarStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVarStructReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStructReq.
 */
template<class T, typename CT> Callback_Initial_opVarStructReqPtr
newCallback_Initial_opVarStructReq(T* instance, void (T::*cb)(const IceUtil::Optional<VarStruct>&, const IceUtil::Optional<VarStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVarStructReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opOneOptional.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOneOptional.
 */
template<class T>
class CallbackNC_Initial_opOneOptional : public Callback_Initial_opOneOptional_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<OneOptionalPtr>&, const IceUtil::Optional<OneOptionalPtr>&);

    CallbackNC_Initial_opOneOptional(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<OneOptionalPtr> iceP_p3;
        IceUtil::Optional<OneOptionalPtr> ret;
        try
        {
            ret = proxy->end_opOneOptional(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptional.
 */
template<class T> Callback_Initial_opOneOptionalPtr
newCallback_Initial_opOneOptional(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPtr>&, const IceUtil::Optional<OneOptionalPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOneOptional<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptional.
 */
template<class T> Callback_Initial_opOneOptionalPtr
newCallback_Initial_opOneOptional(T* instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPtr>&, const IceUtil::Optional<OneOptionalPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOneOptional<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opOneOptional.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOneOptional.
 */
template<class T, typename CT>
class Callback_Initial_opOneOptional : public Callback_Initial_opOneOptional_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<OneOptionalPtr>&, const IceUtil::Optional<OneOptionalPtr>&, const CT&);

    Callback_Initial_opOneOptional(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<OneOptionalPtr> iceP_p3;
        IceUtil::Optional<OneOptionalPtr> ret;
        try
        {
            ret = proxy->end_opOneOptional(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptional.
 */
template<class T, typename CT> Callback_Initial_opOneOptionalPtr
newCallback_Initial_opOneOptional(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPtr>&, const IceUtil::Optional<OneOptionalPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOneOptional<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptional.
 */
template<class T, typename CT> Callback_Initial_opOneOptionalPtr
newCallback_Initial_opOneOptional(T* instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPtr>&, const IceUtil::Optional<OneOptionalPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOneOptional<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opOneOptionalReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOneOptionalReq.
 */
template<class T>
class CallbackNC_Initial_opOneOptionalReq : public Callback_Initial_opOneOptionalReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<OneOptionalPtr>&, const IceUtil::Optional<OneOptionalPtr>&);

    CallbackNC_Initial_opOneOptionalReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<OneOptionalPtr> iceP_p3;
        IceUtil::Optional<OneOptionalPtr> ret;
        try
        {
            ret = proxy->end_opOneOptionalReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptionalReq.
 */
template<class T> Callback_Initial_opOneOptionalReqPtr
newCallback_Initial_opOneOptionalReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPtr>&, const IceUtil::Optional<OneOptionalPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOneOptionalReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptionalReq.
 */
template<class T> Callback_Initial_opOneOptionalReqPtr
newCallback_Initial_opOneOptionalReq(T* instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPtr>&, const IceUtil::Optional<OneOptionalPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOneOptionalReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opOneOptionalReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOneOptionalReq.
 */
template<class T, typename CT>
class Callback_Initial_opOneOptionalReq : public Callback_Initial_opOneOptionalReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<OneOptionalPtr>&, const IceUtil::Optional<OneOptionalPtr>&, const CT&);

    Callback_Initial_opOneOptionalReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<OneOptionalPtr> iceP_p3;
        IceUtil::Optional<OneOptionalPtr> ret;
        try
        {
            ret = proxy->end_opOneOptionalReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptionalReq.
 */
template<class T, typename CT> Callback_Initial_opOneOptionalReqPtr
newCallback_Initial_opOneOptionalReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPtr>&, const IceUtil::Optional<OneOptionalPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOneOptionalReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptionalReq.
 */
template<class T, typename CT> Callback_Initial_opOneOptionalReqPtr
newCallback_Initial_opOneOptionalReq(T* instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPtr>&, const IceUtil::Optional<OneOptionalPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOneOptionalReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opOneOptionalProxy.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOneOptionalProxy.
 */
template<class T>
class CallbackNC_Initial_opOneOptionalProxy : public Callback_Initial_opOneOptionalProxy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<OneOptionalPrx>&, const IceUtil::Optional<OneOptionalPrx>&);

    CallbackNC_Initial_opOneOptionalProxy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<OneOptionalPrx> iceP_p3;
        IceUtil::Optional<OneOptionalPrx> ret;
        try
        {
            ret = proxy->end_opOneOptionalProxy(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptionalProxy.
 */
template<class T> Callback_Initial_opOneOptionalProxyPtr
newCallback_Initial_opOneOptionalProxy(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPrx>&, const IceUtil::Optional<OneOptionalPrx>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOneOptionalProxy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptionalProxy.
 */
template<class T> Callback_Initial_opOneOptionalProxyPtr
newCallback_Initial_opOneOptionalProxy(T* instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPrx>&, const IceUtil::Optional<OneOptionalPrx>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOneOptionalProxy<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opOneOptionalProxy.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOneOptionalProxy.
 */
template<class T, typename CT>
class Callback_Initial_opOneOptionalProxy : public Callback_Initial_opOneOptionalProxy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<OneOptionalPrx>&, const IceUtil::Optional<OneOptionalPrx>&, const CT&);

    Callback_Initial_opOneOptionalProxy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<OneOptionalPrx> iceP_p3;
        IceUtil::Optional<OneOptionalPrx> ret;
        try
        {
            ret = proxy->end_opOneOptionalProxy(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptionalProxy.
 */
template<class T, typename CT> Callback_Initial_opOneOptionalProxyPtr
newCallback_Initial_opOneOptionalProxy(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPrx>&, const IceUtil::Optional<OneOptionalPrx>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOneOptionalProxy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptionalProxy.
 */
template<class T, typename CT> Callback_Initial_opOneOptionalProxyPtr
newCallback_Initial_opOneOptionalProxy(T* instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPrx>&, const IceUtil::Optional<OneOptionalPrx>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOneOptionalProxy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opOneOptionalProxyReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOneOptionalProxyReq.
 */
template<class T>
class CallbackNC_Initial_opOneOptionalProxyReq : public Callback_Initial_opOneOptionalProxyReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<OneOptionalPrx>&, const IceUtil::Optional<OneOptionalPrx>&);

    CallbackNC_Initial_opOneOptionalProxyReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<OneOptionalPrx> iceP_p3;
        IceUtil::Optional<OneOptionalPrx> ret;
        try
        {
            ret = proxy->end_opOneOptionalProxyReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptionalProxyReq.
 */
template<class T> Callback_Initial_opOneOptionalProxyReqPtr
newCallback_Initial_opOneOptionalProxyReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPrx>&, const IceUtil::Optional<OneOptionalPrx>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOneOptionalProxyReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptionalProxyReq.
 */
template<class T> Callback_Initial_opOneOptionalProxyReqPtr
newCallback_Initial_opOneOptionalProxyReq(T* instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPrx>&, const IceUtil::Optional<OneOptionalPrx>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opOneOptionalProxyReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opOneOptionalProxyReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opOneOptionalProxyReq.
 */
template<class T, typename CT>
class Callback_Initial_opOneOptionalProxyReq : public Callback_Initial_opOneOptionalProxyReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<OneOptionalPrx>&, const IceUtil::Optional<OneOptionalPrx>&, const CT&);

    Callback_Initial_opOneOptionalProxyReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<OneOptionalPrx> iceP_p3;
        IceUtil::Optional<OneOptionalPrx> ret;
        try
        {
            ret = proxy->end_opOneOptionalProxyReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptionalProxyReq.
 */
template<class T, typename CT> Callback_Initial_opOneOptionalProxyReqPtr
newCallback_Initial_opOneOptionalProxyReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPrx>&, const IceUtil::Optional<OneOptionalPrx>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOneOptionalProxyReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opOneOptionalProxyReq.
 */
template<class T, typename CT> Callback_Initial_opOneOptionalProxyReqPtr
newCallback_Initial_opOneOptionalProxyReq(T* instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPrx>&, const IceUtil::Optional<OneOptionalPrx>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opOneOptionalProxyReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opByteSeq.
 */
template<class T>
class CallbackNC_Initial_opByteSeq : public Callback_Initial_opByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<ByteSeq>&, const IceUtil::Optional<ByteSeq>&);

    CallbackNC_Initial_opByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<ByteSeq> iceP_p3;
        IceUtil::Optional<ByteSeq> ret;
        try
        {
            ret = proxy->end_opByteSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByteSeq.
 */
template<class T> Callback_Initial_opByteSeqPtr
newCallback_Initial_opByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<ByteSeq>&, const IceUtil::Optional<ByteSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByteSeq.
 */
template<class T> Callback_Initial_opByteSeqPtr
newCallback_Initial_opByteSeq(T* instance, void (T::*cb)(const IceUtil::Optional<ByteSeq>&, const IceUtil::Optional<ByteSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opByteSeq.
 */
template<class T, typename CT>
class Callback_Initial_opByteSeq : public Callback_Initial_opByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<ByteSeq>&, const IceUtil::Optional<ByteSeq>&, const CT&);

    Callback_Initial_opByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<ByteSeq> iceP_p3;
        IceUtil::Optional<ByteSeq> ret;
        try
        {
            ret = proxy->end_opByteSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByteSeq.
 */
template<class T, typename CT> Callback_Initial_opByteSeqPtr
newCallback_Initial_opByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<ByteSeq>&, const IceUtil::Optional<ByteSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByteSeq.
 */
template<class T, typename CT> Callback_Initial_opByteSeqPtr
newCallback_Initial_opByteSeq(T* instance, void (T::*cb)(const IceUtil::Optional<ByteSeq>&, const IceUtil::Optional<ByteSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opByteSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opByteSeqReq.
 */
template<class T>
class CallbackNC_Initial_opByteSeqReq : public Callback_Initial_opByteSeqReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<ByteSeq>&, const IceUtil::Optional<ByteSeq>&);

    CallbackNC_Initial_opByteSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<ByteSeq> iceP_p3;
        IceUtil::Optional<ByteSeq> ret;
        try
        {
            ret = proxy->end_opByteSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByteSeqReq.
 */
template<class T> Callback_Initial_opByteSeqReqPtr
newCallback_Initial_opByteSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<ByteSeq>&, const IceUtil::Optional<ByteSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opByteSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByteSeqReq.
 */
template<class T> Callback_Initial_opByteSeqReqPtr
newCallback_Initial_opByteSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<ByteSeq>&, const IceUtil::Optional<ByteSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opByteSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opByteSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opByteSeqReq.
 */
template<class T, typename CT>
class Callback_Initial_opByteSeqReq : public Callback_Initial_opByteSeqReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<ByteSeq>&, const IceUtil::Optional<ByteSeq>&, const CT&);

    Callback_Initial_opByteSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<ByteSeq> iceP_p3;
        IceUtil::Optional<ByteSeq> ret;
        try
        {
            ret = proxy->end_opByteSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByteSeqReq.
 */
template<class T, typename CT> Callback_Initial_opByteSeqReqPtr
newCallback_Initial_opByteSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<ByteSeq>&, const IceUtil::Optional<ByteSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opByteSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opByteSeqReq.
 */
template<class T, typename CT> Callback_Initial_opByteSeqReqPtr
newCallback_Initial_opByteSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<ByteSeq>&, const IceUtil::Optional<ByteSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opByteSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBoolSeq.
 */
template<class T>
class CallbackNC_Initial_opBoolSeq : public Callback_Initial_opBoolSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<BoolSeq>&, const IceUtil::Optional<BoolSeq>&);

    CallbackNC_Initial_opBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<BoolSeq> iceP_p3;
        IceUtil::Optional<BoolSeq> ret;
        try
        {
            ret = proxy->end_opBoolSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBoolSeq.
 */
template<class T> Callback_Initial_opBoolSeqPtr
newCallback_Initial_opBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<BoolSeq>&, const IceUtil::Optional<BoolSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opBoolSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBoolSeq.
 */
template<class T> Callback_Initial_opBoolSeqPtr
newCallback_Initial_opBoolSeq(T* instance, void (T::*cb)(const IceUtil::Optional<BoolSeq>&, const IceUtil::Optional<BoolSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opBoolSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBoolSeq.
 */
template<class T, typename CT>
class Callback_Initial_opBoolSeq : public Callback_Initial_opBoolSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<BoolSeq>&, const IceUtil::Optional<BoolSeq>&, const CT&);

    Callback_Initial_opBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<BoolSeq> iceP_p3;
        IceUtil::Optional<BoolSeq> ret;
        try
        {
            ret = proxy->end_opBoolSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBoolSeq.
 */
template<class T, typename CT> Callback_Initial_opBoolSeqPtr
newCallback_Initial_opBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<BoolSeq>&, const IceUtil::Optional<BoolSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBoolSeq.
 */
template<class T, typename CT> Callback_Initial_opBoolSeqPtr
newCallback_Initial_opBoolSeq(T* instance, void (T::*cb)(const IceUtil::Optional<BoolSeq>&, const IceUtil::Optional<BoolSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opBoolSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBoolSeqReq.
 */
template<class T>
class CallbackNC_Initial_opBoolSeqReq : public Callback_Initial_opBoolSeqReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<BoolSeq>&, const IceUtil::Optional<BoolSeq>&);

    CallbackNC_Initial_opBoolSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<BoolSeq> iceP_p3;
        IceUtil::Optional<BoolSeq> ret;
        try
        {
            ret = proxy->end_opBoolSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBoolSeqReq.
 */
template<class T> Callback_Initial_opBoolSeqReqPtr
newCallback_Initial_opBoolSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<BoolSeq>&, const IceUtil::Optional<BoolSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opBoolSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBoolSeqReq.
 */
template<class T> Callback_Initial_opBoolSeqReqPtr
newCallback_Initial_opBoolSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<BoolSeq>&, const IceUtil::Optional<BoolSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opBoolSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opBoolSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBoolSeqReq.
 */
template<class T, typename CT>
class Callback_Initial_opBoolSeqReq : public Callback_Initial_opBoolSeqReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<BoolSeq>&, const IceUtil::Optional<BoolSeq>&, const CT&);

    Callback_Initial_opBoolSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<BoolSeq> iceP_p3;
        IceUtil::Optional<BoolSeq> ret;
        try
        {
            ret = proxy->end_opBoolSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBoolSeqReq.
 */
template<class T, typename CT> Callback_Initial_opBoolSeqReqPtr
newCallback_Initial_opBoolSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<BoolSeq>&, const IceUtil::Optional<BoolSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opBoolSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBoolSeqReq.
 */
template<class T, typename CT> Callback_Initial_opBoolSeqReqPtr
newCallback_Initial_opBoolSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<BoolSeq>&, const IceUtil::Optional<BoolSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opBoolSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opShortSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opShortSeq.
 */
template<class T>
class CallbackNC_Initial_opShortSeq : public Callback_Initial_opShortSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<ShortSeq>&, const IceUtil::Optional<ShortSeq>&);

    CallbackNC_Initial_opShortSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<ShortSeq> iceP_p3;
        IceUtil::Optional<ShortSeq> ret;
        try
        {
            ret = proxy->end_opShortSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShortSeq.
 */
template<class T> Callback_Initial_opShortSeqPtr
newCallback_Initial_opShortSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<ShortSeq>&, const IceUtil::Optional<ShortSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opShortSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShortSeq.
 */
template<class T> Callback_Initial_opShortSeqPtr
newCallback_Initial_opShortSeq(T* instance, void (T::*cb)(const IceUtil::Optional<ShortSeq>&, const IceUtil::Optional<ShortSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opShortSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opShortSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opShortSeq.
 */
template<class T, typename CT>
class Callback_Initial_opShortSeq : public Callback_Initial_opShortSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<ShortSeq>&, const IceUtil::Optional<ShortSeq>&, const CT&);

    Callback_Initial_opShortSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<ShortSeq> iceP_p3;
        IceUtil::Optional<ShortSeq> ret;
        try
        {
            ret = proxy->end_opShortSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShortSeq.
 */
template<class T, typename CT> Callback_Initial_opShortSeqPtr
newCallback_Initial_opShortSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<ShortSeq>&, const IceUtil::Optional<ShortSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opShortSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShortSeq.
 */
template<class T, typename CT> Callback_Initial_opShortSeqPtr
newCallback_Initial_opShortSeq(T* instance, void (T::*cb)(const IceUtil::Optional<ShortSeq>&, const IceUtil::Optional<ShortSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opShortSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opShortSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opShortSeqReq.
 */
template<class T>
class CallbackNC_Initial_opShortSeqReq : public Callback_Initial_opShortSeqReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<ShortSeq>&, const IceUtil::Optional<ShortSeq>&);

    CallbackNC_Initial_opShortSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<ShortSeq> iceP_p3;
        IceUtil::Optional<ShortSeq> ret;
        try
        {
            ret = proxy->end_opShortSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShortSeqReq.
 */
template<class T> Callback_Initial_opShortSeqReqPtr
newCallback_Initial_opShortSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<ShortSeq>&, const IceUtil::Optional<ShortSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opShortSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShortSeqReq.
 */
template<class T> Callback_Initial_opShortSeqReqPtr
newCallback_Initial_opShortSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<ShortSeq>&, const IceUtil::Optional<ShortSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opShortSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opShortSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opShortSeqReq.
 */
template<class T, typename CT>
class Callback_Initial_opShortSeqReq : public Callback_Initial_opShortSeqReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<ShortSeq>&, const IceUtil::Optional<ShortSeq>&, const CT&);

    Callback_Initial_opShortSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<ShortSeq> iceP_p3;
        IceUtil::Optional<ShortSeq> ret;
        try
        {
            ret = proxy->end_opShortSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShortSeqReq.
 */
template<class T, typename CT> Callback_Initial_opShortSeqReqPtr
newCallback_Initial_opShortSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<ShortSeq>&, const IceUtil::Optional<ShortSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opShortSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opShortSeqReq.
 */
template<class T, typename CT> Callback_Initial_opShortSeqReqPtr
newCallback_Initial_opShortSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<ShortSeq>&, const IceUtil::Optional<ShortSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opShortSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opIntSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntSeq.
 */
template<class T>
class CallbackNC_Initial_opIntSeq : public Callback_Initial_opIntSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<IntSeq>&, const IceUtil::Optional<IntSeq>&);

    CallbackNC_Initial_opIntSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<IntSeq> iceP_p3;
        IceUtil::Optional<IntSeq> ret;
        try
        {
            ret = proxy->end_opIntSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntSeq.
 */
template<class T> Callback_Initial_opIntSeqPtr
newCallback_Initial_opIntSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<IntSeq>&, const IceUtil::Optional<IntSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntSeq.
 */
template<class T> Callback_Initial_opIntSeqPtr
newCallback_Initial_opIntSeq(T* instance, void (T::*cb)(const IceUtil::Optional<IntSeq>&, const IceUtil::Optional<IntSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opIntSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntSeq.
 */
template<class T, typename CT>
class Callback_Initial_opIntSeq : public Callback_Initial_opIntSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<IntSeq>&, const IceUtil::Optional<IntSeq>&, const CT&);

    Callback_Initial_opIntSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<IntSeq> iceP_p3;
        IceUtil::Optional<IntSeq> ret;
        try
        {
            ret = proxy->end_opIntSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntSeq.
 */
template<class T, typename CT> Callback_Initial_opIntSeqPtr
newCallback_Initial_opIntSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<IntSeq>&, const IceUtil::Optional<IntSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntSeq.
 */
template<class T, typename CT> Callback_Initial_opIntSeqPtr
newCallback_Initial_opIntSeq(T* instance, void (T::*cb)(const IceUtil::Optional<IntSeq>&, const IceUtil::Optional<IntSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opIntSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntSeqReq.
 */
template<class T>
class CallbackNC_Initial_opIntSeqReq : public Callback_Initial_opIntSeqReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<IntSeq>&, const IceUtil::Optional<IntSeq>&);

    CallbackNC_Initial_opIntSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<IntSeq> iceP_p3;
        IceUtil::Optional<IntSeq> ret;
        try
        {
            ret = proxy->end_opIntSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntSeqReq.
 */
template<class T> Callback_Initial_opIntSeqReqPtr
newCallback_Initial_opIntSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<IntSeq>&, const IceUtil::Optional<IntSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntSeqReq.
 */
template<class T> Callback_Initial_opIntSeqReqPtr
newCallback_Initial_opIntSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<IntSeq>&, const IceUtil::Optional<IntSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opIntSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntSeqReq.
 */
template<class T, typename CT>
class Callback_Initial_opIntSeqReq : public Callback_Initial_opIntSeqReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<IntSeq>&, const IceUtil::Optional<IntSeq>&, const CT&);

    Callback_Initial_opIntSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<IntSeq> iceP_p3;
        IceUtil::Optional<IntSeq> ret;
        try
        {
            ret = proxy->end_opIntSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntSeqReq.
 */
template<class T, typename CT> Callback_Initial_opIntSeqReqPtr
newCallback_Initial_opIntSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<IntSeq>&, const IceUtil::Optional<IntSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntSeqReq.
 */
template<class T, typename CT> Callback_Initial_opIntSeqReqPtr
newCallback_Initial_opIntSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<IntSeq>&, const IceUtil::Optional<IntSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opLongSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opLongSeq.
 */
template<class T>
class CallbackNC_Initial_opLongSeq : public Callback_Initial_opLongSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<LongSeq>&, const IceUtil::Optional<LongSeq>&);

    CallbackNC_Initial_opLongSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<LongSeq> iceP_p3;
        IceUtil::Optional<LongSeq> ret;
        try
        {
            ret = proxy->end_opLongSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLongSeq.
 */
template<class T> Callback_Initial_opLongSeqPtr
newCallback_Initial_opLongSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<LongSeq>&, const IceUtil::Optional<LongSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opLongSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLongSeq.
 */
template<class T> Callback_Initial_opLongSeqPtr
newCallback_Initial_opLongSeq(T* instance, void (T::*cb)(const IceUtil::Optional<LongSeq>&, const IceUtil::Optional<LongSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opLongSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opLongSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opLongSeq.
 */
template<class T, typename CT>
class Callback_Initial_opLongSeq : public Callback_Initial_opLongSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<LongSeq>&, const IceUtil::Optional<LongSeq>&, const CT&);

    Callback_Initial_opLongSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<LongSeq> iceP_p3;
        IceUtil::Optional<LongSeq> ret;
        try
        {
            ret = proxy->end_opLongSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLongSeq.
 */
template<class T, typename CT> Callback_Initial_opLongSeqPtr
newCallback_Initial_opLongSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<LongSeq>&, const IceUtil::Optional<LongSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opLongSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLongSeq.
 */
template<class T, typename CT> Callback_Initial_opLongSeqPtr
newCallback_Initial_opLongSeq(T* instance, void (T::*cb)(const IceUtil::Optional<LongSeq>&, const IceUtil::Optional<LongSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opLongSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opLongSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opLongSeqReq.
 */
template<class T>
class CallbackNC_Initial_opLongSeqReq : public Callback_Initial_opLongSeqReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<LongSeq>&, const IceUtil::Optional<LongSeq>&);

    CallbackNC_Initial_opLongSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<LongSeq> iceP_p3;
        IceUtil::Optional<LongSeq> ret;
        try
        {
            ret = proxy->end_opLongSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLongSeqReq.
 */
template<class T> Callback_Initial_opLongSeqReqPtr
newCallback_Initial_opLongSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<LongSeq>&, const IceUtil::Optional<LongSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opLongSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLongSeqReq.
 */
template<class T> Callback_Initial_opLongSeqReqPtr
newCallback_Initial_opLongSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<LongSeq>&, const IceUtil::Optional<LongSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opLongSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opLongSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opLongSeqReq.
 */
template<class T, typename CT>
class Callback_Initial_opLongSeqReq : public Callback_Initial_opLongSeqReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<LongSeq>&, const IceUtil::Optional<LongSeq>&, const CT&);

    Callback_Initial_opLongSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<LongSeq> iceP_p3;
        IceUtil::Optional<LongSeq> ret;
        try
        {
            ret = proxy->end_opLongSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLongSeqReq.
 */
template<class T, typename CT> Callback_Initial_opLongSeqReqPtr
newCallback_Initial_opLongSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<LongSeq>&, const IceUtil::Optional<LongSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opLongSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opLongSeqReq.
 */
template<class T, typename CT> Callback_Initial_opLongSeqReqPtr
newCallback_Initial_opLongSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<LongSeq>&, const IceUtil::Optional<LongSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opLongSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opFloatSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFloatSeq.
 */
template<class T>
class CallbackNC_Initial_opFloatSeq : public Callback_Initial_opFloatSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<FloatSeq>&, const IceUtil::Optional<FloatSeq>&);

    CallbackNC_Initial_opFloatSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FloatSeq> iceP_p3;
        IceUtil::Optional<FloatSeq> ret;
        try
        {
            ret = proxy->end_opFloatSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloatSeq.
 */
template<class T> Callback_Initial_opFloatSeqPtr
newCallback_Initial_opFloatSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FloatSeq>&, const IceUtil::Optional<FloatSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFloatSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloatSeq.
 */
template<class T> Callback_Initial_opFloatSeqPtr
newCallback_Initial_opFloatSeq(T* instance, void (T::*cb)(const IceUtil::Optional<FloatSeq>&, const IceUtil::Optional<FloatSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFloatSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opFloatSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFloatSeq.
 */
template<class T, typename CT>
class Callback_Initial_opFloatSeq : public Callback_Initial_opFloatSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<FloatSeq>&, const IceUtil::Optional<FloatSeq>&, const CT&);

    Callback_Initial_opFloatSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FloatSeq> iceP_p3;
        IceUtil::Optional<FloatSeq> ret;
        try
        {
            ret = proxy->end_opFloatSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloatSeq.
 */
template<class T, typename CT> Callback_Initial_opFloatSeqPtr
newCallback_Initial_opFloatSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FloatSeq>&, const IceUtil::Optional<FloatSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFloatSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloatSeq.
 */
template<class T, typename CT> Callback_Initial_opFloatSeqPtr
newCallback_Initial_opFloatSeq(T* instance, void (T::*cb)(const IceUtil::Optional<FloatSeq>&, const IceUtil::Optional<FloatSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFloatSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opFloatSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFloatSeqReq.
 */
template<class T>
class CallbackNC_Initial_opFloatSeqReq : public Callback_Initial_opFloatSeqReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<FloatSeq>&, const IceUtil::Optional<FloatSeq>&);

    CallbackNC_Initial_opFloatSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FloatSeq> iceP_p3;
        IceUtil::Optional<FloatSeq> ret;
        try
        {
            ret = proxy->end_opFloatSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloatSeqReq.
 */
template<class T> Callback_Initial_opFloatSeqReqPtr
newCallback_Initial_opFloatSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FloatSeq>&, const IceUtil::Optional<FloatSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFloatSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloatSeqReq.
 */
template<class T> Callback_Initial_opFloatSeqReqPtr
newCallback_Initial_opFloatSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<FloatSeq>&, const IceUtil::Optional<FloatSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFloatSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opFloatSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFloatSeqReq.
 */
template<class T, typename CT>
class Callback_Initial_opFloatSeqReq : public Callback_Initial_opFloatSeqReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<FloatSeq>&, const IceUtil::Optional<FloatSeq>&, const CT&);

    Callback_Initial_opFloatSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FloatSeq> iceP_p3;
        IceUtil::Optional<FloatSeq> ret;
        try
        {
            ret = proxy->end_opFloatSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloatSeqReq.
 */
template<class T, typename CT> Callback_Initial_opFloatSeqReqPtr
newCallback_Initial_opFloatSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FloatSeq>&, const IceUtil::Optional<FloatSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFloatSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFloatSeqReq.
 */
template<class T, typename CT> Callback_Initial_opFloatSeqReqPtr
newCallback_Initial_opFloatSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<FloatSeq>&, const IceUtil::Optional<FloatSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFloatSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opDoubleSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDoubleSeq.
 */
template<class T>
class CallbackNC_Initial_opDoubleSeq : public Callback_Initial_opDoubleSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<DoubleSeq>&, const IceUtil::Optional<DoubleSeq>&);

    CallbackNC_Initial_opDoubleSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<DoubleSeq> iceP_p3;
        IceUtil::Optional<DoubleSeq> ret;
        try
        {
            ret = proxy->end_opDoubleSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDoubleSeq.
 */
template<class T> Callback_Initial_opDoubleSeqPtr
newCallback_Initial_opDoubleSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<DoubleSeq>&, const IceUtil::Optional<DoubleSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDoubleSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDoubleSeq.
 */
template<class T> Callback_Initial_opDoubleSeqPtr
newCallback_Initial_opDoubleSeq(T* instance, void (T::*cb)(const IceUtil::Optional<DoubleSeq>&, const IceUtil::Optional<DoubleSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDoubleSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opDoubleSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDoubleSeq.
 */
template<class T, typename CT>
class Callback_Initial_opDoubleSeq : public Callback_Initial_opDoubleSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<DoubleSeq>&, const IceUtil::Optional<DoubleSeq>&, const CT&);

    Callback_Initial_opDoubleSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<DoubleSeq> iceP_p3;
        IceUtil::Optional<DoubleSeq> ret;
        try
        {
            ret = proxy->end_opDoubleSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDoubleSeq.
 */
template<class T, typename CT> Callback_Initial_opDoubleSeqPtr
newCallback_Initial_opDoubleSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<DoubleSeq>&, const IceUtil::Optional<DoubleSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDoubleSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDoubleSeq.
 */
template<class T, typename CT> Callback_Initial_opDoubleSeqPtr
newCallback_Initial_opDoubleSeq(T* instance, void (T::*cb)(const IceUtil::Optional<DoubleSeq>&, const IceUtil::Optional<DoubleSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDoubleSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opDoubleSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDoubleSeqReq.
 */
template<class T>
class CallbackNC_Initial_opDoubleSeqReq : public Callback_Initial_opDoubleSeqReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<DoubleSeq>&, const IceUtil::Optional<DoubleSeq>&);

    CallbackNC_Initial_opDoubleSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<DoubleSeq> iceP_p3;
        IceUtil::Optional<DoubleSeq> ret;
        try
        {
            ret = proxy->end_opDoubleSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDoubleSeqReq.
 */
template<class T> Callback_Initial_opDoubleSeqReqPtr
newCallback_Initial_opDoubleSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<DoubleSeq>&, const IceUtil::Optional<DoubleSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDoubleSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDoubleSeqReq.
 */
template<class T> Callback_Initial_opDoubleSeqReqPtr
newCallback_Initial_opDoubleSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<DoubleSeq>&, const IceUtil::Optional<DoubleSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opDoubleSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opDoubleSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opDoubleSeqReq.
 */
template<class T, typename CT>
class Callback_Initial_opDoubleSeqReq : public Callback_Initial_opDoubleSeqReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<DoubleSeq>&, const IceUtil::Optional<DoubleSeq>&, const CT&);

    Callback_Initial_opDoubleSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<DoubleSeq> iceP_p3;
        IceUtil::Optional<DoubleSeq> ret;
        try
        {
            ret = proxy->end_opDoubleSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDoubleSeqReq.
 */
template<class T, typename CT> Callback_Initial_opDoubleSeqReqPtr
newCallback_Initial_opDoubleSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<DoubleSeq>&, const IceUtil::Optional<DoubleSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDoubleSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opDoubleSeqReq.
 */
template<class T, typename CT> Callback_Initial_opDoubleSeqReqPtr
newCallback_Initial_opDoubleSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<DoubleSeq>&, const IceUtil::Optional<DoubleSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opDoubleSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringSeq.
 */
template<class T>
class CallbackNC_Initial_opStringSeq : public Callback_Initial_opStringSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&);

    CallbackNC_Initial_opStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringSeq> iceP_p3;
        IceUtil::Optional<StringSeq> ret;
        try
        {
            ret = proxy->end_opStringSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringSeq.
 */
template<class T> Callback_Initial_opStringSeqPtr
newCallback_Initial_opStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opStringSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringSeq.
 */
template<class T> Callback_Initial_opStringSeqPtr
newCallback_Initial_opStringSeq(T* instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opStringSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringSeq.
 */
template<class T, typename CT>
class Callback_Initial_opStringSeq : public Callback_Initial_opStringSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&, const CT&);

    Callback_Initial_opStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringSeq> iceP_p3;
        IceUtil::Optional<StringSeq> ret;
        try
        {
            ret = proxy->end_opStringSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringSeq.
 */
template<class T, typename CT> Callback_Initial_opStringSeqPtr
newCallback_Initial_opStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opStringSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringSeq.
 */
template<class T, typename CT> Callback_Initial_opStringSeqPtr
newCallback_Initial_opStringSeq(T* instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opStringSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opStringSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringSeqReq.
 */
template<class T>
class CallbackNC_Initial_opStringSeqReq : public Callback_Initial_opStringSeqReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&);

    CallbackNC_Initial_opStringSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringSeq> iceP_p3;
        IceUtil::Optional<StringSeq> ret;
        try
        {
            ret = proxy->end_opStringSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringSeqReq.
 */
template<class T> Callback_Initial_opStringSeqReqPtr
newCallback_Initial_opStringSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opStringSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringSeqReq.
 */
template<class T> Callback_Initial_opStringSeqReqPtr
newCallback_Initial_opStringSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opStringSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opStringSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringSeqReq.
 */
template<class T, typename CT>
class Callback_Initial_opStringSeqReq : public Callback_Initial_opStringSeqReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&, const CT&);

    Callback_Initial_opStringSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringSeq> iceP_p3;
        IceUtil::Optional<StringSeq> ret;
        try
        {
            ret = proxy->end_opStringSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringSeqReq.
 */
template<class T, typename CT> Callback_Initial_opStringSeqReqPtr
newCallback_Initial_opStringSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opStringSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringSeqReq.
 */
template<class T, typename CT> Callback_Initial_opStringSeqReqPtr
newCallback_Initial_opStringSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opStringSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructSeq.
 */
template<class T>
class CallbackNC_Initial_opSmallStructSeq : public Callback_Initial_opSmallStructSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStructSeq>&, const IceUtil::Optional<SmallStructSeq>&);

    CallbackNC_Initial_opSmallStructSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStructSeq> iceP_p3;
        IceUtil::Optional<SmallStructSeq> ret;
        try
        {
            ret = proxy->end_opSmallStructSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructSeq.
 */
template<class T> Callback_Initial_opSmallStructSeqPtr
newCallback_Initial_opSmallStructSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStructSeq>&, const IceUtil::Optional<SmallStructSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStructSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructSeq.
 */
template<class T> Callback_Initial_opSmallStructSeqPtr
newCallback_Initial_opSmallStructSeq(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStructSeq>&, const IceUtil::Optional<SmallStructSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStructSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructSeq.
 */
template<class T, typename CT>
class Callback_Initial_opSmallStructSeq : public Callback_Initial_opSmallStructSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStructSeq>&, const IceUtil::Optional<SmallStructSeq>&, const CT&);

    Callback_Initial_opSmallStructSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStructSeq> iceP_p3;
        IceUtil::Optional<SmallStructSeq> ret;
        try
        {
            ret = proxy->end_opSmallStructSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructSeq.
 */
template<class T, typename CT> Callback_Initial_opSmallStructSeqPtr
newCallback_Initial_opSmallStructSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStructSeq>&, const IceUtil::Optional<SmallStructSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStructSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructSeq.
 */
template<class T, typename CT> Callback_Initial_opSmallStructSeqPtr
newCallback_Initial_opSmallStructSeq(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStructSeq>&, const IceUtil::Optional<SmallStructSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStructSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructSeqReq.
 */
template<class T>
class CallbackNC_Initial_opSmallStructSeqReq : public Callback_Initial_opSmallStructSeqReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStructSeq>&, const IceUtil::Optional<SmallStructSeq>&);

    CallbackNC_Initial_opSmallStructSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStructSeq> iceP_p3;
        IceUtil::Optional<SmallStructSeq> ret;
        try
        {
            ret = proxy->end_opSmallStructSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructSeqReq.
 */
template<class T> Callback_Initial_opSmallStructSeqReqPtr
newCallback_Initial_opSmallStructSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStructSeq>&, const IceUtil::Optional<SmallStructSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStructSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructSeqReq.
 */
template<class T> Callback_Initial_opSmallStructSeqReqPtr
newCallback_Initial_opSmallStructSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStructSeq>&, const IceUtil::Optional<SmallStructSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStructSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructSeqReq.
 */
template<class T, typename CT>
class Callback_Initial_opSmallStructSeqReq : public Callback_Initial_opSmallStructSeqReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStructSeq>&, const IceUtil::Optional<SmallStructSeq>&, const CT&);

    Callback_Initial_opSmallStructSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStructSeq> iceP_p3;
        IceUtil::Optional<SmallStructSeq> ret;
        try
        {
            ret = proxy->end_opSmallStructSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructSeqReq.
 */
template<class T, typename CT> Callback_Initial_opSmallStructSeqReqPtr
newCallback_Initial_opSmallStructSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStructSeq>&, const IceUtil::Optional<SmallStructSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStructSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructSeqReq.
 */
template<class T, typename CT> Callback_Initial_opSmallStructSeqReqPtr
newCallback_Initial_opSmallStructSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStructSeq>&, const IceUtil::Optional<SmallStructSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStructSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructList.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructList.
 */
template<class T>
class CallbackNC_Initial_opSmallStructList : public Callback_Initial_opSmallStructList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStructList>&, const IceUtil::Optional<SmallStructList>&);

    CallbackNC_Initial_opSmallStructList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStructList> iceP_p3;
        IceUtil::Optional<SmallStructList> ret;
        try
        {
            ret = proxy->end_opSmallStructList(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructList.
 */
template<class T> Callback_Initial_opSmallStructListPtr
newCallback_Initial_opSmallStructList(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStructList>&, const IceUtil::Optional<SmallStructList>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStructList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructList.
 */
template<class T> Callback_Initial_opSmallStructListPtr
newCallback_Initial_opSmallStructList(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStructList>&, const IceUtil::Optional<SmallStructList>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStructList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructList.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructList.
 */
template<class T, typename CT>
class Callback_Initial_opSmallStructList : public Callback_Initial_opSmallStructList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStructList>&, const IceUtil::Optional<SmallStructList>&, const CT&);

    Callback_Initial_opSmallStructList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStructList> iceP_p3;
        IceUtil::Optional<SmallStructList> ret;
        try
        {
            ret = proxy->end_opSmallStructList(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructList.
 */
template<class T, typename CT> Callback_Initial_opSmallStructListPtr
newCallback_Initial_opSmallStructList(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStructList>&, const IceUtil::Optional<SmallStructList>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStructList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructList.
 */
template<class T, typename CT> Callback_Initial_opSmallStructListPtr
newCallback_Initial_opSmallStructList(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStructList>&, const IceUtil::Optional<SmallStructList>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStructList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructListReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructListReq.
 */
template<class T>
class CallbackNC_Initial_opSmallStructListReq : public Callback_Initial_opSmallStructListReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStructList>&, const IceUtil::Optional<SmallStructList>&);

    CallbackNC_Initial_opSmallStructListReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStructList> iceP_p3;
        IceUtil::Optional<SmallStructList> ret;
        try
        {
            ret = proxy->end_opSmallStructListReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructListReq.
 */
template<class T> Callback_Initial_opSmallStructListReqPtr
newCallback_Initial_opSmallStructListReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStructList>&, const IceUtil::Optional<SmallStructList>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStructListReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructListReq.
 */
template<class T> Callback_Initial_opSmallStructListReqPtr
newCallback_Initial_opSmallStructListReq(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStructList>&, const IceUtil::Optional<SmallStructList>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSmallStructListReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opSmallStructListReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSmallStructListReq.
 */
template<class T, typename CT>
class Callback_Initial_opSmallStructListReq : public Callback_Initial_opSmallStructListReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStructList>&, const IceUtil::Optional<SmallStructList>&, const CT&);

    Callback_Initial_opSmallStructListReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStructList> iceP_p3;
        IceUtil::Optional<SmallStructList> ret;
        try
        {
            ret = proxy->end_opSmallStructListReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructListReq.
 */
template<class T, typename CT> Callback_Initial_opSmallStructListReqPtr
newCallback_Initial_opSmallStructListReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStructList>&, const IceUtil::Optional<SmallStructList>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStructListReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSmallStructListReq.
 */
template<class T, typename CT> Callback_Initial_opSmallStructListReqPtr
newCallback_Initial_opSmallStructListReq(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStructList>&, const IceUtil::Optional<SmallStructList>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSmallStructListReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructSeq.
 */
template<class T>
class CallbackNC_Initial_opFixedStructSeq : public Callback_Initial_opFixedStructSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<FixedStructSeq>&, const IceUtil::Optional<FixedStructSeq>&);

    CallbackNC_Initial_opFixedStructSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FixedStructSeq> iceP_p3;
        IceUtil::Optional<FixedStructSeq> ret;
        try
        {
            ret = proxy->end_opFixedStructSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructSeq.
 */
template<class T> Callback_Initial_opFixedStructSeqPtr
newCallback_Initial_opFixedStructSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FixedStructSeq>&, const IceUtil::Optional<FixedStructSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStructSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructSeq.
 */
template<class T> Callback_Initial_opFixedStructSeqPtr
newCallback_Initial_opFixedStructSeq(T* instance, void (T::*cb)(const IceUtil::Optional<FixedStructSeq>&, const IceUtil::Optional<FixedStructSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStructSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructSeq.
 */
template<class T, typename CT>
class Callback_Initial_opFixedStructSeq : public Callback_Initial_opFixedStructSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<FixedStructSeq>&, const IceUtil::Optional<FixedStructSeq>&, const CT&);

    Callback_Initial_opFixedStructSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FixedStructSeq> iceP_p3;
        IceUtil::Optional<FixedStructSeq> ret;
        try
        {
            ret = proxy->end_opFixedStructSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructSeq.
 */
template<class T, typename CT> Callback_Initial_opFixedStructSeqPtr
newCallback_Initial_opFixedStructSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FixedStructSeq>&, const IceUtil::Optional<FixedStructSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStructSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructSeq.
 */
template<class T, typename CT> Callback_Initial_opFixedStructSeqPtr
newCallback_Initial_opFixedStructSeq(T* instance, void (T::*cb)(const IceUtil::Optional<FixedStructSeq>&, const IceUtil::Optional<FixedStructSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStructSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructSeqReq.
 */
template<class T>
class CallbackNC_Initial_opFixedStructSeqReq : public Callback_Initial_opFixedStructSeqReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<FixedStructSeq>&, const IceUtil::Optional<FixedStructSeq>&);

    CallbackNC_Initial_opFixedStructSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FixedStructSeq> iceP_p3;
        IceUtil::Optional<FixedStructSeq> ret;
        try
        {
            ret = proxy->end_opFixedStructSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructSeqReq.
 */
template<class T> Callback_Initial_opFixedStructSeqReqPtr
newCallback_Initial_opFixedStructSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FixedStructSeq>&, const IceUtil::Optional<FixedStructSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStructSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructSeqReq.
 */
template<class T> Callback_Initial_opFixedStructSeqReqPtr
newCallback_Initial_opFixedStructSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<FixedStructSeq>&, const IceUtil::Optional<FixedStructSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStructSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructSeqReq.
 */
template<class T, typename CT>
class Callback_Initial_opFixedStructSeqReq : public Callback_Initial_opFixedStructSeqReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<FixedStructSeq>&, const IceUtil::Optional<FixedStructSeq>&, const CT&);

    Callback_Initial_opFixedStructSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FixedStructSeq> iceP_p3;
        IceUtil::Optional<FixedStructSeq> ret;
        try
        {
            ret = proxy->end_opFixedStructSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructSeqReq.
 */
template<class T, typename CT> Callback_Initial_opFixedStructSeqReqPtr
newCallback_Initial_opFixedStructSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FixedStructSeq>&, const IceUtil::Optional<FixedStructSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStructSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructSeqReq.
 */
template<class T, typename CT> Callback_Initial_opFixedStructSeqReqPtr
newCallback_Initial_opFixedStructSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<FixedStructSeq>&, const IceUtil::Optional<FixedStructSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStructSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructList.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructList.
 */
template<class T>
class CallbackNC_Initial_opFixedStructList : public Callback_Initial_opFixedStructList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<FixedStructList>&, const IceUtil::Optional<FixedStructList>&);

    CallbackNC_Initial_opFixedStructList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FixedStructList> iceP_p3;
        IceUtil::Optional<FixedStructList> ret;
        try
        {
            ret = proxy->end_opFixedStructList(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructList.
 */
template<class T> Callback_Initial_opFixedStructListPtr
newCallback_Initial_opFixedStructList(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FixedStructList>&, const IceUtil::Optional<FixedStructList>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStructList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructList.
 */
template<class T> Callback_Initial_opFixedStructListPtr
newCallback_Initial_opFixedStructList(T* instance, void (T::*cb)(const IceUtil::Optional<FixedStructList>&, const IceUtil::Optional<FixedStructList>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStructList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructList.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructList.
 */
template<class T, typename CT>
class Callback_Initial_opFixedStructList : public Callback_Initial_opFixedStructList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<FixedStructList>&, const IceUtil::Optional<FixedStructList>&, const CT&);

    Callback_Initial_opFixedStructList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FixedStructList> iceP_p3;
        IceUtil::Optional<FixedStructList> ret;
        try
        {
            ret = proxy->end_opFixedStructList(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructList.
 */
template<class T, typename CT> Callback_Initial_opFixedStructListPtr
newCallback_Initial_opFixedStructList(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FixedStructList>&, const IceUtil::Optional<FixedStructList>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStructList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructList.
 */
template<class T, typename CT> Callback_Initial_opFixedStructListPtr
newCallback_Initial_opFixedStructList(T* instance, void (T::*cb)(const IceUtil::Optional<FixedStructList>&, const IceUtil::Optional<FixedStructList>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStructList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructListReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructListReq.
 */
template<class T>
class CallbackNC_Initial_opFixedStructListReq : public Callback_Initial_opFixedStructListReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<FixedStructList>&, const IceUtil::Optional<FixedStructList>&);

    CallbackNC_Initial_opFixedStructListReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FixedStructList> iceP_p3;
        IceUtil::Optional<FixedStructList> ret;
        try
        {
            ret = proxy->end_opFixedStructListReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructListReq.
 */
template<class T> Callback_Initial_opFixedStructListReqPtr
newCallback_Initial_opFixedStructListReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FixedStructList>&, const IceUtil::Optional<FixedStructList>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStructListReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructListReq.
 */
template<class T> Callback_Initial_opFixedStructListReqPtr
newCallback_Initial_opFixedStructListReq(T* instance, void (T::*cb)(const IceUtil::Optional<FixedStructList>&, const IceUtil::Optional<FixedStructList>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opFixedStructListReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opFixedStructListReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opFixedStructListReq.
 */
template<class T, typename CT>
class Callback_Initial_opFixedStructListReq : public Callback_Initial_opFixedStructListReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<FixedStructList>&, const IceUtil::Optional<FixedStructList>&, const CT&);

    Callback_Initial_opFixedStructListReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<FixedStructList> iceP_p3;
        IceUtil::Optional<FixedStructList> ret;
        try
        {
            ret = proxy->end_opFixedStructListReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructListReq.
 */
template<class T, typename CT> Callback_Initial_opFixedStructListReqPtr
newCallback_Initial_opFixedStructListReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<FixedStructList>&, const IceUtil::Optional<FixedStructList>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStructListReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opFixedStructListReq.
 */
template<class T, typename CT> Callback_Initial_opFixedStructListReqPtr
newCallback_Initial_opFixedStructListReq(T* instance, void (T::*cb)(const IceUtil::Optional<FixedStructList>&, const IceUtil::Optional<FixedStructList>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opFixedStructListReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opVarStructSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVarStructSeq.
 */
template<class T>
class CallbackNC_Initial_opVarStructSeq : public Callback_Initial_opVarStructSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<VarStructSeq>&, const IceUtil::Optional<VarStructSeq>&);

    CallbackNC_Initial_opVarStructSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<VarStructSeq> iceP_p3;
        IceUtil::Optional<VarStructSeq> ret;
        try
        {
            ret = proxy->end_opVarStructSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStructSeq.
 */
template<class T> Callback_Initial_opVarStructSeqPtr
newCallback_Initial_opVarStructSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<VarStructSeq>&, const IceUtil::Optional<VarStructSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVarStructSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStructSeq.
 */
template<class T> Callback_Initial_opVarStructSeqPtr
newCallback_Initial_opVarStructSeq(T* instance, void (T::*cb)(const IceUtil::Optional<VarStructSeq>&, const IceUtil::Optional<VarStructSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVarStructSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opVarStructSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVarStructSeq.
 */
template<class T, typename CT>
class Callback_Initial_opVarStructSeq : public Callback_Initial_opVarStructSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<VarStructSeq>&, const IceUtil::Optional<VarStructSeq>&, const CT&);

    Callback_Initial_opVarStructSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<VarStructSeq> iceP_p3;
        IceUtil::Optional<VarStructSeq> ret;
        try
        {
            ret = proxy->end_opVarStructSeq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStructSeq.
 */
template<class T, typename CT> Callback_Initial_opVarStructSeqPtr
newCallback_Initial_opVarStructSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<VarStructSeq>&, const IceUtil::Optional<VarStructSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVarStructSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStructSeq.
 */
template<class T, typename CT> Callback_Initial_opVarStructSeqPtr
newCallback_Initial_opVarStructSeq(T* instance, void (T::*cb)(const IceUtil::Optional<VarStructSeq>&, const IceUtil::Optional<VarStructSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVarStructSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opVarStructSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVarStructSeqReq.
 */
template<class T>
class CallbackNC_Initial_opVarStructSeqReq : public Callback_Initial_opVarStructSeqReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<VarStructSeq>&, const IceUtil::Optional<VarStructSeq>&);

    CallbackNC_Initial_opVarStructSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<VarStructSeq> iceP_p3;
        IceUtil::Optional<VarStructSeq> ret;
        try
        {
            ret = proxy->end_opVarStructSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStructSeqReq.
 */
template<class T> Callback_Initial_opVarStructSeqReqPtr
newCallback_Initial_opVarStructSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<VarStructSeq>&, const IceUtil::Optional<VarStructSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVarStructSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStructSeqReq.
 */
template<class T> Callback_Initial_opVarStructSeqReqPtr
newCallback_Initial_opVarStructSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<VarStructSeq>&, const IceUtil::Optional<VarStructSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVarStructSeqReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opVarStructSeqReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVarStructSeqReq.
 */
template<class T, typename CT>
class Callback_Initial_opVarStructSeqReq : public Callback_Initial_opVarStructSeqReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<VarStructSeq>&, const IceUtil::Optional<VarStructSeq>&, const CT&);

    Callback_Initial_opVarStructSeqReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<VarStructSeq> iceP_p3;
        IceUtil::Optional<VarStructSeq> ret;
        try
        {
            ret = proxy->end_opVarStructSeqReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStructSeqReq.
 */
template<class T, typename CT> Callback_Initial_opVarStructSeqReqPtr
newCallback_Initial_opVarStructSeqReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<VarStructSeq>&, const IceUtil::Optional<VarStructSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVarStructSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVarStructSeqReq.
 */
template<class T, typename CT> Callback_Initial_opVarStructSeqReqPtr
newCallback_Initial_opVarStructSeqReq(T* instance, void (T::*cb)(const IceUtil::Optional<VarStructSeq>&, const IceUtil::Optional<VarStructSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVarStructSeqReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opSerializable.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSerializable.
 */
template<class T>
class CallbackNC_Initial_opSerializable : public Callback_Initial_opSerializable_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<Serializable>&, const IceUtil::Optional<Serializable>&);

    CallbackNC_Initial_opSerializable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<Serializable> iceP_p3;
        IceUtil::Optional<Serializable> ret;
        try
        {
            ret = proxy->end_opSerializable(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSerializable.
 */
template<class T> Callback_Initial_opSerializablePtr
newCallback_Initial_opSerializable(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<Serializable>&, const IceUtil::Optional<Serializable>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSerializable<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSerializable.
 */
template<class T> Callback_Initial_opSerializablePtr
newCallback_Initial_opSerializable(T* instance, void (T::*cb)(const IceUtil::Optional<Serializable>&, const IceUtil::Optional<Serializable>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSerializable<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opSerializable.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSerializable.
 */
template<class T, typename CT>
class Callback_Initial_opSerializable : public Callback_Initial_opSerializable_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<Serializable>&, const IceUtil::Optional<Serializable>&, const CT&);

    Callback_Initial_opSerializable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<Serializable> iceP_p3;
        IceUtil::Optional<Serializable> ret;
        try
        {
            ret = proxy->end_opSerializable(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSerializable.
 */
template<class T, typename CT> Callback_Initial_opSerializablePtr
newCallback_Initial_opSerializable(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<Serializable>&, const IceUtil::Optional<Serializable>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSerializable<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSerializable.
 */
template<class T, typename CT> Callback_Initial_opSerializablePtr
newCallback_Initial_opSerializable(T* instance, void (T::*cb)(const IceUtil::Optional<Serializable>&, const IceUtil::Optional<Serializable>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSerializable<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opSerializableReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSerializableReq.
 */
template<class T>
class CallbackNC_Initial_opSerializableReq : public Callback_Initial_opSerializableReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<Serializable>&, const IceUtil::Optional<Serializable>&);

    CallbackNC_Initial_opSerializableReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<Serializable> iceP_p3;
        IceUtil::Optional<Serializable> ret;
        try
        {
            ret = proxy->end_opSerializableReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSerializableReq.
 */
template<class T> Callback_Initial_opSerializableReqPtr
newCallback_Initial_opSerializableReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<Serializable>&, const IceUtil::Optional<Serializable>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSerializableReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSerializableReq.
 */
template<class T> Callback_Initial_opSerializableReqPtr
newCallback_Initial_opSerializableReq(T* instance, void (T::*cb)(const IceUtil::Optional<Serializable>&, const IceUtil::Optional<Serializable>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opSerializableReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opSerializableReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opSerializableReq.
 */
template<class T, typename CT>
class Callback_Initial_opSerializableReq : public Callback_Initial_opSerializableReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<Serializable>&, const IceUtil::Optional<Serializable>&, const CT&);

    Callback_Initial_opSerializableReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<Serializable> iceP_p3;
        IceUtil::Optional<Serializable> ret;
        try
        {
            ret = proxy->end_opSerializableReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSerializableReq.
 */
template<class T, typename CT> Callback_Initial_opSerializableReqPtr
newCallback_Initial_opSerializableReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<Serializable>&, const IceUtil::Optional<Serializable>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSerializableReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opSerializableReq.
 */
template<class T, typename CT> Callback_Initial_opSerializableReqPtr
newCallback_Initial_opSerializableReq(T* instance, void (T::*cb)(const IceUtil::Optional<Serializable>&, const IceUtil::Optional<Serializable>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opSerializableReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opIntIntDict.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntIntDict.
 */
template<class T>
class CallbackNC_Initial_opIntIntDict : public Callback_Initial_opIntIntDict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<IntIntDict>&, const IceUtil::Optional<IntIntDict>&);

    CallbackNC_Initial_opIntIntDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<IntIntDict> iceP_p3;
        IceUtil::Optional<IntIntDict> ret;
        try
        {
            ret = proxy->end_opIntIntDict(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntIntDict.
 */
template<class T> Callback_Initial_opIntIntDictPtr
newCallback_Initial_opIntIntDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<IntIntDict>&, const IceUtil::Optional<IntIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntIntDict<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntIntDict.
 */
template<class T> Callback_Initial_opIntIntDictPtr
newCallback_Initial_opIntIntDict(T* instance, void (T::*cb)(const IceUtil::Optional<IntIntDict>&, const IceUtil::Optional<IntIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntIntDict<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opIntIntDict.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntIntDict.
 */
template<class T, typename CT>
class Callback_Initial_opIntIntDict : public Callback_Initial_opIntIntDict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<IntIntDict>&, const IceUtil::Optional<IntIntDict>&, const CT&);

    Callback_Initial_opIntIntDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<IntIntDict> iceP_p3;
        IceUtil::Optional<IntIntDict> ret;
        try
        {
            ret = proxy->end_opIntIntDict(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntIntDict.
 */
template<class T, typename CT> Callback_Initial_opIntIntDictPtr
newCallback_Initial_opIntIntDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<IntIntDict>&, const IceUtil::Optional<IntIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntIntDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntIntDict.
 */
template<class T, typename CT> Callback_Initial_opIntIntDictPtr
newCallback_Initial_opIntIntDict(T* instance, void (T::*cb)(const IceUtil::Optional<IntIntDict>&, const IceUtil::Optional<IntIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntIntDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opIntIntDictReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntIntDictReq.
 */
template<class T>
class CallbackNC_Initial_opIntIntDictReq : public Callback_Initial_opIntIntDictReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<IntIntDict>&, const IceUtil::Optional<IntIntDict>&);

    CallbackNC_Initial_opIntIntDictReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<IntIntDict> iceP_p3;
        IceUtil::Optional<IntIntDict> ret;
        try
        {
            ret = proxy->end_opIntIntDictReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntIntDictReq.
 */
template<class T> Callback_Initial_opIntIntDictReqPtr
newCallback_Initial_opIntIntDictReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<IntIntDict>&, const IceUtil::Optional<IntIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntIntDictReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntIntDictReq.
 */
template<class T> Callback_Initial_opIntIntDictReqPtr
newCallback_Initial_opIntIntDictReq(T* instance, void (T::*cb)(const IceUtil::Optional<IntIntDict>&, const IceUtil::Optional<IntIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntIntDictReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opIntIntDictReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntIntDictReq.
 */
template<class T, typename CT>
class Callback_Initial_opIntIntDictReq : public Callback_Initial_opIntIntDictReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<IntIntDict>&, const IceUtil::Optional<IntIntDict>&, const CT&);

    Callback_Initial_opIntIntDictReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<IntIntDict> iceP_p3;
        IceUtil::Optional<IntIntDict> ret;
        try
        {
            ret = proxy->end_opIntIntDictReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntIntDictReq.
 */
template<class T, typename CT> Callback_Initial_opIntIntDictReqPtr
newCallback_Initial_opIntIntDictReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<IntIntDict>&, const IceUtil::Optional<IntIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntIntDictReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntIntDictReq.
 */
template<class T, typename CT> Callback_Initial_opIntIntDictReqPtr
newCallback_Initial_opIntIntDictReq(T* instance, void (T::*cb)(const IceUtil::Optional<IntIntDict>&, const IceUtil::Optional<IntIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntIntDictReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opStringIntDict.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringIntDict.
 */
template<class T>
class CallbackNC_Initial_opStringIntDict : public Callback_Initial_opStringIntDict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&);

    CallbackNC_Initial_opStringIntDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringIntDict> iceP_p3;
        IceUtil::Optional<StringIntDict> ret;
        try
        {
            ret = proxy->end_opStringIntDict(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringIntDict.
 */
template<class T> Callback_Initial_opStringIntDictPtr
newCallback_Initial_opStringIntDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opStringIntDict<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringIntDict.
 */
template<class T> Callback_Initial_opStringIntDictPtr
newCallback_Initial_opStringIntDict(T* instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opStringIntDict<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opStringIntDict.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringIntDict.
 */
template<class T, typename CT>
class Callback_Initial_opStringIntDict : public Callback_Initial_opStringIntDict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&, const CT&);

    Callback_Initial_opStringIntDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringIntDict> iceP_p3;
        IceUtil::Optional<StringIntDict> ret;
        try
        {
            ret = proxy->end_opStringIntDict(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringIntDict.
 */
template<class T, typename CT> Callback_Initial_opStringIntDictPtr
newCallback_Initial_opStringIntDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opStringIntDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringIntDict.
 */
template<class T, typename CT> Callback_Initial_opStringIntDictPtr
newCallback_Initial_opStringIntDict(T* instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opStringIntDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opStringIntDictReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringIntDictReq.
 */
template<class T>
class CallbackNC_Initial_opStringIntDictReq : public Callback_Initial_opStringIntDictReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&);

    CallbackNC_Initial_opStringIntDictReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringIntDict> iceP_p3;
        IceUtil::Optional<StringIntDict> ret;
        try
        {
            ret = proxy->end_opStringIntDictReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringIntDictReq.
 */
template<class T> Callback_Initial_opStringIntDictReqPtr
newCallback_Initial_opStringIntDictReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opStringIntDictReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringIntDictReq.
 */
template<class T> Callback_Initial_opStringIntDictReqPtr
newCallback_Initial_opStringIntDictReq(T* instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opStringIntDictReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opStringIntDictReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opStringIntDictReq.
 */
template<class T, typename CT>
class Callback_Initial_opStringIntDictReq : public Callback_Initial_opStringIntDictReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&, const CT&);

    Callback_Initial_opStringIntDictReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringIntDict> iceP_p3;
        IceUtil::Optional<StringIntDict> ret;
        try
        {
            ret = proxy->end_opStringIntDictReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringIntDictReq.
 */
template<class T, typename CT> Callback_Initial_opStringIntDictReqPtr
newCallback_Initial_opStringIntDictReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opStringIntDictReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opStringIntDictReq.
 */
template<class T, typename CT> Callback_Initial_opStringIntDictReqPtr
newCallback_Initial_opStringIntDictReq(T* instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opStringIntDictReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opIntOneOptionalDict.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntOneOptionalDict.
 */
template<class T>
class CallbackNC_Initial_opIntOneOptionalDict : public Callback_Initial_opIntOneOptionalDict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<IntOneOptionalDict>&, const IceUtil::Optional<IntOneOptionalDict>&);

    CallbackNC_Initial_opIntOneOptionalDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<IntOneOptionalDict> iceP_p3;
        IceUtil::Optional<IntOneOptionalDict> ret;
        try
        {
            ret = proxy->end_opIntOneOptionalDict(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntOneOptionalDict.
 */
template<class T> Callback_Initial_opIntOneOptionalDictPtr
newCallback_Initial_opIntOneOptionalDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<IntOneOptionalDict>&, const IceUtil::Optional<IntOneOptionalDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntOneOptionalDict<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntOneOptionalDict.
 */
template<class T> Callback_Initial_opIntOneOptionalDictPtr
newCallback_Initial_opIntOneOptionalDict(T* instance, void (T::*cb)(const IceUtil::Optional<IntOneOptionalDict>&, const IceUtil::Optional<IntOneOptionalDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntOneOptionalDict<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opIntOneOptionalDict.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntOneOptionalDict.
 */
template<class T, typename CT>
class Callback_Initial_opIntOneOptionalDict : public Callback_Initial_opIntOneOptionalDict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<IntOneOptionalDict>&, const IceUtil::Optional<IntOneOptionalDict>&, const CT&);

    Callback_Initial_opIntOneOptionalDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<IntOneOptionalDict> iceP_p3;
        IceUtil::Optional<IntOneOptionalDict> ret;
        try
        {
            ret = proxy->end_opIntOneOptionalDict(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntOneOptionalDict.
 */
template<class T, typename CT> Callback_Initial_opIntOneOptionalDictPtr
newCallback_Initial_opIntOneOptionalDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<IntOneOptionalDict>&, const IceUtil::Optional<IntOneOptionalDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntOneOptionalDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntOneOptionalDict.
 */
template<class T, typename CT> Callback_Initial_opIntOneOptionalDictPtr
newCallback_Initial_opIntOneOptionalDict(T* instance, void (T::*cb)(const IceUtil::Optional<IntOneOptionalDict>&, const IceUtil::Optional<IntOneOptionalDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntOneOptionalDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opIntOneOptionalDictReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntOneOptionalDictReq.
 */
template<class T>
class CallbackNC_Initial_opIntOneOptionalDictReq : public Callback_Initial_opIntOneOptionalDictReq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<IntOneOptionalDict>&, const IceUtil::Optional<IntOneOptionalDict>&);

    CallbackNC_Initial_opIntOneOptionalDictReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<IntOneOptionalDict> iceP_p3;
        IceUtil::Optional<IntOneOptionalDict> ret;
        try
        {
            ret = proxy->end_opIntOneOptionalDictReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntOneOptionalDictReq.
 */
template<class T> Callback_Initial_opIntOneOptionalDictReqPtr
newCallback_Initial_opIntOneOptionalDictReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<IntOneOptionalDict>&, const IceUtil::Optional<IntOneOptionalDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntOneOptionalDictReq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntOneOptionalDictReq.
 */
template<class T> Callback_Initial_opIntOneOptionalDictReqPtr
newCallback_Initial_opIntOneOptionalDictReq(T* instance, void (T::*cb)(const IceUtil::Optional<IntOneOptionalDict>&, const IceUtil::Optional<IntOneOptionalDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opIntOneOptionalDictReq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opIntOneOptionalDictReq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opIntOneOptionalDictReq.
 */
template<class T, typename CT>
class Callback_Initial_opIntOneOptionalDictReq : public Callback_Initial_opIntOneOptionalDictReq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<IntOneOptionalDict>&, const IceUtil::Optional<IntOneOptionalDict>&, const CT&);

    Callback_Initial_opIntOneOptionalDictReq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<IntOneOptionalDict> iceP_p3;
        IceUtil::Optional<IntOneOptionalDict> ret;
        try
        {
            ret = proxy->end_opIntOneOptionalDictReq(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntOneOptionalDictReq.
 */
template<class T, typename CT> Callback_Initial_opIntOneOptionalDictReqPtr
newCallback_Initial_opIntOneOptionalDictReq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<IntOneOptionalDict>&, const IceUtil::Optional<IntOneOptionalDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntOneOptionalDictReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opIntOneOptionalDictReq.
 */
template<class T, typename CT> Callback_Initial_opIntOneOptionalDictReqPtr
newCallback_Initial_opIntOneOptionalDictReq(T* instance, void (T::*cb)(const IceUtil::Optional<IntOneOptionalDict>&, const IceUtil::Optional<IntOneOptionalDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opIntOneOptionalDictReq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opClassAndUnknownOptional.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opClassAndUnknownOptional.
 */
template<class T>
class CallbackNC_Initial_opClassAndUnknownOptional : public Callback_Initial_opClassAndUnknownOptional_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_opClassAndUnknownOptional(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opClassAndUnknownOptional.
 */
template<class T> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opClassAndUnknownOptional<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opClassAndUnknownOptional.
 */
template<class T> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opClassAndUnknownOptional<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opClassAndUnknownOptional.
 */
template<class T> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opClassAndUnknownOptional<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opClassAndUnknownOptional.
 */
template<class T> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opClassAndUnknownOptional<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opClassAndUnknownOptional.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opClassAndUnknownOptional.
 */
template<class T, typename CT>
class Callback_Initial_opClassAndUnknownOptional : public Callback_Initial_opClassAndUnknownOptional_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_opClassAndUnknownOptional(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opClassAndUnknownOptional.
 */
template<class T, typename CT> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opClassAndUnknownOptional<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opClassAndUnknownOptional.
 */
template<class T, typename CT> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opClassAndUnknownOptional<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opClassAndUnknownOptional.
 */
template<class T, typename CT> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opClassAndUnknownOptional<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opClassAndUnknownOptional.
 */
template<class T, typename CT> Callback_Initial_opClassAndUnknownOptionalPtr
newCallback_Initial_opClassAndUnknownOptional(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opClassAndUnknownOptional<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_sendOptionalClass.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_sendOptionalClass.
 */
template<class T>
class CallbackNC_Initial_sendOptionalClass : public Callback_Initial_sendOptionalClass_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_sendOptionalClass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_sendOptionalClass.
 */
template<class T> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_sendOptionalClass<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_sendOptionalClass.
 */
template<class T> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_sendOptionalClass<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_sendOptionalClass.
 */
template<class T> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_sendOptionalClass<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_sendOptionalClass.
 */
template<class T> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_sendOptionalClass<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_sendOptionalClass.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_sendOptionalClass.
 */
template<class T, typename CT>
class Callback_Initial_sendOptionalClass : public Callback_Initial_sendOptionalClass_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_sendOptionalClass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_sendOptionalClass.
 */
template<class T, typename CT> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_sendOptionalClass<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_sendOptionalClass.
 */
template<class T, typename CT> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_sendOptionalClass<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_sendOptionalClass.
 */
template<class T, typename CT> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_sendOptionalClass<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_sendOptionalClass.
 */
template<class T, typename CT> Callback_Initial_sendOptionalClassPtr
newCallback_Initial_sendOptionalClass(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_sendOptionalClass<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_returnOptionalClass.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_returnOptionalClass.
 */
template<class T>
class CallbackNC_Initial_returnOptionalClass : public Callback_Initial_returnOptionalClass_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<OneOptionalPtr>&);

    CallbackNC_Initial_returnOptionalClass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<OneOptionalPtr> iceP_o;
        try
        {
            proxy->end_returnOptionalClass(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_o);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_returnOptionalClass.
 */
template<class T> Callback_Initial_returnOptionalClassPtr
newCallback_Initial_returnOptionalClass(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_returnOptionalClass<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_returnOptionalClass.
 */
template<class T> Callback_Initial_returnOptionalClassPtr
newCallback_Initial_returnOptionalClass(T* instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_returnOptionalClass<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_returnOptionalClass.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_returnOptionalClass.
 */
template<class T, typename CT>
class Callback_Initial_returnOptionalClass : public Callback_Initial_returnOptionalClass_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<OneOptionalPtr>&, const CT&);

    Callback_Initial_returnOptionalClass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<OneOptionalPtr> iceP_o;
        try
        {
            proxy->end_returnOptionalClass(iceP_o, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_o, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_returnOptionalClass.
 */
template<class T, typename CT> Callback_Initial_returnOptionalClassPtr
newCallback_Initial_returnOptionalClass(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_returnOptionalClass<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_returnOptionalClass.
 */
template<class T, typename CT> Callback_Initial_returnOptionalClassPtr
newCallback_Initial_returnOptionalClass(T* instance, void (T::*cb)(const IceUtil::Optional<OneOptionalPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_returnOptionalClass<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opG.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opG.
 */
template<class T>
class CallbackNC_Initial_opG : public Callback_Initial_opG_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const GPtr&);

    CallbackNC_Initial_opG(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        GPtr ret;
        try
        {
            ret = proxy->end_opG(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opG.
 */
template<class T> Callback_Initial_opGPtr
newCallback_Initial_opG(const IceUtil::Handle<T>& instance, void (T::*cb)(const GPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opG<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opG.
 */
template<class T> Callback_Initial_opGPtr
newCallback_Initial_opG(T* instance, void (T::*cb)(const GPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opG<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opG.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opG.
 */
template<class T, typename CT>
class Callback_Initial_opG : public Callback_Initial_opG_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const GPtr&, const CT&);

    Callback_Initial_opG(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        GPtr ret;
        try
        {
            ret = proxy->end_opG(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opG.
 */
template<class T, typename CT> Callback_Initial_opGPtr
newCallback_Initial_opG(const IceUtil::Handle<T>& instance, void (T::*cb)(const GPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opG<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opG.
 */
template<class T, typename CT> Callback_Initial_opGPtr
newCallback_Initial_opG(T* instance, void (T::*cb)(const GPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opG<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opVoid.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVoid.
 */
template<class T>
class CallbackNC_Initial_opVoid : public Callback_Initial_opVoid_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_opVoid(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVoid.
 */
template<class T> Callback_Initial_opVoidPtr
newCallback_Initial_opVoid(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVoid<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVoid.
 */
template<class T> Callback_Initial_opVoidPtr
newCallback_Initial_opVoid(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVoid<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVoid.
 */
template<class T> Callback_Initial_opVoidPtr
newCallback_Initial_opVoid(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVoid<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVoid.
 */
template<class T> Callback_Initial_opVoidPtr
newCallback_Initial_opVoid(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opVoid<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opVoid.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opVoid.
 */
template<class T, typename CT>
class Callback_Initial_opVoid : public Callback_Initial_opVoid_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_opVoid(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVoid.
 */
template<class T, typename CT> Callback_Initial_opVoidPtr
newCallback_Initial_opVoid(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVoid<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVoid.
 */
template<class T, typename CT> Callback_Initial_opVoidPtr
newCallback_Initial_opVoid(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVoid<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVoid.
 */
template<class T, typename CT> Callback_Initial_opVoidPtr
newCallback_Initial_opVoid(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVoid<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opVoid.
 */
template<class T, typename CT> Callback_Initial_opVoidPtr
newCallback_Initial_opVoid(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opVoid<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opMStruct1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMStruct1.
 */
template<class T>
class CallbackNC_Initial_opMStruct1 : public Callback_Initial_opMStruct1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStruct>&);

    CallbackNC_Initial_opMStruct1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStruct> ret;
        try
        {
            ret = proxy->end_opMStruct1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMStruct1.
 */
template<class T> Callback_Initial_opMStruct1Ptr
newCallback_Initial_opMStruct1(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMStruct1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMStruct1.
 */
template<class T> Callback_Initial_opMStruct1Ptr
newCallback_Initial_opMStruct1(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMStruct1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opMStruct1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMStruct1.
 */
template<class T, typename CT>
class Callback_Initial_opMStruct1 : public Callback_Initial_opMStruct1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStruct>&, const CT&);

    Callback_Initial_opMStruct1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStruct> ret;
        try
        {
            ret = proxy->end_opMStruct1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMStruct1.
 */
template<class T, typename CT> Callback_Initial_opMStruct1Ptr
newCallback_Initial_opMStruct1(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMStruct1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMStruct1.
 */
template<class T, typename CT> Callback_Initial_opMStruct1Ptr
newCallback_Initial_opMStruct1(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMStruct1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opMStruct2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMStruct2.
 */
template<class T>
class CallbackNC_Initial_opMStruct2 : public Callback_Initial_opMStruct2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&);

    CallbackNC_Initial_opMStruct2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStruct> iceP_p2;
        IceUtil::Optional<SmallStruct> ret;
        try
        {
            ret = proxy->end_opMStruct2(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMStruct2.
 */
template<class T> Callback_Initial_opMStruct2Ptr
newCallback_Initial_opMStruct2(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMStruct2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMStruct2.
 */
template<class T> Callback_Initial_opMStruct2Ptr
newCallback_Initial_opMStruct2(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMStruct2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opMStruct2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMStruct2.
 */
template<class T, typename CT>
class Callback_Initial_opMStruct2 : public Callback_Initial_opMStruct2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&, const CT&);

    Callback_Initial_opMStruct2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<SmallStruct> iceP_p2;
        IceUtil::Optional<SmallStruct> ret;
        try
        {
            ret = proxy->end_opMStruct2(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMStruct2.
 */
template<class T, typename CT> Callback_Initial_opMStruct2Ptr
newCallback_Initial_opMStruct2(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMStruct2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMStruct2.
 */
template<class T, typename CT> Callback_Initial_opMStruct2Ptr
newCallback_Initial_opMStruct2(T* instance, void (T::*cb)(const IceUtil::Optional<SmallStruct>&, const IceUtil::Optional<SmallStruct>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMStruct2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opMSeq1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMSeq1.
 */
template<class T>
class CallbackNC_Initial_opMSeq1 : public Callback_Initial_opMSeq1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<StringSeq>&);

    CallbackNC_Initial_opMSeq1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringSeq> ret;
        try
        {
            ret = proxy->end_opMSeq1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMSeq1.
 */
template<class T> Callback_Initial_opMSeq1Ptr
newCallback_Initial_opMSeq1(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMSeq1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMSeq1.
 */
template<class T> Callback_Initial_opMSeq1Ptr
newCallback_Initial_opMSeq1(T* instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMSeq1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opMSeq1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMSeq1.
 */
template<class T, typename CT>
class Callback_Initial_opMSeq1 : public Callback_Initial_opMSeq1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<StringSeq>&, const CT&);

    Callback_Initial_opMSeq1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringSeq> ret;
        try
        {
            ret = proxy->end_opMSeq1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMSeq1.
 */
template<class T, typename CT> Callback_Initial_opMSeq1Ptr
newCallback_Initial_opMSeq1(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMSeq1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMSeq1.
 */
template<class T, typename CT> Callback_Initial_opMSeq1Ptr
newCallback_Initial_opMSeq1(T* instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMSeq1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opMSeq2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMSeq2.
 */
template<class T>
class CallbackNC_Initial_opMSeq2 : public Callback_Initial_opMSeq2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&);

    CallbackNC_Initial_opMSeq2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringSeq> iceP_p2;
        IceUtil::Optional<StringSeq> ret;
        try
        {
            ret = proxy->end_opMSeq2(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMSeq2.
 */
template<class T> Callback_Initial_opMSeq2Ptr
newCallback_Initial_opMSeq2(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMSeq2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMSeq2.
 */
template<class T> Callback_Initial_opMSeq2Ptr
newCallback_Initial_opMSeq2(T* instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMSeq2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opMSeq2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMSeq2.
 */
template<class T, typename CT>
class Callback_Initial_opMSeq2 : public Callback_Initial_opMSeq2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&, const CT&);

    Callback_Initial_opMSeq2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringSeq> iceP_p2;
        IceUtil::Optional<StringSeq> ret;
        try
        {
            ret = proxy->end_opMSeq2(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMSeq2.
 */
template<class T, typename CT> Callback_Initial_opMSeq2Ptr
newCallback_Initial_opMSeq2(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMSeq2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMSeq2.
 */
template<class T, typename CT> Callback_Initial_opMSeq2Ptr
newCallback_Initial_opMSeq2(T* instance, void (T::*cb)(const IceUtil::Optional<StringSeq>&, const IceUtil::Optional<StringSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMSeq2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opMDict1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMDict1.
 */
template<class T>
class CallbackNC_Initial_opMDict1 : public Callback_Initial_opMDict1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<StringIntDict>&);

    CallbackNC_Initial_opMDict1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringIntDict> ret;
        try
        {
            ret = proxy->end_opMDict1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMDict1.
 */
template<class T> Callback_Initial_opMDict1Ptr
newCallback_Initial_opMDict1(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMDict1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMDict1.
 */
template<class T> Callback_Initial_opMDict1Ptr
newCallback_Initial_opMDict1(T* instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMDict1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opMDict1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMDict1.
 */
template<class T, typename CT>
class Callback_Initial_opMDict1 : public Callback_Initial_opMDict1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<StringIntDict>&, const CT&);

    Callback_Initial_opMDict1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringIntDict> ret;
        try
        {
            ret = proxy->end_opMDict1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMDict1.
 */
template<class T, typename CT> Callback_Initial_opMDict1Ptr
newCallback_Initial_opMDict1(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMDict1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMDict1.
 */
template<class T, typename CT> Callback_Initial_opMDict1Ptr
newCallback_Initial_opMDict1(T* instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMDict1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opMDict2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMDict2.
 */
template<class T>
class CallbackNC_Initial_opMDict2 : public Callback_Initial_opMDict2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&);

    CallbackNC_Initial_opMDict2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringIntDict> iceP_p2;
        IceUtil::Optional<StringIntDict> ret;
        try
        {
            ret = proxy->end_opMDict2(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMDict2.
 */
template<class T> Callback_Initial_opMDict2Ptr
newCallback_Initial_opMDict2(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMDict2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMDict2.
 */
template<class T> Callback_Initial_opMDict2Ptr
newCallback_Initial_opMDict2(T* instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMDict2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opMDict2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMDict2.
 */
template<class T, typename CT>
class Callback_Initial_opMDict2 : public Callback_Initial_opMDict2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&, const CT&);

    Callback_Initial_opMDict2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<StringIntDict> iceP_p2;
        IceUtil::Optional<StringIntDict> ret;
        try
        {
            ret = proxy->end_opMDict2(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMDict2.
 */
template<class T, typename CT> Callback_Initial_opMDict2Ptr
newCallback_Initial_opMDict2(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMDict2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMDict2.
 */
template<class T, typename CT> Callback_Initial_opMDict2Ptr
newCallback_Initial_opMDict2(T* instance, void (T::*cb)(const IceUtil::Optional<StringIntDict>&, const IceUtil::Optional<StringIntDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMDict2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opMG1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMG1.
 */
template<class T>
class CallbackNC_Initial_opMG1 : public Callback_Initial_opMG1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<GPtr>&);

    CallbackNC_Initial_opMG1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<GPtr> ret;
        try
        {
            ret = proxy->end_opMG1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMG1.
 */
template<class T> Callback_Initial_opMG1Ptr
newCallback_Initial_opMG1(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<GPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMG1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMG1.
 */
template<class T> Callback_Initial_opMG1Ptr
newCallback_Initial_opMG1(T* instance, void (T::*cb)(const IceUtil::Optional<GPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMG1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opMG1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMG1.
 */
template<class T, typename CT>
class Callback_Initial_opMG1 : public Callback_Initial_opMG1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<GPtr>&, const CT&);

    Callback_Initial_opMG1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<GPtr> ret;
        try
        {
            ret = proxy->end_opMG1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMG1.
 */
template<class T, typename CT> Callback_Initial_opMG1Ptr
newCallback_Initial_opMG1(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<GPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMG1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMG1.
 */
template<class T, typename CT> Callback_Initial_opMG1Ptr
newCallback_Initial_opMG1(T* instance, void (T::*cb)(const IceUtil::Optional<GPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMG1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opMG2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMG2.
 */
template<class T>
class CallbackNC_Initial_opMG2 : public Callback_Initial_opMG2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional<GPtr>&, const IceUtil::Optional<GPtr>&);

    CallbackNC_Initial_opMG2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<GPtr> iceP_p2;
        IceUtil::Optional<GPtr> ret;
        try
        {
            ret = proxy->end_opMG2(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMG2.
 */
template<class T> Callback_Initial_opMG2Ptr
newCallback_Initial_opMG2(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<GPtr>&, const IceUtil::Optional<GPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMG2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMG2.
 */
template<class T> Callback_Initial_opMG2Ptr
newCallback_Initial_opMG2(T* instance, void (T::*cb)(const IceUtil::Optional<GPtr>&, const IceUtil::Optional<GPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opMG2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opMG2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opMG2.
 */
template<class T, typename CT>
class Callback_Initial_opMG2 : public Callback_Initial_opMG2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional<GPtr>&, const IceUtil::Optional<GPtr>&, const CT&);

    Callback_Initial_opMG2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IceUtil::Optional<GPtr> iceP_p2;
        IceUtil::Optional<GPtr> ret;
        try
        {
            ret = proxy->end_opMG2(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMG2.
 */
template<class T, typename CT> Callback_Initial_opMG2Ptr
newCallback_Initial_opMG2(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional<GPtr>&, const IceUtil::Optional<GPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMG2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opMG2.
 */
template<class T, typename CT> Callback_Initial_opMG2Ptr
newCallback_Initial_opMG2(T* instance, void (T::*cb)(const IceUtil::Optional<GPtr>&, const IceUtil::Optional<GPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opMG2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_supportsRequiredParams.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsRequiredParams.
 */
template<class T>
class CallbackNC_Initial_supportsRequiredParams : public Callback_Initial_supportsRequiredParams_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Initial_supportsRequiredParams(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsRequiredParams(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsRequiredParams.
 */
template<class T> Callback_Initial_supportsRequiredParamsPtr
newCallback_Initial_supportsRequiredParams(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsRequiredParams<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsRequiredParams.
 */
template<class T> Callback_Initial_supportsRequiredParamsPtr
newCallback_Initial_supportsRequiredParams(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsRequiredParams<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_supportsRequiredParams.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsRequiredParams.
 */
template<class T, typename CT>
class Callback_Initial_supportsRequiredParams : public Callback_Initial_supportsRequiredParams_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Initial_supportsRequiredParams(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsRequiredParams(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsRequiredParams.
 */
template<class T, typename CT> Callback_Initial_supportsRequiredParamsPtr
newCallback_Initial_supportsRequiredParams(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsRequiredParams<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsRequiredParams.
 */
template<class T, typename CT> Callback_Initial_supportsRequiredParamsPtr
newCallback_Initial_supportsRequiredParams(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsRequiredParams<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_supportsJavaSerializable.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsJavaSerializable.
 */
template<class T>
class CallbackNC_Initial_supportsJavaSerializable : public Callback_Initial_supportsJavaSerializable_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Initial_supportsJavaSerializable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsJavaSerializable(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsJavaSerializable.
 */
template<class T> Callback_Initial_supportsJavaSerializablePtr
newCallback_Initial_supportsJavaSerializable(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsJavaSerializable<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsJavaSerializable.
 */
template<class T> Callback_Initial_supportsJavaSerializablePtr
newCallback_Initial_supportsJavaSerializable(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsJavaSerializable<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_supportsJavaSerializable.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsJavaSerializable.
 */
template<class T, typename CT>
class Callback_Initial_supportsJavaSerializable : public Callback_Initial_supportsJavaSerializable_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Initial_supportsJavaSerializable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsJavaSerializable(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsJavaSerializable.
 */
template<class T, typename CT> Callback_Initial_supportsJavaSerializablePtr
newCallback_Initial_supportsJavaSerializable(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsJavaSerializable<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsJavaSerializable.
 */
template<class T, typename CT> Callback_Initial_supportsJavaSerializablePtr
newCallback_Initial_supportsJavaSerializable(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsJavaSerializable<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_supportsCsharpSerializable.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsCsharpSerializable.
 */
template<class T>
class CallbackNC_Initial_supportsCsharpSerializable : public Callback_Initial_supportsCsharpSerializable_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Initial_supportsCsharpSerializable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsCsharpSerializable(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsCsharpSerializable.
 */
template<class T> Callback_Initial_supportsCsharpSerializablePtr
newCallback_Initial_supportsCsharpSerializable(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsCsharpSerializable<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsCsharpSerializable.
 */
template<class T> Callback_Initial_supportsCsharpSerializablePtr
newCallback_Initial_supportsCsharpSerializable(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsCsharpSerializable<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_supportsCsharpSerializable.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsCsharpSerializable.
 */
template<class T, typename CT>
class Callback_Initial_supportsCsharpSerializable : public Callback_Initial_supportsCsharpSerializable_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Initial_supportsCsharpSerializable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsCsharpSerializable(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsCsharpSerializable.
 */
template<class T, typename CT> Callback_Initial_supportsCsharpSerializablePtr
newCallback_Initial_supportsCsharpSerializable(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsCsharpSerializable<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsCsharpSerializable.
 */
template<class T, typename CT> Callback_Initial_supportsCsharpSerializablePtr
newCallback_Initial_supportsCsharpSerializable(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsCsharpSerializable<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_supportsCppStringView.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsCppStringView.
 */
template<class T>
class CallbackNC_Initial_supportsCppStringView : public Callback_Initial_supportsCppStringView_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Initial_supportsCppStringView(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsCppStringView(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsCppStringView.
 */
template<class T> Callback_Initial_supportsCppStringViewPtr
newCallback_Initial_supportsCppStringView(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsCppStringView<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsCppStringView.
 */
template<class T> Callback_Initial_supportsCppStringViewPtr
newCallback_Initial_supportsCppStringView(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsCppStringView<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_supportsCppStringView.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsCppStringView.
 */
template<class T, typename CT>
class Callback_Initial_supportsCppStringView : public Callback_Initial_supportsCppStringView_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Initial_supportsCppStringView(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsCppStringView(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsCppStringView.
 */
template<class T, typename CT> Callback_Initial_supportsCppStringViewPtr
newCallback_Initial_supportsCppStringView(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsCppStringView<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsCppStringView.
 */
template<class T, typename CT> Callback_Initial_supportsCppStringViewPtr
newCallback_Initial_supportsCppStringView(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsCppStringView<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_supportsNullOptional.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsNullOptional.
 */
template<class T>
class CallbackNC_Initial_supportsNullOptional : public Callback_Initial_supportsNullOptional_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Initial_supportsNullOptional(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsNullOptional(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsNullOptional.
 */
template<class T> Callback_Initial_supportsNullOptionalPtr
newCallback_Initial_supportsNullOptional(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsNullOptional<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsNullOptional.
 */
template<class T> Callback_Initial_supportsNullOptionalPtr
newCallback_Initial_supportsNullOptional(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsNullOptional<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_supportsNullOptional.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsNullOptional.
 */
template<class T, typename CT>
class Callback_Initial_supportsNullOptional : public Callback_Initial_supportsNullOptional_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Initial_supportsNullOptional(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsNullOptional(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsNullOptional.
 */
template<class T, typename CT> Callback_Initial_supportsNullOptionalPtr
newCallback_Initial_supportsNullOptional(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsNullOptional<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsNullOptional.
 */
template<class T, typename CT> Callback_Initial_supportsNullOptionalPtr
newCallback_Initial_supportsNullOptional(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsNullOptional<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
