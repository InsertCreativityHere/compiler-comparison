//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/Context.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{

class MyClass;
class MyClassPrx;
struct AnotherStruct;
struct Structure;
struct MyStruct;
struct MyStruct1;
class MyClass1;
class MyDerivedClass;
class MyDerivedClassPrx;

}

namespace Test2
{

class MyDerivedClass;
class MyDerivedClassPrx;

}

namespace Test
{

enum class MyEnum : unsigned char
{
    enum1,
    enum2,
    enum3
};

using ByteS = ::std::vector<::Ice::Byte>;

using BoolS = ::std::vector<bool>;

using ShortS = ::std::vector<short>;

using IntS = ::std::vector<int>;

using LongS = ::std::vector<long long int>;

using FloatS = ::std::vector<float>;

using DoubleS = ::std::vector<double>;

using StringS = ::std::vector<::std::string>;

using WStringS = ::std::vector<::std::wstring>;

using MyEnumS = ::std::vector<MyEnum>;

using MyClassS = ::std::vector<::std::shared_ptr<MyClassPrx>>;

using ByteSS = ::std::vector<ByteS>;

using BoolSS = ::std::vector<BoolS>;

using ShortSS = ::std::vector<ShortS>;

using IntSS = ::std::vector<IntS>;

using LongSS = ::std::vector<LongS>;

using FloatSS = ::std::vector<FloatS>;

using DoubleSS = ::std::vector<DoubleS>;

using StringSS = ::std::vector<StringS>;

using MyEnumSS = ::std::vector<MyEnumS>;

using MyClassSS = ::std::vector<MyClassS>;

using StringSSS = ::std::vector<StringSS>;

using ByteBoolD = ::std::map<::Ice::Byte, bool>;

using ShortIntD = ::std::map<short, int>;

using LongFloatD = ::std::map<long long int, float>;

using StringStringD = ::std::map<::std::string, ::std::string>;

using StringMyEnumD = ::std::map<::std::string, MyEnum>;

using MyEnumStringD = ::std::map<MyEnum, ::std::string>;

using MyStructMyEnumD = ::std::map<MyStruct, MyEnum>;

using ByteBoolDS = ::std::vector<ByteBoolD>;

using ShortIntDS = ::std::vector<ShortIntD>;

using LongFloatDS = ::std::vector<LongFloatD>;

using StringStringDS = ::std::vector<StringStringD>;

using StringMyEnumDS = ::std::vector<StringMyEnumD>;

using MyEnumStringDS = ::std::vector<MyEnumStringD>;

using MyStructMyEnumDS = ::std::vector<MyStructMyEnumD>;

using ByteByteSD = ::std::map<::Ice::Byte, ByteS>;

using BoolBoolSD = ::std::map<bool, BoolS>;

using ShortShortSD = ::std::map<short, ShortS>;

using IntIntSD = ::std::map<int, IntS>;

using LongLongSD = ::std::map<long long int, LongS>;

using StringFloatSD = ::std::map<::std::string, FloatS>;

using StringDoubleSD = ::std::map<::std::string, DoubleS>;

using StringStringSD = ::std::map<::std::string, StringS>;

using MyEnumMyEnumSD = ::std::map<MyEnum, MyEnumS>;

const ::std::string s0 = "\\";

const ::std::string s1 = "A";

const ::std::string s2 = "Ice";

const ::std::string s3 = "A21";

const ::std::string s4 = "\\u0041 \\U00000041";

const ::std::string s5 = "\303\277";

const ::std::string s6 = "\317\277";

const ::std::string s7 = "\327\260";

const ::std::string s8 = "\360\220\200\200";

const ::std::string s9 = "\360\237\215\214";

const ::std::string s10 = "\340\266\247";

const ::std::string s11 = "\342\202\254\342\202\254\342\202\254";

const ::std::string s12 = "\\101";

const ::std::string sw0 = "\\";

const ::std::string sw1 = "A";

const ::std::string sw2 = "Ice";

const ::std::string sw3 = "A21";

const ::std::string sw4 = "\\u0041 \\U00000041";

const ::std::string sw5 = "\303\277";

const ::std::string sw6 = "\317\277";

const ::std::string sw7 = "\327\260";

const ::std::string sw8 = "\360\220\200\200";

const ::std::string sw9 = "\360\237\215\214";

const ::std::string sw10 = "\340\266\247";

/**
 * \'      single quote    byte 0x27 in ASCII encoding
 * \"      double quote    byte 0x22 in ASCII encoding
 * \?      question mark   byte 0x3f in ASCII encoding
 * \\      backslash       byte 0x5c in ASCII encoding
 * \a      audible bell    byte 0x07 in ASCII encoding
 * \b      backspace       byte 0x08 in ASCII encoding
 * \f      form feed - new page    byte 0x0c in ASCII encoding
 * \n      line feed - new line    byte 0x0a in ASCII encoding
 * \r      carriage return byte 0x0d in ASCII encoding
 * \t      horizontal tab  byte 0x09 in ASCII encoding
 * \v      vertical tab    byte 0x0b in ASCII encoding
 */
const ::std::string ss0 = "'\"\?\\\a\b\f\n\r\t\v\006";

const ::std::string ss1 = "'\"\?\\\a\b\f\n\r\t\v\006";

const ::std::string ss2 = "'\"\?\\\a\b\f\n\r\t\v\006";

/**
 * \\U\u\
 */
const ::std::string ss3 = "\\\\U\\u\\";

/**
 * \A\
 */
const ::std::string ss4 = "\\A\\";

/**
 * \u0041\
 */
const ::std::string ss5 = "\\u0041\\";

const ::std::string su0 = "\304\250\305\270\303\277\304\200\341\274\200\360\220\206\224\360\220\205\252\360\220\206\230\360\237\215\200\360\237\215\201\360\237\215\202\360\237\215\203";

const ::std::string su1 = "\304\250\305\270\303\277\304\200\341\274\200\360\220\206\224\360\220\205\252\360\220\206\230\360\237\215\200\360\237\215\201\360\237\215\202\360\237\215\203";

const ::std::string su2 = "\304\250\305\270\303\277\304\200\341\274\200\360\220\206\224\360\220\205\252\360\220\206\230\360\237\215\200\360\237\215\201\360\237\215\202\360\237\215\203";

const ::std::wstring ws0 = L"\\";

const ::std::wstring ws1 = L"A";

const ::std::wstring ws2 = L"Ice";

const ::std::wstring ws3 = L"A21";

const ::std::wstring ws4 = L"\\u0041 \\U00000041";

const ::std::wstring ws5 = L"\u00FF";

const ::std::wstring ws6 = L"\u03FF";

const ::std::wstring ws7 = L"\u05F0";

const ::std::wstring ws8 = L"\U00010000";

const ::std::wstring ws9 = L"\U0001F34C";

const ::std::wstring ws10 = L"\u0DA7";

const ::std::wstring wsw0 = L"\\";

const ::std::wstring wsw1 = L"A";

const ::std::wstring wsw2 = L"Ice";

const ::std::wstring wsw3 = L"A21";

const ::std::wstring wsw4 = L"\\u0041 \\U00000041";

const ::std::wstring wsw5 = L"\U000000FF";

const ::std::wstring wsw6 = L"\U000003FF";

const ::std::wstring wsw7 = L"\U000005F0";

const ::std::wstring wsw8 = L"\U00010000";

const ::std::wstring wsw9 = L"\U0001F34C";

const ::std::wstring wsw10 = L"\U00000DA7";

/**
 * \'      single quote    byte 0x27 in ASCII encoding
 * \"      double quote    byte 0x22 in ASCII encoding
 * \?      question mark   byte 0x3f in ASCII encoding
 * \\      backslash       byte 0x5c in ASCII encoding
 * \a      audible bell    byte 0x07 in ASCII encoding
 * \b      backspace       byte 0x08 in ASCII encoding
 * \f      form feed - new page    byte 0x0c in ASCII encoding
 * \n      line feed - new line    byte 0x0a in ASCII encoding
 * \r      carriage return byte 0x0d in ASCII encoding
 * \t      horizontal tab  byte 0x09 in ASCII encoding
 * \v      vertical tab    byte 0x0b in ASCII encoding
 */
const ::std::wstring wss0 = L"'\"\?\\\a\b\f\n\r\t\v\u0006";

const ::std::wstring wss1 = L"'\"\?\\\a\b\f\n\r\t\v\u0006";

const ::std::wstring wss2 = L"'\"\?\\\a\b\f\n\r\t\v\u0006";

/**
 * \\U\u\
 */
const ::std::wstring wss3 = L"\\\\U\\u\\";

/**
 * \A\
 */
const ::std::wstring wss4 = L"\\A\\";

/**
 * \u0041\
 */
const ::std::wstring wss5 = L"\\u0041\\";

const ::std::wstring wsu0 = L"\u0128\u0178\u00ff\u0100\u1f00\U00010194\U0001016a\U00010198\U0001f340\U0001f341\U0001f342\U0001f343";

const ::std::wstring wsu1 = L"\u0128\u0178\u00FF\u0100\u1F00\U00010194\U0001016A\U00010198\U0001F340\U0001F341\U0001F342\U0001F343";

const ::std::wstring wsu2 = L"\U00000128\U00000178\U000000FF\U00000100\U00001F00\U00010194\U0001016A\U00010198\U0001F340\U0001F341\U0001F342\U0001F343";

}

namespace Test2
{

}

namespace Test
{

class MyClassPrx : public ::Ice::Proxy<MyClassPrx, ::Ice::ObjectPrx>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<void> shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsCompress(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<bool> supportsCompressAsync(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    supportsCompressAsync(::std::function<void(bool)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_supportsCompress(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    void opVoid(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<void> opVoidAsync(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opVoidAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opVoid(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ::Ice::Byte opByte(::Ice::Byte p1, ::Ice::Byte p2, ::Ice::Byte& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<::Ice::Byte, ::Ice::Byte>> opByteAsync(::Ice::Byte p1, ::Ice::Byte p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opByteAsync(::Ice::Byte p1, ::Ice::Byte p2,
                ::std::function<void(::Ice::Byte, ::Ice::Byte)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opByte(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::Ice::Byte, ::Ice::Byte>>>&, ::Ice::Byte, ::Ice::Byte, const ::Ice::Context&);
    /// \endcond

    bool opBool(bool p1, bool p2, bool& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<bool, bool>> opBoolAsync(bool p1, bool p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opBoolAsync(bool p1, bool p2,
                ::std::function<void(bool, bool)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opBool(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<bool, bool>>>&, bool, bool, const ::Ice::Context&);
    /// \endcond

    long long int opShortIntLong(short p1, int p2, long long int p3, short& p4, int& p5, long long int& p6, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<long long int, short, int, long long int>> opShortIntLongAsync(short p1, int p2, long long int p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opShortIntLongAsync(short p1, int p2, long long int p3,
                        ::std::function<void(long long int, short, int, long long int)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opShortIntLong(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<long long int, short, int, long long int>>>&, short, int, long long int, const ::Ice::Context&);
    /// \endcond

    double opFloatDouble(float p1, double p2, float& p3, double& p4, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<double, float, double>> opFloatDoubleAsync(float p1, double p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opFloatDoubleAsync(float p1, double p2,
                       ::std::function<void(double, float, double)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opFloatDouble(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<double, float, double>>>&, float, double, const ::Ice::Context&);
    /// \endcond

    ::std::string opString(const ::std::string& p1, const ::std::string& p2, ::std::string& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<::std::string, ::std::string>> opStringAsync(const ::std::string& p1, const ::std::string& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStringAsync(const ::std::string& p1, const ::std::string& p2,
                  ::std::function<void(::std::string, ::std::string)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::string, ::std::string>>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    MyEnum opMyEnum(MyEnum p1, MyEnum& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<MyEnum, MyEnum>> opMyEnumAsync(MyEnum p1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMyEnumAsync(MyEnum p1,
                  ::std::function<void(::Test::MyEnum, ::Test::MyEnum)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMyEnum(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyEnum, MyEnum>>>&, MyEnum, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<MyClassPrx> opMyClass(const ::std::shared_ptr<MyClassPrx>& p1, ::std::shared_ptr<MyClassPrx>& p2, ::std::shared_ptr<MyClassPrx>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<::std::shared_ptr<MyClassPrx>, ::std::shared_ptr<MyClassPrx>, ::std::shared_ptr<MyClassPrx>>> opMyClassAsync(const ::std::shared_ptr<MyClassPrx>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMyClassAsync(const ::std::shared_ptr<MyClassPrx>& p1,
                   ::std::function<void(::std::shared_ptr<::Test::MyClassPrx>, ::std::shared_ptr<::Test::MyClassPrx>, ::std::shared_ptr<::Test::MyClassPrx>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMyClass(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<MyClassPrx>, ::std::shared_ptr<MyClassPrx>, ::std::shared_ptr<MyClassPrx>>>>&, const ::std::shared_ptr<MyClassPrx>&, const ::Ice::Context&);
    /// \endcond

    Structure opStruct(const Structure& p1, const Structure& p2, Structure& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<Structure, Structure>> opStructAsync(const Structure& p1, const Structure& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStructAsync(const Structure& p1, const Structure& p2,
                  ::std::function<void(::Test::Structure, ::Test::Structure)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<Structure, Structure>>>&, const Structure&, const Structure&, const ::Ice::Context&);
    /// \endcond

    ByteS opByteS(const ByteS& p1, const ByteS& p2, ByteS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<ByteS, ByteS>> opByteSAsync(const ByteS& p1, const ByteS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opByteSAsync(const ByteS& p1, const ByteS& p2,
                 ::std::function<void(::Test::ByteS, ::Test::ByteS)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteS, ByteS>>>&, const ByteS&, const ByteS&, const ::Ice::Context&);
    /// \endcond

    BoolS opBoolS(const BoolS& p1, const BoolS& p2, BoolS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<BoolS, BoolS>> opBoolSAsync(const BoolS& p1, const BoolS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opBoolSAsync(const BoolS& p1, const BoolS& p2,
                 ::std::function<void(::Test::BoolS, ::Test::BoolS)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolS, BoolS>>>&, const BoolS&, const BoolS&, const ::Ice::Context&);
    /// \endcond

    LongS opShortIntLongS(const ShortS& p1, const IntS& p2, const LongS& p3, ShortS& p4, IntS& p5, LongS& p6, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<LongS, ShortS, IntS, LongS>> opShortIntLongSAsync(const ShortS& p1, const IntS& p2, const LongS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opShortIntLongSAsync(const ShortS& p1, const IntS& p2, const LongS& p3,
                         ::std::function<void(::Test::LongS, ::Test::ShortS, ::Test::IntS, ::Test::LongS)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opShortIntLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongS, ShortS, IntS, LongS>>>&, const ShortS&, const IntS&, const LongS&, const ::Ice::Context&);
    /// \endcond

    DoubleS opFloatDoubleS(const FloatS& p1, const DoubleS& p2, FloatS& p3, DoubleS& p4, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<DoubleS, FloatS, DoubleS>> opFloatDoubleSAsync(const FloatS& p1, const DoubleS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opFloatDoubleSAsync(const FloatS& p1, const DoubleS& p2,
                        ::std::function<void(::Test::DoubleS, ::Test::FloatS, ::Test::DoubleS)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opFloatDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleS, FloatS, DoubleS>>>&, const FloatS&, const DoubleS&, const ::Ice::Context&);
    /// \endcond

    StringS opStringS(const StringS& p1, const StringS& p2, StringS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<StringS, StringS>> opStringSAsync(const StringS& p1, const StringS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStringSAsync(const StringS& p1, const StringS& p2,
                   ::std::function<void(::Test::StringS, ::Test::StringS)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringS, StringS>>>&, const StringS&, const StringS&, const ::Ice::Context&);
    /// \endcond

    ByteSS opByteSS(const ByteSS& p1, const ByteSS& p2, ByteSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<ByteSS, ByteSS>> opByteSSAsync(const ByteSS& p1, const ByteSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opByteSSAsync(const ByteSS& p1, const ByteSS& p2,
                  ::std::function<void(::Test::ByteSS, ::Test::ByteSS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opByteSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteSS, ByteSS>>>&, const ByteSS&, const ByteSS&, const ::Ice::Context&);
    /// \endcond

    BoolSS opBoolSS(const BoolSS& p1, const BoolSS& p2, BoolSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<BoolSS, BoolSS>> opBoolSSAsync(const BoolSS& p1, const BoolSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opBoolSSAsync(const BoolSS& p1, const BoolSS& p2,
                  ::std::function<void(::Test::BoolSS, ::Test::BoolSS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opBoolSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolSS, BoolSS>>>&, const BoolSS&, const BoolSS&, const ::Ice::Context&);
    /// \endcond

    LongSS opShortIntLongSS(const ShortSS& p1, const IntSS& p2, const LongSS& p3, ShortSS& p4, IntSS& p5, LongSS& p6, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<LongSS, ShortSS, IntSS, LongSS>> opShortIntLongSSAsync(const ShortSS& p1, const IntSS& p2, const LongSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opShortIntLongSSAsync(const ShortSS& p1, const IntSS& p2, const LongSS& p3,
                          ::std::function<void(::Test::LongSS, ::Test::ShortSS, ::Test::IntSS, ::Test::LongSS)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opShortIntLongSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongSS, ShortSS, IntSS, LongSS>>>&, const ShortSS&, const IntSS&, const LongSS&, const ::Ice::Context&);
    /// \endcond

    DoubleSS opFloatDoubleSS(const FloatSS& p1, const DoubleSS& p2, FloatSS& p3, DoubleSS& p4, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<DoubleSS, FloatSS, DoubleSS>> opFloatDoubleSSAsync(const FloatSS& p1, const DoubleSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opFloatDoubleSSAsync(const FloatSS& p1, const DoubleSS& p2,
                         ::std::function<void(::Test::DoubleSS, ::Test::FloatSS, ::Test::DoubleSS)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opFloatDoubleSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleSS, FloatSS, DoubleSS>>>&, const FloatSS&, const DoubleSS&, const ::Ice::Context&);
    /// \endcond

    StringSS opStringSS(const StringSS& p1, const StringSS& p2, StringSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<StringSS, StringSS>> opStringSSAsync(const StringSS& p1, const StringSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStringSSAsync(const StringSS& p1, const StringSS& p2,
                    ::std::function<void(::Test::StringSS, ::Test::StringSS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opStringSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringSS, StringSS>>>&, const StringSS&, const StringSS&, const ::Ice::Context&);
    /// \endcond

    StringSSS opStringSSS(const StringSSS& p1, const StringSSS& p2, StringSSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<StringSSS, StringSSS>> opStringSSSAsync(const StringSSS& p1, const StringSSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStringSSSAsync(const StringSSS& p1, const StringSSS& p2,
                     ::std::function<void(::Test::StringSSS, ::Test::StringSSS)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opStringSSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringSSS, StringSSS>>>&, const StringSSS&, const StringSSS&, const ::Ice::Context&);
    /// \endcond

    ByteBoolD opByteBoolD(const ByteBoolD& p1, const ByteBoolD& p2, ByteBoolD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<ByteBoolD, ByteBoolD>> opByteBoolDAsync(const ByteBoolD& p1, const ByteBoolD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opByteBoolDAsync(const ByteBoolD& p1, const ByteBoolD& p2,
                     ::std::function<void(::Test::ByteBoolD, ::Test::ByteBoolD)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opByteBoolD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteBoolD, ByteBoolD>>>&, const ByteBoolD&, const ByteBoolD&, const ::Ice::Context&);
    /// \endcond

    ShortIntD opShortIntD(const ShortIntD& p1, const ShortIntD& p2, ShortIntD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<ShortIntD, ShortIntD>> opShortIntDAsync(const ShortIntD& p1, const ShortIntD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opShortIntDAsync(const ShortIntD& p1, const ShortIntD& p2,
                     ::std::function<void(::Test::ShortIntD, ::Test::ShortIntD)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opShortIntD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortIntD, ShortIntD>>>&, const ShortIntD&, const ShortIntD&, const ::Ice::Context&);
    /// \endcond

    LongFloatD opLongFloatD(const LongFloatD& p1, const LongFloatD& p2, LongFloatD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<LongFloatD, LongFloatD>> opLongFloatDAsync(const LongFloatD& p1, const LongFloatD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opLongFloatDAsync(const LongFloatD& p1, const LongFloatD& p2,
                      ::std::function<void(::Test::LongFloatD, ::Test::LongFloatD)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opLongFloatD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongFloatD, LongFloatD>>>&, const LongFloatD&, const LongFloatD&, const ::Ice::Context&);
    /// \endcond

    StringStringD opStringStringD(const StringStringD& p1, const StringStringD& p2, StringStringD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<StringStringD, StringStringD>> opStringStringDAsync(const StringStringD& p1, const StringStringD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStringStringDAsync(const StringStringD& p1, const StringStringD& p2,
                         ::std::function<void(::Test::StringStringD, ::Test::StringStringD)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opStringStringD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringStringD, StringStringD>>>&, const StringStringD&, const StringStringD&, const ::Ice::Context&);
    /// \endcond

    StringMyEnumD opStringMyEnumD(const StringMyEnumD& p1, const StringMyEnumD& p2, StringMyEnumD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<StringMyEnumD, StringMyEnumD>> opStringMyEnumDAsync(const StringMyEnumD& p1, const StringMyEnumD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStringMyEnumDAsync(const StringMyEnumD& p1, const StringMyEnumD& p2,
                         ::std::function<void(::Test::StringMyEnumD, ::Test::StringMyEnumD)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opStringMyEnumD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringMyEnumD, StringMyEnumD>>>&, const StringMyEnumD&, const StringMyEnumD&, const ::Ice::Context&);
    /// \endcond

    MyEnumStringD opMyEnumStringD(const MyEnumStringD& p1, const MyEnumStringD& p2, MyEnumStringD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<MyEnumStringD, MyEnumStringD>> opMyEnumStringDAsync(const MyEnumStringD& p1, const MyEnumStringD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMyEnumStringDAsync(const MyEnumStringD& p1, const MyEnumStringD& p2,
                         ::std::function<void(::Test::MyEnumStringD, ::Test::MyEnumStringD)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMyEnumStringD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyEnumStringD, MyEnumStringD>>>&, const MyEnumStringD&, const MyEnumStringD&, const ::Ice::Context&);
    /// \endcond

    MyStructMyEnumD opMyStructMyEnumD(const MyStructMyEnumD& p1, const MyStructMyEnumD& p2, MyStructMyEnumD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<MyStructMyEnumD, MyStructMyEnumD>> opMyStructMyEnumDAsync(const MyStructMyEnumD& p1, const MyStructMyEnumD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMyStructMyEnumDAsync(const MyStructMyEnumD& p1, const MyStructMyEnumD& p2,
                           ::std::function<void(::Test::MyStructMyEnumD, ::Test::MyStructMyEnumD)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMyStructMyEnumD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyStructMyEnumD, MyStructMyEnumD>>>&, const MyStructMyEnumD&, const MyStructMyEnumD&, const ::Ice::Context&);
    /// \endcond

    ByteBoolDS opByteBoolDS(const ByteBoolDS& p1, const ByteBoolDS& p2, ByteBoolDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<ByteBoolDS, ByteBoolDS>> opByteBoolDSAsync(const ByteBoolDS& p1, const ByteBoolDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opByteBoolDSAsync(const ByteBoolDS& p1, const ByteBoolDS& p2,
                      ::std::function<void(::Test::ByteBoolDS, ::Test::ByteBoolDS)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opByteBoolDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteBoolDS, ByteBoolDS>>>&, const ByteBoolDS&, const ByteBoolDS&, const ::Ice::Context&);
    /// \endcond

    ShortIntDS opShortIntDS(const ShortIntDS& p1, const ShortIntDS& p2, ShortIntDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<ShortIntDS, ShortIntDS>> opShortIntDSAsync(const ShortIntDS& p1, const ShortIntDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opShortIntDSAsync(const ShortIntDS& p1, const ShortIntDS& p2,
                      ::std::function<void(::Test::ShortIntDS, ::Test::ShortIntDS)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opShortIntDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortIntDS, ShortIntDS>>>&, const ShortIntDS&, const ShortIntDS&, const ::Ice::Context&);
    /// \endcond

    LongFloatDS opLongFloatDS(const LongFloatDS& p1, const LongFloatDS& p2, LongFloatDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<LongFloatDS, LongFloatDS>> opLongFloatDSAsync(const LongFloatDS& p1, const LongFloatDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opLongFloatDSAsync(const LongFloatDS& p1, const LongFloatDS& p2,
                       ::std::function<void(::Test::LongFloatDS, ::Test::LongFloatDS)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opLongFloatDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongFloatDS, LongFloatDS>>>&, const LongFloatDS&, const LongFloatDS&, const ::Ice::Context&);
    /// \endcond

    StringStringDS opStringStringDS(const StringStringDS& p1, const StringStringDS& p2, StringStringDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<StringStringDS, StringStringDS>> opStringStringDSAsync(const StringStringDS& p1, const StringStringDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStringStringDSAsync(const StringStringDS& p1, const StringStringDS& p2,
                          ::std::function<void(::Test::StringStringDS, ::Test::StringStringDS)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opStringStringDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringStringDS, StringStringDS>>>&, const StringStringDS&, const StringStringDS&, const ::Ice::Context&);
    /// \endcond

    StringMyEnumDS opStringMyEnumDS(const StringMyEnumDS& p1, const StringMyEnumDS& p2, StringMyEnumDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<StringMyEnumDS, StringMyEnumDS>> opStringMyEnumDSAsync(const StringMyEnumDS& p1, const StringMyEnumDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStringMyEnumDSAsync(const StringMyEnumDS& p1, const StringMyEnumDS& p2,
                          ::std::function<void(::Test::StringMyEnumDS, ::Test::StringMyEnumDS)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opStringMyEnumDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringMyEnumDS, StringMyEnumDS>>>&, const StringMyEnumDS&, const StringMyEnumDS&, const ::Ice::Context&);
    /// \endcond

    MyEnumStringDS opMyEnumStringDS(const MyEnumStringDS& p1, const MyEnumStringDS& p2, MyEnumStringDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<MyEnumStringDS, MyEnumStringDS>> opMyEnumStringDSAsync(const MyEnumStringDS& p1, const MyEnumStringDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMyEnumStringDSAsync(const MyEnumStringDS& p1, const MyEnumStringDS& p2,
                          ::std::function<void(::Test::MyEnumStringDS, ::Test::MyEnumStringDS)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMyEnumStringDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyEnumStringDS, MyEnumStringDS>>>&, const MyEnumStringDS&, const MyEnumStringDS&, const ::Ice::Context&);
    /// \endcond

    MyStructMyEnumDS opMyStructMyEnumDS(const MyStructMyEnumDS& p1, const MyStructMyEnumDS& p2, MyStructMyEnumDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<MyStructMyEnumDS, MyStructMyEnumDS>> opMyStructMyEnumDSAsync(const MyStructMyEnumDS& p1, const MyStructMyEnumDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMyStructMyEnumDSAsync(const MyStructMyEnumDS& p1, const MyStructMyEnumDS& p2,
                            ::std::function<void(::Test::MyStructMyEnumDS, ::Test::MyStructMyEnumDS)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMyStructMyEnumDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyStructMyEnumDS, MyStructMyEnumDS>>>&, const MyStructMyEnumDS&, const MyStructMyEnumDS&, const ::Ice::Context&);
    /// \endcond

    ByteByteSD opByteByteSD(const ByteByteSD& p1, const ByteByteSD& p2, ByteByteSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<ByteByteSD, ByteByteSD>> opByteByteSDAsync(const ByteByteSD& p1, const ByteByteSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opByteByteSDAsync(const ByteByteSD& p1, const ByteByteSD& p2,
                      ::std::function<void(::Test::ByteByteSD, ::Test::ByteByteSD)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opByteByteSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteByteSD, ByteByteSD>>>&, const ByteByteSD&, const ByteByteSD&, const ::Ice::Context&);
    /// \endcond

    BoolBoolSD opBoolBoolSD(const BoolBoolSD& p1, const BoolBoolSD& p2, BoolBoolSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<BoolBoolSD, BoolBoolSD>> opBoolBoolSDAsync(const BoolBoolSD& p1, const BoolBoolSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opBoolBoolSDAsync(const BoolBoolSD& p1, const BoolBoolSD& p2,
                      ::std::function<void(::Test::BoolBoolSD, ::Test::BoolBoolSD)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opBoolBoolSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolBoolSD, BoolBoolSD>>>&, const BoolBoolSD&, const BoolBoolSD&, const ::Ice::Context&);
    /// \endcond

    ShortShortSD opShortShortSD(const ShortShortSD& p1, const ShortShortSD& p2, ShortShortSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<ShortShortSD, ShortShortSD>> opShortShortSDAsync(const ShortShortSD& p1, const ShortShortSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opShortShortSDAsync(const ShortShortSD& p1, const ShortShortSD& p2,
                        ::std::function<void(::Test::ShortShortSD, ::Test::ShortShortSD)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opShortShortSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortShortSD, ShortShortSD>>>&, const ShortShortSD&, const ShortShortSD&, const ::Ice::Context&);
    /// \endcond

    IntIntSD opIntIntSD(const IntIntSD& p1, const IntIntSD& p2, IntIntSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<IntIntSD, IntIntSD>> opIntIntSDAsync(const IntIntSD& p1, const IntIntSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opIntIntSDAsync(const IntIntSD& p1, const IntIntSD& p2,
                    ::std::function<void(::Test::IntIntSD, ::Test::IntIntSD)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opIntIntSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<IntIntSD, IntIntSD>>>&, const IntIntSD&, const IntIntSD&, const ::Ice::Context&);
    /// \endcond

    LongLongSD opLongLongSD(const LongLongSD& p1, const LongLongSD& p2, LongLongSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<LongLongSD, LongLongSD>> opLongLongSDAsync(const LongLongSD& p1, const LongLongSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opLongLongSDAsync(const LongLongSD& p1, const LongLongSD& p2,
                      ::std::function<void(::Test::LongLongSD, ::Test::LongLongSD)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opLongLongSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongLongSD, LongLongSD>>>&, const LongLongSD&, const LongLongSD&, const ::Ice::Context&);
    /// \endcond

    StringFloatSD opStringFloatSD(const StringFloatSD& p1, const StringFloatSD& p2, StringFloatSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<StringFloatSD, StringFloatSD>> opStringFloatSDAsync(const StringFloatSD& p1, const StringFloatSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStringFloatSDAsync(const StringFloatSD& p1, const StringFloatSD& p2,
                         ::std::function<void(::Test::StringFloatSD, ::Test::StringFloatSD)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opStringFloatSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringFloatSD, StringFloatSD>>>&, const StringFloatSD&, const StringFloatSD&, const ::Ice::Context&);
    /// \endcond

    StringDoubleSD opStringDoubleSD(const StringDoubleSD& p1, const StringDoubleSD& p2, StringDoubleSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<StringDoubleSD, StringDoubleSD>> opStringDoubleSDAsync(const StringDoubleSD& p1, const StringDoubleSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStringDoubleSDAsync(const StringDoubleSD& p1, const StringDoubleSD& p2,
                          ::std::function<void(::Test::StringDoubleSD, ::Test::StringDoubleSD)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opStringDoubleSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringDoubleSD, StringDoubleSD>>>&, const StringDoubleSD&, const StringDoubleSD&, const ::Ice::Context&);
    /// \endcond

    StringStringSD opStringStringSD(const StringStringSD& p1, const StringStringSD& p2, StringStringSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<StringStringSD, StringStringSD>> opStringStringSDAsync(const StringStringSD& p1, const StringStringSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStringStringSDAsync(const StringStringSD& p1, const StringStringSD& p2,
                          ::std::function<void(::Test::StringStringSD, ::Test::StringStringSD)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opStringStringSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringStringSD, StringStringSD>>>&, const StringStringSD&, const StringStringSD&, const ::Ice::Context&);
    /// \endcond

    MyEnumMyEnumSD opMyEnumMyEnumSD(const MyEnumMyEnumSD& p1, const MyEnumMyEnumSD& p2, MyEnumMyEnumSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<MyEnumMyEnumSD, MyEnumMyEnumSD>> opMyEnumMyEnumSDAsync(const MyEnumMyEnumSD& p1, const MyEnumMyEnumSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMyEnumMyEnumSDAsync(const MyEnumMyEnumSD& p1, const MyEnumMyEnumSD& p2,
                          ::std::function<void(::Test::MyEnumMyEnumSD, ::Test::MyEnumMyEnumSD)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMyEnumMyEnumSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyEnumMyEnumSD, MyEnumMyEnumSD>>>&, const MyEnumMyEnumSD&, const MyEnumMyEnumSD&, const ::Ice::Context&);
    /// \endcond

    IntS opIntS(const IntS& s, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<IntS> opIntSAsync(const IntS& s, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opIntSAsync(const IntS& s,
                ::std::function<void(::Test::IntS)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IntS>>&, const IntS&, const ::Ice::Context&);
    /// \endcond

    void opByteSOneway(const ByteS& s, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<void> opByteSOnewayAsync(const ByteS& s, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opByteSOnewayAsync(const ByteS& s,
                       ::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opByteSOneway(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ByteS&, const ::Ice::Context&);
    /// \endcond

    int opByteSOnewayCallCount(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<int> opByteSOnewayCallCountAsync(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opByteSOnewayCallCountAsync(::std::function<void(int)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opByteSOnewayCallCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    ::Ice::Context opContext(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::Ice::Context> opContextAsync(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opContextAsync(::std::function<void(::Ice::Context)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opContext(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::Context>>&, const ::Ice::Context&);
    /// \endcond

    void opDoubleMarshaling(double p1, const DoubleS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<void> opDoubleMarshalingAsync(double p1, const DoubleS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opDoubleMarshalingAsync(double p1, const DoubleS& p2,
                            ::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opDoubleMarshaling(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, double, const DoubleS&, const ::Ice::Context&);
    /// \endcond

    void opIdempotent(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<void> opIdempotentAsync(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opIdempotentAsync(::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opIdempotent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void opNonmutating(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<void> opNonmutatingAsync(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opNonmutatingAsync(::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opNonmutating(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ::Ice::Byte opByte1(::Ice::Byte opByte1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::Ice::Byte> opByte1Async(::Ice::Byte opByte1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opByte1Async(::Ice::Byte opByte1,
                 ::std::function<void(::Ice::Byte)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opByte1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::Byte>>&, ::Ice::Byte, const ::Ice::Context&);
    /// \endcond

    short opShort1(short opShort1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<short> opShort1Async(short opShort1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opShort1Async(short opShort1,
                  ::std::function<void(short)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opShort1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<short>>&, short, const ::Ice::Context&);
    /// \endcond

    int opInt1(int opInt1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<int> opInt1Async(int opInt1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opInt1Async(int opInt1,
                ::std::function<void(int)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opInt1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, int, const ::Ice::Context&);
    /// \endcond

    long long int opLong1(long long int opLong1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<long long int> opLong1Async(long long int opLong1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opLong1Async(long long int opLong1,
                 ::std::function<void(long long int)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opLong1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<long long int>>&, long long int, const ::Ice::Context&);
    /// \endcond

    float opFloat1(float opFloat1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<float> opFloat1Async(float opFloat1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opFloat1Async(float opFloat1,
                  ::std::function<void(float)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opFloat1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<float>>&, float, const ::Ice::Context&);
    /// \endcond

    double opDouble1(double opDouble1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<double> opDouble1Async(double opDouble1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opDouble1Async(double opDouble1,
                   ::std::function<void(double)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opDouble1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<double>>&, double, const ::Ice::Context&);
    /// \endcond

    ::std::string opString1(const ::std::string& opString1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::string> opString1Async(const ::std::string& opString1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opString1Async(const ::std::string& opString1,
                   ::std::function<void(::std::string)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opString1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    StringS opStringS1(const StringS& opStringS1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<StringS> opStringS1Async(const StringS& opStringS1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStringS1Async(const StringS& opStringS1,
                    ::std::function<void(::Test::StringS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opStringS1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<StringS>>&, const StringS&, const ::Ice::Context&);
    /// \endcond

    ByteBoolD opByteBoolD1(const ByteBoolD& opByteBoolD1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<ByteBoolD> opByteBoolD1Async(const ByteBoolD& opByteBoolD1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opByteBoolD1Async(const ByteBoolD& opByteBoolD1,
                      ::std::function<void(::Test::ByteBoolD)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opByteBoolD1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ByteBoolD>>&, const ByteBoolD&, const ::Ice::Context&);
    /// \endcond

    StringS opStringS2(const StringS& stringS, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<StringS> opStringS2Async(const StringS& stringS, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStringS2Async(const StringS& stringS,
                    ::std::function<void(::Test::StringS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opStringS2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<StringS>>&, const StringS&, const ::Ice::Context&);
    /// \endcond

    ByteBoolD opByteBoolD2(const ByteBoolD& byteBoolD, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<ByteBoolD> opByteBoolD2Async(const ByteBoolD& byteBoolD, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opByteBoolD2Async(const ByteBoolD& byteBoolD,
                      ::std::function<void(::Test::ByteBoolD)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opByteBoolD2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ByteBoolD>>&, const ByteBoolD&, const ::Ice::Context&);
    /// \endcond

    StringS opStringLiterals(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<StringS> opStringLiteralsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opStringLiteralsAsync(::std::function<void(::Test::StringS)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opStringLiterals(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<StringS>>&, const ::Ice::Context&);
    /// \endcond

    WStringS opWStringLiterals(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<WStringS> opWStringLiteralsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opWStringLiteralsAsync(::std::function<void(::Test::WStringS)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opWStringLiterals(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<WStringS>>&, const ::Ice::Context&);
    /// \endcond

    Structure opMStruct1(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<Structure> opMStruct1Async(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMStruct1Async(::std::function<void(::Test::Structure)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMStruct1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Structure>>&, const ::Ice::Context&);
    /// \endcond

    Structure opMStruct2(const Structure& p1, Structure& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<Structure, Structure>> opMStruct2Async(const Structure& p1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMStruct2Async(const Structure& p1,
                    ::std::function<void(::Test::Structure, ::Test::Structure)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMStruct2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<Structure, Structure>>>&, const Structure&, const ::Ice::Context&);
    /// \endcond

    StringS opMSeq1(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<StringS> opMSeq1Async(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMSeq1Async(::std::function<void(::Test::StringS)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMSeq1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<StringS>>&, const ::Ice::Context&);
    /// \endcond

    StringS opMSeq2(const StringS& p1, StringS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<StringS, StringS>> opMSeq2Async(const StringS& p1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMSeq2Async(const StringS& p1,
                 ::std::function<void(::Test::StringS, ::Test::StringS)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMSeq2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringS, StringS>>>&, const StringS&, const ::Ice::Context&);
    /// \endcond

    StringStringD opMDict1(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<StringStringD> opMDict1Async(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMDict1Async(::std::function<void(::Test::StringStringD)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMDict1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<StringStringD>>&, const ::Ice::Context&);
    /// \endcond

    StringStringD opMDict2(const StringStringD& p1, StringStringD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::tuple<StringStringD, StringStringD>> opMDict2Async(const StringStringD& p1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMDict2Async(const StringStringD& p1,
                  ::std::function<void(::Test::StringStringD, ::Test::StringStringD)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMDict2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringStringD, StringStringD>>>&, const StringStringD&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit MyClassPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    /// \cond INTERNAL
    MyClassPrx(const ::IceInternal::ReferencePtr& ref) : ::Ice::ObjectPrx(ref)
    {
    }
    /// \endcond

protected:

    /// \cond INTERNAL
    MyClassPrx() = default;
    /// \endcond
};

class MyDerivedClassPrx : public ::Ice::Proxy<MyDerivedClassPrx, MyClassPrx>
{
public:

    void opDerived(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<void> opDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opDerivedAsync(::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<MyClass1> opMyClass1(const ::std::shared_ptr<MyClass1>& opMyClass1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<::std::shared_ptr<MyClass1>> opMyClass1Async(const ::std::shared_ptr<MyClass1>& opMyClass1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMyClass1Async(const ::std::shared_ptr<MyClass1>& opMyClass1,
                    ::std::function<void(::std::shared_ptr<::Test::MyClass1>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMyClass1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<MyClass1>>>&, const ::std::shared_ptr<MyClass1>&, const ::Ice::Context&);
    /// \endcond

    MyStruct1 opMyStruct1(const MyStruct1& opMyStruct1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::future<MyStruct1> opMyStruct1Async(const MyStruct1& opMyStruct1, const ::Ice::Context& context = ::Ice::noExplicitContext);

    ::std::function<void()>
    opMyStruct1Async(const MyStruct1& opMyStruct1,
                     ::std::function<void(::Test::MyStruct1)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opMyStruct1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyStruct1>>&, const MyStruct1&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit MyDerivedClassPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    /// \cond INTERNAL
    MyDerivedClassPrx(const ::IceInternal::ReferencePtr& ref) : ::Ice::ObjectPrx(ref)
    {
    }
    /// \endcond

protected:

    /// \cond INTERNAL
    MyDerivedClassPrx() = default;
    /// \endcond
};

}

namespace Test2
{

/**
 * Makes sure that proxy operations are correctly generated when extending an interface from
 * a different module (ICE-7639).
 */
class MyDerivedClassPrx : public ::Ice::Proxy<MyDerivedClassPrx, ::Test::MyClassPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit MyDerivedClassPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    /// \cond INTERNAL
    MyDerivedClassPrx(const ::IceInternal::ReferencePtr& ref) : ::Ice::ObjectPrx(ref)
    {
    }
    /// \endcond

protected:

    /// \cond INTERNAL
    MyDerivedClassPrx() = default;
    /// \endcond
};

}

namespace Test
{

struct AnotherStruct
{
    ::std::string s;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(s);
    }
};

struct Structure
{
    ::std::shared_ptr<::Test::MyClassPrx> p;
    ::Test::MyEnum e;
    ::Test::AnotherStruct s;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::MyClassPrx>&, const ::Test::MyEnum&, const ::Test::AnotherStruct&> ice_tuple() const
    {
        return std::tie(p, e, s);
    }
};

struct MyStruct
{
    int i;
    int j;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(i, j);
    }
};

struct MyStruct1
{
    ::std::string tesT;
    ::std::shared_ptr<::Test::MyClassPrx> myClass;
    ::std::string myStruct1;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::MyClassPrx>&, const ::std::string&> ice_tuple() const
    {
        return std::tie(tesT, myClass, myStruct1);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class MyClass1 : public ::Ice::ValueHelper<MyClass1, ::Ice::Value>
{
public:

    virtual ~MyClass1();

    MyClass1() = default;

    MyClass1(const MyClass1&) = default;
    MyClass1(MyClass1&&) = default;
    MyClass1& operator=(const MyClass1&) = default;
    MyClass1& operator=(MyClass1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    MyClass1(const ::std::string& tesT, const ::std::shared_ptr<::Test::MyClassPrx>& myClass, const ::std::string& myClass1) :
        tesT(tesT),
        myClass(myClass),
        myClass1(myClass1)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::MyClassPrx>&, const ::std::string&> ice_tuple() const
    {
        return std::tie(tesT, myClass, myClass1);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string tesT;
    ::std::shared_ptr<::Test::MyClassPrx> myClass;
    ::std::string myClass1;
};

/// \cond INTERNAL
static MyClass1 _iceS_MyClass1_init;
/// \endcond

}

namespace Test
{

class SomeException : public ::Ice::UserExceptionHelper<SomeException, ::Ice::UserException>
{
public:

    virtual ~SomeException();

    SomeException(const SomeException&) = default;

    SomeException() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

/// \cond INTERNAL
static SomeException _iceS_SomeException_init;
/// \endcond

}

namespace Test
{

class MyClass : public virtual ::Ice::Object
{
public:

    using ProxyType = MyClassPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsCompress(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsCompress(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVoid(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVoid(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByte.
     */
    struct OpByteResult
    {
        ::Ice::Byte returnValue;
        ::Ice::Byte p3;
    };

    virtual ::Ice::Byte opByte(::Ice::Byte p1, ::Ice::Byte p2, ::Ice::Byte& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByte(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBool.
     */
    struct OpBoolResult
    {
        bool returnValue;
        bool p3;
    };

    virtual bool opBool(bool p1, bool p2, bool& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBool(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortIntLong.
     */
    struct OpShortIntLongResult
    {
        long long int returnValue;
        short p4;
        int p5;
        long long int p6;
    };

    virtual long long int opShortIntLong(short p1, int p2, long long int p3, short& p4, int& p5, long long int& p6, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntLong(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatDouble.
     */
    struct OpFloatDoubleResult
    {
        double returnValue;
        float p3;
        double p4;
    };

    virtual double opFloatDouble(float p1, double p2, float& p3, double& p4, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatDouble(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opString.
     */
    struct OpStringResult
    {
        ::std::string returnValue;
        ::std::string p3;
    };

    virtual ::std::string opString(::std::string p1, ::std::string p2, ::std::string& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opString(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyEnum.
     */
    struct OpMyEnumResult
    {
        MyEnum returnValue;
        MyEnum p2;
    };

    virtual MyEnum opMyEnum(MyEnum p1, MyEnum& p2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnum(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyClass.
     */
    struct OpMyClassResult
    {
        ::std::shared_ptr<MyClassPrx> returnValue;
        ::std::shared_ptr<MyClassPrx> p2;
        ::std::shared_ptr<MyClassPrx> p3;
    };

    virtual ::std::shared_ptr<MyClassPrx> opMyClass(::std::shared_ptr<MyClassPrx> p1, ::std::shared_ptr<MyClassPrx>& p2, ::std::shared_ptr<MyClassPrx>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyClass(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStruct.
     */
    struct OpStructResult
    {
        Structure returnValue;
        Structure p3;
    };

    virtual Structure opStruct(Structure p1, Structure p2, Structure& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteS.
     */
    struct OpByteSResult
    {
        ByteS returnValue;
        ByteS p3;
    };

    virtual ByteS opByteS(ByteS p1, ByteS p2, ByteS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolS.
     */
    struct OpBoolSResult
    {
        BoolS returnValue;
        BoolS p3;
    };

    virtual BoolS opBoolS(BoolS p1, BoolS p2, BoolS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortIntLongS.
     */
    struct OpShortIntLongSResult
    {
        LongS returnValue;
        ShortS p4;
        IntS p5;
        LongS p6;
    };

    virtual LongS opShortIntLongS(ShortS p1, IntS p2, LongS p3, ShortS& p4, IntS& p5, LongS& p6, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntLongS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatDoubleS.
     */
    struct OpFloatDoubleSResult
    {
        DoubleS returnValue;
        FloatS p3;
        DoubleS p4;
    };

    virtual DoubleS opFloatDoubleS(FloatS p1, DoubleS p2, FloatS& p3, DoubleS& p4, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatDoubleS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringS.
     */
    struct OpStringSResult
    {
        StringS returnValue;
        StringS p3;
    };

    virtual StringS opStringS(StringS p1, StringS p2, StringS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteSS.
     */
    struct OpByteSSResult
    {
        ByteSS returnValue;
        ByteSS p3;
    };

    virtual ByteSS opByteSS(ByteSS p1, ByteSS p2, ByteSS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolSS.
     */
    struct OpBoolSSResult
    {
        BoolSS returnValue;
        BoolSS p3;
    };

    virtual BoolSS opBoolSS(BoolSS p1, BoolSS p2, BoolSS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortIntLongSS.
     */
    struct OpShortIntLongSSResult
    {
        LongSS returnValue;
        ShortSS p4;
        IntSS p5;
        LongSS p6;
    };

    virtual LongSS opShortIntLongSS(ShortSS p1, IntSS p2, LongSS p3, ShortSS& p4, IntSS& p5, LongSS& p6, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntLongSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatDoubleSS.
     */
    struct OpFloatDoubleSSResult
    {
        DoubleSS returnValue;
        FloatSS p3;
        DoubleSS p4;
    };

    virtual DoubleSS opFloatDoubleSS(FloatSS p1, DoubleSS p2, FloatSS& p3, DoubleSS& p4, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatDoubleSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSS.
     */
    struct OpStringSSResult
    {
        StringSS returnValue;
        StringSS p3;
    };

    virtual StringSS opStringSS(StringSS p1, StringSS p2, StringSS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSSS.
     */
    struct OpStringSSSResult
    {
        StringSSS returnValue;
        StringSSS p3;
    };

    virtual StringSSS opStringSSS(StringSSS p1, StringSSS p2, StringSSS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteBoolD.
     */
    struct OpByteBoolDResult
    {
        ByteBoolD returnValue;
        ByteBoolD p3;
    };

    virtual ByteBoolD opByteBoolD(ByteBoolD p1, ByteBoolD p2, ByteBoolD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBoolD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortIntD.
     */
    struct OpShortIntDResult
    {
        ShortIntD returnValue;
        ShortIntD p3;
    };

    virtual ShortIntD opShortIntD(ShortIntD p1, ShortIntD p2, ShortIntD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongFloatD.
     */
    struct OpLongFloatDResult
    {
        LongFloatD returnValue;
        LongFloatD p3;
    };

    virtual LongFloatD opLongFloatD(LongFloatD p1, LongFloatD p2, LongFloatD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongFloatD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringStringD.
     */
    struct OpStringStringDResult
    {
        StringStringD returnValue;
        StringStringD p3;
    };

    virtual StringStringD opStringStringD(StringStringD p1, StringStringD p2, StringStringD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringMyEnumD.
     */
    struct OpStringMyEnumDResult
    {
        StringMyEnumD returnValue;
        StringMyEnumD p3;
    };

    virtual StringMyEnumD opStringMyEnumD(StringMyEnumD p1, StringMyEnumD p2, StringMyEnumD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringMyEnumD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyEnumStringD.
     */
    struct OpMyEnumStringDResult
    {
        MyEnumStringD returnValue;
        MyEnumStringD p3;
    };

    virtual MyEnumStringD opMyEnumStringD(MyEnumStringD p1, MyEnumStringD p2, MyEnumStringD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnumStringD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyStructMyEnumD.
     */
    struct OpMyStructMyEnumDResult
    {
        MyStructMyEnumD returnValue;
        MyStructMyEnumD p3;
    };

    virtual MyStructMyEnumD opMyStructMyEnumD(MyStructMyEnumD p1, MyStructMyEnumD p2, MyStructMyEnumD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyStructMyEnumD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteBoolDS.
     */
    struct OpByteBoolDSResult
    {
        ByteBoolDS returnValue;
        ByteBoolDS p3;
    };

    virtual ByteBoolDS opByteBoolDS(ByteBoolDS p1, ByteBoolDS p2, ByteBoolDS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBoolDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortIntDS.
     */
    struct OpShortIntDSResult
    {
        ShortIntDS returnValue;
        ShortIntDS p3;
    };

    virtual ShortIntDS opShortIntDS(ShortIntDS p1, ShortIntDS p2, ShortIntDS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongFloatDS.
     */
    struct OpLongFloatDSResult
    {
        LongFloatDS returnValue;
        LongFloatDS p3;
    };

    virtual LongFloatDS opLongFloatDS(LongFloatDS p1, LongFloatDS p2, LongFloatDS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongFloatDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringStringDS.
     */
    struct OpStringStringDSResult
    {
        StringStringDS returnValue;
        StringStringDS p3;
    };

    virtual StringStringDS opStringStringDS(StringStringDS p1, StringStringDS p2, StringStringDS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringMyEnumDS.
     */
    struct OpStringMyEnumDSResult
    {
        StringMyEnumDS returnValue;
        StringMyEnumDS p3;
    };

    virtual StringMyEnumDS opStringMyEnumDS(StringMyEnumDS p1, StringMyEnumDS p2, StringMyEnumDS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringMyEnumDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyEnumStringDS.
     */
    struct OpMyEnumStringDSResult
    {
        MyEnumStringDS returnValue;
        MyEnumStringDS p3;
    };

    virtual MyEnumStringDS opMyEnumStringDS(MyEnumStringDS p1, MyEnumStringDS p2, MyEnumStringDS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnumStringDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyStructMyEnumDS.
     */
    struct OpMyStructMyEnumDSResult
    {
        MyStructMyEnumDS returnValue;
        MyStructMyEnumDS p3;
    };

    virtual MyStructMyEnumDS opMyStructMyEnumDS(MyStructMyEnumDS p1, MyStructMyEnumDS p2, MyStructMyEnumDS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyStructMyEnumDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteByteSD.
     */
    struct OpByteByteSDResult
    {
        ByteByteSD returnValue;
        ByteByteSD p3;
    };

    virtual ByteByteSD opByteByteSD(ByteByteSD p1, ByteByteSD p2, ByteByteSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteByteSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolBoolSD.
     */
    struct OpBoolBoolSDResult
    {
        BoolBoolSD returnValue;
        BoolBoolSD p3;
    };

    virtual BoolBoolSD opBoolBoolSD(BoolBoolSD p1, BoolBoolSD p2, BoolBoolSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolBoolSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortShortSD.
     */
    struct OpShortShortSDResult
    {
        ShortShortSD returnValue;
        ShortShortSD p3;
    };

    virtual ShortShortSD opShortShortSD(ShortShortSD p1, ShortShortSD p2, ShortShortSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortShortSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntIntSD.
     */
    struct OpIntIntSDResult
    {
        IntIntSD returnValue;
        IntIntSD p3;
    };

    virtual IntIntSD opIntIntSD(IntIntSD p1, IntIntSD p2, IntIntSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntIntSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongLongSD.
     */
    struct OpLongLongSDResult
    {
        LongLongSD returnValue;
        LongLongSD p3;
    };

    virtual LongLongSD opLongLongSD(LongLongSD p1, LongLongSD p2, LongLongSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongLongSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringFloatSD.
     */
    struct OpStringFloatSDResult
    {
        StringFloatSD returnValue;
        StringFloatSD p3;
    };

    virtual StringFloatSD opStringFloatSD(StringFloatSD p1, StringFloatSD p2, StringFloatSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringFloatSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringDoubleSD.
     */
    struct OpStringDoubleSDResult
    {
        StringDoubleSD returnValue;
        StringDoubleSD p3;
    };

    virtual StringDoubleSD opStringDoubleSD(StringDoubleSD p1, StringDoubleSD p2, StringDoubleSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringDoubleSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringStringSD.
     */
    struct OpStringStringSDResult
    {
        StringStringSD returnValue;
        StringStringSD p3;
    };

    virtual StringStringSD opStringStringSD(StringStringSD p1, StringStringSD p2, StringStringSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyEnumMyEnumSD.
     */
    struct OpMyEnumMyEnumSDResult
    {
        MyEnumMyEnumSD returnValue;
        MyEnumMyEnumSD p3;
    };

    virtual MyEnumMyEnumSD opMyEnumMyEnumSD(MyEnumMyEnumSD p1, MyEnumMyEnumSD p2, MyEnumMyEnumSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnumMyEnumSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual IntS opIntS(IntS s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteSOneway(ByteS s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSOneway(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int opByteSOnewayCallCount(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSOnewayCallCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Context opContext(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opContext(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opDoubleMarshaling(double p1, DoubleS p2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleMarshaling(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opIdempotent(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIdempotent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opNonmutating(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opNonmutating(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Byte opByte1(::Ice::Byte opByte1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByte1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual short opShort1(short opShort1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShort1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int opInt1(int opInt1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opInt1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual long long int opLong1(long long int opLong1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLong1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual float opFloat1(float opFloat1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloat1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual double opDouble1(double opDouble1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDouble1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string opString1(::std::string opString1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opString1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringS opStringS1(StringS opStringS1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringS1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteBoolD opByteBoolD1(ByteBoolD opByteBoolD1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBoolD1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringS opStringS2(StringS stringS, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringS2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteBoolD opByteBoolD2(ByteBoolD byteBoolD, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBoolD2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringS opStringLiterals(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringLiterals(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual WStringS opWStringLiterals(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opWStringLiterals(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Marshaled result structure for operation opMStruct1.
     */
    class OpMStruct1MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMStruct1MarshaledResult(const Structure& returnValue, const ::Ice::Current& current);
    };

    virtual OpMStruct1MarshaledResult opMStruct1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMStruct1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMStruct2.
     */
    struct OpMStruct2Result
    {
        Structure returnValue;
        Structure p2;
    };

    /**
     * Marshaled result structure for operation opMStruct2.
     */
    class OpMStruct2MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMStruct2MarshaledResult(const Structure& returnValue, const Structure& p2, const ::Ice::Current& current);
    };

    virtual OpMStruct2MarshaledResult opMStruct2(Structure p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMStruct2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Marshaled result structure for operation opMSeq1.
     */
    class OpMSeq1MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMSeq1MarshaledResult(const StringS& returnValue, const ::Ice::Current& current);
    };

    virtual OpMSeq1MarshaledResult opMSeq1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMSeq1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMSeq2.
     */
    struct OpMSeq2Result
    {
        StringS returnValue;
        StringS p2;
    };

    /**
     * Marshaled result structure for operation opMSeq2.
     */
    class OpMSeq2MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMSeq2MarshaledResult(const StringS& returnValue, const StringS& p2, const ::Ice::Current& current);
    };

    virtual OpMSeq2MarshaledResult opMSeq2(StringS p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMSeq2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Marshaled result structure for operation opMDict1.
     */
    class OpMDict1MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMDict1MarshaledResult(const StringStringD& returnValue, const ::Ice::Current& current);
    };

    virtual OpMDict1MarshaledResult opMDict1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMDict1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMDict2.
     */
    struct OpMDict2Result
    {
        StringStringD returnValue;
        StringStringD p2;
    };

    /**
     * Marshaled result structure for operation opMDict2.
     */
    class OpMDict2MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMDict2MarshaledResult(const StringStringD& returnValue, const StringStringD& p2, const ::Ice::Current& current);
    };

    virtual OpMDict2MarshaledResult opMDict2(StringStringD p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMDict2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class MyDerivedClass : public virtual MyClass
{
public:

    using ProxyType = MyDerivedClassPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void opDerived(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<MyClass1> opMyClass1(::std::shared_ptr<MyClass1> opMyClass1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyClass1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MyStruct1 opMyStruct1(MyStruct1 opMyStruct1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyStruct1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test2
{

/**
 * Makes sure that proxy operations are correctly generated when extending an interface from
 * a different module (ICE-7639).
 */
class MyDerivedClass : public virtual ::Test::MyClass
{
public:

    using ProxyType = MyDerivedClassPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::MyEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::AnotherStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::AnotherStruct, S>
{
    static void read(S* istr, ::Test::AnotherStruct& v)
    {
        istr->readAll(v.s);
    }
};

template<>
struct StreamableTraits<::Test::Structure>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Structure, S>
{
    static void read(S* istr, ::Test::Structure& v)
    {
        istr->readAll(v.p, v.e, v.s);
    }
};

template<>
struct StreamableTraits<::Test::MyStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::MyStruct, S>
{
    static void read(S* istr, ::Test::MyStruct& v)
    {
        istr->readAll(v.i, v.j);
    }
};

template<>
struct StreamableTraits<::Test::MyStruct1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::MyStruct1, S>
{
    static void read(S* istr, ::Test::MyStruct1& v)
    {
        istr->readAll(v.tesT, v.myClass, v.myStruct1);
    }
};

template<typename S>
struct StreamReader<::Test::MyClass1, S>
{
    static void read(S* istr, ::Test::MyClass1& v)
    {
        istr->readAll(v.tesT, v.myClass, v.myClass1);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using MyClassPtr = ::std::shared_ptr<MyClass>;

using MyClassPrxPtr = ::std::shared_ptr<MyClassPrx>;

using MyClass1Ptr = ::std::shared_ptr<MyClass1>;

using MyDerivedClassPtr = ::std::shared_ptr<MyDerivedClass>;

using MyDerivedClassPrxPtr = ::std::shared_ptr<MyDerivedClassPrx>;

}
/// \endcond

/// \cond INTERNAL
namespace Test2
{

using MyDerivedClassPtr = ::std::shared_ptr<MyDerivedClass>;

using MyDerivedClassPrxPtr = ::std::shared_ptr<MyDerivedClassPrx>;

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
