//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{

struct S;
class Base;

using BasePtr = ::std::shared_ptr<Base>;
class B;

using BPtr = ::std::shared_ptr<B>;
class C;

using CPtr = ::std::shared_ptr<C>;
class A;

using APtr = ::std::shared_ptr<A>;
class D;

using DPtr = ::std::shared_ptr<D>;
class E;

using EPtr = ::std::shared_ptr<E>;
class F;

using FPtr = ::std::shared_ptr<F>;
class G;

using GPtr = ::std::shared_ptr<G>;
class IPrx;

using IPrxPtr = ::std::optional<IPrx>;
class JPrx;

using JPrxPtr = ::std::optional<JPrx>;

using BaseSeq = ::std::vector<::std::shared_ptr<Base>>;
class CompactExt;

using CompactExtPtr = ::std::shared_ptr<CompactExt>;
class Compact;

using CompactPtr = ::std::shared_ptr<Compact>;

constexpr ::std::int32_t CompactExtId = 789;

namespace Inner
{

class A;

using APtr = ::std::shared_ptr<A>;

namespace Sub
{

class A;

using APtr = ::std::shared_ptr<A>;

}

}
class A1;

using A1Ptr = ::std::shared_ptr<A1>;
class B1;

using B1Ptr = ::std::shared_ptr<B1>;
class D1;

using D1Ptr = ::std::shared_ptr<D1>;
class Recursive;

using RecursivePtr = ::std::shared_ptr<Recursive>;
class K;

using KPtr = ::std::shared_ptr<K>;
class L;

using LPtr = ::std::shared_ptr<L>;

using ValueSeq = ::std::vector<::std::shared_ptr<::Ice::Value>>;

using ValueMap = ::std::map<::std::string, ::std::shared_ptr<::Ice::Value>>;
struct StructKey;

using LMap = ::std::map<StructKey, ::std::shared_ptr<L>>;
class M;

using MPtr = ::std::shared_ptr<M>;
class F1;

using F1Ptr = ::std::shared_ptr<F1>;
class F2Prx;

using F2PrxPtr = ::std::optional<F2Prx>;
class F3;

using F3Ptr = ::std::shared_ptr<F3>;
class InitialPrx;

using InitialPrxPtr = ::std::optional<InitialPrx>;
class TestIntfPrx;

using TestIntfPrxPtr = ::std::optional<TestIntfPrx>;
class Empty;

using EmptyPtr = ::std::shared_ptr<Empty>;
class AlsoEmpty;

using AlsoEmptyPtr = ::std::shared_ptr<AlsoEmpty>;
class UnexpectedObjectExceptionTestPrx;

using UnexpectedObjectExceptionTestPrxPtr = ::std::optional<UnexpectedObjectExceptionTestPrx>;
class COneMember;

using COneMemberPtr = ::std::shared_ptr<COneMember>;
class CTwoMembers;

using CTwoMembersPtr = ::std::shared_ptr<CTwoMembers>;
struct SOneMember;
struct STwoMembers;

using DOneMember = ::std::map<::std::int32_t, ::std::shared_ptr<COneMember>>;

using DTwoMembers = ::std::map<::std::int32_t, ::std::shared_ptr<CTwoMembers>>;

}

namespace Test
{

class IPrx : public ::Ice::Proxy<IPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    explicit IPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    IPrx(const IPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    IPrx(IPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    IPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    IPrx& operator=(const IPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    IPrx& operator=(IPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static IPrx _fromReference(::IceInternal::ReferencePtr ref) { return IPrx(::std::move(ref)); }

protected:

    IPrx() = default;

    explicit IPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

class JPrx : public ::Ice::Proxy<JPrx, IPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

#if defined(__GNUC__)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Wextra" // initialize all virtual bases in correct order
#endif

    explicit JPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    JPrx(const JPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    JPrx(JPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    JPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    JPrx& operator=(const JPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    JPrx& operator=(JPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static JPrx _fromReference(::IceInternal::ReferencePtr ref) { return JPrx(::std::move(ref)); }

protected:

    JPrx() = default;

    explicit JPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond

#if defined(__GNUC__)
#   pragma GCC diagnostic pop
#endif
};

class InitialPrx : public ::Ice::Proxy<InitialPrx, ::Ice::ObjectPrx>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<B> getB1(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<B>> getB1Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getB1Async(::std::function<void(::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getB1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<B>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<B> getB2(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<B>> getB2Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getB2Async(::std::function<void(::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getB2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<B>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<C> getC(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<C>> getCAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getCAsync(::std::function<void(::std::shared_ptr<::Test::C>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getC(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<C>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<D> getD(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<D>> getDAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getDAsync(::std::function<void(::std::shared_ptr<::Test::D>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<D>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<E> getE(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<E>> getEAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getEAsync(::std::function<void(::std::shared_ptr<::Test::E>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getE(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<E>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<F> getF(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<F>> getFAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getFAsync(::std::function<void(::std::shared_ptr<::Test::F>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getF(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<F>>>&, const ::Ice::Context&) const;
    /// \endcond

    void setRecursive(const ::std::shared_ptr<Recursive>& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> setRecursiveAsync(const ::std::shared_ptr<Recursive>& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    setRecursiveAsync(const ::std::shared_ptr<Recursive>& p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_setRecursive(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<Recursive>&, const ::Ice::Context&) const;
    /// \endcond

    bool supportsClassGraphDepthMax(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<bool> supportsClassGraphDepthMaxAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    supportsClassGraphDepthMaxAsync(::std::function<void(bool)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_supportsClassGraphDepthMax(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&) const;
    /// \endcond

    void setCycle(const ::std::shared_ptr<Recursive>& r, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> setCycleAsync(const ::std::shared_ptr<Recursive>& r, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    setCycleAsync(const ::std::shared_ptr<Recursive>& r, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_setCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<Recursive>&, const ::Ice::Context&) const;
    /// \endcond

    bool acceptsClassCycles(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<bool> acceptsClassCyclesAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    acceptsClassCyclesAsync(::std::function<void(bool)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_acceptsClassCycles(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<B> getMB(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<B>> getMBAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getMBAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getMB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<B>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<B> getAMDMB(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<B>> getAMDMBAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getAMDMBAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getAMDMB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<B>>>&, const ::Ice::Context&) const;
    /// \endcond

    void getAll(::std::shared_ptr<B>& b1, ::std::shared_ptr<B>& b2, ::std::shared_ptr<C>& theC, ::std::shared_ptr<D>& theD, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<C>, ::std::shared_ptr<D>>> getAllAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getAllAsync(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::C>, ::std::shared_ptr<::Test::D>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getAll(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<C>, ::std::shared_ptr<D>>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<K> getK(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<K>> getKAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getKAsync(::std::function<void(::std::shared_ptr<::Test::K>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getK(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<K>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<::Ice::Value> opValue(const ::std::shared_ptr<::Ice::Value>& v1, ::std::shared_ptr<::Ice::Value>& v2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::shared_ptr<::Ice::Value>, ::std::shared_ptr<::Ice::Value>>> opValueAsync(const ::std::shared_ptr<::Ice::Value>& v1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opValueAsync(const ::std::shared_ptr<::Ice::Value>& v1, ::std::function<void(::std::shared_ptr<::Ice::Value>, ::std::shared_ptr<::Ice::Value>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opValue(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<::Ice::Value>, ::std::shared_ptr<::Ice::Value>>>>&, const ::std::shared_ptr<::Ice::Value>&, const ::Ice::Context&) const;
    /// \endcond

    ValueSeq opValueSeq(const ValueSeq& v1, ValueSeq& v2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ValueSeq, ValueSeq>> opValueSeqAsync(const ValueSeq& v1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opValueSeqAsync(const ValueSeq& v1, ::std::function<void(::Test::ValueSeq, ::Test::ValueSeq)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opValueSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ValueSeq, ValueSeq>>>&, const ValueSeq&, const ::Ice::Context&) const;
    /// \endcond

    ValueMap opValueMap(const ValueMap& v1, ValueMap& v2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ValueMap, ValueMap>> opValueMapAsync(const ValueMap& v1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opValueMapAsync(const ValueMap& v1, ::std::function<void(::Test::ValueMap, ::Test::ValueMap)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opValueMap(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ValueMap, ValueMap>>>&, const ValueMap&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<D1> getD1(const ::std::shared_ptr<D1>& d1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<D1>> getD1Async(const ::std::shared_ptr<D1>& d1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getD1Async(const ::std::shared_ptr<D1>& d1, ::std::function<void(::std::shared_ptr<::Test::D1>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getD1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<D1>>>&, const ::std::shared_ptr<D1>&, const ::Ice::Context&) const;
    /// \endcond

    void throwEDerived(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> throwEDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    throwEDerivedAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_throwEDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void setG(const ::std::shared_ptr<G>& theG, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> setGAsync(const ::std::shared_ptr<G>& theG, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    setGAsync(const ::std::shared_ptr<G>& theG, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_setG(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<G>&, const ::Ice::Context&) const;
    /// \endcond

    BaseSeq opBaseSeq(const BaseSeq& inSeq, BaseSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<BaseSeq, BaseSeq>> opBaseSeqAsync(const BaseSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opBaseSeqAsync(const BaseSeq& inSeq, ::std::function<void(::Test::BaseSeq, ::Test::BaseSeq)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBaseSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BaseSeq, BaseSeq>>>&, const BaseSeq&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<Compact> getCompact(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<Compact>> getCompactAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getCompactAsync(::std::function<void(::std::shared_ptr<::Test::Compact>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getCompact(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<Compact>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<::Test::Inner::A> getInnerA(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<::Test::Inner::A>> getInnerAAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getInnerAAsync(::std::function<void(::std::shared_ptr<::Test::Inner::A>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getInnerA(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Inner::A>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<::Test::Inner::Sub::A> getInnerSubA(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<::Test::Inner::Sub::A>> getInnerSubAAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getInnerSubAAsync(::std::function<void(::std::shared_ptr<::Test::Inner::Sub::A>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getInnerSubA(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Inner::Sub::A>>>&, const ::Ice::Context&) const;
    /// \endcond

    void throwInnerEx(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> throwInnerExAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    throwInnerExAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_throwInnerEx(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void throwInnerSubEx(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> throwInnerSubExAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    throwInnerSubExAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_throwInnerSubEx(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<M> opM(const ::std::shared_ptr<M>& v1, ::std::shared_ptr<M>& v2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::shared_ptr<M>, ::std::shared_ptr<M>>> opMAsync(const ::std::shared_ptr<M>& v1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opMAsync(const ::std::shared_ptr<M>& v1, ::std::function<void(::std::shared_ptr<::Test::M>, ::std::shared_ptr<::Test::M>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opM(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<M>, ::std::shared_ptr<M>>>>&, const ::std::shared_ptr<M>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<F1> opF1(const ::std::shared_ptr<F1>& f11, ::std::shared_ptr<F1>& f12, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::shared_ptr<F1>, ::std::shared_ptr<F1>>> opF1Async(const ::std::shared_ptr<F1>& f11, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opF1Async(const ::std::shared_ptr<F1>& f11, ::std::function<void(::std::shared_ptr<::Test::F1>, ::std::shared_ptr<::Test::F1>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opF1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<F1>, ::std::shared_ptr<F1>>>>&, const ::std::shared_ptr<F1>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<F2Prx> opF2(const ::std::optional<F2Prx>& f21, ::std::optional<F2Prx>& f22, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<F2Prx>, ::std::optional<F2Prx>>> opF2Async(const ::std::optional<F2Prx>& f21, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opF2Async(const ::std::optional<F2Prx>& f21, ::std::function<void(::std::optional<::Test::F2Prx>, ::std::optional<::Test::F2Prx>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opF2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<F2Prx>, ::std::optional<F2Prx>>>>&, const ::std::optional<F2Prx>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<F3> opF3(const ::std::shared_ptr<F3>& f31, ::std::shared_ptr<F3>& f32, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::shared_ptr<F3>, ::std::shared_ptr<F3>>> opF3Async(const ::std::shared_ptr<F3>& f31, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opF3Async(const ::std::shared_ptr<F3>& f31, ::std::function<void(::std::shared_ptr<::Test::F3>, ::std::shared_ptr<::Test::F3>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opF3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<F3>, ::std::shared_ptr<F3>>>>&, const ::std::shared_ptr<F3>&, const ::Ice::Context&) const;
    /// \endcond

    bool hasF3(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<bool> hasF3Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    hasF3Async(::std::function<void(bool)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_hasF3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    explicit InitialPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    InitialPrx(const InitialPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    InitialPrx(InitialPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    InitialPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    InitialPrx& operator=(const InitialPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    InitialPrx& operator=(InitialPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static InitialPrx _fromReference(::IceInternal::ReferencePtr ref) { return InitialPrx(::std::move(ref)); }

protected:

    InitialPrx() = default;

    explicit InitialPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

class TestIntfPrx : public ::Ice::Proxy<TestIntfPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<Base> opDerived(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<Base>> opDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opDerivedAsync(::std::function<void(::std::shared_ptr<::Test::Base>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<Base>>>&, const ::Ice::Context&) const;
    /// \endcond

    void throwDerived(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> throwDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    throwDerivedAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_throwDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    explicit TestIntfPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    TestIntfPrx(const TestIntfPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    TestIntfPrx(TestIntfPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    TestIntfPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    TestIntfPrx& operator=(const TestIntfPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    TestIntfPrx& operator=(TestIntfPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static TestIntfPrx _fromReference(::IceInternal::ReferencePtr ref) { return TestIntfPrx(::std::move(ref)); }

protected:

    TestIntfPrx() = default;

    explicit TestIntfPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

class UnexpectedObjectExceptionTestPrx : public ::Ice::Proxy<UnexpectedObjectExceptionTestPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<Empty> op(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<Empty>> opAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opAsync(::std::function<void(::std::shared_ptr<::Test::Empty>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_op(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<Empty>>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    explicit UnexpectedObjectExceptionTestPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    UnexpectedObjectExceptionTestPrx(const UnexpectedObjectExceptionTestPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    UnexpectedObjectExceptionTestPrx(UnexpectedObjectExceptionTestPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    UnexpectedObjectExceptionTestPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    UnexpectedObjectExceptionTestPrx& operator=(const UnexpectedObjectExceptionTestPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    UnexpectedObjectExceptionTestPrx& operator=(UnexpectedObjectExceptionTestPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static UnexpectedObjectExceptionTestPrx _fromReference(::IceInternal::ReferencePtr ref) { return UnexpectedObjectExceptionTestPrx(::std::move(ref)); }

protected:

    UnexpectedObjectExceptionTestPrx() = default;

    explicit UnexpectedObjectExceptionTestPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

}

namespace Test
{

struct S
{
    ::std::string str;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(str);
    }
};

class Base : public ::Ice::ValueHelper<Base, ::Ice::Value>
{
public:

    virtual ~Base();

    Base() = default;

    Base(const Base&) = default;
    Base(Base&&) = default;
    Base& operator=(const Base&) = default;
    Base& operator=(Base&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Base(const ::Test::S& theS, ::std::string_view str) :
        theS(theS),
        str(str)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::S&, const ::std::string&> ice_tuple() const
    {
        return std::tie(theS, str);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::Test::S theS;
    ::std::string str;
};

/// \cond INTERNAL
static Base _iceS_Base_init;
/// \endcond

class BaseEx : public ::Ice::UserExceptionHelper<BaseEx, ::Ice::UserException>
{
public:

    virtual ~BaseEx();

    BaseEx(const BaseEx&) = default;

    BaseEx() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    BaseEx(::std::string_view reason) :
        reason(reason)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(reason);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::string reason;
};

class A : public ::Ice::ValueHelper<A, ::Ice::Value>
{
public:

    virtual ~A();

    A() = default;

    A(const A&) = default;
    A(A&&) = default;
    A& operator=(const A&) = default;
    A& operator=(A&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    A(const ::std::shared_ptr<::Test::B>& theB, const ::std::shared_ptr<::Test::C>& theC, bool preMarshalInvoked, bool postUnmarshalInvoked) :
        theB(theB),
        theC(theC),
        preMarshalInvoked(preMarshalInvoked),
        postUnmarshalInvoked(postUnmarshalInvoked)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::B>&, const ::std::shared_ptr<::Test::C>&, const bool&, const bool&> ice_tuple() const
    {
        return std::tie(theB, theC, preMarshalInvoked, postUnmarshalInvoked);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::B> theB;
    ::std::shared_ptr<::Test::C> theC;
    bool preMarshalInvoked;
    bool postUnmarshalInvoked;
};

class B : public ::Ice::ValueHelper<B, A>
{
public:

    virtual ~B();

    B() = default;

    B(const B&) = default;
    B(B&&) = default;
    B& operator=(const B&) = default;
    B& operator=(B&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    B(const ::std::shared_ptr<::Test::B>& theB, const ::std::shared_ptr<::Test::C>& theC, bool preMarshalInvoked, bool postUnmarshalInvoked, const ::std::shared_ptr<::Test::A>& theA) :
        Ice::ValueHelper<B, A>(theB, theC, preMarshalInvoked, postUnmarshalInvoked),
        theA(theA)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::B>&, const ::std::shared_ptr<::Test::C>&, const bool&, const bool&, const ::std::shared_ptr<::Test::A>&> ice_tuple() const
    {
        return std::tie(theB, theC, preMarshalInvoked, postUnmarshalInvoked, theA);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::A> theA;
};

class C : public ::Ice::ValueHelper<C, ::Ice::Value>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    C(const ::std::shared_ptr<::Test::B>& theB, bool preMarshalInvoked, bool postUnmarshalInvoked) :
        theB(theB),
        preMarshalInvoked(preMarshalInvoked),
        postUnmarshalInvoked(postUnmarshalInvoked)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::B>&, const bool&, const bool&> ice_tuple() const
    {
        return std::tie(theB, preMarshalInvoked, postUnmarshalInvoked);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::B> theB;
    bool preMarshalInvoked;
    bool postUnmarshalInvoked;
};

class D : public ::Ice::ValueHelper<D, ::Ice::Value>
{
public:

    virtual ~D();

    D() = default;

    D(const D&) = default;
    D(D&&) = default;
    D& operator=(const D&) = default;
    D& operator=(D&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D(const ::std::shared_ptr<::Test::A>& theA, const ::std::shared_ptr<::Test::B>& theB, const ::std::shared_ptr<::Test::C>& theC, bool preMarshalInvoked, bool postUnmarshalInvoked) :
        theA(theA),
        theB(theB),
        theC(theC),
        preMarshalInvoked(preMarshalInvoked),
        postUnmarshalInvoked(postUnmarshalInvoked)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A>&, const ::std::shared_ptr<::Test::B>&, const ::std::shared_ptr<::Test::C>&, const bool&, const bool&> ice_tuple() const
    {
        return std::tie(theA, theB, theC, preMarshalInvoked, postUnmarshalInvoked);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::A> theA;
    ::std::shared_ptr<::Test::B> theB;
    ::std::shared_ptr<::Test::C> theC;
    bool preMarshalInvoked;
    bool postUnmarshalInvoked;
};

class E : public ::Ice::ValueHelper<E, ::Ice::Value>
{
public:

    virtual ~E();

    E() = default;

    E(const E&) = default;
    E(E&&) = default;
    E& operator=(const E&) = default;
    E& operator=(E&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    E(::std::int32_t i, ::std::string_view s) :
        i(i),
        s(s)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&> ice_tuple() const
    {
        return std::tie(i, s);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

protected:

    ::std::int32_t i;
    ::std::string s;

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};

class F : public ::Ice::ValueHelper<F, ::Ice::Value>
{
public:

    virtual ~F();

    F() = default;

    F(const F&) = default;
    F(F&&) = default;
    F& operator=(const F&) = default;
    F& operator=(F&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    F(const ::std::shared_ptr<::Test::E>& e1, const ::std::shared_ptr<::Test::E>& e2) :
        e1(e1),
        e2(e2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::E>&, const ::std::shared_ptr<::Test::E>&> ice_tuple() const
    {
        return std::tie(e1, e2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

protected:

    ::std::shared_ptr<::Test::E> e1;

public:

    ::std::shared_ptr<::Test::E> e2;

protected:

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};

class G : public ::Ice::ValueHelper<G, Base>
{
public:

    virtual ~G();

    G() = default;

    G(const G&) = default;
    G(G&&) = default;
    G& operator=(const G&) = default;
    G& operator=(G&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    G(const ::Test::S& theS, ::std::string_view str) :
        Ice::ValueHelper<G, Base>(theS, str)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::S&, const ::std::string&> ice_tuple() const
    {
        return std::tie(theS, str);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();
};

class Compact : public ::Ice::ValueHelper<Compact, ::Ice::Value>
{
public:

    virtual ~Compact();

    Compact() = default;

    Compact(const Compact&) = default;
    Compact(Compact&&) = default;
    Compact& operator=(const Compact&) = default;
    Compact& operator=(Compact&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();
};

class CompactExt : public ::Ice::ValueHelper<CompactExt, Compact>
{
public:

    virtual ~CompactExt();

    CompactExt() = default;

    CompactExt(const CompactExt&) = default;
    CompactExt(CompactExt&&) = default;
    CompactExt& operator=(const CompactExt&) = default;
    CompactExt& operator=(CompactExt&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();
};

namespace Inner
{

class A : public ::Ice::ValueHelper<A, ::Ice::Value>
{
public:

    virtual ~A();

    A() = default;

    A(const A&) = default;
    A(A&&) = default;
    A& operator=(const A&) = default;
    A& operator=(A&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit A(const ::std::shared_ptr<::Test::A>& theA) :
        theA(theA)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A>&> ice_tuple() const
    {
        return std::tie(theA);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::A> theA;
};

class Ex : public ::Ice::UserExceptionHelper<Ex, ::Ice::UserException>
{
public:

    virtual ~Ex();

    Ex(const Ex&) = default;

    Ex() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Ex(::std::string_view reason) :
        reason(reason)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(reason);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::string reason;
};

namespace Sub
{

class A : public ::Ice::ValueHelper<A, ::Ice::Value>
{
public:

    virtual ~A();

    A() = default;

    A(const A&) = default;
    A(A&&) = default;
    A& operator=(const A&) = default;
    A& operator=(A&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit A(const ::std::shared_ptr<::Test::Inner::A>& theA) :
        theA(theA)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Inner::A>&> ice_tuple() const
    {
        return std::tie(theA);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::Inner::A> theA;
};

class Ex : public ::Ice::UserExceptionHelper<Ex, ::Ice::UserException>
{
public:

    virtual ~Ex();

    Ex(const Ex&) = default;

    Ex() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Ex(::std::string_view reason) :
        reason(reason)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(reason);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::string reason;
};

}

}

class A1 : public ::Ice::ValueHelper<A1, ::Ice::Value>
{
public:

    virtual ~A1();

    A1() = default;

    A1(const A1&) = default;
    A1(A1&&) = default;
    A1& operator=(const A1&) = default;
    A1& operator=(A1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit A1(::std::string_view name) :
        name(name)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(name);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::string name;
};

class B1 : public ::Ice::ValueHelper<B1, ::Ice::Value>
{
public:

    virtual ~B1();

    B1() = default;

    B1(const B1&) = default;
    B1(B1&&) = default;
    B1& operator=(const B1&) = default;
    B1& operator=(B1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    B1(const ::std::shared_ptr<::Test::A1>& a1, const ::std::shared_ptr<::Test::A1>& a2) :
        a1(a1),
        a2(a2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&> ice_tuple() const
    {
        return std::tie(a1, a2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::A1> a1;
    ::std::shared_ptr<::Test::A1> a2;
};

class D1 : public ::Ice::ValueHelper<D1, B1>
{
public:

    virtual ~D1();

    D1() = default;

    D1(const D1&) = default;
    D1(D1&&) = default;
    D1& operator=(const D1&) = default;
    D1& operator=(D1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D1(const ::std::shared_ptr<::Test::A1>& a1, const ::std::shared_ptr<::Test::A1>& a2, const ::std::shared_ptr<::Test::A1>& a3, const ::std::shared_ptr<::Test::A1>& a4) :
        Ice::ValueHelper<D1, B1>(a1, a2),
        a3(a3),
        a4(a4)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&> ice_tuple() const
    {
        return std::tie(a1, a2, a3, a4);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::A1> a3;
    ::std::shared_ptr<::Test::A1> a4;
};

class EBase : public ::Ice::UserExceptionHelper<EBase, ::Ice::UserException>
{
public:

    virtual ~EBase();

    EBase(const EBase&) = default;

    EBase() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    EBase(const ::std::shared_ptr<A1>& a1, const ::std::shared_ptr<A1>& a2) :
        a1(a1),
        a2(a2)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&> ice_tuple() const
    {
        return std::tie(a1, a2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::shared_ptr<::Test::A1> a1;
    ::std::shared_ptr<::Test::A1> a2;
};

class EDerived : public ::Ice::UserExceptionHelper<EDerived, EBase>
{
public:

    virtual ~EDerived();

    EDerived(const EDerived&) = default;

    EDerived() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    EDerived(const ::std::shared_ptr<A1>& a1, const ::std::shared_ptr<A1>& a2, const ::std::shared_ptr<A1>& a3, const ::std::shared_ptr<A1>& a4) :
        ::Ice::UserExceptionHelper<EDerived, EBase>(a1, a2),
        a3(a3),
        a4(a4)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&> ice_tuple() const
    {
        return std::tie(a1, a2, a3, a4);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::A1> a3;
    ::std::shared_ptr<::Test::A1> a4;
};

class Recursive : public ::Ice::ValueHelper<Recursive, ::Ice::Value>
{
public:

    virtual ~Recursive();

    Recursive() = default;

    Recursive(const Recursive&) = default;
    Recursive(Recursive&&) = default;
    Recursive& operator=(const Recursive&) = default;
    Recursive& operator=(Recursive&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Recursive(const ::std::shared_ptr<::Test::Recursive>& v) :
        v(v)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Recursive>&> ice_tuple() const
    {
        return std::tie(v);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::Recursive> v;
};

class K : public ::Ice::ValueHelper<K, ::Ice::Value>
{
public:

    virtual ~K();

    K() = default;

    K(const K&) = default;
    K(K&&) = default;
    K& operator=(const K&) = default;
    K& operator=(K&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit K(const ::std::shared_ptr<::Ice::Value>& value) :
        value(value)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Ice::Value>&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Ice::Value> value;
};

class L : public ::Ice::ValueHelper<L, ::Ice::Value>
{
public:

    virtual ~L();

    L() = default;

    L(const L&) = default;
    L(L&&) = default;
    L& operator=(const L&) = default;
    L& operator=(L&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit L(::std::string_view data) :
        data(data)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(data);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::string data;
};

struct StructKey
{
    ::std::int32_t i;
    ::std::string s;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&> ice_tuple() const
    {
        return std::tie(i, s);
    }
};

class M : public ::Ice::ValueHelper<M, ::Ice::Value>
{
public:

    virtual ~M();

    M() = default;

    M(const M&) = default;
    M(M&&) = default;
    M& operator=(const M&) = default;
    M& operator=(M&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit M(const ::Test::LMap& v) :
        v(v)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::LMap&> ice_tuple() const
    {
        return std::tie(v);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::Test::LMap v;
};

class F3 : public ::Ice::ValueHelper<F3, ::Ice::Value>
{
public:

    virtual ~F3();

    F3() = default;

    F3(const F3&) = default;
    F3(F3&&) = default;
    F3& operator=(const F3&) = default;
    F3& operator=(F3&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    F3(const ::std::shared_ptr<::Test::F1>& f1, const ::std::optional<::Test::F2Prx>& f2) :
        f1(f1),
        f2(f2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::F1>&, const ::std::optional<::Test::F2Prx>&> ice_tuple() const
    {
        return std::tie(f1, f2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::F1> f1;
    ::std::optional<::Test::F2Prx> f2;
};

class Empty : public ::Ice::ValueHelper<Empty, ::Ice::Value>
{
public:

    virtual ~Empty();

    Empty() = default;

    Empty(const Empty&) = default;
    Empty(Empty&&) = default;
    Empty& operator=(const Empty&) = default;
    Empty& operator=(Empty&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();
};

class AlsoEmpty : public ::Ice::ValueHelper<AlsoEmpty, ::Ice::Value>
{
public:

    virtual ~AlsoEmpty();

    AlsoEmpty() = default;

    AlsoEmpty(const AlsoEmpty&) = default;
    AlsoEmpty(AlsoEmpty&&) = default;
    AlsoEmpty& operator=(const AlsoEmpty&) = default;
    AlsoEmpty& operator=(AlsoEmpty&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();
};

class COneMember : public ::Ice::ValueHelper<COneMember, ::Ice::Value>
{
public:

    virtual ~COneMember();

    COneMember() = default;

    COneMember(const COneMember&) = default;
    COneMember(COneMember&&) = default;
    COneMember& operator=(const COneMember&) = default;
    COneMember& operator=(COneMember&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit COneMember(const ::std::shared_ptr<::Test::Empty>& e) :
        e(e)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Empty>&> ice_tuple() const
    {
        return std::tie(e);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::Empty> e;
};

class CTwoMembers : public ::Ice::ValueHelper<CTwoMembers, ::Ice::Value>
{
public:

    virtual ~CTwoMembers();

    CTwoMembers() = default;

    CTwoMembers(const CTwoMembers&) = default;
    CTwoMembers(CTwoMembers&&) = default;
    CTwoMembers& operator=(const CTwoMembers&) = default;
    CTwoMembers& operator=(CTwoMembers&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    CTwoMembers(const ::std::shared_ptr<::Test::Empty>& e1, const ::std::shared_ptr<::Test::Empty>& e2) :
        e1(e1),
        e2(e2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Empty>&, const ::std::shared_ptr<::Test::Empty>&> ice_tuple() const
    {
        return std::tie(e1, e2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::Empty> e1;
    ::std::shared_ptr<::Test::Empty> e2;
};

class EOneMember : public ::Ice::UserExceptionHelper<EOneMember, ::Ice::UserException>
{
public:

    virtual ~EOneMember();

    EOneMember(const EOneMember&) = default;

    EOneMember() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    EOneMember(const ::std::shared_ptr<Empty>& e) :
        e(e)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Empty>&> ice_tuple() const
    {
        return std::tie(e);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::shared_ptr<::Test::Empty> e;
};

class ETwoMembers : public ::Ice::UserExceptionHelper<ETwoMembers, ::Ice::UserException>
{
public:

    virtual ~ETwoMembers();

    ETwoMembers(const ETwoMembers&) = default;

    ETwoMembers() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    ETwoMembers(const ::std::shared_ptr<Empty>& e1, const ::std::shared_ptr<Empty>& e2) :
        e1(e1),
        e2(e2)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Empty>&, const ::std::shared_ptr<::Test::Empty>&> ice_tuple() const
    {
        return std::tie(e1, e2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::shared_ptr<::Test::Empty> e1;
    ::std::shared_ptr<::Test::Empty> e2;
};

struct SOneMember
{
    ::std::shared_ptr<::Test::Empty> e;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Empty>&> ice_tuple() const
    {
        return std::tie(e);
    }
};

struct STwoMembers
{
    ::std::shared_ptr<::Test::Empty> e1;
    ::std::shared_ptr<::Test::Empty> e2;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Empty>&, const ::std::shared_ptr<::Test::Empty>&> ice_tuple() const
    {
        return std::tie(e1, e2);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class I : public virtual ::Ice::Object
{
public:

    using ProxyType = IPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();
};

using IPtr = ::std::shared_ptr<I>;

class J : public virtual I
{
public:

    using ProxyType = JPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();
};

using JPtr = ::std::shared_ptr<J>;

class Initial : public virtual ::Ice::Object
{
public:

    using ProxyType = InitialPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<B> getB1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getB1(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<B> getB2(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getB2(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<C> getC(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getC(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<D> getD(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getD(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<E> getE(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getE(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<F> getF(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getF(::IceInternal::Incoming&);
    /// \endcond

    virtual void setRecursive(::std::shared_ptr<Recursive> p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setRecursive(::IceInternal::Incoming&);
    /// \endcond

    virtual bool supportsClassGraphDepthMax(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsClassGraphDepthMax(::IceInternal::Incoming&);
    /// \endcond

    virtual void setCycle(::std::shared_ptr<Recursive> r, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setCycle(::IceInternal::Incoming&);
    /// \endcond

    virtual bool acceptsClassCycles(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_acceptsClassCycles(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Marshaled result structure for operation getMB.
     */
    class GetMBMarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        GetMBMarshaledResult(const ::std::shared_ptr<B>& returnValue, const ::Ice::Current& current);
    };

    virtual GetMBMarshaledResult getMB(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getMB(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Marshaled result structure for operation getAMDMBAsync.
     */
    class GetAMDMBMarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        GetAMDMBMarshaledResult(const ::std::shared_ptr<B>& returnValue, const ::Ice::Current& current);
    };

    virtual void getAMDMBAsync(::std::function<void(GetAMDMBMarshaledResult)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getAMDMB(::IceInternal::Incoming&);
    /// \endcond

    virtual void getAll(::std::shared_ptr<B>& b1, ::std::shared_ptr<B>& b2, ::std::shared_ptr<C>& theC, ::std::shared_ptr<D>& theD, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getAll(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<K> getK(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getK(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<::Ice::Value> opValue(::std::shared_ptr<::Ice::Value> v1, ::std::shared_ptr<::Ice::Value>& v2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opValue(::IceInternal::Incoming&);
    /// \endcond

    virtual ValueSeq opValueSeq(ValueSeq v1, ValueSeq& v2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opValueSeq(::IceInternal::Incoming&);
    /// \endcond

    virtual ValueMap opValueMap(ValueMap v1, ValueMap& v2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opValueMap(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<D1> getD1(::std::shared_ptr<D1> d1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getD1(::IceInternal::Incoming&);
    /// \endcond

    virtual void throwEDerived(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwEDerived(::IceInternal::Incoming&);
    /// \endcond

    virtual void setG(::std::shared_ptr<G> theG, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setG(::IceInternal::Incoming&);
    /// \endcond

    virtual BaseSeq opBaseSeq(BaseSeq inSeq, BaseSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBaseSeq(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<Compact> getCompact(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getCompact(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<::Test::Inner::A> getInnerA(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getInnerA(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<::Test::Inner::Sub::A> getInnerSubA(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getInnerSubA(::IceInternal::Incoming&);
    /// \endcond

    virtual void throwInnerEx(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwInnerEx(::IceInternal::Incoming&);
    /// \endcond

    virtual void throwInnerSubEx(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwInnerSubEx(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<M> opM(::std::shared_ptr<M> v1, ::std::shared_ptr<M>& v2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opM(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<F1> opF1(::std::shared_ptr<F1> f11, ::std::shared_ptr<F1>& f12, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opF1(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::optional<F2Prx> opF2(::std::optional<F2Prx> f21, ::std::optional<F2Prx>& f22, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opF2(::IceInternal::Incoming&);
    /// \endcond

    virtual ::std::shared_ptr<F3> opF3(::std::shared_ptr<F3> f31, ::std::shared_ptr<F3>& f32, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opF3(::IceInternal::Incoming&);
    /// \endcond

    virtual bool hasF3(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_hasF3(::IceInternal::Incoming&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&) override;
    /// \endcond
};

using InitialPtr = ::std::shared_ptr<Initial>;

class TestIntf : public virtual ::Ice::Object
{
public:

    using ProxyType = TestIntfPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    virtual ::std::shared_ptr<Base> opDerived(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDerived(::IceInternal::Incoming&);
    /// \endcond

    virtual void throwDerived(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwDerived(::IceInternal::Incoming&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&) override;
    /// \endcond
};

using TestIntfPtr = ::std::shared_ptr<TestIntf>;

class UnexpectedObjectExceptionTest : public virtual ::Ice::Object
{
public:

    using ProxyType = UnexpectedObjectExceptionTestPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    virtual ::std::shared_ptr<Empty> op(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_op(::IceInternal::Incoming&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&) override;
    /// \endcond
};

using UnexpectedObjectExceptionTestPtr = ::std::shared_ptr<UnexpectedObjectExceptionTest>;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::S, S>
{
    static void read(S* istr, ::Test::S& v)
    {
        istr->readAll(v.str);
    }
};

template<typename S>
struct StreamReader<::Test::Base, S>
{
    static void read(S* istr, ::Test::Base& v)
    {
        istr->readAll(v.theS, v.str);
    }
};

template<typename S>
struct StreamReader<::Test::BaseEx, S>
{
    static void read(S* istr, ::Test::BaseEx& v)
    {
        istr->readAll(v.reason);
    }
};

template<typename S>
struct StreamReader<::Test::A, S>
{
    static void read(S* istr, ::Test::A& v)
    {
        istr->readAll(v.theB, v.theC, v.preMarshalInvoked, v.postUnmarshalInvoked);
    }
};

template<typename S>
struct StreamWriter<::Test::B, S>
{
    static void write(S* ostr, const ::Test::B& v)
    {
        ostr->writeAll(v.theA);
    }
};

template<typename S>
struct StreamReader<::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->readAll(v.theA);
    }
};

template<typename S>
struct StreamReader<::Test::C, S>
{
    static void read(S* istr, ::Test::C& v)
    {
        istr->readAll(v.theB, v.preMarshalInvoked, v.postUnmarshalInvoked);
    }
};

template<typename S>
struct StreamReader<::Test::D, S>
{
    static void read(S* istr, ::Test::D& v)
    {
        istr->readAll(v.theA, v.theB, v.theC, v.preMarshalInvoked, v.postUnmarshalInvoked);
    }
};

template<typename S>
struct StreamReader<::Test::E, S>
{
    static void read(S* istr, ::Test::E& v)
    {
        istr->readAll(v.i, v.s);
    }
};

template<typename S>
struct StreamReader<::Test::F, S>
{
    static void read(S* istr, ::Test::F& v)
    {
        istr->readAll(v.e1, v.e2);
    }
};

template<typename S>
struct StreamWriter<::Test::G, S>
{
    static void write(S*, const ::Test::G&)
    {
    }
};

template<typename S>
struct StreamReader<::Test::G, S>
{
    static void read(S*, ::Test::G&)
    {
    }
};

template<typename S>
struct StreamReader<::Test::Inner::A, S>
{
    static void read(S* istr, ::Test::Inner::A& v)
    {
        istr->readAll(v.theA);
    }
};

template<typename S>
struct StreamReader<::Test::Inner::Ex, S>
{
    static void read(S* istr, ::Test::Inner::Ex& v)
    {
        istr->readAll(v.reason);
    }
};

template<typename S>
struct StreamReader<::Test::Inner::Sub::A, S>
{
    static void read(S* istr, ::Test::Inner::Sub::A& v)
    {
        istr->readAll(v.theA);
    }
};

template<typename S>
struct StreamReader<::Test::Inner::Sub::Ex, S>
{
    static void read(S* istr, ::Test::Inner::Sub::Ex& v)
    {
        istr->readAll(v.reason);
    }
};

template<typename S>
struct StreamReader<::Test::A1, S>
{
    static void read(S* istr, ::Test::A1& v)
    {
        istr->readAll(v.name);
    }
};

template<typename S>
struct StreamReader<::Test::B1, S>
{
    static void read(S* istr, ::Test::B1& v)
    {
        istr->readAll(v.a1, v.a2);
    }
};

template<typename S>
struct StreamWriter<::Test::D1, S>
{
    static void write(S* ostr, const ::Test::D1& v)
    {
        ostr->writeAll(v.a3, v.a4);
    }
};

template<typename S>
struct StreamReader<::Test::D1, S>
{
    static void read(S* istr, ::Test::D1& v)
    {
        istr->readAll(v.a3, v.a4);
    }
};

template<typename S>
struct StreamReader<::Test::EBase, S>
{
    static void read(S* istr, ::Test::EBase& v)
    {
        istr->readAll(v.a1, v.a2);
    }
};

template<typename S>
struct StreamWriter<::Test::EDerived, S>
{
    static void write(S* ostr, const ::Test::EDerived& v)
    {
        ostr->writeAll(v.a3, v.a4);
    }
};

template<typename S>
struct StreamReader<::Test::EDerived, S>
{
    static void read(S* istr, ::Test::EDerived& v)
    {
        istr->readAll(v.a3, v.a4);
    }
};

template<typename S>
struct StreamReader<::Test::Recursive, S>
{
    static void read(S* istr, ::Test::Recursive& v)
    {
        istr->readAll(v.v);
    }
};

template<typename S>
struct StreamReader<::Test::K, S>
{
    static void read(S* istr, ::Test::K& v)
    {
        istr->readAll(v.value);
    }
};

template<typename S>
struct StreamReader<::Test::L, S>
{
    static void read(S* istr, ::Test::L& v)
    {
        istr->readAll(v.data);
    }
};

template<>
struct StreamableTraits<::Test::StructKey>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::StructKey, S>
{
    static void read(S* istr, ::Test::StructKey& v)
    {
        istr->readAll(v.i, v.s);
    }
};

template<typename S>
struct StreamReader<::Test::M, S>
{
    static void read(S* istr, ::Test::M& v)
    {
        istr->readAll(v.v);
    }
};

template<typename S>
struct StreamReader<::Test::F3, S>
{
    static void read(S* istr, ::Test::F3& v)
    {
        istr->readAll(v.f1, v.f2);
    }
};

template<typename S>
struct StreamReader<::Test::COneMember, S>
{
    static void read(S* istr, ::Test::COneMember& v)
    {
        istr->readAll(v.e);
    }
};

template<typename S>
struct StreamReader<::Test::CTwoMembers, S>
{
    static void read(S* istr, ::Test::CTwoMembers& v)
    {
        istr->readAll(v.e1, v.e2);
    }
};

template<typename S>
struct StreamReader<::Test::EOneMember, S>
{
    static void read(S* istr, ::Test::EOneMember& v)
    {
        istr->readAll(v.e);
    }
};

template<typename S>
struct StreamReader<::Test::ETwoMembers, S>
{
    static void read(S* istr, ::Test::ETwoMembers& v)
    {
        istr->readAll(v.e1, v.e2);
    }
};

template<>
struct StreamableTraits<::Test::SOneMember>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::SOneMember, S>
{
    static void read(S* istr, ::Test::SOneMember& v)
    {
        istr->readAll(v.e);
    }
};

template<>
struct StreamableTraits<::Test::STwoMembers>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::STwoMembers, S>
{
    static void read(S* istr, ::Test::STwoMembers& v)
    {
        istr->readAll(v.e1, v.e2);
    }
};

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
