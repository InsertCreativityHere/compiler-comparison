//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{


enum class Color : unsigned char
{
    red,
    green,
    blue
};

namespace Nested
{


enum class Color : unsigned char
{
    red,
    green,
    blue
};

}
struct Struct1;

constexpr bool ConstBool = true;

constexpr ::std::uint8_t ConstByte = 254;

constexpr ::std::int16_t ConstShort = 16000;

constexpr ::std::int32_t ConstInt = 3;

constexpr ::std::int64_t ConstLong = 4LL;

constexpr float ConstFloat = 5.1F;

constexpr double ConstDouble = 6.2;

const ::std::string ConstString = "foo \\ \"bar\n \r\n\t\v\f\a\b\? \a \a";

constexpr Color ConstColor1 = ::Test::Color::red;

constexpr Color ConstColor2 = ::Test::Color::green;

constexpr Color ConstColor3 = ::Test::Color::blue;

constexpr ::Test::Nested::Color ConstNestedColor1 = ::Test::Nested::Color::red;

constexpr ::Test::Nested::Color ConstNestedColor2 = ::Test::Nested::Color::green;

constexpr ::Test::Nested::Color ConstNestedColor3 = ::Test::Nested::Color::blue;

constexpr ::std::int32_t ConstZeroI = 0;

constexpr ::std::int64_t ConstZeroL = 0LL;

constexpr float ConstZeroF = 0.0F;

constexpr float ConstZeroDotF = 0.0F;

constexpr double ConstZeroD = 0;

constexpr double ConstZeroDotD = 0;
struct Struct2;
struct Struct3;
class Base;

using BasePtr = ::std::shared_ptr<Base>;
class Derived;

using DerivedPtr = ::std::shared_ptr<Derived>;

}

namespace Test
{

struct Struct1
{
    bool boolFalse = false;
    bool boolTrue = true;
    ::std::uint8_t b = 254;
    ::std::int16_t s = 16000;
    ::std::int32_t i = 3;
    ::std::int64_t l = 4LL;
    float f = 5.1F;
    double d = 6.2;
    ::std::string str = "foo \\ \"bar\n \r\n\t\v\f\a\b\? \a \a";
    ::Test::Color c1 = ::Test::Color::red;
    ::Test::Color c2 = ::Test::Color::green;
    ::Test::Color c3 = ::Test::Color::blue;
    ::Test::Nested::Color nc1 = ::Test::Nested::Color::red;
    ::Test::Nested::Color nc2 = ::Test::Nested::Color::green;
    ::Test::Nested::Color nc3 = ::Test::Nested::Color::blue;
    ::std::string noDefault;
    ::std::int32_t zeroI = 0;
    ::std::int64_t zeroL = 0LL;
    float zeroF = 0.0F;
    float zeroDotF = 0.0F;
    double zeroD = 0;
    double zeroDotD = 0;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const bool&, const ::std::uint8_t&, const ::std::int16_t&, const ::std::int32_t&, const ::std::int64_t&, const float&, const double&, const ::std::string&, const ::Test::Color&, const ::Test::Color&, const ::Test::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&, const ::std::string&, const ::std::int32_t&, const ::std::int64_t&, const float&, const float&, const double&, const double&> ice_tuple() const
    {
        return std::tie(boolFalse, boolTrue, b, s, i, l, f, d, str, c1, c2, c3, nc1, nc2, nc3, noDefault, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD);
    }
};

struct Struct2
{
    bool boolTrue = ::Test::ConstBool;
    ::std::uint8_t b = ::Test::ConstByte;
    ::std::int16_t s = ::Test::ConstShort;
    ::std::int32_t i = ::Test::ConstInt;
    ::std::int64_t l = ::Test::ConstLong;
    float f = ::Test::ConstFloat;
    double d = ::Test::ConstDouble;
    ::std::string str = ::Test::ConstString;
    ::Test::Color c1 = ::Test::ConstColor1;
    ::Test::Color c2 = ::Test::ConstColor2;
    ::Test::Color c3 = ::Test::ConstColor3;
    ::Test::Nested::Color nc1 = ::Test::ConstNestedColor1;
    ::Test::Nested::Color nc2 = ::Test::ConstNestedColor2;
    ::Test::Nested::Color nc3 = ::Test::ConstNestedColor3;
    ::std::int32_t zeroI = ::Test::ConstZeroI;
    ::std::int64_t zeroL = ::Test::ConstZeroL;
    float zeroF = ::Test::ConstZeroF;
    float zeroDotF = ::Test::ConstZeroDotF;
    double zeroD = ::Test::ConstZeroD;
    double zeroDotD = ::Test::ConstZeroDotD;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const ::std::uint8_t&, const ::std::int16_t&, const ::std::int32_t&, const ::std::int64_t&, const float&, const double&, const ::std::string&, const ::Test::Color&, const ::Test::Color&, const ::Test::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&, const ::std::int32_t&, const ::std::int64_t&, const float&, const float&, const double&, const double&> ice_tuple() const
    {
        return std::tie(boolTrue, b, s, i, l, f, d, str, c1, c2, c3, nc1, nc2, nc3, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD);
    }
};

struct Struct3
{
    bool boolFalse = false;
    bool boolTrue = true;
    ::std::uint8_t b = 1;
    ::std::int16_t s = 2;
    ::std::int32_t i = 3;
    ::std::int64_t l = 4LL;
    float f = 5.1F;
    double d = 6.2;
    ::std::string str = "foo \\ \"bar\n \r\n\t\v\f\a\b\? \a \a";
    ::Test::Color c1 = ::Test::Color::red;
    ::Test::Color c2 = ::Test::Color::green;
    ::Test::Color c3 = ::Test::Color::blue;
    ::Test::Nested::Color nc1 = ::Test::Nested::Color::red;
    ::Test::Nested::Color nc2 = ::Test::Nested::Color::green;
    ::Test::Nested::Color nc3 = ::Test::Nested::Color::blue;
    ::std::string noDefault;
    ::std::int32_t zeroI = 0;
    ::std::int64_t zeroL = 0LL;
    float zeroF = 0.0F;
    float zeroDotF = 0.0F;
    double zeroD = 0;
    double zeroDotD = 0;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const bool&, const ::std::uint8_t&, const ::std::int16_t&, const ::std::int32_t&, const ::std::int64_t&, const float&, const double&, const ::std::string&, const ::Test::Color&, const ::Test::Color&, const ::Test::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&, const ::std::string&, const ::std::int32_t&, const ::std::int64_t&, const float&, const float&, const double&, const double&> ice_tuple() const
    {
        return std::tie(boolFalse, boolTrue, b, s, i, l, f, d, str, c1, c2, c3, nc1, nc2, nc3, noDefault, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD);
    }
};

class Base : public ::Ice::ValueHelper<Base, ::Ice::Value>
{
public:

    virtual ~Base();

    Base() = default;

    Base(const Base&) = default;
    Base(Base&&) = default;
    Base& operator=(const Base&) = default;
    Base& operator=(Base&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Base(bool boolFalse, bool boolTrue, ::std::uint8_t b, ::std::int16_t s, ::std::int32_t i, ::std::int64_t l, float f, double d, const ::std::string& str, const ::std::string& noDefault, ::std::int32_t zeroI, ::std::int64_t zeroL, float zeroF, float zeroDotF, double zeroD, double zeroDotD) :
        boolFalse(boolFalse),
        boolTrue(boolTrue),
        b(b),
        s(s),
        i(i),
        l(l),
        f(f),
        d(d),
        str(str),
        noDefault(noDefault),
        zeroI(zeroI),
        zeroL(zeroL),
        zeroF(zeroF),
        zeroDotF(zeroDotF),
        zeroD(zeroD),
        zeroDotD(zeroDotD)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const bool&, const ::std::uint8_t&, const ::std::int16_t&, const ::std::int32_t&, const ::std::int64_t&, const float&, const double&, const ::std::string&, const ::std::string&, const ::std::int32_t&, const ::std::int64_t&, const float&, const float&, const double&, const double&> ice_tuple() const
    {
        return std::tie(boolFalse, boolTrue, b, s, i, l, f, d, str, noDefault, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    bool boolFalse = false;
    bool boolTrue = true;
    ::std::uint8_t b = 1;
    ::std::int16_t s = 2;
    ::std::int32_t i = 3;
    ::std::int64_t l = 4LL;
    float f = 5.1F;
    double d = 6.2;
    ::std::string str = "foo \\ \"bar\n \r\n\t\v\f\a\b\? \a \a";
    ::std::string noDefault;
    ::std::int32_t zeroI = 0;
    ::std::int64_t zeroL = 0LL;
    float zeroF = 0.0F;
    float zeroDotF = 0.0F;
    double zeroD = 0;
    double zeroDotD = 0;
};

/// \cond INTERNAL
static Base _iceS_Base_init;
/// \endcond

class Derived : public ::Ice::ValueHelper<Derived, Base>
{
public:

    virtual ~Derived();

    Derived() = default;

    Derived(const Derived&) = default;
    Derived(Derived&&) = default;
    Derived& operator=(const Derived&) = default;
    Derived& operator=(Derived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Derived(bool boolFalse, bool boolTrue, ::std::uint8_t b, ::std::int16_t s, ::std::int32_t i, ::std::int64_t l, float f, double d, const ::std::string& str, const ::std::string& noDefault, ::std::int32_t zeroI, ::std::int64_t zeroL, float zeroF, float zeroDotF, double zeroD, double zeroDotD, ::Test::Color c1, ::Test::Color c2, ::Test::Color c3, ::Test::Nested::Color nc1, ::Test::Nested::Color nc2, ::Test::Nested::Color nc3) :
        Ice::ValueHelper<Derived, Base>(boolFalse, boolTrue, b, s, i, l, f, d, str, noDefault, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD),
        c1(c1),
        c2(c2),
        c3(c3),
        nc1(nc1),
        nc2(nc2),
        nc3(nc3)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const bool&, const ::std::uint8_t&, const ::std::int16_t&, const ::std::int32_t&, const ::std::int64_t&, const float&, const double&, const ::std::string&, const ::std::string&, const ::std::int32_t&, const ::std::int64_t&, const float&, const float&, const double&, const double&, const ::Test::Color&, const ::Test::Color&, const ::Test::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&> ice_tuple() const
    {
        return std::tie(boolFalse, boolTrue, b, s, i, l, f, d, str, noDefault, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD, c1, c2, c3, nc1, nc2, nc3);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::Color c1 = ::Test::Color::red;
    ::Test::Color c2 = ::Test::Color::green;
    ::Test::Color c3 = ::Test::Color::blue;
    ::Test::Nested::Color nc1 = ::Test::Nested::Color::red;
    ::Test::Nested::Color nc2 = ::Test::Nested::Color::green;
    ::Test::Nested::Color nc3 = ::Test::Nested::Color::blue;
};

class BaseEx : public ::Ice::UserExceptionHelper<BaseEx, ::Ice::UserException>
{
public:

    virtual ~BaseEx();

    BaseEx(const BaseEx&) = default;

    BaseEx() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    BaseEx(bool boolFalse, bool boolTrue, ::std::uint8_t b, ::std::int16_t s, ::std::int32_t i, ::std::int64_t l, float f, double d, const ::std::string& str, const ::std::string& noDefault, ::std::int32_t zeroI, ::std::int64_t zeroL, float zeroF, float zeroDotF, double zeroD, double zeroDotD) :
        boolFalse(boolFalse),
        boolTrue(boolTrue),
        b(b),
        s(s),
        i(i),
        l(l),
        f(f),
        d(d),
        str(str),
        noDefault(noDefault),
        zeroI(zeroI),
        zeroL(zeroL),
        zeroF(zeroF),
        zeroDotF(zeroDotF),
        zeroD(zeroD),
        zeroDotD(zeroDotD)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const bool&, const ::std::uint8_t&, const ::std::int16_t&, const ::std::int32_t&, const ::std::int64_t&, const float&, const double&, const ::std::string&, const ::std::string&, const ::std::int32_t&, const ::std::int64_t&, const float&, const float&, const double&, const double&> ice_tuple() const
    {
        return std::tie(boolFalse, boolTrue, b, s, i, l, f, d, str, noDefault, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    bool boolFalse = false;
    bool boolTrue = true;
    ::std::uint8_t b = 1;
    ::std::int16_t s = 2;
    ::std::int32_t i = 3;
    ::std::int64_t l = 4LL;
    float f = 5.1F;
    double d = 6.2;
    ::std::string str = "foo \\ \"bar\n \r\n\t\v\f\a\b\? \a \a";
    ::std::string noDefault;
    ::std::int32_t zeroI = 0;
    ::std::int64_t zeroL = 0LL;
    float zeroF = 0.0F;
    float zeroDotF = 0.0F;
    double zeroD = 0;
    double zeroDotD = 0;
};

class DerivedEx : public ::Ice::UserExceptionHelper<DerivedEx, BaseEx>
{
public:

    virtual ~DerivedEx();

    DerivedEx(const DerivedEx&) = default;

    DerivedEx() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    DerivedEx(bool boolFalse, bool boolTrue, ::std::uint8_t b, ::std::int16_t s, ::std::int32_t i, ::std::int64_t l, float f, double d, const ::std::string& str, const ::std::string& noDefault, ::std::int32_t zeroI, ::std::int64_t zeroL, float zeroF, float zeroDotF, double zeroD, double zeroDotD, Color c1, Color c2, Color c3, ::Test::Nested::Color nc1, ::Test::Nested::Color nc2, ::Test::Nested::Color nc3) :
        ::Ice::UserExceptionHelper<DerivedEx, BaseEx>(boolFalse, boolTrue, b, s, i, l, f, d, str, noDefault, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD),
        c1(c1),
        c2(c2),
        c3(c3),
        nc1(nc1),
        nc2(nc2),
        nc3(nc3)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const bool&, const ::std::uint8_t&, const ::std::int16_t&, const ::std::int32_t&, const ::std::int64_t&, const float&, const double&, const ::std::string&, const ::std::string&, const ::std::int32_t&, const ::std::int64_t&, const float&, const float&, const double&, const double&, const ::Test::Color&, const ::Test::Color&, const ::Test::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&> ice_tuple() const
    {
        return std::tie(boolFalse, boolTrue, b, s, i, l, f, d, str, noDefault, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD, c1, c2, c3, nc1, nc2, nc3);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::Color c1 = ::Test::ConstColor1;
    ::Test::Color c2 = ::Test::ConstColor2;
    ::Test::Color c3 = ::Test::ConstColor3;
    ::Test::Nested::Color nc1 = ::Test::ConstNestedColor1;
    ::Test::Nested::Color nc2 = ::Test::ConstNestedColor2;
    ::Test::Nested::Color nc3 = ::Test::ConstNestedColor3;
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::Color>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::Nested::Color>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::Struct1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 73;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Struct1, S>
{
    static void read(S* istr, ::Test::Struct1& v)
    {
        istr->readAll(v.boolFalse, v.boolTrue, v.b, v.s, v.i, v.l, v.f, v.d, v.str, v.c1, v.c2, v.c3, v.nc1, v.nc2, v.nc3, v.noDefault, v.zeroI, v.zeroL, v.zeroF, v.zeroDotF, v.zeroD, v.zeroDotD);
    }
};

template<>
struct StreamableTraits<::Test::Struct2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 71;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Struct2, S>
{
    static void read(S* istr, ::Test::Struct2& v)
    {
        istr->readAll(v.boolTrue, v.b, v.s, v.i, v.l, v.f, v.d, v.str, v.c1, v.c2, v.c3, v.nc1, v.nc2, v.nc3, v.zeroI, v.zeroL, v.zeroF, v.zeroDotF, v.zeroD, v.zeroDotD);
    }
};

template<>
struct StreamableTraits<::Test::Struct3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 73;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Struct3, S>
{
    static void read(S* istr, ::Test::Struct3& v)
    {
        istr->readAll(v.boolFalse, v.boolTrue, v.b, v.s, v.i, v.l, v.f, v.d, v.str, v.c1, v.c2, v.c3, v.nc1, v.nc2, v.nc3, v.noDefault, v.zeroI, v.zeroL, v.zeroF, v.zeroDotF, v.zeroD, v.zeroDotD);
    }
};

template<typename S>
struct StreamReader<::Test::Base, S>
{
    static void read(S* istr, ::Test::Base& v)
    {
        istr->readAll(v.boolFalse, v.boolTrue, v.b, v.s, v.i, v.l, v.f, v.d, v.str, v.noDefault, v.zeroI, v.zeroL, v.zeroF, v.zeroDotF, v.zeroD, v.zeroDotD);
    }
};

template<typename S>
struct StreamWriter<::Test::Derived, S>
{
    static void write(S* ostr, const ::Test::Derived& v)
    {
        ostr->writeAll(v.c1, v.c2, v.c3, v.nc1, v.nc2, v.nc3);
    }
};

template<typename S>
struct StreamReader<::Test::Derived, S>
{
    static void read(S* istr, ::Test::Derived& v)
    {
        istr->readAll(v.c1, v.c2, v.c3, v.nc1, v.nc2, v.nc3);
    }
};

template<typename S>
struct StreamReader<::Test::BaseEx, S>
{
    static void read(S* istr, ::Test::BaseEx& v)
    {
        istr->readAll(v.boolFalse, v.boolTrue, v.b, v.s, v.i, v.l, v.f, v.d, v.str, v.noDefault, v.zeroI, v.zeroL, v.zeroF, v.zeroDotF, v.zeroD, v.zeroDotD);
    }
};

template<typename S>
struct StreamWriter<::Test::DerivedEx, S>
{
    static void write(S* ostr, const ::Test::DerivedEx& v)
    {
        ostr->writeAll(v.c1, v.c2, v.c3, v.nc1, v.nc2, v.nc3);
    }
};

template<typename S>
struct StreamReader<::Test::DerivedEx, S>
{
    static void read(S* istr, ::Test::DerivedEx& v)
    {
        istr->readAll(v.c1, v.c2, v.c3, v.nc1, v.nc2, v.nc3);
    }
};

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
