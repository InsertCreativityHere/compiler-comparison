//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `ClientPrivate.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __ClientPrivate_h__
#define __ClientPrivate_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include <Ice/SlicedDataF.h>
#include <Test.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 9
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class D3;
class PCUnknown;
class PCDerived;
class PCDerived2;
class PCDerived3;
class CompactPCDerived;

}

namespace Test
{

class D3 : public ::Ice::ValueHelper<D3, B>
{
public:

    virtual ~D3();

    D3() = default;

    D3(const D3&) = default;
    D3(D3&&) = default;
    D3& operator=(const D3&) = default;
    D3& operator=(D3&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D3(const ::std::string& sb, const ::std::shared_ptr<::Test::B>& pb, const ::std::string& sd3, const ::std::shared_ptr<::Test::B>& pd3) :
        Ice::ValueHelper<D3, B>(sb, pb),
        sd3(sd3),
        pd3(pd3)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb, sd3, pd3);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sd3;
    ::std::shared_ptr<::Test::B> pd3;
};

/// \cond INTERNAL
static D3 _iceS_D3_init;
/// \endcond

class PCUnknown : public ::Ice::ValueHelper<PCUnknown, PBase>
{
public:

    virtual ~PCUnknown();

    PCUnknown() = default;

    PCUnknown(const PCUnknown&) = default;
    PCUnknown(PCUnknown&&) = default;
    PCUnknown& operator=(const PCUnknown&) = default;
    PCUnknown& operator=(PCUnknown&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PCUnknown(int pi, const ::std::string& pu) :
        Ice::ValueHelper<PCUnknown, PBase>(pi),
        pu(pu)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(pi, pu);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown value type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the value was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const override;
    virtual void _iceRead(::Ice::InputStream*) override;
    /// \endcond

    ::std::string pu;

protected:

    /// \cond STREAM
    ::std::shared_ptr<::Ice::SlicedData> _iceSlicedData;
    /// \endcond
};

class PCDerived : public ::Ice::ValueHelper<PCDerived, PDerived>
{
public:

    virtual ~PCDerived();

    PCDerived() = default;

    PCDerived(const PCDerived&) = default;
    PCDerived(PCDerived&&) = default;
    PCDerived& operator=(const PCDerived&) = default;
    PCDerived& operator=(PCDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PCDerived(int pi, const ::std::string& ps, const ::std::shared_ptr<::Test::PBase>& pb, const ::Test::PBaseSeq& pbs) :
        Ice::ValueHelper<PCDerived, PDerived>(pi, ps, pb),
        pbs(pbs)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&, const ::Test::PBaseSeq&> ice_tuple() const
    {
        return std::tie(pi, ps, pb, pbs);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::PBaseSeq pbs;
};

class PCDerived2 : public ::Ice::ValueHelper<PCDerived2, PCDerived>
{
public:

    virtual ~PCDerived2();

    PCDerived2() = default;

    PCDerived2(const PCDerived2&) = default;
    PCDerived2(PCDerived2&&) = default;
    PCDerived2& operator=(const PCDerived2&) = default;
    PCDerived2& operator=(PCDerived2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PCDerived2(int pi, const ::std::string& ps, const ::std::shared_ptr<::Test::PBase>& pb, const ::Test::PBaseSeq& pbs, int pcd2) :
        Ice::ValueHelper<PCDerived2, PCDerived>(pi, ps, pb, pbs),
        pcd2(pcd2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&, const ::Test::PBaseSeq&, const int&> ice_tuple() const
    {
        return std::tie(pi, ps, pb, pbs, pcd2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int pcd2;
};

class PCDerived3 : public ::Ice::ValueHelper<PCDerived3, PCDerived2>
{
public:

    virtual ~PCDerived3();

    PCDerived3() = default;

    PCDerived3(const PCDerived3&) = default;
    PCDerived3(PCDerived3&&) = default;
    PCDerived3& operator=(const PCDerived3&) = default;
    PCDerived3& operator=(PCDerived3&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PCDerived3(int pi, const ::std::string& ps, const ::std::shared_ptr<::Test::PBase>& pb, const ::Test::PBaseSeq& pbs, int pcd2, const ::std::shared_ptr<::Ice::Value>& pcd3) :
        Ice::ValueHelper<PCDerived3, PCDerived2>(pi, ps, pb, pbs, pcd2),
        pcd3(pcd3)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&, const ::Test::PBaseSeq&, const int&, const ::std::shared_ptr<::Ice::Value>&> ice_tuple() const
    {
        return std::tie(pi, ps, pb, pbs, pcd2, pcd3);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Ice::Value> pcd3;
};

class CompactPCDerived : public ::Ice::ValueHelper<CompactPCDerived, CompactPDerived>
{
public:

    virtual ~CompactPCDerived();

    CompactPCDerived() = default;

    CompactPCDerived(const CompactPCDerived&) = default;
    CompactPCDerived(CompactPCDerived&&) = default;
    CompactPCDerived& operator=(const CompactPCDerived&) = default;
    CompactPCDerived& operator=(CompactPCDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    CompactPCDerived(int pi, const ::std::string& ps, const ::std::shared_ptr<::Test::PBase>& pb, const ::Test::PBaseSeq& pbs) :
        Ice::ValueHelper<CompactPCDerived, CompactPDerived>(pi, ps, pb),
        pbs(pbs)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&, const ::Test::PBaseSeq&> ice_tuple() const
    {
        return std::tie(pi, ps, pb, pbs);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::PBaseSeq pbs;
};

}

namespace Test
{

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter<::Test::D3, S>
{
    static void write(S* ostr, const ::Test::D3& v)
    {
        ostr->writeAll(v.sd3, v.pd3);
    }
};

template<typename S>
struct StreamReader<::Test::D3, S>
{
    static void read(S* istr, ::Test::D3& v)
    {
        istr->readAll(v.sd3, v.pd3);
    }
};

template<typename S>
struct StreamWriter<::Test::PCUnknown, S>
{
    static void write(S* ostr, const ::Test::PCUnknown& v)
    {
        ostr->writeAll(v.pu);
    }
};

template<typename S>
struct StreamReader<::Test::PCUnknown, S>
{
    static void read(S* istr, ::Test::PCUnknown& v)
    {
        istr->readAll(v.pu);
    }
};

template<typename S>
struct StreamWriter<::Test::PCDerived, S>
{
    static void write(S* ostr, const ::Test::PCDerived& v)
    {
        ostr->writeAll(v.pbs);
    }
};

template<typename S>
struct StreamReader<::Test::PCDerived, S>
{
    static void read(S* istr, ::Test::PCDerived& v)
    {
        istr->readAll(v.pbs);
    }
};

template<typename S>
struct StreamWriter<::Test::PCDerived2, S>
{
    static void write(S* ostr, const ::Test::PCDerived2& v)
    {
        ostr->writeAll(v.pcd2);
    }
};

template<typename S>
struct StreamReader<::Test::PCDerived2, S>
{
    static void read(S* istr, ::Test::PCDerived2& v)
    {
        istr->readAll(v.pcd2);
    }
};

template<typename S>
struct StreamWriter<::Test::PCDerived3, S>
{
    static void write(S* ostr, const ::Test::PCDerived3& v)
    {
        ostr->writeAll(v.pcd3);
    }
};

template<typename S>
struct StreamReader<::Test::PCDerived3, S>
{
    static void read(S* istr, ::Test::PCDerived3& v)
    {
        istr->readAll(v.pcd3);
    }
};

template<typename S>
struct StreamWriter<::Test::CompactPCDerived, S>
{
    static void write(S* ostr, const ::Test::CompactPCDerived& v)
    {
        ostr->writeAll(v.pbs);
    }
};

template<typename S>
struct StreamReader<::Test::CompactPCDerived, S>
{
    static void read(S* istr, ::Test::CompactPCDerived& v)
    {
        istr->readAll(v.pbs);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using D3Ptr = ::std::shared_ptr<D3>;

using PCUnknownPtr = ::std::shared_ptr<PCUnknown>;

using PCDerivedPtr = ::std::shared_ptr<PCDerived>;

using PCDerived2Ptr = ::std::shared_ptr<PCDerived2>;

using PCDerived3Ptr = ::std::shared_ptr<PCDerived3>;

using CompactPCDerivedPtr = ::std::shared_ptr<CompactPCDerived>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class D3;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< D3>&);
::IceProxy::Ice::Object* upCast(D3*);
/// \endcond

class PCUnknown;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< PCUnknown>&);
::IceProxy::Ice::Object* upCast(PCUnknown*);
/// \endcond

class PCDerived;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< PCDerived>&);
::IceProxy::Ice::Object* upCast(PCDerived*);
/// \endcond

class PCDerived2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< PCDerived2>&);
::IceProxy::Ice::Object* upCast(PCDerived2*);
/// \endcond

class PCDerived3;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< PCDerived3>&);
::IceProxy::Ice::Object* upCast(PCDerived3*);
/// \endcond

class CompactPCDerived;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< CompactPCDerived>&);
::IceProxy::Ice::Object* upCast(CompactPCDerived*);
/// \endcond

}

}

namespace Test
{

class D3;
/// \cond INTERNAL
::Ice::Object* upCast(D3*);
/// \endcond
typedef ::IceInternal::Handle< D3> D3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::D3> D3Prx;
typedef D3Prx D3PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(D3Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class PCUnknown;
/// \cond INTERNAL
::Ice::Object* upCast(PCUnknown*);
/// \endcond
typedef ::IceInternal::Handle< PCUnknown> PCUnknownPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::PCUnknown> PCUnknownPrx;
typedef PCUnknownPrx PCUnknownPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(PCUnknownPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class PCDerived;
/// \cond INTERNAL
::Ice::Object* upCast(PCDerived*);
/// \endcond
typedef ::IceInternal::Handle< PCDerived> PCDerivedPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::PCDerived> PCDerivedPrx;
typedef PCDerivedPrx PCDerivedPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(PCDerivedPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class PCDerived2;
/// \cond INTERNAL
::Ice::Object* upCast(PCDerived2*);
/// \endcond
typedef ::IceInternal::Handle< PCDerived2> PCDerived2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::PCDerived2> PCDerived2Prx;
typedef PCDerived2Prx PCDerived2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(PCDerived2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class PCDerived3;
/// \cond INTERNAL
::Ice::Object* upCast(PCDerived3*);
/// \endcond
typedef ::IceInternal::Handle< PCDerived3> PCDerived3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::PCDerived3> PCDerived3Prx;
typedef PCDerived3Prx PCDerived3PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(PCDerived3Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class CompactPCDerived;
/// \cond INTERNAL
::Ice::Object* upCast(CompactPCDerived*);
/// \endcond
typedef ::IceInternal::Handle< CompactPCDerived> CompactPCDerivedPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::CompactPCDerived> CompactPCDerivedPrx;
typedef CompactPCDerivedPrx CompactPCDerivedPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CompactPCDerivedPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

/// \cond INTERNAL
namespace IceAsync
{

}
/// \endcond

namespace Test
{

}

namespace IceProxy
{

namespace Test
{

class D3 : public virtual ::Ice::Proxy<D3, ::IceProxy::Test::B>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class PCUnknown : public virtual ::Ice::Proxy<PCUnknown, ::IceProxy::Test::PBase>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class PCDerived : public virtual ::Ice::Proxy<PCDerived, ::IceProxy::Test::PDerived>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class PCDerived2 : public virtual ::Ice::Proxy<PCDerived2, ::IceProxy::Test::PCDerived>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class PCDerived3 : public virtual ::Ice::Proxy<PCDerived3, ::IceProxy::Test::PCDerived2>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class CompactPCDerived : public virtual ::Ice::Proxy<CompactPCDerived, ::IceProxy::Test::CompactPDerived>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class D3 : public B
{
public:

    typedef D3Prx ProxyType;
    typedef D3Ptr PointerType;

    virtual ~D3();

    D3()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    D3(const ::std::string& sb, const ::Test::BPtr& pb, const ::std::string& sd3, const ::Test::BPtr& pd3) :
        ::Test::B(sb, pb),
        sd3(sd3),
        pd3(pd3)
    {
    }

#ifdef ICE_CPP11_COMPILER
    D3(const D3&) = default;
    D3& operator=(const D3&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string sd3;
    ::Test::BPtr pd3;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_D3_init = ::Test::D3::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const D3& lhs, const D3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const D3& lhs, const D3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class PCUnknown : public PBase, public ::IceInternal::GCObject
{
public:

    typedef PCUnknownPrx ProxyType;
    typedef PCUnknownPtr PointerType;

    virtual ~PCUnknown();

    PCUnknown()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    PCUnknown(::Ice::Int pi, const ::std::string& pu) :
        ::Test::PBase(pi),
        pu(pu)
    {
    }

#ifdef ICE_CPP11_COMPILER
    PCUnknown(const PCUnknown&) = default;
    PCUnknown& operator=(const PCUnknown&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

    /**
     * Obtains the SlicedData object created when an unknown class type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the class was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::Ice::SlicedDataPtr ice_getSlicedData() const;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const;
    virtual void _iceRead(::Ice::InputStream*);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string pu;

protected:

    /// \cond STREAM
    ::Ice::SlicedDataPtr _iceSlicedData;
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_PCUnknown_init = ::Test::PCUnknown::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const PCUnknown& lhs, const PCUnknown& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const PCUnknown& lhs, const PCUnknown& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class PCDerived : public PDerived
{
public:

    typedef PCDerivedPrx ProxyType;
    typedef PCDerivedPtr PointerType;

    virtual ~PCDerived();

    PCDerived()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    PCDerived(::Ice::Int pi, const ::std::string& ps, const ::Test::PBasePtr& pb, const ::Test::PBaseSeq& pbs) :
        ::Test::PDerived(pi, ps, pb),
        pbs(pbs)
    {
    }

#ifdef ICE_CPP11_COMPILER
    PCDerived(const PCDerived&) = default;
    PCDerived& operator=(const PCDerived&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::PBaseSeq pbs;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_PCDerived_init = ::Test::PCDerived::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const PCDerived& lhs, const PCDerived& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const PCDerived& lhs, const PCDerived& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class PCDerived2 : public PCDerived
{
public:

    typedef PCDerived2Prx ProxyType;
    typedef PCDerived2Ptr PointerType;

    virtual ~PCDerived2();

    PCDerived2()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    PCDerived2(::Ice::Int pi, const ::std::string& ps, const ::Test::PBasePtr& pb, const ::Test::PBaseSeq& pbs, ::Ice::Int pcd2) :
        ::Test::PCDerived(pi, ps, pb, pbs),
        pcd2(pcd2)
    {
    }

#ifdef ICE_CPP11_COMPILER
    PCDerived2(const PCDerived2&) = default;
    PCDerived2& operator=(const PCDerived2&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int pcd2;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_PCDerived2_init = ::Test::PCDerived2::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const PCDerived2& lhs, const PCDerived2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const PCDerived2& lhs, const PCDerived2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class PCDerived3 : public PCDerived2
{
public:

    typedef PCDerived3Prx ProxyType;
    typedef PCDerived3Ptr PointerType;

    virtual ~PCDerived3();

    PCDerived3()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    PCDerived3(::Ice::Int pi, const ::std::string& ps, const ::Test::PBasePtr& pb, const ::Test::PBaseSeq& pbs, ::Ice::Int pcd2, const ::Ice::ObjectPtr& pcd3) :
        ::Test::PCDerived2(pi, ps, pb, pbs, pcd2),
        pcd3(pcd3)
    {
    }

#ifdef ICE_CPP11_COMPILER
    PCDerived3(const PCDerived3&) = default;
    PCDerived3& operator=(const PCDerived3&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::ObjectPtr pcd3;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_PCDerived3_init = ::Test::PCDerived3::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const PCDerived3& lhs, const PCDerived3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const PCDerived3& lhs, const PCDerived3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class CompactPCDerived : public CompactPDerived
{
public:

    typedef CompactPCDerivedPrx ProxyType;
    typedef CompactPCDerivedPtr PointerType;

    virtual ~CompactPCDerived();

    CompactPCDerived()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    CompactPCDerived(::Ice::Int pi, const ::std::string& ps, const ::Test::PBasePtr& pb, const ::Test::PBaseSeq& pbs) :
        ::Test::CompactPDerived(pi, ps, pb),
        pbs(pbs)
    {
    }

#ifdef ICE_CPP11_COMPILER
    CompactPCDerived(const CompactPCDerived&) = default;
    CompactPCDerived& operator=(const CompactPCDerived&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::PBaseSeq pbs;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CompactPCDerived_init = ::Test::CompactPCDerived::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CompactPCDerived& lhs, const CompactPCDerived& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const CompactPCDerived& lhs, const CompactPCDerived& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter< ::Test::D3, S>
{
    static void write(S* ostr, const ::Test::D3& v)
    {
        ostr->write(v.sd3);
        ostr->write(v.pd3);
    }
};

template<typename S>
struct StreamReader< ::Test::D3, S>
{
    static void read(S* istr, ::Test::D3& v)
    {
        istr->read(v.sd3);
        istr->read(v.pd3);
    }
};

template<typename S>
struct StreamWriter< ::Test::PCUnknown, S>
{
    static void write(S* ostr, const ::Test::PCUnknown& v)
    {
        ostr->write(v.pu);
    }
};

template<typename S>
struct StreamReader< ::Test::PCUnknown, S>
{
    static void read(S* istr, ::Test::PCUnknown& v)
    {
        istr->read(v.pu);
    }
};

template<typename S>
struct StreamWriter< ::Test::PCDerived, S>
{
    static void write(S* ostr, const ::Test::PCDerived& v)
    {
        ostr->write(v.pbs);
    }
};

template<typename S>
struct StreamReader< ::Test::PCDerived, S>
{
    static void read(S* istr, ::Test::PCDerived& v)
    {
        istr->read(v.pbs);
    }
};

template<typename S>
struct StreamWriter< ::Test::PCDerived2, S>
{
    static void write(S* ostr, const ::Test::PCDerived2& v)
    {
        ostr->write(v.pcd2);
    }
};

template<typename S>
struct StreamReader< ::Test::PCDerived2, S>
{
    static void read(S* istr, ::Test::PCDerived2& v)
    {
        istr->read(v.pcd2);
    }
};

template<typename S>
struct StreamWriter< ::Test::PCDerived3, S>
{
    static void write(S* ostr, const ::Test::PCDerived3& v)
    {
        ostr->write(v.pcd3);
    }
};

template<typename S>
struct StreamReader< ::Test::PCDerived3, S>
{
    static void read(S* istr, ::Test::PCDerived3& v)
    {
        istr->read(v.pcd3);
    }
};

template<typename S>
struct StreamWriter< ::Test::CompactPCDerived, S>
{
    static void write(S* ostr, const ::Test::CompactPCDerived& v)
    {
        ostr->write(v.pbs);
    }
};

template<typename S>
struct StreamReader< ::Test::CompactPCDerived, S>
{
    static void read(S* istr, ::Test::CompactPCDerived& v)
    {
        istr->read(v.pbs);
    }
};

}
/// \endcond

namespace Test
{

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
