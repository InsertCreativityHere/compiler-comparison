//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `ServerPrivate.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __ServerPrivate_h__
#define __ServerPrivate_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Test.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{

class SBSUnknownDerived;

using SBSUnknownDerivedPtr = ::std::shared_ptr<SBSUnknownDerived>;
class SUnknown;

using SUnknownPtr = ::std::shared_ptr<SUnknown>;
class D2;

using D2Ptr = ::std::shared_ptr<D2>;
class D4;

using D4Ptr = ::std::shared_ptr<D4>;
class MyClass;

using MyClassPtr = ::std::shared_ptr<MyClass>;
class PSUnknown;

using PSUnknownPtr = ::std::shared_ptr<PSUnknown>;
class PSUnknown2;

using PSUnknown2Ptr = ::std::shared_ptr<PSUnknown2>;

}

namespace Test
{

class SBSUnknownDerived : public ::Ice::ValueHelper<SBSUnknownDerived, SBase>
{
public:

    SBSUnknownDerived() = default;
    SBSUnknownDerived(const SBSUnknownDerived&) = default;
    SBSUnknownDerived(SBSUnknownDerived&&) = default;
    SBSUnknownDerived& operator=(const SBSUnknownDerived&) = default;
    SBSUnknownDerived& operator=(SBSUnknownDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SBSUnknownDerived(::std::string sb, ::std::string sbsud) :
        Ice::ValueHelper<SBSUnknownDerived, SBase>(::std::move(sb)),
        sbsud(::std::move(sbsud))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(sb, sbsud);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string sbsud;
};

/// \cond INTERNAL
static SBSUnknownDerived _iceS_SBSUnknownDerived_init;
/// \endcond

class SUnknown : public ::Ice::ValueHelper<SUnknown, ::Ice::Value>
{
public:

    SUnknown() = default;
    SUnknown(const SUnknown&) = default;
    SUnknown(SUnknown&&) = default;
    SUnknown& operator=(const SUnknown&) = default;
    SUnknown& operator=(SUnknown&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SUnknown(::std::string su, ::std::shared_ptr<::Test::SUnknown> cycle) :
        su(::std::move(su)),
        cycle(::std::move(cycle))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::SUnknown>&> ice_tuple() const
    {
        return std::tie(su, cycle);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string su;
    ::std::shared_ptr<::Test::SUnknown> cycle;
};

class D2 : public ::Ice::ValueHelper<D2, B>
{
public:

    D2() = default;
    D2(const D2&) = default;
    D2(D2&&) = default;
    D2& operator=(const D2&) = default;
    D2& operator=(D2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D2(::std::string sb, ::std::shared_ptr<::Test::B> pb, ::std::string sd2, ::std::shared_ptr<::Test::B> pd2) :
        Ice::ValueHelper<D2, B>(::std::move(sb), ::std::move(pb)),
        sd2(::std::move(sd2)),
        pd2(::std::move(pd2))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb, sd2, pd2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string sd2;
    ::std::shared_ptr<::Test::B> pd2;
};

class D4 : public ::Ice::ValueHelper<D4, B>
{
public:

    D4() = default;
    D4(const D4&) = default;
    D4(D4&&) = default;
    D4& operator=(const D4&) = default;
    D4& operator=(D4&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D4(::std::string sb, ::std::shared_ptr<::Test::B> pb, ::std::shared_ptr<::Test::B> p1, ::std::shared_ptr<::Test::B> p2) :
        Ice::ValueHelper<D4, B>(::std::move(sb), ::std::move(pb)),
        p1(::std::move(p1)),
        p2(::std::move(p2))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::shared_ptr<::Test::B>&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb, p1, p2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::shared_ptr<::Test::B> p1;
    ::std::shared_ptr<::Test::B> p2;
};

class UnknownDerivedException : public BaseException
{
public:
    using BaseException::BaseException;

    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownDerivedException(::std::string sbe, ::std::shared_ptr<B> pb, ::std::string sude, ::std::shared_ptr<D2> pd2) noexcept :
        BaseException(::std::move(sbe), ::std::move(pb)),
        sude(::std::move(sude)),
        pd2(::std::move(pd2))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::D2>&> ice_tuple() const
    {
        return std::tie(sbe, pb, sude, pd2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    void ice_throw() const override;

    ::std::string sude;
    ::std::shared_ptr<::Test::D2> pd2;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

class MyClass : public ::Ice::ValueHelper<MyClass, ::Ice::Value>
{
public:

    MyClass() = default;
    MyClass(const MyClass&) = default;
    MyClass(MyClass&&) = default;
    MyClass& operator=(const MyClass&) = default;
    MyClass& operator=(MyClass&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit MyClass(::std::int32_t i) :
        i(i)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(i);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::int32_t i;
};

class PSUnknown : public ::Ice::ValueHelper<PSUnknown, Preserved>
{
public:

    PSUnknown() = default;
    PSUnknown(const PSUnknown&) = default;
    PSUnknown(PSUnknown&&) = default;
    PSUnknown& operator=(const PSUnknown&) = default;
    PSUnknown& operator=(PSUnknown&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknown(::std::int32_t pi, ::std::string ps, ::std::string psu, ::std::shared_ptr<::Test::PNode> graph, ::std::shared_ptr<::Test::MyClass> cl) :
        Ice::ValueHelper<PSUnknown, Preserved>(pi, ::std::move(ps)),
        psu(::std::move(psu)),
        graph(::std::move(graph)),
        cl(::std::move(cl))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::std::string&, const ::std::shared_ptr<::Test::PNode>&, const ::std::shared_ptr<::Test::MyClass>&> ice_tuple() const
    {
        return std::tie(pi, ps, psu, graph, cl);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string psu;
    ::std::shared_ptr<::Test::PNode> graph;
    ::std::shared_ptr<::Test::MyClass> cl;
};

class PSUnknown2 : public ::Ice::ValueHelper<PSUnknown2, Preserved>
{
public:

    PSUnknown2() = default;
    PSUnknown2(const PSUnknown2&) = default;
    PSUnknown2(PSUnknown2&&) = default;
    PSUnknown2& operator=(const PSUnknown2&) = default;
    PSUnknown2& operator=(PSUnknown2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknown2(::std::int32_t pi, ::std::string ps, ::std::shared_ptr<::Test::PBase> pb) :
        Ice::ValueHelper<PSUnknown2, Preserved>(pi, ::std::move(ps)),
        pb(::std::move(pb))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&> ice_tuple() const
    {
        return std::tie(pi, ps, pb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::shared_ptr<::Test::PBase> pb;
};

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter<::Test::SBSUnknownDerived, S>
{
    static void write(S* ostr, const ::Test::SBSUnknownDerived& v)
    {
        ostr->writeAll(v.sbsud);
    }
};

template<typename S>
struct StreamReader<::Test::SBSUnknownDerived, S>
{
    static void read(S* istr, ::Test::SBSUnknownDerived& v)
    {
        istr->readAll(v.sbsud);
    }
};

template<typename S>
struct StreamReader<::Test::SUnknown, S>
{
    static void read(S* istr, ::Test::SUnknown& v)
    {
        istr->readAll(v.su, v.cycle);
    }
};

template<typename S>
struct StreamWriter<::Test::D2, S>
{
    static void write(S* ostr, const ::Test::D2& v)
    {
        ostr->writeAll(v.sd2, v.pd2);
    }
};

template<typename S>
struct StreamReader<::Test::D2, S>
{
    static void read(S* istr, ::Test::D2& v)
    {
        istr->readAll(v.sd2, v.pd2);
    }
};

template<typename S>
struct StreamWriter<::Test::D4, S>
{
    static void write(S* ostr, const ::Test::D4& v)
    {
        ostr->writeAll(v.p1, v.p2);
    }
};

template<typename S>
struct StreamReader<::Test::D4, S>
{
    static void read(S* istr, ::Test::D4& v)
    {
        istr->readAll(v.p1, v.p2);
    }
};

template<typename S>
struct StreamWriter<::Test::UnknownDerivedException, S>
{
    static void write(S* ostr, const ::Test::UnknownDerivedException& v)
    {
        ostr->writeAll(v.sude, v.pd2);
    }
};

template<typename S>
struct StreamReader<::Test::UnknownDerivedException, S>
{
    static void read(S* istr, ::Test::UnknownDerivedException& v)
    {
        istr->readAll(v.sude, v.pd2);
    }
};

template<typename S>
struct StreamReader<::Test::MyClass, S>
{
    static void read(S* istr, ::Test::MyClass& v)
    {
        istr->readAll(v.i);
    }
};

template<typename S>
struct StreamWriter<::Test::PSUnknown, S>
{
    static void write(S* ostr, const ::Test::PSUnknown& v)
    {
        ostr->writeAll(v.psu, v.graph, v.cl);
    }
};

template<typename S>
struct StreamReader<::Test::PSUnknown, S>
{
    static void read(S* istr, ::Test::PSUnknown& v)
    {
        istr->readAll(v.psu, v.graph, v.cl);
    }
};

template<typename S>
struct StreamWriter<::Test::PSUnknown2, S>
{
    static void write(S* ostr, const ::Test::PSUnknown2& v)
    {
        ostr->writeAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::PSUnknown2, S>
{
    static void read(S* istr, ::Test::PSUnknown2& v)
    {
        istr->readAll(v.pb);
    }
};

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
