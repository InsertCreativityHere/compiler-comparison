// Copyright (c) ZeroC, Inc.
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file 'Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

// clang-format off

#ifndef Test_h_
#define Test_h_

#include <Ice/PushDisableWarnings.h>
#include <Ice/Ice.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{
    using ByteString = ::std::vector<std::byte>;

    using ByteList = ::std::vector<std::byte>;

    using StringList = ::std::vector<::std::string>;

    using StringTuple = ::std::vector<::std::string>;

    using BoolSeq1 = ::std::vector<bool>;

    using BoolSeq2 = ::std::vector<bool>;

    using ByteSeq1 = ::std::vector<std::byte>;

    using ByteSeq2 = ::std::vector<std::byte>;

    using ShortSeq1 = ::std::vector<::std::int16_t>;

    using ShortSeq2 = ::std::vector<::std::int16_t>;

    using IntSeq1 = ::std::vector<::std::int32_t>;

    using IntSeq2 = ::std::vector<::std::int32_t>;

    using LongSeq1 = ::std::vector<::std::int64_t>;

    using LongSeq2 = ::std::vector<::std::int64_t>;

    using FloatSeq1 = ::std::vector<float>;

    using FloatSeq2 = ::std::vector<float>;

    using DoubleSeq1 = ::std::vector<double>;

    using DoubleSeq2 = ::std::vector<double>;

    struct S;

    class C;
    using CPtr = ::std::shared_ptr<C>;

    class D;
    using DPtr = ::std::shared_ptr<D>;

    class CustomPrx;

}

namespace Test
{

class CustomPrx : public Ice::Proxy<CustomPrx, Ice::ObjectPrx>
{
public:

    ByteString opByteString1(const ByteString& b1, ByteString& b2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<ByteString, ByteString>> opByteString1Async(const ByteString& b1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opByteString1Async(const ByteString& b1, ::std::function<void(::Test::ByteString, ::Test::ByteString)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteString1(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<ByteString, ByteString>>>&, const ByteString&, const Ice::Context&) const;
    /// \endcond

    ByteString opByteString2(const ByteString& b1, ByteString& b2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<ByteString, ByteString>> opByteString2Async(const ByteString& b1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opByteString2Async(const ByteString& b1, ::std::function<void(::Test::ByteString, ::Test::ByteString)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteString2(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<ByteString, ByteString>>>&, const ByteString&, const Ice::Context&) const;
    /// \endcond

    ByteList opByteList1(const ByteList& b1, ByteList& b2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<ByteList, ByteList>> opByteList1Async(const ByteList& b1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opByteList1Async(const ByteList& b1, ::std::function<void(::Test::ByteList, ::Test::ByteList)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteList1(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>&, const ByteList&, const Ice::Context&) const;
    /// \endcond

    ByteList opByteList2(const ByteList& b1, ByteList& b2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<ByteList, ByteList>> opByteList2Async(const ByteList& b1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opByteList2Async(const ByteList& b1, ::std::function<void(::Test::ByteList, ::Test::ByteList)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteList2(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>&, const ByteList&, const Ice::Context&) const;
    /// \endcond

    StringList opStringList1(const StringList& s1, StringList& s2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<StringList, StringList>> opStringList1Async(const StringList& s1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opStringList1Async(const StringList& s1, ::std::function<void(::Test::StringList, ::Test::StringList)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opStringList1(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<StringList, StringList>>>&, const StringList&, const Ice::Context&) const;
    /// \endcond

    StringList opStringList2(const StringList& s1, StringList& s2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<StringList, StringList>> opStringList2Async(const StringList& s1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opStringList2Async(const StringList& s1, ::std::function<void(::Test::StringList, ::Test::StringList)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opStringList2(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<StringList, StringList>>>&, const StringList&, const Ice::Context&) const;
    /// \endcond

    StringTuple opStringTuple1(const StringTuple& s1, StringTuple& s2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<StringTuple, StringTuple>> opStringTuple1Async(const StringTuple& s1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opStringTuple1Async(const StringTuple& s1, ::std::function<void(::Test::StringTuple, ::Test::StringTuple)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opStringTuple1(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<StringTuple, StringTuple>>>&, const StringTuple&, const Ice::Context&) const;
    /// \endcond

    StringTuple opStringTuple2(const StringTuple& s1, StringTuple& s2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<StringTuple, StringTuple>> opStringTuple2Async(const StringTuple& s1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opStringTuple2Async(const StringTuple& s1, ::std::function<void(::Test::StringTuple, ::Test::StringTuple)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opStringTuple2(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<StringTuple, StringTuple>>>&, const StringTuple&, const Ice::Context&) const;
    /// \endcond

    void sendS(const S& val, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> sendSAsync(const S& val, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    sendSAsync(const S& val, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_sendS(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const S&, const Ice::Context&) const;
    /// \endcond

    void sendC(const CPtr& val, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> sendCAsync(const CPtr& val, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    sendCAsync(const CPtr& val, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_sendC(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const CPtr&, const Ice::Context&) const;
    /// \endcond

    BoolSeq1 opBoolSeq(const BoolSeq1& v1, BoolSeq2& v2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<BoolSeq1, BoolSeq2>> opBoolSeqAsync(const BoolSeq1& v1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opBoolSeqAsync(const BoolSeq1& v1, ::std::function<void(::Test::BoolSeq1, ::Test::BoolSeq2)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolSeq(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<BoolSeq1, BoolSeq2>>>&, const BoolSeq1&, const Ice::Context&) const;
    /// \endcond

    ByteSeq1 opByteSeq(const ByteSeq1& v1, ByteSeq2& v2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<ByteSeq1, ByteSeq2>> opByteSeqAsync(const ByteSeq1& v1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opByteSeqAsync(const ByteSeq1& v1, ::std::function<void(::Test::ByteSeq1, ::Test::ByteSeq2)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteSeq(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<ByteSeq1, ByteSeq2>>>&, const ByteSeq1&, const Ice::Context&) const;
    /// \endcond

    ShortSeq1 opShortSeq(const ShortSeq1& v1, ShortSeq2& v2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<ShortSeq1, ShortSeq2>> opShortSeqAsync(const ShortSeq1& v1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opShortSeqAsync(const ShortSeq1& v1, ::std::function<void(::Test::ShortSeq1, ::Test::ShortSeq2)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opShortSeq(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<ShortSeq1, ShortSeq2>>>&, const ShortSeq1&, const Ice::Context&) const;
    /// \endcond

    IntSeq1 opIntSeq(const IntSeq1& v1, IntSeq2& v2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<IntSeq1, IntSeq2>> opIntSeqAsync(const IntSeq1& v1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opIntSeqAsync(const IntSeq1& v1, ::std::function<void(::Test::IntSeq1, ::Test::IntSeq2)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opIntSeq(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<IntSeq1, IntSeq2>>>&, const IntSeq1&, const Ice::Context&) const;
    /// \endcond

    LongSeq1 opLongSeq(const LongSeq1& v1, LongSeq2& v2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<LongSeq1, LongSeq2>> opLongSeqAsync(const LongSeq1& v1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opLongSeqAsync(const LongSeq1& v1, ::std::function<void(::Test::LongSeq1, ::Test::LongSeq2)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opLongSeq(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<LongSeq1, LongSeq2>>>&, const LongSeq1&, const Ice::Context&) const;
    /// \endcond

    FloatSeq1 opFloatSeq(const FloatSeq1& v1, FloatSeq2& v2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<FloatSeq1, FloatSeq2>> opFloatSeqAsync(const FloatSeq1& v1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opFloatSeqAsync(const FloatSeq1& v1, ::std::function<void(::Test::FloatSeq1, ::Test::FloatSeq2)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opFloatSeq(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<FloatSeq1, FloatSeq2>>>&, const FloatSeq1&, const Ice::Context&) const;
    /// \endcond

    DoubleSeq1 opDoubleSeq(const DoubleSeq1& v1, DoubleSeq2& v2, const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<DoubleSeq1, DoubleSeq2>> opDoubleSeqAsync(const DoubleSeq1& v1, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opDoubleSeqAsync(const DoubleSeq1& v1, ::std::function<void(::Test::DoubleSeq1, ::Test::DoubleSeq2)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opDoubleSeq(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<::std::tuple<DoubleSeq1, DoubleSeq2>>>&, const DoubleSeq1&, const Ice::Context&) const;
    /// \endcond

    BoolSeq1 opBogusArrayNotExistsFactory(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

    [[nodiscard]] ::std::future<BoolSeq1> opBogusArrayNotExistsFactoryAsync(const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opBogusArrayNotExistsFactoryAsync(::std::function<void(::Test::BoolSeq1)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBogusArrayNotExistsFactory(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<BoolSeq1>>&, const Ice::Context&) const;
    /// \endcond

    BoolSeq1 opBogusArrayThrowFactory(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

    [[nodiscard]] ::std::future<BoolSeq1> opBogusArrayThrowFactoryAsync(const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opBogusArrayThrowFactoryAsync(::std::function<void(::Test::BoolSeq1)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBogusArrayThrowFactory(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<BoolSeq1>>&, const Ice::Context&) const;
    /// \endcond

    BoolSeq1 opBogusArrayType(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

    [[nodiscard]] ::std::future<BoolSeq1> opBogusArrayTypeAsync(const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opBogusArrayTypeAsync(::std::function<void(::Test::BoolSeq1)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBogusArrayType(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<BoolSeq1>>&, const Ice::Context&) const;
    /// \endcond

    BoolSeq1 opBogusArrayNoneFactory(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

    [[nodiscard]] ::std::future<BoolSeq1> opBogusArrayNoneFactoryAsync(const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opBogusArrayNoneFactoryAsync(::std::function<void(::Test::BoolSeq1)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBogusArrayNoneFactory(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<BoolSeq1>>&, const Ice::Context&) const;
    /// \endcond

    BoolSeq1 opBogusArraySignatureFactory(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

    [[nodiscard]] ::std::future<BoolSeq1> opBogusArraySignatureFactoryAsync(const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opBogusArraySignatureFactoryAsync(::std::function<void(::Test::BoolSeq1)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBogusArraySignatureFactory(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<BoolSeq1>>&, const Ice::Context&) const;
    /// \endcond

    BoolSeq1 opBogusArrayNoCallableFactory(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

    [[nodiscard]] ::std::future<BoolSeq1> opBogusArrayNoCallableFactoryAsync(const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opBogusArrayNoCallableFactoryAsync(::std::function<void(::Test::BoolSeq1)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBogusArrayNoCallableFactory(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<BoolSeq1>>&, const Ice::Context&) const;
    /// \endcond

    DPtr opD(const DPtr& d, const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

    [[nodiscard]] ::std::future<DPtr> opDAsync(const DPtr& d, const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    opDAsync(const DPtr& d, ::std::function<void(::Test::DPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opD(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<DPtr>>&, const DPtr&, const Ice::Context&) const;
    /// \endcond

    void shutdown(const Ice::Context& context = Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> shutdownAsync(const Ice::Context& context = Ice::noExplicitContext) const;

    ::std::function<void()> // NOLINT(modernize-use-nodiscard)
    shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const Ice::Context&) const;
    /// \endcond

    /// Obtains the Slice type ID of this interface.
    /// @return The fully-scoped type ID.
    static const char* ice_staticId() noexcept;

    CustomPrx(const CustomPrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

    CustomPrx(CustomPrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

    CustomPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

    ~CustomPrx() override;

    CustomPrx& operator=(const CustomPrx& rhs) noexcept
    {
        if (this != &rhs)
        {
            Ice::ObjectPrx::operator=(rhs);
        }
        return *this;
    }

    CustomPrx& operator=(CustomPrx&& rhs) noexcept
    {
        if (this != &rhs)
        {
            Ice::ObjectPrx::operator=(std::move(rhs));
        }
        return *this;
    }

    /// \cond INTERNAL
    static CustomPrx _fromReference(IceInternal::ReferencePtr ref) { return CustomPrx(std::move(ref)); }

protected:

    CustomPrx() = default;

    explicit CustomPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
    {
    }
    /// \endcond
};

}

namespace Test
{

struct S
{
    ::Test::ByteString b1;
    ::Test::ByteString b2;
    ::Test::ByteList b3;
    ::Test::ByteList b4;
    ::Test::StringList s1;
    ::Test::StringList s2;
    ::Test::StringTuple s3;
    ::Test::StringTuple s4;

    /// Obtains a tuple containing all of the struct's data members.
    /// @return The data members in a tuple.
    [[nodiscard]] std::tuple<const ::Test::ByteString&, const ::Test::ByteString&, const ::Test::ByteList&, const ::Test::ByteList&, const ::Test::StringList&, const ::Test::StringList&, const ::Test::StringTuple&, const ::Test::StringTuple&> ice_tuple() const
    {
        return std::tie(b1, b2, b3, b4, s1, s2, s3, s4);
    }

    /// Outputs the name and value of each field of this instance to the stream.
    /// @param os The output stream.
    void ice_printFields(::std::ostream& os) const;
};

::std::ostream& operator<<(::std::ostream&, const S&);

class C : public Ice::Value
{
public:
    /// Default constructor.
    C() noexcept = default;

    /// One-shot constructor to initialize all data members.
    C(::Test::ByteString b1, ::Test::ByteString b2, ::Test::ByteList b3, ::Test::ByteList b4, ::Test::StringList s1, ::Test::StringList s2, ::Test::StringTuple s3, ::Test::StringTuple s4) noexcept :
        b1(::std::move(b1)),
        b2(::std::move(b2)),
        b3(::std::move(b3)),
        b4(::std::move(b4)),
        s1(::std::move(s1)),
        s2(::std::move(s2)),
        s3(::std::move(s3)),
        s4(::std::move(s4))
    {
    }

    /// Obtains the Slice type ID of this value.
    /// @return The fully-scoped type ID.
    static const char* ice_staticId() noexcept;

    [[nodiscard]] const char* ice_id() const noexcept override;

    /// Obtains a tuple containing all of the value's data members.
    /// @return The data members in a tuple.
    [[nodiscard]] std::tuple<const ::Test::ByteString&, const ::Test::ByteString&, const ::Test::ByteList&, const ::Test::ByteList&, const ::Test::StringList&, const ::Test::StringList&, const ::Test::StringTuple&, const ::Test::StringTuple&> ice_tuple() const
    {
        return std::tie(b1, b2, b3, b4, s1, s2, s3, s4);
    }

    /// Creates a shallow polymorphic copy of this instance.
    /// @return The cloned value.
    [[nodiscard]] CPtr ice_clone() const { return ::std::static_pointer_cast<C>(_iceCloneImpl()); }

    ::Test::ByteString b1;
    ::Test::ByteString b2;
    ::Test::ByteList b3;
    ::Test::ByteList b4;
    ::Test::StringList s1;
    ::Test::StringList s2;
    ::Test::StringTuple s3;
    ::Test::StringTuple s4;

    void ice_printFields(std::ostream& os) const override;
    C(const C&) = default;

    [[nodiscard]] Ice::ValuePtr _iceCloneImpl() const override;

    void _iceWriteImpl(Ice::OutputStream*) const override;

    void _iceReadImpl(Ice::InputStream*) override;
};

class D : public Ice::Value
{
public:
    /// Default constructor.
    D() noexcept = default;

    /// One-shot constructor to initialize all data members.
    D(::std::optional<::Test::BoolSeq1> boolSeq, ::std::optional<::Test::ByteSeq1> byteSeq, ::std::optional<::Test::ShortSeq1> shortSeq, ::std::optional<::Test::IntSeq1> intSeq, ::std::optional<::Test::LongSeq1> longSeq, ::std::optional<::Test::FloatSeq1> floatSeq, ::std::optional<::Test::DoubleSeq1> doubleSeq) noexcept :
        boolSeq(::std::move(boolSeq)),
        byteSeq(::std::move(byteSeq)),
        shortSeq(::std::move(shortSeq)),
        intSeq(::std::move(intSeq)),
        longSeq(::std::move(longSeq)),
        floatSeq(::std::move(floatSeq)),
        doubleSeq(::std::move(doubleSeq))
    {
    }

    /// Obtains the Slice type ID of this value.
    /// @return The fully-scoped type ID.
    static const char* ice_staticId() noexcept;

    [[nodiscard]] const char* ice_id() const noexcept override;

    /// Obtains a tuple containing all of the value's data members.
    /// @return The data members in a tuple.
    [[nodiscard]] std::tuple<const ::std::optional<::Test::BoolSeq1>&, const ::std::optional<::Test::ByteSeq1>&, const ::std::optional<::Test::ShortSeq1>&, const ::std::optional<::Test::IntSeq1>&, const ::std::optional<::Test::LongSeq1>&, const ::std::optional<::Test::FloatSeq1>&, const ::std::optional<::Test::DoubleSeq1>&> ice_tuple() const
    {
        return std::tie(boolSeq, byteSeq, shortSeq, intSeq, longSeq, floatSeq, doubleSeq);
    }

    /// Creates a shallow polymorphic copy of this instance.
    /// @return The cloned value.
    [[nodiscard]] DPtr ice_clone() const { return ::std::static_pointer_cast<D>(_iceCloneImpl()); }

    ::std::optional<::Test::BoolSeq1> boolSeq;
    ::std::optional<::Test::ByteSeq1> byteSeq;
    ::std::optional<::Test::ShortSeq1> shortSeq;
    ::std::optional<::Test::IntSeq1> intSeq;
    ::std::optional<::Test::LongSeq1> longSeq;
    ::std::optional<::Test::FloatSeq1> floatSeq;
    ::std::optional<::Test::DoubleSeq1> doubleSeq;

    void ice_printFields(std::ostream& os) const override;
    D(const D&) = default;

    [[nodiscard]] Ice::ValuePtr _iceCloneImpl() const override;

    void _iceWriteImpl(Ice::OutputStream*) const override;

    void _iceReadImpl(Ice::InputStream*) override;
};

using Ice::Tuple::operator<;
using Ice::Tuple::operator<=;
using Ice::Tuple::operator>;
using Ice::Tuple::operator>=;
using Ice::Tuple::operator==;
using Ice::Tuple::operator!=;

}

namespace Test
{

class Custom : public virtual Ice::Object
{
public:

    using ProxyType = CustomPrx;

    /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
    /// @param current The Current object for the invocation.
    /// @return A list of fully-scoped type IDs.
    [[nodiscard]] ::std::vector<::std::string> ice_ids(const Ice::Current& current) const override;

    /// Obtains a Slice type ID representing the most-derived interface supported by this object.
    /// @param current The Current object for the invocation.
    /// @return A fully-scoped type ID.
    [[nodiscard]] ::std::string ice_id(const Ice::Current& current) const override;

    /// Obtains the Slice type ID corresponding to this interface.
    /// @return A fully-scoped type ID.
    static const char* ice_staticId() noexcept;

    virtual ByteString opByteString1(ByteString b1, ByteString& b2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opByteString1(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual ByteString opByteString2(ByteString b1, ByteString& b2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opByteString2(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual ByteList opByteList1(ByteList b1, ByteList& b2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opByteList1(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual ByteList opByteList2(ByteList b1, ByteList& b2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opByteList2(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual StringList opStringList1(StringList s1, StringList& s2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opStringList1(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual StringList opStringList2(StringList s1, StringList& s2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opStringList2(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual StringTuple opStringTuple1(StringTuple s1, StringTuple& s2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opStringTuple1(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual StringTuple opStringTuple2(StringTuple s1, StringTuple& s2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opStringTuple2(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual void sendS(S val, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_sendS(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual void sendC(CPtr val, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_sendC(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual BoolSeq1 opBoolSeq(BoolSeq1 v1, BoolSeq2& v2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opBoolSeq(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual ByteSeq1 opByteSeq(ByteSeq1 v1, ByteSeq2& v2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opByteSeq(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual ShortSeq1 opShortSeq(ShortSeq1 v1, ShortSeq2& v2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opShortSeq(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual IntSeq1 opIntSeq(IntSeq1 v1, IntSeq2& v2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opIntSeq(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual LongSeq1 opLongSeq(LongSeq1 v1, LongSeq2& v2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opLongSeq(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual FloatSeq1 opFloatSeq(FloatSeq1 v1, FloatSeq2& v2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opFloatSeq(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual DoubleSeq1 opDoubleSeq(DoubleSeq1 v1, DoubleSeq2& v2, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opDoubleSeq(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual BoolSeq1 opBogusArrayNotExistsFactory(const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opBogusArrayNotExistsFactory(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual BoolSeq1 opBogusArrayThrowFactory(const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opBogusArrayThrowFactory(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual BoolSeq1 opBogusArrayType(const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opBogusArrayType(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual BoolSeq1 opBogusArrayNoneFactory(const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opBogusArrayNoneFactory(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual BoolSeq1 opBogusArraySignatureFactory(const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opBogusArraySignatureFactory(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual BoolSeq1 opBogusArrayNoCallableFactory(const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opBogusArrayNoCallableFactory(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual DPtr opD(DPtr d, const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opD(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    virtual void shutdown(const Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_shutdown(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(Ice::IncomingRequest&, ::std::function<void(Ice::OutgoingResponse)>) override;
    /// \endcond
};

using CustomPtr = ::std::shared_ptr<Custom>;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::Test::S>
{
    static void read(InputStream* istr, ::Test::S& v)
    {
        istr->readAll(v.b1, v.b2, v.b3, v.b4, v.s1, v.s2, v.s3, v.s4);
    }
};

}
/// \endcond

#include <Ice/PopDisableWarnings.h>
#endif
