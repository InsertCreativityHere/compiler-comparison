//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/BuiltinSequences.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class Empty;
class EmptyPrx;
class Thrower;
class ThrowerPrx;

namespace Mod
{


}
class WrongOperation;
class WrongOperationPrx;

}

namespace Test
{

class A : public ::Ice::UserExceptionHelper<A, ::Ice::UserException>
{
public:

    virtual ~A();

    A(const A&) = default;

    A() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    A(int aMem) :
        aMem(aMem)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(aMem);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int aMem;
};

/// \cond INTERNAL
static A _iceS_A_init;
/// \endcond

class B : public ::Ice::UserExceptionHelper<B, A>
{
public:

    virtual ~B();

    B(const B&) = default;

    B() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    B(int aMem, int bMem) :
        ::Ice::UserExceptionHelper<B, A>(aMem),
        bMem(bMem)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(aMem, bMem);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int bMem;
};

class C : public ::Ice::UserExceptionHelper<C, B>
{
public:

    virtual ~C();

    C(const C&) = default;

    C() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    C(int aMem, int bMem, int cMem) :
        ::Ice::UserExceptionHelper<C, B>(aMem, bMem),
        cMem(cMem)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const int&> ice_tuple() const
    {
        return std::tie(aMem, bMem, cMem);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int cMem;
};

class D : public ::Ice::UserExceptionHelper<D, ::Ice::UserException>
{
public:

    virtual ~D();

    D(const D&) = default;

    D() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D(int dMem) :
        dMem(dMem)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(dMem);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int dMem;
};

namespace Mod
{

class A : public ::Ice::UserExceptionHelper<A, ::Test::A>
{
public:

    virtual ~A();

    A(const A&) = default;

    A() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    A(int aMem, int a2Mem) :
        ::Ice::UserExceptionHelper<A, ::Test::A>(aMem),
        a2Mem(a2Mem)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(aMem, a2Mem);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int a2Mem;
};

}

}

namespace Test
{

class Empty : public virtual ::Ice::Object
{
public:

    using ProxyType = EmptyPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class Thrower : public virtual ::Ice::Object
{
public:

    using ProxyType = ThrowerPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsUndeclaredExceptions(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsUndeclaredExceptions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsAssertException(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsAssertException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwAasA(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwAasA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwAorDasAorD(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwAorDasAorD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwBasA(int a, int b, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwBasA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwCasA(int a, int b, int c, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwCasA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwBasB(int a, int b, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwBasB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwCasB(int a, int b, int c, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwCasB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwCasC(int a, int b, int c, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwCasC(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwModA(int a, int a2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwModA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUndeclaredA(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUndeclaredA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUndeclaredB(int a, int b, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUndeclaredB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUndeclaredC(int a, int b, int c, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUndeclaredC(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwLocalException(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwLocalException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwNonIceException(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwNonIceException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwAssertException(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwAssertException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::ByteSeq throwMemoryLimitException(::Ice::ByteSeq seq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwMemoryLimitException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwLocalExceptionIdempotent(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwLocalExceptionIdempotent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwAfterResponse(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwAfterResponse(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwAfterException(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwAfterException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to throwMarshalException.
     */
    struct ThrowMarshalExceptionResult
    {
        int returnValue;
        int p;
    };

    virtual int throwMarshalException(int& p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwMarshalException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class WrongOperation : public virtual ::Ice::Object
{
public:

    using ProxyType = WrongOperationPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void noSuchOperation(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_noSuchOperation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class EmptyPrx : public virtual ::Ice::Proxy<EmptyPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    EmptyPrx() = default;
    friend ::std::shared_ptr<EmptyPrx> IceInternal::createProxy<EmptyPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class ThrowerPrx : public virtual ::Ice::Proxy<ThrowerPrx, ::Ice::ObjectPrx>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsUndeclaredExceptions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ThrowerPrx::_iceI_supportsUndeclaredExceptions, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsUndeclaredExceptionsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ThrowerPrx::_iceI_supportsUndeclaredExceptions, context);
    }

    ::std::function<void()>
    supportsUndeclaredExceptionsAsync(::std::function<void(bool)> response,
                                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                      ::std::function<void(bool)> sent = nullptr,
                                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_supportsUndeclaredExceptions, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsUndeclaredExceptions(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsAssertException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ThrowerPrx::_iceI_supportsAssertException, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsAssertExceptionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ThrowerPrx::_iceI_supportsAssertException, context);
    }

    ::std::function<void()>
    supportsAssertExceptionAsync(::std::function<void(bool)> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_supportsAssertException, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsAssertException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    void throwAasA(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwAasA, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwAasAAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwAasA, a, context);
    }

    ::std::function<void()>
    throwAasAAsync(int a,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwAasA, a, context);
    }

    /// \cond INTERNAL
    void _iceI_throwAasA(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void throwAorDasAorD(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwAorDasAorD, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwAorDasAorDAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwAorDasAorD, a, context);
    }

    ::std::function<void()>
    throwAorDasAorDAsync(int a,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwAorDasAorD, a, context);
    }

    /// \cond INTERNAL
    void _iceI_throwAorDasAorD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void throwBasA(int a, int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwBasA, a, b, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwBasAAsync(int a, int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwBasA, a, b, context);
    }

    ::std::function<void()>
    throwBasAAsync(int a, int b,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwBasA, a, b, context);
    }

    /// \cond INTERNAL
    void _iceI_throwBasA(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, const ::Ice::Context&);
    /// \endcond

    void throwCasA(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwCasA, a, b, c, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwCasAAsync(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwCasA, a, b, c, context);
    }

    ::std::function<void()>
    throwCasAAsync(int a, int b, int c,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwCasA, a, b, c, context);
    }

    /// \cond INTERNAL
    void _iceI_throwCasA(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, int, const ::Ice::Context&);
    /// \endcond

    void throwBasB(int a, int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwBasB, a, b, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwBasBAsync(int a, int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwBasB, a, b, context);
    }

    ::std::function<void()>
    throwBasBAsync(int a, int b,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwBasB, a, b, context);
    }

    /// \cond INTERNAL
    void _iceI_throwBasB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, const ::Ice::Context&);
    /// \endcond

    void throwCasB(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwCasB, a, b, c, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwCasBAsync(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwCasB, a, b, c, context);
    }

    ::std::function<void()>
    throwCasBAsync(int a, int b, int c,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwCasB, a, b, c, context);
    }

    /// \cond INTERNAL
    void _iceI_throwCasB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, int, const ::Ice::Context&);
    /// \endcond

    void throwCasC(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwCasC, a, b, c, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwCasCAsync(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwCasC, a, b, c, context);
    }

    ::std::function<void()>
    throwCasCAsync(int a, int b, int c,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwCasC, a, b, c, context);
    }

    /// \cond INTERNAL
    void _iceI_throwCasC(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, int, const ::Ice::Context&);
    /// \endcond

    void throwModA(int a, int a2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwModA, a, a2, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwModAAsync(int a, int a2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwModA, a, a2, context);
    }

    ::std::function<void()>
    throwModAAsync(int a, int a2,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwModA, a, a2, context);
    }

    /// \cond INTERNAL
    void _iceI_throwModA(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, const ::Ice::Context&);
    /// \endcond

    void throwUndeclaredA(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwUndeclaredA, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwUndeclaredAAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwUndeclaredA, a, context);
    }

    ::std::function<void()>
    throwUndeclaredAAsync(int a,
                          ::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwUndeclaredA, a, context);
    }

    /// \cond INTERNAL
    void _iceI_throwUndeclaredA(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void throwUndeclaredB(int a, int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwUndeclaredB, a, b, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwUndeclaredBAsync(int a, int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwUndeclaredB, a, b, context);
    }

    ::std::function<void()>
    throwUndeclaredBAsync(int a, int b,
                          ::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwUndeclaredB, a, b, context);
    }

    /// \cond INTERNAL
    void _iceI_throwUndeclaredB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, const ::Ice::Context&);
    /// \endcond

    void throwUndeclaredC(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwUndeclaredC, a, b, c, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwUndeclaredCAsync(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwUndeclaredC, a, b, c, context);
    }

    ::std::function<void()>
    throwUndeclaredCAsync(int a, int b, int c,
                          ::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwUndeclaredC, a, b, c, context);
    }

    /// \cond INTERNAL
    void _iceI_throwUndeclaredC(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, int, const ::Ice::Context&);
    /// \endcond

    void throwLocalException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwLocalException, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwLocalExceptionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwLocalException, context);
    }

    ::std::function<void()>
    throwLocalExceptionAsync(::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwLocalException, context);
    }

    /// \cond INTERNAL
    void _iceI_throwLocalException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void throwNonIceException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwNonIceException, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwNonIceExceptionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwNonIceException, context);
    }

    ::std::function<void()>
    throwNonIceExceptionAsync(::std::function<void()> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwNonIceException, context);
    }

    /// \cond INTERNAL
    void _iceI_throwNonIceException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void throwAssertException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwAssertException, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwAssertExceptionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwAssertException, context);
    }

    ::std::function<void()>
    throwAssertExceptionAsync(::std::function<void()> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwAssertException, context);
    }

    /// \cond INTERNAL
    void _iceI_throwAssertException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ::Ice::ByteSeq throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Ice::ByteSeq>(true, this, &ThrowerPrx::_iceI_throwMemoryLimitException, seq, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwMemoryLimitExceptionAsync(const ::Ice::ByteSeq& seq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Ice::ByteSeq>>().get_future())
    {
        return _makePromiseOutgoing<::Ice::ByteSeq, P>(false, this, &ThrowerPrx::_iceI_throwMemoryLimitException, seq, context);
    }

    ::std::function<void()>
    throwMemoryLimitExceptionAsync(const ::Ice::ByteSeq& seq,
                                   ::std::function<void(::Ice::ByteSeq)> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::Ice::ByteSeq>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwMemoryLimitException, seq, context);
    }

    /// \cond INTERNAL
    void _iceI_throwMemoryLimitException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::ByteSeq>>&, const ::Ice::ByteSeq&, const ::Ice::Context&);
    /// \endcond

    void throwLocalExceptionIdempotent(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwLocalExceptionIdempotent, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwLocalExceptionIdempotentAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwLocalExceptionIdempotent, context);
    }

    ::std::function<void()>
    throwLocalExceptionIdempotentAsync(::std::function<void()> response,
                                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                       ::std::function<void(bool)> sent = nullptr,
                                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwLocalExceptionIdempotent, context);
    }

    /// \cond INTERNAL
    void _iceI_throwLocalExceptionIdempotent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void throwAfterResponse(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwAfterResponse, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwAfterResponseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwAfterResponse, context);
    }

    ::std::function<void()>
    throwAfterResponseAsync(::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwAfterResponse, context);
    }

    /// \cond INTERNAL
    void _iceI_throwAfterResponse(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void throwAfterException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwAfterException, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwAfterExceptionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwAfterException, context);
    }

    ::std::function<void()>
    throwAfterExceptionAsync(::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwAfterException, context);
    }

    /// \cond INTERNAL
    void _iceI_throwAfterException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    int throwMarshalException(int& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Thrower::ThrowMarshalExceptionResult>(true, this, &ThrowerPrx::_iceI_throwMarshalException, context).get();
        p = _result.p;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto throwMarshalExceptionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Thrower::ThrowMarshalExceptionResult>>().get_future())
    {
        return _makePromiseOutgoing<Thrower::ThrowMarshalExceptionResult, P>(false, this, &ThrowerPrx::_iceI_throwMarshalException, context);
    }

    ::std::function<void()>
    throwMarshalExceptionAsync(::std::function<void(int, int)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Thrower::ThrowMarshalExceptionResult&& _result)
        {
            response(_result.returnValue, _result.p);
        };
        return _makeLambdaOutgoing<Thrower::ThrowMarshalExceptionResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwMarshalException, context);
    }

    /// \cond INTERNAL
    void _iceI_throwMarshalException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Thrower::ThrowMarshalExceptionResult>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    ThrowerPrx() = default;
    friend ::std::shared_ptr<ThrowerPrx> IceInternal::createProxy<ThrowerPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class WrongOperationPrx : public virtual ::Ice::Proxy<WrongOperationPrx, ::Ice::ObjectPrx>
{
public:

    void noSuchOperation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &WrongOperationPrx::_iceI_noSuchOperation, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto noSuchOperationAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &WrongOperationPrx::_iceI_noSuchOperation, context);
    }

    ::std::function<void()>
    noSuchOperationAsync(::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::WrongOperationPrx::_iceI_noSuchOperation, context);
    }

    /// \cond INTERNAL
    void _iceI_noSuchOperation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    WrongOperationPrx() = default;
    friend ::std::shared_ptr<WrongOperationPrx> IceInternal::createProxy<WrongOperationPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::Test::A, S>
{
    static void read(S* istr, ::Test::A& v)
    {
        istr->readAll(v.aMem);
    }
};

template<typename S>
struct StreamWriter<::Test::B, S>
{
    static void write(S* ostr, const ::Test::B& v)
    {
        ostr->writeAll(v.bMem);
    }
};

template<typename S>
struct StreamReader<::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->readAll(v.bMem);
    }
};

template<typename S>
struct StreamWriter<::Test::C, S>
{
    static void write(S* ostr, const ::Test::C& v)
    {
        ostr->writeAll(v.cMem);
    }
};

template<typename S>
struct StreamReader<::Test::C, S>
{
    static void read(S* istr, ::Test::C& v)
    {
        istr->readAll(v.cMem);
    }
};

template<typename S>
struct StreamReader<::Test::D, S>
{
    static void read(S* istr, ::Test::D& v)
    {
        istr->readAll(v.dMem);
    }
};

template<typename S>
struct StreamWriter<::Test::Mod::A, S>
{
    static void write(S* ostr, const ::Test::Mod::A& v)
    {
        ostr->writeAll(v.a2Mem);
    }
};

template<typename S>
struct StreamReader<::Test::Mod::A, S>
{
    static void read(S* istr, ::Test::Mod::A& v)
    {
        istr->readAll(v.a2Mem);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using EmptyPtr = ::std::shared_ptr<Empty>;
using EmptyPrxPtr = ::std::shared_ptr<EmptyPrx>;

using ThrowerPtr = ::std::shared_ptr<Thrower>;
using ThrowerPrxPtr = ::std::shared_ptr<ThrowerPrx>;

using WrongOperationPtr = ::std::shared_ptr<WrongOperation>;
using WrongOperationPrxPtr = ::std::shared_ptr<WrongOperationPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class Empty;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Empty>&);
::IceProxy::Ice::Object* upCast(Empty*);
/// \endcond

class Thrower;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Thrower>&);
::IceProxy::Ice::Object* upCast(Thrower*);
/// \endcond

class WrongOperation;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< WrongOperation>&);
::IceProxy::Ice::Object* upCast(WrongOperation*);
/// \endcond

}

}

namespace Test
{
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Empty> EmptyPrx;
typedef EmptyPrx EmptyPrxPtr;

class Empty;
typedef ::IceInternal::Handle< Empty> EmptyPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Thrower> ThrowerPrx;
typedef ThrowerPrx ThrowerPrxPtr;

class Thrower;
typedef ::IceInternal::Handle< Thrower> ThrowerPtr;

namespace Mod
{

}
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::WrongOperation> WrongOperationPrx;
typedef WrongOperationPrx WrongOperationPrxPtr;

class WrongOperation;
typedef ::IceInternal::Handle< WrongOperation> WrongOperationPtr;

}

namespace Test
{

class A : public ::Ice::UserException
{
public:

    A() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    explicit A(::Ice::Int aMem);
    A(const A&) = default;
    virtual ~A();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual A* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::Ice::Int aMem;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
static A _iceS_A_init;
/// \endcond

class B : public A
{
public:

    B() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    B(::Ice::Int aMem, ::Ice::Int bMem);
    B(const B&) = default;
    virtual ~B();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual B* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::Ice::Int bMem;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class C : public B
{
public:

    C() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    C(::Ice::Int aMem, ::Ice::Int bMem, ::Ice::Int cMem);
    C(const C&) = default;
    virtual ~C();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual C* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::Ice::Int cMem;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class D : public ::Ice::UserException
{
public:

    D() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    explicit D(::Ice::Int dMem);
    D(const D&) = default;
    virtual ~D();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual D* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::Ice::Int dMem;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

namespace Mod
{

class A : public ::Test::A
{
public:

    A() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    A(::Ice::Int aMem, ::Ice::Int a2Mem);
    A(const A&) = default;
    virtual ~A();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual A* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::Ice::Int a2Mem;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

}

}

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_shutdown.
 */
class Callback_Thrower_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_shutdown_Base> Callback_Thrower_shutdownPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_supportsUndeclaredExceptions.
 */
class Callback_Thrower_supportsUndeclaredExceptions_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_supportsUndeclaredExceptions_Base> Callback_Thrower_supportsUndeclaredExceptionsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_supportsAssertException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_supportsAssertException.
 */
class Callback_Thrower_supportsAssertException_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_supportsAssertException_Base> Callback_Thrower_supportsAssertExceptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwAasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAasA.
 */
class Callback_Thrower_throwAasA_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwAasA_Base> Callback_Thrower_throwAasAPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwAorDasAorD.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAorDasAorD.
 */
class Callback_Thrower_throwAorDasAorD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwAorDasAorD_Base> Callback_Thrower_throwAorDasAorDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwBasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwBasA.
 */
class Callback_Thrower_throwBasA_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwBasA_Base> Callback_Thrower_throwBasAPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwCasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasA.
 */
class Callback_Thrower_throwCasA_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwCasA_Base> Callback_Thrower_throwCasAPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwBasB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwBasB.
 */
class Callback_Thrower_throwBasB_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwBasB_Base> Callback_Thrower_throwBasBPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwCasB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasB.
 */
class Callback_Thrower_throwCasB_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwCasB_Base> Callback_Thrower_throwCasBPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwCasC.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasC.
 */
class Callback_Thrower_throwCasC_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwCasC_Base> Callback_Thrower_throwCasCPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwModA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwModA.
 */
class Callback_Thrower_throwModA_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwModA_Base> Callback_Thrower_throwModAPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredA.
 */
class Callback_Thrower_throwUndeclaredA_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwUndeclaredA_Base> Callback_Thrower_throwUndeclaredAPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredB.
 */
class Callback_Thrower_throwUndeclaredB_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwUndeclaredB_Base> Callback_Thrower_throwUndeclaredBPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredC.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredC.
 */
class Callback_Thrower_throwUndeclaredC_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwUndeclaredC_Base> Callback_Thrower_throwUndeclaredCPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwLocalException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwLocalException.
 */
class Callback_Thrower_throwLocalException_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwLocalException_Base> Callback_Thrower_throwLocalExceptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwNonIceException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwNonIceException.
 */
class Callback_Thrower_throwNonIceException_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwNonIceException_Base> Callback_Thrower_throwNonIceExceptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwAssertException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAssertException.
 */
class Callback_Thrower_throwAssertException_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwAssertException_Base> Callback_Thrower_throwAssertExceptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwMemoryLimitException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwMemoryLimitException.
 */
class Callback_Thrower_throwMemoryLimitException_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwMemoryLimitException_Base> Callback_Thrower_throwMemoryLimitExceptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwLocalExceptionIdempotent.
 */
class Callback_Thrower_throwLocalExceptionIdempotent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwLocalExceptionIdempotent_Base> Callback_Thrower_throwLocalExceptionIdempotentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwAfterResponse.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAfterResponse.
 */
class Callback_Thrower_throwAfterResponse_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwAfterResponse_Base> Callback_Thrower_throwAfterResponsePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwAfterException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAfterException.
 */
class Callback_Thrower_throwAfterException_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwAfterException_Base> Callback_Thrower_throwAfterExceptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwMarshalException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwMarshalException.
 */
class Callback_Thrower_throwMarshalException_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwMarshalException_Base> Callback_Thrower_throwMarshalExceptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::WrongOperation::begin_noSuchOperation.
 * Create a wrapper instance by calling ::Test::newCallback_WrongOperation_noSuchOperation.
 */
class Callback_WrongOperation_noSuchOperation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_WrongOperation_noSuchOperation_Base> Callback_WrongOperation_noSuchOperationPtr;

}

namespace IceProxy
{

namespace Test
{

class Empty : public virtual ::Ice::Proxy<Empty, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Thrower : public virtual ::Ice::Proxy<Thrower, ::IceProxy::Ice::Object>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_Thrower_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_Thrower_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool supportsUndeclaredExceptions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_supportsUndeclaredExceptions(_iceI_begin_supportsUndeclaredExceptions(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_supportsUndeclaredExceptions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_supportsUndeclaredExceptions(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsUndeclaredExceptions(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsUndeclaredExceptions(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsUndeclaredExceptions(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsUndeclaredExceptions(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsUndeclaredExceptions(const ::Test::Callback_Thrower_supportsUndeclaredExceptionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsUndeclaredExceptions(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsUndeclaredExceptions(const ::Ice::Context& context, const ::Test::Callback_Thrower_supportsUndeclaredExceptionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsUndeclaredExceptions(context, cb, cookie);
    }

    bool end_supportsUndeclaredExceptions(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_supportsUndeclaredExceptions(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool supportsAssertException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_supportsAssertException(_iceI_begin_supportsAssertException(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_supportsAssertException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_supportsAssertException(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsAssertException(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsAssertException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsAssertException(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsAssertException(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsAssertException(const ::Test::Callback_Thrower_supportsAssertExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsAssertException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsAssertException(const ::Ice::Context& context, const ::Test::Callback_Thrower_supportsAssertExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsAssertException(context, cb, cookie);
    }

    bool end_supportsAssertException(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_supportsAssertException(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwAasA(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwAasA(_iceI_begin_throwAasA(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwAasA(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwAasA(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwAasA(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAasA(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAasA(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAasA(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAasA(::Ice::Int a, const ::Test::Callback_Thrower_throwAasAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAasA(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAasA(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwAasAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAasA(a, context, cb, cookie);
    }

    void end_throwAasA(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwAasA(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwAorDasAorD(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwAorDasAorD(_iceI_begin_throwAorDasAorD(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwAorDasAorD(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwAorDasAorD(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwAorDasAorD(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAorDasAorD(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAorDasAorD(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAorDasAorD(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAorDasAorD(::Ice::Int a, const ::Test::Callback_Thrower_throwAorDasAorDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAorDasAorD(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAorDasAorD(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwAorDasAorDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAorDasAorD(a, context, cb, cookie);
    }

    void end_throwAorDasAorD(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwAorDasAorD(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwBasA(_iceI_begin_throwBasA(a, b, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwBasA(a, b, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasA(a, b, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasA(a, b, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBasA(::Ice::Int a, ::Ice::Int b, const ::Test::Callback_Thrower_throwBasAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasA(a, b, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwBasAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasA(a, b, context, cb, cookie);
    }

    void end_throwBasA(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwBasA(::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwCasA(_iceI_begin_throwCasA(a, b, c, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwCasA(a, b, c, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasA(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasA(a, b, c, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Test::Callback_Thrower_throwCasAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasA(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwCasAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasA(a, b, c, context, cb, cookie);
    }

    void end_throwCasA(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwCasA(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwBasB(_iceI_begin_throwBasB(a, b, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwBasB(a, b, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasB(a, b, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasB(a, b, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBasB(::Ice::Int a, ::Ice::Int b, const ::Test::Callback_Thrower_throwBasBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasB(a, b, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwBasBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasB(a, b, context, cb, cookie);
    }

    void end_throwBasB(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwBasB(::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwCasB(_iceI_begin_throwCasB(a, b, c, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwCasB(a, b, c, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasB(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasB(a, b, c, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Test::Callback_Thrower_throwCasBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasB(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwCasBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasB(a, b, c, context, cb, cookie);
    }

    void end_throwCasB(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwCasB(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwCasC(_iceI_begin_throwCasC(a, b, c, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwCasC(a, b, c, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasC(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasC(a, b, c, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Test::Callback_Thrower_throwCasCPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasC(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwCasCPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasC(a, b, c, context, cb, cookie);
    }

    void end_throwCasC(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwCasC(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwModA(::Ice::Int a, ::Ice::Int a2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwModA(_iceI_begin_throwModA(a, a2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwModA(::Ice::Int a, ::Ice::Int a2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwModA(a, a2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwModA(::Ice::Int a, ::Ice::Int a2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwModA(a, a2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwModA(::Ice::Int a, ::Ice::Int a2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwModA(a, a2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwModA(::Ice::Int a, ::Ice::Int a2, const ::Test::Callback_Thrower_throwModAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwModA(a, a2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwModA(::Ice::Int a, ::Ice::Int a2, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwModAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwModA(a, a2, context, cb, cookie);
    }

    void end_throwModA(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwModA(::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwUndeclaredA(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwUndeclaredA(_iceI_begin_throwUndeclaredA(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredA(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwUndeclaredA(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredA(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredA(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredA(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredA(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredA(::Ice::Int a, const ::Test::Callback_Thrower_throwUndeclaredAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredA(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredA(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwUndeclaredAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredA(a, context, cb, cookie);
    }

    void end_throwUndeclaredA(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwUndeclaredA(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwUndeclaredB(_iceI_begin_throwUndeclaredB(a, b, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwUndeclaredB(a, b, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredB(a, b, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredB(a, b, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Test::Callback_Thrower_throwUndeclaredBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredB(a, b, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwUndeclaredBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredB(a, b, context, cb, cookie);
    }

    void end_throwUndeclaredB(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwUndeclaredB(::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwUndeclaredC(_iceI_begin_throwUndeclaredC(a, b, c, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwUndeclaredC(a, b, c, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredC(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredC(a, b, c, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Test::Callback_Thrower_throwUndeclaredCPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredC(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwUndeclaredCPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredC(a, b, c, context, cb, cookie);
    }

    void end_throwUndeclaredC(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwUndeclaredC(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwLocalException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwLocalException(_iceI_begin_throwLocalException(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwLocalException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwLocalException(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwLocalException(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwLocalException(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalException(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwLocalException(const ::Test::Callback_Thrower_throwLocalExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwLocalException(const ::Ice::Context& context, const ::Test::Callback_Thrower_throwLocalExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalException(context, cb, cookie);
    }

    void end_throwLocalException(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwLocalException(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwNonIceException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwNonIceException(_iceI_begin_throwNonIceException(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwNonIceException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwNonIceException(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwNonIceException(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwNonIceException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwNonIceException(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwNonIceException(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwNonIceException(const ::Test::Callback_Thrower_throwNonIceExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwNonIceException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwNonIceException(const ::Ice::Context& context, const ::Test::Callback_Thrower_throwNonIceExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwNonIceException(context, cb, cookie);
    }

    void end_throwNonIceException(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwNonIceException(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwAssertException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwAssertException(_iceI_begin_throwAssertException(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwAssertException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwAssertException(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwAssertException(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAssertException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAssertException(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAssertException(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAssertException(const ::Test::Callback_Thrower_throwAssertExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAssertException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAssertException(const ::Ice::Context& context, const ::Test::Callback_Thrower_throwAssertExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAssertException(context, cb, cookie);
    }

    void end_throwAssertException(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwAssertException(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::ByteSeq throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_throwMemoryLimitException(_iceI_begin_throwMemoryLimitException(seq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwMemoryLimitException(seq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwMemoryLimitException(seq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwMemoryLimitException(seq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Test::Callback_Thrower_throwMemoryLimitExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwMemoryLimitException(seq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwMemoryLimitExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwMemoryLimitException(seq, context, cb, cookie);
    }

    ::Ice::ByteSeq end_throwMemoryLimitException(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwMemoryLimitException(const ::Ice::ByteSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwLocalExceptionIdempotent(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwLocalExceptionIdempotent(_iceI_begin_throwLocalExceptionIdempotent(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwLocalExceptionIdempotent(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwLocalExceptionIdempotent(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwLocalExceptionIdempotent(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalExceptionIdempotent(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwLocalExceptionIdempotent(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalExceptionIdempotent(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwLocalExceptionIdempotent(const ::Test::Callback_Thrower_throwLocalExceptionIdempotentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalExceptionIdempotent(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwLocalExceptionIdempotent(const ::Ice::Context& context, const ::Test::Callback_Thrower_throwLocalExceptionIdempotentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalExceptionIdempotent(context, cb, cookie);
    }

    void end_throwLocalExceptionIdempotent(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwLocalExceptionIdempotent(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwAfterResponse(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwAfterResponse(_iceI_begin_throwAfterResponse(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwAfterResponse(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwAfterResponse(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwAfterResponse(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAfterResponse(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAfterResponse(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAfterResponse(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAfterResponse(const ::Test::Callback_Thrower_throwAfterResponsePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAfterResponse(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAfterResponse(const ::Ice::Context& context, const ::Test::Callback_Thrower_throwAfterResponsePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAfterResponse(context, cb, cookie);
    }

    void end_throwAfterResponse(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwAfterResponse(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwAfterException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwAfterException(_iceI_begin_throwAfterException(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwAfterException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwAfterException(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwAfterException(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAfterException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAfterException(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAfterException(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAfterException(const ::Test::Callback_Thrower_throwAfterExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAfterException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAfterException(const ::Ice::Context& context, const ::Test::Callback_Thrower_throwAfterExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAfterException(context, cb, cookie);
    }

    void end_throwAfterException(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwAfterException(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int throwMarshalException(::Ice::Int& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_throwMarshalException(p, _iceI_begin_throwMarshalException(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwMarshalException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwMarshalException(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwMarshalException(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwMarshalException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwMarshalException(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwMarshalException(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwMarshalException(const ::Test::Callback_Thrower_throwMarshalExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwMarshalException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwMarshalException(const ::Ice::Context& context, const ::Test::Callback_Thrower_throwMarshalExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwMarshalException(context, cb, cookie);
    }

    ::Ice::Int end_throwMarshalException(::Ice::Int& p, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_throwMarshalException(::Ice::Int& iceP_p, ::Ice::Int& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwMarshalException(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class WrongOperation : public virtual ::Ice::Proxy<WrongOperation, ::IceProxy::Ice::Object>
{
public:

    void noSuchOperation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_noSuchOperation(_iceI_begin_noSuchOperation(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_noSuchOperation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_noSuchOperation(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_noSuchOperation(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_noSuchOperation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_noSuchOperation(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_noSuchOperation(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_noSuchOperation(const ::Test::Callback_WrongOperation_noSuchOperationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_noSuchOperation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_noSuchOperation(const ::Ice::Context& context, const ::Test::Callback_WrongOperation_noSuchOperationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_noSuchOperation(context, cb, cookie);
    }

    void end_noSuchOperation(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_noSuchOperation(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class Empty : public virtual ::Ice::Object
{
public:

    typedef EmptyPrx ProxyType;

    virtual ~Empty();
    Empty() = default;
    Empty(const Empty&) = default;
    Empty& operator=(const Empty&) = default;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class Thrower : public virtual ::Ice::Object
{
public:

    typedef ThrowerPrx ProxyType;

    virtual ~Thrower();
    Thrower() = default;
    Thrower(const Thrower&) = default;
    Thrower& operator=(const Thrower&) = default;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void shutdown(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsUndeclaredExceptions(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsUndeclaredExceptions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsAssertException(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsAssertException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwAasA(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwAasA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwAorDasAorD(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwAorDasAorD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwBasA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwCasA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwBasB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwCasB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwCasC(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwModA(::Ice::Int a, ::Ice::Int a2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwModA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUndeclaredA(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUndeclaredA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUndeclaredB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUndeclaredC(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwLocalException(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwLocalException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwNonIceException(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwNonIceException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwAssertException(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwAssertException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::ByteSeq throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwMemoryLimitException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwLocalExceptionIdempotent(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwLocalExceptionIdempotent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwAfterResponse(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwAfterResponse(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwAfterException(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwAfterException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int throwMarshalException(::Ice::Int& p, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwMarshalException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond
};

class WrongOperation : public virtual ::Ice::Object
{
public:

    typedef WrongOperationPrx ProxyType;

    virtual ~WrongOperation();
    WrongOperation() = default;
    WrongOperation(const WrongOperation&) = default;
    WrongOperation& operator=(const WrongOperation&) = default;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void noSuchOperation(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_noSuchOperation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::A>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::A, S>
{
    static void write(S* ostr, const ::Test::A& v)
    {
        ostr->write(v.aMem);
    }
};

template<typename S>
struct StreamReader< ::Test::A, S>
{
    static void read(S* istr, ::Test::A& v)
    {
        istr->read(v.aMem);
    }
};

template<>
struct StreamableTraits< ::Test::B>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::B, S>
{
    static void write(S* ostr, const ::Test::B& v)
    {
        ostr->write(v.bMem);
    }
};

template<typename S>
struct StreamReader< ::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->read(v.bMem);
    }
};

template<>
struct StreamableTraits< ::Test::C>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::C, S>
{
    static void write(S* ostr, const ::Test::C& v)
    {
        ostr->write(v.cMem);
    }
};

template<typename S>
struct StreamReader< ::Test::C, S>
{
    static void read(S* istr, ::Test::C& v)
    {
        istr->read(v.cMem);
    }
};

template<>
struct StreamableTraits< ::Test::D>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::D, S>
{
    static void write(S* ostr, const ::Test::D& v)
    {
        ostr->write(v.dMem);
    }
};

template<typename S>
struct StreamReader< ::Test::D, S>
{
    static void read(S* istr, ::Test::D& v)
    {
        istr->read(v.dMem);
    }
};

template<>
struct StreamableTraits< ::Test::Mod::A>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::Mod::A, S>
{
    static void write(S* ostr, const ::Test::Mod::A& v)
    {
        ostr->write(v.a2Mem);
    }
};

template<typename S>
struct StreamReader< ::Test::Mod::A, S>
{
    static void read(S* istr, ::Test::Mod::A& v)
    {
        istr->read(v.a2Mem);
    }
};

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_shutdown.
 */
template<class T>
class CallbackNC_Thrower_shutdown : public Callback_Thrower_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_shutdown.
 */
template<class T, typename CT>
class Callback_Thrower_shutdown : public Callback_Thrower_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T, typename CT> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T, typename CT> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T, typename CT> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T, typename CT> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_supportsUndeclaredExceptions.
 */
template<class T>
class CallbackNC_Thrower_supportsUndeclaredExceptions : public Callback_Thrower_supportsUndeclaredExceptions_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Thrower_supportsUndeclaredExceptions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsUndeclaredExceptions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions.
 */
template<class T> Callback_Thrower_supportsUndeclaredExceptionsPtr
newCallback_Thrower_supportsUndeclaredExceptions(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_supportsUndeclaredExceptions<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions.
 */
template<class T> Callback_Thrower_supportsUndeclaredExceptionsPtr
newCallback_Thrower_supportsUndeclaredExceptions(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_supportsUndeclaredExceptions<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_supportsUndeclaredExceptions.
 */
template<class T, typename CT>
class Callback_Thrower_supportsUndeclaredExceptions : public Callback_Thrower_supportsUndeclaredExceptions_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Thrower_supportsUndeclaredExceptions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsUndeclaredExceptions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions.
 */
template<class T, typename CT> Callback_Thrower_supportsUndeclaredExceptionsPtr
newCallback_Thrower_supportsUndeclaredExceptions(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_supportsUndeclaredExceptions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions.
 */
template<class T, typename CT> Callback_Thrower_supportsUndeclaredExceptionsPtr
newCallback_Thrower_supportsUndeclaredExceptions(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_supportsUndeclaredExceptions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_supportsAssertException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_supportsAssertException.
 */
template<class T>
class CallbackNC_Thrower_supportsAssertException : public Callback_Thrower_supportsAssertException_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Thrower_supportsAssertException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsAssertException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_supportsAssertException.
 */
template<class T> Callback_Thrower_supportsAssertExceptionPtr
newCallback_Thrower_supportsAssertException(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_supportsAssertException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_supportsAssertException.
 */
template<class T> Callback_Thrower_supportsAssertExceptionPtr
newCallback_Thrower_supportsAssertException(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_supportsAssertException<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_supportsAssertException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_supportsAssertException.
 */
template<class T, typename CT>
class Callback_Thrower_supportsAssertException : public Callback_Thrower_supportsAssertException_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Thrower_supportsAssertException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsAssertException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_supportsAssertException.
 */
template<class T, typename CT> Callback_Thrower_supportsAssertExceptionPtr
newCallback_Thrower_supportsAssertException(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_supportsAssertException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_supportsAssertException.
 */
template<class T, typename CT> Callback_Thrower_supportsAssertExceptionPtr
newCallback_Thrower_supportsAssertException(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_supportsAssertException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwAasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAasA.
 */
template<class T>
class CallbackNC_Thrower_throwAasA : public Callback_Thrower_throwAasA_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwAasA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwAasA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAasA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAasA<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAasA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAasA<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwAasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAasA.
 */
template<class T, typename CT>
class Callback_Thrower_throwAasA : public Callback_Thrower_throwAasA_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwAasA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwAasA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T, typename CT> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAasA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T, typename CT> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAasA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T, typename CT> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAasA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T, typename CT> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAasA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwAorDasAorD.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAorDasAorD.
 */
template<class T>
class CallbackNC_Thrower_throwAorDasAorD : public Callback_Thrower_throwAorDasAorD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwAorDasAorD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwAorDasAorD(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAorDasAorD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAorDasAorD<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAorDasAorD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAorDasAorD<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwAorDasAorD.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAorDasAorD.
 */
template<class T, typename CT>
class Callback_Thrower_throwAorDasAorD : public Callback_Thrower_throwAorDasAorD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwAorDasAorD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwAorDasAorD(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T, typename CT> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAorDasAorD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T, typename CT> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAorDasAorD<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T, typename CT> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAorDasAorD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T, typename CT> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAorDasAorD<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwBasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwBasA.
 */
template<class T>
class CallbackNC_Thrower_throwBasA : public Callback_Thrower_throwBasA_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwBasA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwBasA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasA<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasA<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwBasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwBasA.
 */
template<class T, typename CT>
class Callback_Thrower_throwBasA : public Callback_Thrower_throwBasA_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwBasA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwBasA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T, typename CT> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T, typename CT> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T, typename CT> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T, typename CT> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwCasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasA.
 */
template<class T>
class CallbackNC_Thrower_throwCasA : public Callback_Thrower_throwCasA_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwCasA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwCasA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasA<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasA<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwCasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasA.
 */
template<class T, typename CT>
class Callback_Thrower_throwCasA : public Callback_Thrower_throwCasA_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwCasA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwCasA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T, typename CT> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T, typename CT> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T, typename CT> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T, typename CT> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwBasB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwBasB.
 */
template<class T>
class CallbackNC_Thrower_throwBasB : public Callback_Thrower_throwBasB_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwBasB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwBasB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasB<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasB<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwBasB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwBasB.
 */
template<class T, typename CT>
class Callback_Thrower_throwBasB : public Callback_Thrower_throwBasB_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwBasB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwBasB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T, typename CT> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T, typename CT> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T, typename CT> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T, typename CT> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwCasB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasB.
 */
template<class T>
class CallbackNC_Thrower_throwCasB : public Callback_Thrower_throwCasB_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwCasB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwCasB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasB<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasB<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwCasB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasB.
 */
template<class T, typename CT>
class Callback_Thrower_throwCasB : public Callback_Thrower_throwCasB_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwCasB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwCasB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T, typename CT> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T, typename CT> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T, typename CT> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T, typename CT> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwCasC.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasC.
 */
template<class T>
class CallbackNC_Thrower_throwCasC : public Callback_Thrower_throwCasC_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwCasC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwCasC(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasC<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasC<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasC<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasC<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwCasC.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasC.
 */
template<class T, typename CT>
class Callback_Thrower_throwCasC : public Callback_Thrower_throwCasC_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwCasC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwCasC(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T, typename CT> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasC<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T, typename CT> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasC<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T, typename CT> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasC<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T, typename CT> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasC<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwModA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwModA.
 */
template<class T>
class CallbackNC_Thrower_throwModA : public Callback_Thrower_throwModA_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwModA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwModA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwModA.
 */
template<class T> Callback_Thrower_throwModAPtr
newCallback_Thrower_throwModA(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwModA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwModA.
 */
template<class T> Callback_Thrower_throwModAPtr
newCallback_Thrower_throwModA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwModA<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwModA.
 */
template<class T> Callback_Thrower_throwModAPtr
newCallback_Thrower_throwModA(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwModA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwModA.
 */
template<class T> Callback_Thrower_throwModAPtr
newCallback_Thrower_throwModA(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwModA<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwModA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwModA.
 */
template<class T, typename CT>
class Callback_Thrower_throwModA : public Callback_Thrower_throwModA_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwModA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwModA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwModA.
 */
template<class T, typename CT> Callback_Thrower_throwModAPtr
newCallback_Thrower_throwModA(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwModA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwModA.
 */
template<class T, typename CT> Callback_Thrower_throwModAPtr
newCallback_Thrower_throwModA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwModA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwModA.
 */
template<class T, typename CT> Callback_Thrower_throwModAPtr
newCallback_Thrower_throwModA(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwModA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwModA.
 */
template<class T, typename CT> Callback_Thrower_throwModAPtr
newCallback_Thrower_throwModA(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwModA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredA.
 */
template<class T>
class CallbackNC_Thrower_throwUndeclaredA : public Callback_Thrower_throwUndeclaredA_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwUndeclaredA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredA<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredA<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredA.
 */
template<class T, typename CT>
class Callback_Thrower_throwUndeclaredA : public Callback_Thrower_throwUndeclaredA_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwUndeclaredA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredB.
 */
template<class T>
class CallbackNC_Thrower_throwUndeclaredB : public Callback_Thrower_throwUndeclaredB_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwUndeclaredB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredB<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredB<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredB.
 */
template<class T, typename CT>
class Callback_Thrower_throwUndeclaredB : public Callback_Thrower_throwUndeclaredB_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwUndeclaredB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredC.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredC.
 */
template<class T>
class CallbackNC_Thrower_throwUndeclaredC : public Callback_Thrower_throwUndeclaredC_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwUndeclaredC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredC<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredC<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredC<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredC<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredC.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredC.
 */
template<class T, typename CT>
class Callback_Thrower_throwUndeclaredC : public Callback_Thrower_throwUndeclaredC_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwUndeclaredC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredC<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredC<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredC<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredC<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwLocalException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwLocalException.
 */
template<class T>
class CallbackNC_Thrower_throwLocalException : public Callback_Thrower_throwLocalException_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwLocalException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalException<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalException<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwLocalException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwLocalException.
 */
template<class T, typename CT>
class Callback_Thrower_throwLocalException : public Callback_Thrower_throwLocalException_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwLocalException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwNonIceException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwNonIceException.
 */
template<class T>
class CallbackNC_Thrower_throwNonIceException : public Callback_Thrower_throwNonIceException_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwNonIceException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwNonIceException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwNonIceException<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwNonIceException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwNonIceException<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwNonIceException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwNonIceException.
 */
template<class T, typename CT>
class Callback_Thrower_throwNonIceException : public Callback_Thrower_throwNonIceException_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwNonIceException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T, typename CT> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwNonIceException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T, typename CT> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwNonIceException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T, typename CT> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwNonIceException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T, typename CT> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwNonIceException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwAssertException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAssertException.
 */
template<class T>
class CallbackNC_Thrower_throwAssertException : public Callback_Thrower_throwAssertException_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwAssertException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAssertException.
 */
template<class T> Callback_Thrower_throwAssertExceptionPtr
newCallback_Thrower_throwAssertException(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAssertException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAssertException.
 */
template<class T> Callback_Thrower_throwAssertExceptionPtr
newCallback_Thrower_throwAssertException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAssertException<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAssertException.
 */
template<class T> Callback_Thrower_throwAssertExceptionPtr
newCallback_Thrower_throwAssertException(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAssertException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAssertException.
 */
template<class T> Callback_Thrower_throwAssertExceptionPtr
newCallback_Thrower_throwAssertException(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAssertException<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwAssertException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAssertException.
 */
template<class T, typename CT>
class Callback_Thrower_throwAssertException : public Callback_Thrower_throwAssertException_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwAssertException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAssertException.
 */
template<class T, typename CT> Callback_Thrower_throwAssertExceptionPtr
newCallback_Thrower_throwAssertException(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAssertException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAssertException.
 */
template<class T, typename CT> Callback_Thrower_throwAssertExceptionPtr
newCallback_Thrower_throwAssertException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAssertException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAssertException.
 */
template<class T, typename CT> Callback_Thrower_throwAssertExceptionPtr
newCallback_Thrower_throwAssertException(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAssertException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAssertException.
 */
template<class T, typename CT> Callback_Thrower_throwAssertExceptionPtr
newCallback_Thrower_throwAssertException(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAssertException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwMemoryLimitException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwMemoryLimitException.
 */
template<class T>
class CallbackNC_Thrower_throwMemoryLimitException : public Callback_Thrower_throwMemoryLimitException_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ByteSeq&);

    CallbackNC_Thrower_throwMemoryLimitException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        ::Ice::ByteSeq ret;
        try
        {
            ret = proxy->end_throwMemoryLimitException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwMemoryLimitException.
 */
template<class T> Callback_Thrower_throwMemoryLimitExceptionPtr
newCallback_Thrower_throwMemoryLimitException(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwMemoryLimitException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwMemoryLimitException.
 */
template<class T> Callback_Thrower_throwMemoryLimitExceptionPtr
newCallback_Thrower_throwMemoryLimitException(T* instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwMemoryLimitException<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwMemoryLimitException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwMemoryLimitException.
 */
template<class T, typename CT>
class Callback_Thrower_throwMemoryLimitException : public Callback_Thrower_throwMemoryLimitException_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ByteSeq&, const CT&);

    Callback_Thrower_throwMemoryLimitException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        ::Ice::ByteSeq ret;
        try
        {
            ret = proxy->end_throwMemoryLimitException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwMemoryLimitException.
 */
template<class T, typename CT> Callback_Thrower_throwMemoryLimitExceptionPtr
newCallback_Thrower_throwMemoryLimitException(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwMemoryLimitException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwMemoryLimitException.
 */
template<class T, typename CT> Callback_Thrower_throwMemoryLimitExceptionPtr
newCallback_Thrower_throwMemoryLimitException(T* instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwMemoryLimitException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwLocalExceptionIdempotent.
 */
template<class T>
class CallbackNC_Thrower_throwLocalExceptionIdempotent : public Callback_Thrower_throwLocalExceptionIdempotent_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwLocalExceptionIdempotent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalExceptionIdempotent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalExceptionIdempotent<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalExceptionIdempotent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalExceptionIdempotent<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwLocalExceptionIdempotent.
 */
template<class T, typename CT>
class Callback_Thrower_throwLocalExceptionIdempotent : public Callback_Thrower_throwLocalExceptionIdempotent_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwLocalExceptionIdempotent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalExceptionIdempotent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalExceptionIdempotent<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalExceptionIdempotent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalExceptionIdempotent<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwAfterResponse.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAfterResponse.
 */
template<class T>
class CallbackNC_Thrower_throwAfterResponse : public Callback_Thrower_throwAfterResponse_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwAfterResponse(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterResponse.
 */
template<class T> Callback_Thrower_throwAfterResponsePtr
newCallback_Thrower_throwAfterResponse(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAfterResponse<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterResponse.
 */
template<class T> Callback_Thrower_throwAfterResponsePtr
newCallback_Thrower_throwAfterResponse(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAfterResponse<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterResponse.
 */
template<class T> Callback_Thrower_throwAfterResponsePtr
newCallback_Thrower_throwAfterResponse(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAfterResponse<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterResponse.
 */
template<class T> Callback_Thrower_throwAfterResponsePtr
newCallback_Thrower_throwAfterResponse(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAfterResponse<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwAfterResponse.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAfterResponse.
 */
template<class T, typename CT>
class Callback_Thrower_throwAfterResponse : public Callback_Thrower_throwAfterResponse_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwAfterResponse(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterResponse.
 */
template<class T, typename CT> Callback_Thrower_throwAfterResponsePtr
newCallback_Thrower_throwAfterResponse(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAfterResponse<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterResponse.
 */
template<class T, typename CT> Callback_Thrower_throwAfterResponsePtr
newCallback_Thrower_throwAfterResponse(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAfterResponse<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterResponse.
 */
template<class T, typename CT> Callback_Thrower_throwAfterResponsePtr
newCallback_Thrower_throwAfterResponse(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAfterResponse<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterResponse.
 */
template<class T, typename CT> Callback_Thrower_throwAfterResponsePtr
newCallback_Thrower_throwAfterResponse(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAfterResponse<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwAfterException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAfterException.
 */
template<class T>
class CallbackNC_Thrower_throwAfterException : public Callback_Thrower_throwAfterException_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwAfterException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwAfterException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterException.
 */
template<class T> Callback_Thrower_throwAfterExceptionPtr
newCallback_Thrower_throwAfterException(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAfterException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterException.
 */
template<class T> Callback_Thrower_throwAfterExceptionPtr
newCallback_Thrower_throwAfterException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAfterException<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterException.
 */
template<class T> Callback_Thrower_throwAfterExceptionPtr
newCallback_Thrower_throwAfterException(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAfterException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterException.
 */
template<class T> Callback_Thrower_throwAfterExceptionPtr
newCallback_Thrower_throwAfterException(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAfterException<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwAfterException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAfterException.
 */
template<class T, typename CT>
class Callback_Thrower_throwAfterException : public Callback_Thrower_throwAfterException_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwAfterException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwAfterException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterException.
 */
template<class T, typename CT> Callback_Thrower_throwAfterExceptionPtr
newCallback_Thrower_throwAfterException(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAfterException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterException.
 */
template<class T, typename CT> Callback_Thrower_throwAfterExceptionPtr
newCallback_Thrower_throwAfterException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAfterException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterException.
 */
template<class T, typename CT> Callback_Thrower_throwAfterExceptionPtr
newCallback_Thrower_throwAfterException(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAfterException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAfterException.
 */
template<class T, typename CT> Callback_Thrower_throwAfterExceptionPtr
newCallback_Thrower_throwAfterException(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAfterException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwMarshalException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwMarshalException.
 */
template<class T>
class CallbackNC_Thrower_throwMarshalException : public Callback_Thrower_throwMarshalException_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int);

    CallbackNC_Thrower_throwMarshalException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        ::Ice::Int iceP_p;
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_throwMarshalException(iceP_p, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwMarshalException.
 */
template<class T> Callback_Thrower_throwMarshalExceptionPtr
newCallback_Thrower_throwMarshalException(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwMarshalException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwMarshalException.
 */
template<class T> Callback_Thrower_throwMarshalExceptionPtr
newCallback_Thrower_throwMarshalException(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwMarshalException<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwMarshalException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwMarshalException.
 */
template<class T, typename CT>
class Callback_Thrower_throwMarshalException : public Callback_Thrower_throwMarshalException_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int, const CT&);

    Callback_Thrower_throwMarshalException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        ::Ice::Int iceP_p;
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_throwMarshalException(iceP_p, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwMarshalException.
 */
template<class T, typename CT> Callback_Thrower_throwMarshalExceptionPtr
newCallback_Thrower_throwMarshalException(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwMarshalException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwMarshalException.
 */
template<class T, typename CT> Callback_Thrower_throwMarshalExceptionPtr
newCallback_Thrower_throwMarshalException(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwMarshalException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::WrongOperation::begin_noSuchOperation.
 * Create a wrapper instance by calling ::Test::newCallback_WrongOperation_noSuchOperation.
 */
template<class T>
class CallbackNC_WrongOperation_noSuchOperation : public Callback_WrongOperation_noSuchOperation_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_WrongOperation_noSuchOperation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_WrongOperation_noSuchOperation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_WrongOperation_noSuchOperation<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_WrongOperation_noSuchOperation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_WrongOperation_noSuchOperation<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::WrongOperation::begin_noSuchOperation.
 * Create a wrapper instance by calling ::Test::newCallback_WrongOperation_noSuchOperation.
 */
template<class T, typename CT>
class Callback_WrongOperation_noSuchOperation : public Callback_WrongOperation_noSuchOperation_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_WrongOperation_noSuchOperation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T, typename CT> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_WrongOperation_noSuchOperation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T, typename CT> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_WrongOperation_noSuchOperation<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T, typename CT> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_WrongOperation_noSuchOperation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T, typename CT> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_WrongOperation_noSuchOperation<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
