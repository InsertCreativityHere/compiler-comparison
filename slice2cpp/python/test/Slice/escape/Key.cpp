//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Key.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <Key.h>
#include <IceUtil/PushDisableWarnings.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::std::string iceC_and_del_ids[2] =
{
    "::Ice::Object",
    "::and::del"
};
const ::std::string iceC_and_del_ops[] =
{
    "elif",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_and_del_elif_name = "elif";

const ::std::string iceC_and_exec_ids[2] =
{
    "::Ice::Object",
    "::and::exec"
};
const ::std::string iceC_and_exec_ops[] =
{
    "finally",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_and_exec_finally_name = "finally";

const ::IceInternal::DefaultValueFactoryInit<::_cpp_and::_cpp_for> iceC_and_for_init("::and::for");

const ::std::string iceC_and_if_ids[4] =
{
    "::Ice::Object",
    "::and::del",
    "::and::exec",
    "::and::if"
};
const ::std::string iceC_and_if_ops[] =
{
    "elif",
    "finally",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

const ::IceInternal::DefaultUserExceptionFactoryInit<::_cpp_and::is> iceC_and_is_init("::and::is");

const ::IceInternal::DefaultUserExceptionFactoryInit<::_cpp_and::_cpp_not> iceC_and_not_init("::and::not");

const ::std::string iceC_and_print_ids[2] =
{
    "::Ice::Object",
    "::and::print"
};
const ::std::string iceC_and_print_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "raise"
};
const ::std::string iceC_and_print_raise_name = "raise";

}

_cpp_and::is::~is()
{
}

const ::std::string&
_cpp_and::is::ice_staticId()
{
    static const ::std::string typeId = "::and::is";
    return typeId;
}

_cpp_and::_cpp_not::~_cpp_not()
{
}

const ::std::string&
_cpp_and::_cpp_not::ice_staticId()
{
    static const ::std::string typeId = "::and::not";
    return typeId;
}

bool
_cpp_and::del::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_and_del_ids, iceC_and_del_ids + 2, s);
}

::std::vector<::std::string>
_cpp_and::del::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_and_del_ids[0], &iceC_and_del_ids[2]);
}

::std::string
_cpp_and::del::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
_cpp_and::del::ice_staticId()
{
    static const ::std::string typeId = "::and::del";
    return typeId;
}

/// \cond INTERNAL
bool
_cpp_and::del::_iceD_elif(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_else;
    istr->readAll(iceP_else);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](int iceP_except)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_except);
        inA->endWriteParams();
        inA->completed();
    };
    this->elifAsync(iceP_else, responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
_cpp_and::del::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_and_del_ops, iceC_and_del_ops + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_and_del_ops)
    {
        case 0:
        {
            return _iceD_elif(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
_cpp_and::exec::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_and_exec_ids, iceC_and_exec_ids + 2, s);
}

::std::vector<::std::string>
_cpp_and::exec::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_and_exec_ids[0], &iceC_and_exec_ids[2]);
}

::std::string
_cpp_and::exec::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
_cpp_and::exec::ice_staticId()
{
    static const ::std::string typeId = "::and::exec";
    return typeId;
}

/// \cond INTERNAL
bool
_cpp_and::exec::_iceD_finally(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->finally(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
_cpp_and::exec::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_and_exec_ops, iceC_and_exec_ops + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_and_exec_ops)
    {
        case 0:
        {
            return _iceD_finally(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
_cpp_and::_cpp_if::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_and_if_ids, iceC_and_if_ids + 4, s);
}

::std::vector<::std::string>
_cpp_and::_cpp_if::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_and_if_ids[0], &iceC_and_if_ids[4]);
}

::std::string
_cpp_and::_cpp_if::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
_cpp_and::_cpp_if::ice_staticId()
{
    static const ::std::string typeId = "::and::if";
    return typeId;
}

/// \cond INTERNAL
bool
_cpp_and::_cpp_if::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_and_if_ops, iceC_and_if_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_and_if_ops)
    {
        case 0:
        {
            return _iceD_elif(in, current);
        }
        case 1:
        {
            return _iceD_finally(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
_cpp_and::print::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_and_print_ids, iceC_and_print_ids + 2, s);
}

::std::vector<::std::string>
_cpp_and::print::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_and_print_ids[0], &iceC_and_print_ids[2]);
}

::std::string
_cpp_and::print::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
_cpp_and::print::ice_staticId()
{
    static const ::std::string typeId = "::and::print";
    return typeId;
}

/// \cond INTERNAL
bool
_cpp_and::print::_iceD_raise(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    _cpp_continue iceP_else;
    ::std::shared_ptr<::and::for> iceP_return;
    ::std::shared_ptr<delPrx> iceP_while;
    ::std::shared_ptr<execPrx> iceP_yield;
    ::std::shared_ptr<ifPrx> iceP_or;
    int iceP_global;
    istr->readAll(iceP_else, iceP_return, iceP_while, iceP_yield, iceP_or, iceP_global);
    istr->readPendingValues();
    inS.endReadParams();
    assert ret = this->raise(::std::move(iceP_else), ::std::move(iceP_return), ::std::move(iceP_while), ::std::move(iceP_yield), ::std::move(iceP_or), iceP_global, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
_cpp_and::print::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_and_print_ops, iceC_and_print_ops + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_and_print_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_raise(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

_cpp_and::_cpp_for::~_cpp_for()
{
}

const ::std::string&
_cpp_and::_cpp_for::ice_staticId()
{
    static const ::std::string typeId = "::and::for";
    return typeId;
}

/// \cond INTERNAL
void
_cpp_and::delPrx::_iceI_elif(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, int iceP_else, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_and_del_elif_name);
    outAsync->invoke(iceC_and_del_elif_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_else);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
_cpp_and::delPrx::_newInstance() const
{
    return ::IceInternal::createProxy<delPrx>();
}
/// \endcond

const ::std::string&
_cpp_and::delPrx::ice_staticId()
{
    return del::ice_staticId();
}

/// \cond INTERNAL
void
_cpp_and::execPrx::_iceI_finally(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_and_exec_finally_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
_cpp_and::execPrx::_newInstance() const
{
    return ::IceInternal::createProxy<execPrx>();
}
/// \endcond

const ::std::string&
_cpp_and::execPrx::ice_staticId()
{
    return exec::ice_staticId();
}

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
_cpp_and::ifPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ifPrx>();
}
/// \endcond

const ::std::string&
_cpp_and::ifPrx::ice_staticId()
{
    return _cpp_if::ice_staticId();
}

/// \cond INTERNAL
void
_cpp_and::printPrx::_iceI_raise(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::_cpp_and::assert>>& outAsync, const _cpp_continue& iceP_else, const ::std::shared_ptr<_cpp_for>& iceP_return, const ::std::shared_ptr<delPrx>& iceP_while, const ::std::shared_ptr<execPrx>& iceP_yield, const ::std::shared_ptr<ifPrx>& iceP_or, int iceP_global, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_and_print_raise_name);
    outAsync->invoke(iceC_and_print_raise_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_else, iceP_return, iceP_while, iceP_yield, iceP_or, iceP_global);
            ostr->writePendingValues();
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const is&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
_cpp_and::printPrx::_newInstance() const
{
    return ::IceInternal::createProxy<printPrx>();
}
/// \endcond

const ::std::string&
_cpp_and::printPrx::ice_staticId()
{
    return print::ice_staticId();
}

namespace Ice
{
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_and_del_elif_name = "elif";

const ::std::string iceC_and_exec_finally_name = "finally";

const ::std::string iceC_and_print_raise_name = "raise";

}

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::_cpp_and::is> iceC_and_is_init("::and::is");

}

_cpp_and::is::is(::Ice::Int lambda) :
    ::Ice::UserException(),
    lambda(lambda)
{
}
_cpp_and::is::~is()
{
}

::std::string
_cpp_and::is::ice_id() const
{
    return "::and::is";
}

_cpp_and::is*
_cpp_and::is::ice_clone() const
{
    return new is(*this);
}

void
_cpp_and::is::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
_cpp_and::is::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::and::is", -1, true);
    ::Ice::StreamWriter< is, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
_cpp_and::is::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< is, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::_cpp_and::_cpp_not> iceC_and_not_init("::and::not");

}

_cpp_and::_cpp_not::_cpp_not(::Ice::Int lambda, ::Ice::Int _cpp_or, ::Ice::Int pass) :
    is(lambda),
    _cpp_or(_cpp_or),
    pass(pass)
{
}
_cpp_and::_cpp_not::~_cpp_not()
{
}

::std::string
_cpp_and::_cpp_not::ice_id() const
{
    return "::and::not";
}

_cpp_and::_cpp_not*
_cpp_and::_cpp_not::ice_clone() const
{
    return new _cpp_not(*this);
}

void
_cpp_and::_cpp_not::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
_cpp_and::_cpp_not::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::and::not", -1, false);
    ::Ice::StreamWriter< _cpp_not, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    is::_writeImpl(ostr);
}

void
_cpp_and::_cpp_not::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< _cpp_not, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    is::_readImpl(istr);
}
/// \endcond

_cpp_and::AMD_del_elif::~AMD_del_elif()
{
}

/// \cond INTERNAL
IceAsync::_cpp_and::AMD_del_elif::AMD_del_elif(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::_cpp_and::AMD_del_elif::ice_response(::Ice::Int except)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(except);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::_cpp_and::upCast(del* p) { return p; }

void
::IceProxy::_cpp_and::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< del>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new del;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::_cpp_and::del::_iceI_begin_elif(::Ice::Int iceP_else, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_and_del_elif_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_and_del_elif_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_and_del_elif_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_else);
        result->endWriteParams();
        result->invoke(iceC_and_del_elif_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::_cpp_and::del::end_elif(::Ice::Int& iceP_except, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_and_del_elif_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_except);
    result->_endReadParams();
}

void IceProxy::_cpp_and::del::_iceI_end_elif(::Ice::Int& iceP_except, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_and_del_elif_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_except);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::_cpp_and::del::_newInstance() const
{
    return new del;
}
/// \endcond

const ::std::string&
IceProxy::_cpp_and::del::ice_staticId()
{
    return ::_cpp_and::del::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::_cpp_and::upCast(exec* p) { return p; }

void
::IceProxy::_cpp_and::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< exec>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new exec;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::_cpp_and::exec::_iceI_begin_finally(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_and_exec_finally_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_and_exec_finally_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_and_exec_finally_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::_cpp_and::exec::end_finally(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_and_exec_finally_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::_cpp_and::exec::_newInstance() const
{
    return new exec;
}
/// \endcond

const ::std::string&
IceProxy::_cpp_and::exec::ice_staticId()
{
    return ::_cpp_and::exec::ice_staticId();
}

::IceProxy::_cpp_and::_ifBase::~_ifBase()
{
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::_cpp_and::upCast(_cpp_if* p) { return p; }

void
::IceProxy::_cpp_and::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< _cpp_if>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new _cpp_if;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::_cpp_and::_cpp_if::_newInstance() const
{
    return new _cpp_if;
}
/// \endcond

const ::std::string&
IceProxy::_cpp_and::_cpp_if::ice_staticId()
{
    return ::_cpp_and::_cpp_if::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::_cpp_and::upCast(print* p) { return p; }

void
::IceProxy::_cpp_and::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< print>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new print;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::_cpp_and::print::_iceI_begin_raise(const ::_cpp_and::_cpp_continue& iceP_else, const ::_cpp_and::forPtr& iceP_return, const ::_cpp_and::delPrx& iceP_while, const ::_cpp_and::execPrx& iceP_yield, const ::_cpp_and::ifPrx& iceP_or, ::Ice::Int iceP_global, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_and_print_raise_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_and_print_raise_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_and_print_raise_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_else);
        ostr->write(iceP_return);
        ostr->write(iceP_while);
        ostr->write(iceP_yield);
        ostr->write(iceP_or);
        ostr->write(iceP_global);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_and_print_raise_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::_cpp_and::assert
IceProxy::_cpp_and::print::end_raise(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_and_print_raise_name);
    ::_cpp_and::assert ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::_cpp_and::is&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::_cpp_and::print::_newInstance() const
{
    return new print;
}
/// \endcond

const ::std::string&
IceProxy::_cpp_and::print::ice_staticId()
{
    return ::_cpp_and::print::ice_staticId();
}

_cpp_and::del::~del()
{
}

namespace
{
const ::std::string iceC_and_del_ids[2] =
{
    "::Ice::Object",
    "::and::del"
};

}

bool
_cpp_and::del::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_and_del_ids, iceC_and_del_ids + 2, s);
}

::std::vector< ::std::string>
_cpp_and::del::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_and_del_ids[0], &iceC_and_del_ids[2]);
}

const ::std::string&
_cpp_and::del::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
_cpp_and::del::ice_staticId()
{
    static const ::std::string typeId = "::and::del";
    return typeId;
}

/// \cond INTERNAL
bool
_cpp_and::del::_iceD_elif(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_else;
    istr->read(iceP_else);
    inS.endReadParams();
    this->elif_async(new IceAsync::_cpp_and::AMD_del_elif(inS), iceP_else, current);
    return false;
}
/// \endcond

namespace
{
const ::std::string iceC_and_del_all[] =
{
    "elif",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
_cpp_and::del::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_and_del_all, iceC_and_del_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_and_del_all)
    {
        case 0:
        {
            return _iceD_elif(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

_cpp_and::exec::~exec()
{
}

namespace
{
const ::std::string iceC_and_exec_ids[2] =
{
    "::Ice::Object",
    "::and::exec"
};

}

bool
_cpp_and::exec::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_and_exec_ids, iceC_and_exec_ids + 2, s);
}

::std::vector< ::std::string>
_cpp_and::exec::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_and_exec_ids[0], &iceC_and_exec_ids[2]);
}

const ::std::string&
_cpp_and::exec::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
_cpp_and::exec::ice_staticId()
{
    static const ::std::string typeId = "::and::exec";
    return typeId;
}

/// \cond INTERNAL
bool
_cpp_and::exec::_iceD_finally(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->finally(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_and_exec_all[] =
{
    "finally",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
_cpp_and::exec::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_and_exec_all, iceC_and_exec_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_and_exec_all)
    {
        case 0:
        {
            return _iceD_finally(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

_cpp_and::_cpp_if::~_cpp_if()
{
}

namespace
{
const ::std::string iceC_and_if_ids[4] =
{
    "::Ice::Object",
    "::and::del",
    "::and::exec",
    "::and::if"
};

}

bool
_cpp_and::_cpp_if::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_and_if_ids, iceC_and_if_ids + 4, s);
}

::std::vector< ::std::string>
_cpp_and::_cpp_if::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_and_if_ids[0], &iceC_and_if_ids[4]);
}

const ::std::string&
_cpp_and::_cpp_if::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
_cpp_and::_cpp_if::ice_staticId()
{
    static const ::std::string typeId = "::and::if";
    return typeId;
}

namespace
{
const ::std::string iceC_and_if_all[] =
{
    "elif",
    "finally",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
_cpp_and::_cpp_if::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_and_if_all, iceC_and_if_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_and_if_all)
    {
        case 0:
        {
            return _iceD_elif(in, current);
        }
        case 1:
        {
            return _iceD_finally(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

_cpp_and::print::~print()
{
}

namespace
{
const ::std::string iceC_and_print_ids[2] =
{
    "::Ice::Object",
    "::and::print"
};

}

bool
_cpp_and::print::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_and_print_ids, iceC_and_print_ids + 2, s);
}

::std::vector< ::std::string>
_cpp_and::print::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_and_print_ids[0], &iceC_and_print_ids[2]);
}

const ::std::string&
_cpp_and::print::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
_cpp_and::print::ice_staticId()
{
    static const ::std::string typeId = "::and::print";
    return typeId;
}

/// \cond INTERNAL
bool
_cpp_and::print::_iceD_raise(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    _cpp_continue iceP_else;
    ::and::forPtr iceP_return;
    delPrx iceP_while;
    execPrx iceP_yield;
    ifPrx iceP_or;
    ::Ice::Int iceP_global;
    istr->read(iceP_else);
    istr->read(iceP_return);
    istr->read(iceP_while);
    istr->read(iceP_yield);
    istr->read(iceP_or);
    istr->read(iceP_global);
    istr->readPendingValues();
    inS.endReadParams();
    assert ret = this->raise(iceP_else, iceP_return, iceP_while, iceP_yield, iceP_or, iceP_global, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_and_print_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "raise"
};

}

/// \cond INTERNAL
bool
_cpp_and::print::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_and_print_all, iceC_and_print_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_and_print_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_raise(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

_cpp_and::_cpp_for::~_cpp_for()
{
}

/// \cond INTERNAL
::Ice::Object* _cpp_and::upCast(_cpp_for* p) { return p; }

/// \endcond
::Ice::ObjectPtr
_cpp_and::_cpp_for::ice_clone() const
{
    ::Ice::Object* p = new _cpp_for(*this);
    return p;
}

namespace
{
const ::std::string iceC_and_for_ids[2] =
{
    "::Ice::Object",
    "::and::for"
};

}

bool
_cpp_and::_cpp_for::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_and_for_ids, iceC_and_for_ids + 2, s);
}

::std::vector< ::std::string>
_cpp_and::_cpp_for::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_and_for_ids[0], &iceC_and_for_ids[2]);
}

const ::std::string&
_cpp_and::_cpp_for::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
_cpp_and::_cpp_for::ice_staticId()
{
    static const ::std::string typeId = "::and::for";
    return typeId;
}

/// \cond STREAM
void
_cpp_and::_cpp_for::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< _cpp_for, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
_cpp_and::_cpp_for::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< _cpp_for, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::_cpp_and::_cpp_for> iceC_and_for_init("::and::for");
}

::Ice::ValueFactoryPtr
_cpp_and::_cpp_for::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::_cpp_and::_cpp_for::ice_staticId());
}

/// \cond INTERNAL
void
_cpp_and::_icePatchObjectPtr(forPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = forPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(_cpp_for::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
