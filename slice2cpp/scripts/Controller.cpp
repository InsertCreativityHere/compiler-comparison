// Copyright (c) ZeroC, Inc.
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file 'Controller.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#define ICE_BUILDING_GENERATED_CODE
#include "Controller.h"
#include <Ice/AsyncResponseHandler.h>
#include <Ice/FactoryTable.h>
#include <Ice/OutgoingAsync.h>
#include <algorithm>

#if defined(_MSC_VER)
#   pragma warning(disable : 4458) // declaration of ... hides class member
#   pragma warning(disable : 4996) // ... was declared deprecated
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#   pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#   pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{
    const ::IceInternal::FactoryTableInit iceC_factoryTableInit;
    const ::IceInternal::DefaultValueFactoryInit<::Test::Common::Config> iceC_Test_Common_Config_init("::Test::Common::Config");
    const ::IceInternal::DefaultValueFactoryInit<::Test::Common::OptionOverrides> iceC_Test_Common_OptionOverrides_init("::Test::Common::OptionOverrides");
    const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::Common::TestCaseNotExistException> iceC_Test_Common_TestCaseNotExistException_init("::Test::Common::TestCaseNotExistException");
    const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::Common::TestCaseFailedException> iceC_Test_Common_TestCaseFailedException_init("::Test::Common::TestCaseFailedException");
    const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::Common::ProcessFailedException> iceC_Test_Common_ProcessFailedException_init("::Test::Common::ProcessFailedException");
}

::std::string
Test::Common::TestCasePrx::startServerSide(const ConfigPtr& iceP_config, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(true, this, &TestCasePrx::_iceI_startServerSide, iceP_config, context).get();
}

::std::future<::std::string>
Test::Common::TestCasePrx::startServerSideAsync(const ConfigPtr& iceP_config, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(false, this, &TestCasePrx::_iceI_startServerSide, iceP_config, context);
}

::std::function<void()>
Test::Common::TestCasePrx::startServerSideAsync(const ConfigPtr& iceP_config, ::std::function<void(::std::string)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::string>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::TestCasePrx::_iceI_startServerSide, iceP_config, context);
}

void
Test::Common::TestCasePrx::_iceI_startServerSide(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ConfigPtr& iceP_config, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "startServerSide";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_config);
            ostr->writePendingValues();
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const TestCaseFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::string
Test::Common::TestCasePrx::stopServerSide(bool iceP_success, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(true, this, &TestCasePrx::_iceI_stopServerSide, iceP_success, context).get();
}

::std::future<::std::string>
Test::Common::TestCasePrx::stopServerSideAsync(bool iceP_success, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(false, this, &TestCasePrx::_iceI_stopServerSide, iceP_success, context);
}

::std::function<void()>
Test::Common::TestCasePrx::stopServerSideAsync(bool iceP_success, ::std::function<void(::std::string)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::string>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::TestCasePrx::_iceI_stopServerSide, iceP_success, context);
}

void
Test::Common::TestCasePrx::_iceI_stopServerSide(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, bool iceP_success, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "stopServerSide";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_success);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const TestCaseFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::string
Test::Common::TestCasePrx::runClientSide(::std::string_view iceP_host, const ConfigPtr& iceP_config, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(true, this, &TestCasePrx::_iceI_runClientSide, iceP_host, iceP_config, context).get();
}

::std::future<::std::string>
Test::Common::TestCasePrx::runClientSideAsync(::std::string_view iceP_host, const ConfigPtr& iceP_config, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(false, this, &TestCasePrx::_iceI_runClientSide, iceP_host, iceP_config, context);
}

::std::function<void()>
Test::Common::TestCasePrx::runClientSideAsync(::std::string_view iceP_host, const ConfigPtr& iceP_config, ::std::function<void(::std::string)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::string>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::TestCasePrx::_iceI_runClientSide, iceP_host, iceP_config, context);
}

void
Test::Common::TestCasePrx::_iceI_runClientSide(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, ::std::string_view iceP_host, const ConfigPtr& iceP_config, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "runClientSide";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_host, iceP_config);
            ostr->writePendingValues();
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const TestCaseFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
Test::Common::TestCasePrx::destroy(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestCasePrx::_iceI_destroy, context).get();
}

::std::future<void>
Test::Common::TestCasePrx::destroyAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestCasePrx::_iceI_destroy, context);
}

::std::function<void()>
Test::Common::TestCasePrx::destroyAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::TestCasePrx::_iceI_destroy, context);
}

void
Test::Common::TestCasePrx::_iceI_destroy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "destroy";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        nullptr,
        nullptr);
}

const char*
Test::Common::TestCasePrx::ice_staticId() noexcept
{
    return "::Test::Common::TestCase";
}

::std::optional<::Test::Common::TestCasePrx>
Test::Common::ControllerPrx::runTestCase(::std::string_view iceP_mapping, ::std::string_view iceP_testsuite, ::std::string_view iceP_testcase, ::std::string_view iceP_cross, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<TestCasePrx>>(true, this, &ControllerPrx::_iceI_runTestCase, iceP_mapping, iceP_testsuite, iceP_testcase, iceP_cross, context).get();
}

::std::future<::std::optional<::Test::Common::TestCasePrx>>
Test::Common::ControllerPrx::runTestCaseAsync(::std::string_view iceP_mapping, ::std::string_view iceP_testsuite, ::std::string_view iceP_testcase, ::std::string_view iceP_cross, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<TestCasePrx>>(false, this, &ControllerPrx::_iceI_runTestCase, iceP_mapping, iceP_testsuite, iceP_testcase, iceP_cross, context);
}

::std::function<void()>
Test::Common::ControllerPrx::runTestCaseAsync(::std::string_view iceP_mapping, ::std::string_view iceP_testsuite, ::std::string_view iceP_testcase, ::std::string_view iceP_cross, ::std::function<void(::std::optional<::Test::Common::TestCasePrx>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::optional<TestCasePrx>>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::ControllerPrx::_iceI_runTestCase, iceP_mapping, iceP_testsuite, iceP_testcase, iceP_cross, context);
}

void
Test::Common::ControllerPrx::_iceI_runTestCase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<TestCasePrx>>>& outAsync, ::std::string_view iceP_mapping, ::std::string_view iceP_testsuite, ::std::string_view iceP_testcase, ::std::string_view iceP_cross, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "runTestCase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_mapping, iceP_testsuite, iceP_testcase, iceP_cross);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const TestCaseNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::Test::Common::OptionOverridesPtr
Test::Common::ControllerPrx::getOptionOverrides(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<OptionOverridesPtr>(true, this, &ControllerPrx::_iceI_getOptionOverrides, context).get();
}

::std::future<::Test::Common::OptionOverridesPtr>
Test::Common::ControllerPrx::getOptionOverridesAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<OptionOverridesPtr>(false, this, &ControllerPrx::_iceI_getOptionOverrides, context);
}

::std::function<void()>
Test::Common::ControllerPrx::getOptionOverridesAsync(::std::function<void(::Test::Common::OptionOverridesPtr)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<OptionOverridesPtr>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::ControllerPrx::_iceI_getOptionOverrides, context);
}

void
Test::Common::ControllerPrx::_iceI_getOptionOverrides(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<OptionOverridesPtr>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getOptionOverrides";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            OptionOverridesPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::Common::StringSeq
Test::Common::ControllerPrx::getTestSuites(::std::string_view iceP_mapping, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<StringSeq>(true, this, &ControllerPrx::_iceI_getTestSuites, iceP_mapping, context).get();
}

::std::future<::Test::Common::StringSeq>
Test::Common::ControllerPrx::getTestSuitesAsync(::std::string_view iceP_mapping, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<StringSeq>(false, this, &ControllerPrx::_iceI_getTestSuites, iceP_mapping, context);
}

::std::function<void()>
Test::Common::ControllerPrx::getTestSuitesAsync(::std::string_view iceP_mapping, ::std::function<void(::Test::Common::StringSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<StringSeq>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::ControllerPrx::_iceI_getTestSuites, iceP_mapping, context);
}

void
Test::Common::ControllerPrx::_iceI_getTestSuites(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<StringSeq>>& outAsync, ::std::string_view iceP_mapping, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getTestSuites";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_mapping);
        },
        nullptr);
}

::std::string
Test::Common::ControllerPrx::getHost(::std::string_view iceP_protocol, bool iceP_ipv6, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(true, this, &ControllerPrx::_iceI_getHost, iceP_protocol, iceP_ipv6, context).get();
}

::std::future<::std::string>
Test::Common::ControllerPrx::getHostAsync(::std::string_view iceP_protocol, bool iceP_ipv6, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(false, this, &ControllerPrx::_iceI_getHost, iceP_protocol, iceP_ipv6, context);
}

::std::function<void()>
Test::Common::ControllerPrx::getHostAsync(::std::string_view iceP_protocol, bool iceP_ipv6, ::std::function<void(::std::string)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::string>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::ControllerPrx::_iceI_getHost, iceP_protocol, iceP_ipv6, context);
}

void
Test::Common::ControllerPrx::_iceI_getHost(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, ::std::string_view iceP_protocol, bool iceP_ipv6, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getHost";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_protocol, iceP_ipv6);
        },
        nullptr);
}

const char*
Test::Common::ControllerPrx::ice_staticId() noexcept
{
    return "::Test::Common::Controller";
}

void
Test::Common::ProcessPrx::waitReady(::std::int32_t iceP_timeout, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &ProcessPrx::_iceI_waitReady, iceP_timeout, context).get();
}

::std::future<void>
Test::Common::ProcessPrx::waitReadyAsync(::std::int32_t iceP_timeout, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &ProcessPrx::_iceI_waitReady, iceP_timeout, context);
}

::std::function<void()>
Test::Common::ProcessPrx::waitReadyAsync(::std::int32_t iceP_timeout, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::ProcessPrx::_iceI_waitReady, iceP_timeout, context);
}

void
Test::Common::ProcessPrx::_iceI_waitReady(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::int32_t iceP_timeout, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "waitReady";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_timeout);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ProcessFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::int32_t
Test::Common::ProcessPrx::waitSuccess(::std::int32_t iceP_timeout, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int32_t>(true, this, &ProcessPrx::_iceI_waitSuccess, iceP_timeout, context).get();
}

::std::future<::std::int32_t>
Test::Common::ProcessPrx::waitSuccessAsync(::std::int32_t iceP_timeout, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int32_t>(false, this, &ProcessPrx::_iceI_waitSuccess, iceP_timeout, context);
}

::std::function<void()>
Test::Common::ProcessPrx::waitSuccessAsync(::std::int32_t iceP_timeout, ::std::function<void(::std::int32_t)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::int32_t>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::ProcessPrx::_iceI_waitSuccess, iceP_timeout, context);
}

void
Test::Common::ProcessPrx::_iceI_waitSuccess(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::int32_t>>& outAsync, ::std::int32_t iceP_timeout, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "waitSuccess";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_timeout);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ProcessFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::string
Test::Common::ProcessPrx::terminate(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(true, this, &ProcessPrx::_iceI_terminate, context).get();
}

::std::future<::std::string>
Test::Common::ProcessPrx::terminateAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(false, this, &ProcessPrx::_iceI_terminate, context);
}

::std::function<void()>
Test::Common::ProcessPrx::terminateAsync(::std::function<void(::std::string)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::string>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::ProcessPrx::_iceI_terminate, context);
}

void
Test::Common::ProcessPrx::_iceI_terminate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "terminate";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        nullptr,
        nullptr);
}

const char*
Test::Common::ProcessPrx::ice_staticId() noexcept
{
    return "::Test::Common::Process";
}

::std::optional<::Test::Common::ProcessPrx>
Test::Common::ProcessControllerPrx::start(::std::string_view iceP_testsuite, ::std::string_view iceP_exe, const StringSeq& iceP_args, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<ProcessPrx>>(true, this, &ProcessControllerPrx::_iceI_start, iceP_testsuite, iceP_exe, iceP_args, context).get();
}

::std::future<::std::optional<::Test::Common::ProcessPrx>>
Test::Common::ProcessControllerPrx::startAsync(::std::string_view iceP_testsuite, ::std::string_view iceP_exe, const StringSeq& iceP_args, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<ProcessPrx>>(false, this, &ProcessControllerPrx::_iceI_start, iceP_testsuite, iceP_exe, iceP_args, context);
}

::std::function<void()>
Test::Common::ProcessControllerPrx::startAsync(::std::string_view iceP_testsuite, ::std::string_view iceP_exe, const StringSeq& iceP_args, ::std::function<void(::std::optional<::Test::Common::ProcessPrx>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::optional<ProcessPrx>>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::ProcessControllerPrx::_iceI_start, iceP_testsuite, iceP_exe, iceP_args, context);
}

void
Test::Common::ProcessControllerPrx::_iceI_start(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<ProcessPrx>>>& outAsync, ::std::string_view iceP_testsuite, ::std::string_view iceP_exe, const StringSeq& iceP_args, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "start";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_testsuite, iceP_exe, iceP_args);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ProcessFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::string
Test::Common::ProcessControllerPrx::getHost(::std::string_view iceP_protocol, bool iceP_ipv6, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(true, this, &ProcessControllerPrx::_iceI_getHost, iceP_protocol, iceP_ipv6, context).get();
}

::std::future<::std::string>
Test::Common::ProcessControllerPrx::getHostAsync(::std::string_view iceP_protocol, bool iceP_ipv6, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(false, this, &ProcessControllerPrx::_iceI_getHost, iceP_protocol, iceP_ipv6, context);
}

::std::function<void()>
Test::Common::ProcessControllerPrx::getHostAsync(::std::string_view iceP_protocol, bool iceP_ipv6, ::std::function<void(::std::string)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::string>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::ProcessControllerPrx::_iceI_getHost, iceP_protocol, iceP_ipv6, context);
}

void
Test::Common::ProcessControllerPrx::_iceI_getHost(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, ::std::string_view iceP_protocol, bool iceP_ipv6, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getHost";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_protocol, iceP_ipv6);
        },
        nullptr);
}

const char*
Test::Common::ProcessControllerPrx::ice_staticId() noexcept
{
    return "::Test::Common::ProcessController";
}

void
Test::Common::BrowserProcessControllerPrx::redirect(::std::string_view iceP_url, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &BrowserProcessControllerPrx::_iceI_redirect, iceP_url, context).get();
}

::std::future<void>
Test::Common::BrowserProcessControllerPrx::redirectAsync(::std::string_view iceP_url, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &BrowserProcessControllerPrx::_iceI_redirect, iceP_url, context);
}

::std::function<void()>
Test::Common::BrowserProcessControllerPrx::redirectAsync(::std::string_view iceP_url, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::BrowserProcessControllerPrx::_iceI_redirect, iceP_url, context);
}

void
Test::Common::BrowserProcessControllerPrx::_iceI_redirect(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_url, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "redirect";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_url);
        },
        nullptr);
}

const char*
Test::Common::BrowserProcessControllerPrx::ice_staticId() noexcept
{
    return "::Test::Common::BrowserProcessController";
}

void
Test::Common::ProcessControllerRegistryPrx::setProcessController(const ::std::optional<ProcessControllerPrx>& iceP_controller, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &ProcessControllerRegistryPrx::_iceI_setProcessController, iceP_controller, context).get();
}

::std::future<void>
Test::Common::ProcessControllerRegistryPrx::setProcessControllerAsync(const ::std::optional<ProcessControllerPrx>& iceP_controller, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &ProcessControllerRegistryPrx::_iceI_setProcessController, iceP_controller, context);
}

::std::function<void()>
Test::Common::ProcessControllerRegistryPrx::setProcessControllerAsync(const ::std::optional<ProcessControllerPrx>& iceP_controller, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::Common::ProcessControllerRegistryPrx::_iceI_setProcessController, iceP_controller, context);
}

void
Test::Common::ProcessControllerRegistryPrx::_iceI_setProcessController(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::optional<ProcessControllerPrx>& iceP_controller, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "setProcessController";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_controller);
        },
        nullptr);
}

const char*
Test::Common::ProcessControllerRegistryPrx::ice_staticId() noexcept
{
    return "::Test::Common::ProcessControllerRegistry";
}

const char*
Test::Common::Config::ice_staticId() noexcept
{
    return "::Test::Common::Config";
}

const char*
Test::Common::Config::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::Common::Config::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "protocol = ", this->protocol);
    Ice::print(os << ", mx = ", this->mx);
    Ice::print(os << ", serialize = ", this->serialize);
    Ice::print(os << ", compress = ", this->compress);
    Ice::print(os << ", ipv6 = ", this->ipv6);
    Ice::print(os << ", cprops = ", this->cprops);
    Ice::print(os << ", sprops = ", this->sprops);
}

::Ice::ValuePtr
Test::Common::Config::_iceCloneImpl() const
{
    return CloneEnabler<Config>::clone(*this);
}

void
Test::Common::Config::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll({1, 2, 3, 4, 5, 6, 7}, this->protocol, this->mx, this->serialize, this->compress, this->ipv6, this->cprops, this->sprops);
    ostr->endSlice();
}

void
Test::Common::Config::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll({1, 2, 3, 4, 5, 6, 7}, this->protocol, this->mx, this->serialize, this->compress, this->ipv6, this->cprops, this->sprops);
    istr->endSlice();
}

const char*
Test::Common::OptionOverrides::ice_staticId() noexcept
{
    return "::Test::Common::OptionOverrides";
}

const char*
Test::Common::OptionOverrides::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::Common::OptionOverrides::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "protocol = ", this->protocol);
    Ice::print(os << ", mx = ", this->mx);
    Ice::print(os << ", serialize = ", this->serialize);
    Ice::print(os << ", compress = ", this->compress);
    Ice::print(os << ", ipv6 = ", this->ipv6);
}

::Ice::ValuePtr
Test::Common::OptionOverrides::_iceCloneImpl() const
{
    return CloneEnabler<OptionOverrides>::clone(*this);
}

void
Test::Common::OptionOverrides::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll({1, 2, 3, 4, 5}, this->protocol, this->mx, this->serialize, this->compress, this->ipv6);
    ostr->endSlice();
}

void
Test::Common::OptionOverrides::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll({1, 2, 3, 4, 5}, this->protocol, this->mx, this->serialize, this->compress, this->ipv6);
    istr->endSlice();
}

const char*
Test::Common::TestCaseNotExistException::ice_staticId() noexcept
{
    return "::Test::Common::TestCaseNotExistException";
}

const char*
Test::Common::TestCaseNotExistException::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::Common::TestCaseNotExistException::ice_throw() const
{
    throw *this;
}

void
Test::Common::TestCaseNotExistException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->reason);
    ostr->endSlice();
}

void
Test::Common::TestCaseNotExistException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->reason);
    istr->endSlice();
}

const char*
Test::Common::TestCaseFailedException::ice_staticId() noexcept
{
    return "::Test::Common::TestCaseFailedException";
}

const char*
Test::Common::TestCaseFailedException::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::Common::TestCaseFailedException::ice_throw() const
{
    throw *this;
}

void
Test::Common::TestCaseFailedException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->output);
    ostr->endSlice();
}

void
Test::Common::TestCaseFailedException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->output);
    istr->endSlice();
}

const char*
Test::Common::ProcessFailedException::ice_staticId() noexcept
{
    return "::Test::Common::ProcessFailedException";
}

const char*
Test::Common::ProcessFailedException::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::Common::ProcessFailedException::ice_throw() const
{
    throw *this;
}

void
Test::Common::ProcessFailedException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->reason);
    ostr->endSlice();
}

void
Test::Common::ProcessFailedException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->reason);
    istr->endSlice();
}

::std::vector<::std::string>
Test::Common::TestCase::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = {"::Ice::Object", "::Test::Common::TestCase"};
    return allTypeIds;
}

::std::string
Test::Common::TestCase::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

const char*
Test::Common::TestCase::ice_staticId() noexcept
{
    return "::Test::Common::TestCase";
}

/// \cond INTERNAL
void
Test::Common::TestCase::_iceD_startServerSide(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ConfigPtr iceP_config;
    istr->readAll(iceP_config);
    istr->readPendingValues();
    istr->endEncapsulation();
    const ::std::string ret = this->startServerSide(::std::move(iceP_config), request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::TestCase::_iceD_stopServerSide(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    bool iceP_success;
    istr->readAll(iceP_success);
    istr->endEncapsulation();
    const ::std::string ret = this->stopServerSide(iceP_success, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::TestCase::_iceD_runClientSide(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::string iceP_host;
    ConfigPtr iceP_config;
    istr->readAll(iceP_host, iceP_config);
    istr->readPendingValues();
    istr->endEncapsulation();
    const ::std::string ret = this->runClientSide(::std::move(iceP_host), ::std::move(iceP_config), request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::TestCase::_iceD_destroy(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    this->destroy(request.current());
    sendResponse(::Ice::makeEmptyOutgoingResponse(request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::TestCase::dispatch(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    static constexpr ::std::string_view allOperations[] = {"destroy", "ice_id", "ice_ids", "ice_isA", "ice_ping", "runClientSide", "startServerSide", "stopServerSide"};

    const ::Ice::Current& current = request.current();
    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 8, current.operation);
    if(r.first == r.second)
    {
        sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            _iceD_destroy(request, ::std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_ice_id(request, ::std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_ice_ids(request, ::std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_ice_isA(request, ::std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_ice_ping(request, ::std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_runClientSide(request, ::std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_startServerSide(request, ::std::move(sendResponse));
            break;
        }
        case 7:
        {
            _iceD_stopServerSide(request, ::std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}
/// \endcond

::std::vector<::std::string>
Test::Common::Controller::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = {"::Ice::Object", "::Test::Common::Controller"};
    return allTypeIds;
}

::std::string
Test::Common::Controller::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

const char*
Test::Common::Controller::ice_staticId() noexcept
{
    return "::Test::Common::Controller";
}

/// \cond INTERNAL
void
Test::Common::Controller::_iceD_runTestCase(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::string iceP_mapping;
    ::std::string iceP_testsuite;
    ::std::string iceP_testcase;
    ::std::string iceP_cross;
    istr->readAll(iceP_mapping, iceP_testsuite, iceP_testcase, iceP_cross);
    istr->endEncapsulation();
    const ::std::optional<TestCasePrx> ret = this->runTestCase(::std::move(iceP_mapping), ::std::move(iceP_testsuite), ::std::move(iceP_testcase), ::std::move(iceP_cross), request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::Controller::_iceD_getOptionOverrides(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    const OptionOverridesPtr ret = this->getOptionOverrides(request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::Controller::_iceD_getTestSuites(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::string iceP_mapping;
    istr->readAll(iceP_mapping);
    istr->endEncapsulation();
    const StringSeq ret = this->getTestSuites(::std::move(iceP_mapping), request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::Controller::_iceD_getHost(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::string iceP_protocol;
    bool iceP_ipv6;
    istr->readAll(iceP_protocol, iceP_ipv6);
    istr->endEncapsulation();
    const ::std::string ret = this->getHost(::std::move(iceP_protocol), iceP_ipv6, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::Controller::dispatch(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    static constexpr ::std::string_view allOperations[] = {"getHost", "getOptionOverrides", "getTestSuites", "ice_id", "ice_ids", "ice_isA", "ice_ping", "runTestCase"};

    const ::Ice::Current& current = request.current();
    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 8, current.operation);
    if(r.first == r.second)
    {
        sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            _iceD_getHost(request, ::std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_getOptionOverrides(request, ::std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_getTestSuites(request, ::std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_ice_id(request, ::std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_ice_ids(request, ::std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_ice_isA(request, ::std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_ice_ping(request, ::std::move(sendResponse));
            break;
        }
        case 7:
        {
            _iceD_runTestCase(request, ::std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}
/// \endcond

::std::vector<::std::string>
Test::Common::Process::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = {"::Ice::Object", "::Test::Common::Process"};
    return allTypeIds;
}

::std::string
Test::Common::Process::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

const char*
Test::Common::Process::ice_staticId() noexcept
{
    return "::Test::Common::Process";
}

/// \cond INTERNAL
void
Test::Common::Process::_iceD_waitReady(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::int32_t iceP_timeout;
    istr->readAll(iceP_timeout);
    istr->endEncapsulation();
    this->waitReady(iceP_timeout, request.current());
    sendResponse(::Ice::makeEmptyOutgoingResponse(request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::Process::_iceD_waitSuccess(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::int32_t iceP_timeout;
    istr->readAll(iceP_timeout);
    istr->endEncapsulation();
    const ::std::int32_t ret = this->waitSuccess(iceP_timeout, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::Process::_iceD_terminate(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    const ::std::string ret = this->terminate(request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::Process::dispatch(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    static constexpr ::std::string_view allOperations[] = {"ice_id", "ice_ids", "ice_isA", "ice_ping", "terminate", "waitReady", "waitSuccess"};

    const ::Ice::Current& current = request.current();
    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 7, current.operation);
    if(r.first == r.second)
    {
        sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            _iceD_ice_id(request, ::std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_ice_ids(request, ::std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_ice_isA(request, ::std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_ice_ping(request, ::std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_terminate(request, ::std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_waitReady(request, ::std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_waitSuccess(request, ::std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}
/// \endcond

::std::vector<::std::string>
Test::Common::ProcessController::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = {"::Ice::Object", "::Test::Common::ProcessController"};
    return allTypeIds;
}

::std::string
Test::Common::ProcessController::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

const char*
Test::Common::ProcessController::ice_staticId() noexcept
{
    return "::Test::Common::ProcessController";
}

/// \cond INTERNAL
void
Test::Common::ProcessController::_iceD_start(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::string iceP_testsuite;
    ::std::string iceP_exe;
    StringSeq iceP_args;
    istr->readAll(iceP_testsuite, iceP_exe, iceP_args);
    istr->endEncapsulation();
    const ::std::optional<ProcessPrx> ret = this->start(::std::move(iceP_testsuite), ::std::move(iceP_exe), ::std::move(iceP_args), request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::ProcessController::_iceD_getHost(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::string iceP_protocol;
    bool iceP_ipv6;
    istr->readAll(iceP_protocol, iceP_ipv6);
    istr->endEncapsulation();
    const ::std::string ret = this->getHost(::std::move(iceP_protocol), iceP_ipv6, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::ProcessController::dispatch(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    static constexpr ::std::string_view allOperations[] = {"getHost", "ice_id", "ice_ids", "ice_isA", "ice_ping", "start"};

    const ::Ice::Current& current = request.current();
    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 6, current.operation);
    if(r.first == r.second)
    {
        sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            _iceD_getHost(request, ::std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_ice_id(request, ::std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_ice_ids(request, ::std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_ice_isA(request, ::std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_ice_ping(request, ::std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_start(request, ::std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}
/// \endcond

::std::vector<::std::string>
Test::Common::BrowserProcessController::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = {"::Ice::Object", "::Test::Common::BrowserProcessController", "::Test::Common::ProcessController"};
    return allTypeIds;
}

::std::string
Test::Common::BrowserProcessController::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

const char*
Test::Common::BrowserProcessController::ice_staticId() noexcept
{
    return "::Test::Common::BrowserProcessController";
}

/// \cond INTERNAL
void
Test::Common::BrowserProcessController::_iceD_redirect(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::string iceP_url;
    istr->readAll(iceP_url);
    istr->endEncapsulation();
    this->redirect(::std::move(iceP_url), request.current());
    sendResponse(::Ice::makeEmptyOutgoingResponse(request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::BrowserProcessController::dispatch(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    static constexpr ::std::string_view allOperations[] = {"getHost", "ice_id", "ice_ids", "ice_isA", "ice_ping", "redirect", "start"};

    const ::Ice::Current& current = request.current();
    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 7, current.operation);
    if(r.first == r.second)
    {
        sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            _iceD_getHost(request, ::std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_ice_id(request, ::std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_ice_ids(request, ::std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_ice_isA(request, ::std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_ice_ping(request, ::std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_redirect(request, ::std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_start(request, ::std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}
/// \endcond

::std::vector<::std::string>
Test::Common::ProcessControllerRegistry::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = {"::Ice::Object", "::Test::Common::ProcessControllerRegistry"};
    return allTypeIds;
}

::std::string
Test::Common::ProcessControllerRegistry::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

const char*
Test::Common::ProcessControllerRegistry::ice_staticId() noexcept
{
    return "::Test::Common::ProcessControllerRegistry";
}

/// \cond INTERNAL
void
Test::Common::ProcessControllerRegistry::_iceD_setProcessController(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<ProcessControllerPrx> iceP_controller;
    istr->readAll(iceP_controller);
    istr->endEncapsulation();
    this->setProcessController(::std::move(iceP_controller), request.current());
    sendResponse(::Ice::makeEmptyOutgoingResponse(request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Common::ProcessControllerRegistry::dispatch(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    static constexpr ::std::string_view allOperations[] = {"ice_id", "ice_ids", "ice_isA", "ice_ping", "setProcessController"};

    const ::Ice::Current& current = request.current();
    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 5, current.operation);
    if(r.first == r.second)
    {
        sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            _iceD_ice_id(request, ::std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_ice_ids(request, ::std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_ice_isA(request, ::std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_ice_ping(request, ::std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_setProcessController(request, ::std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}
/// \endcond
