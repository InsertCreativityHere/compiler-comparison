// Copyright (c) ZeroC, Inc.
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file 'Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#define ICE_BUILDING_GENERATED_CODE
#include "Test.h"
#include <Ice/AsyncResponseHandler.h>
#include <Ice/FactoryTable.h>
#include <Ice/OutgoingAsync.h>
#include <algorithm>
#include <array>

#if defined(_MSC_VER)
#   pragma warning(disable : 4458) // declaration of ... hides class member
#   pragma warning(disable : 4996) // ... was declared deprecated
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#   pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#   pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{
    const IceInternal::FactoryTableInit iceC_factoryTableInit;
    const IceInternal::DefaultValueFactoryInit<::Test::Base> iceC_Test_Base_init("::Test::Base");
    const IceInternal::DefaultValueFactoryInit<::Test::A> iceC_Test_A_init("::Test::A");
    const IceInternal::DefaultValueFactoryInit<::Test::B> iceC_Test_B_init("::Test::B");
    const IceInternal::DefaultValueFactoryInit<::Test::C> iceC_Test_C_init("::Test::C");
    const IceInternal::DefaultValueFactoryInit<::Test::D> iceC_Test_D_init("::Test::D");
    const IceInternal::DefaultValueFactoryInit<::Test::G> iceC_Test_G_init("::Test::G");
    const IceInternal::DefaultValueFactoryInit<::Test::Compact> iceC_Test_Compact_init("::Test::Compact");
    const IceInternal::CompactIdInit iceC_Test_Compact_compactIdInit ("::Test::Compact", 1);
    const IceInternal::DefaultValueFactoryInit<::Test::CompactExt> iceC_Test_CompactExt_init("::Test::CompactExt");
    const IceInternal::CompactIdInit iceC_Test_CompactExt_compactIdInit ("::Test::CompactExt", 789);
    const IceInternal::DefaultValueFactoryInit<::Test::A1> iceC_Test_A1_init("::Test::A1");
    const IceInternal::DefaultValueFactoryInit<::Test::B1> iceC_Test_B1_init("::Test::B1");
    const IceInternal::DefaultValueFactoryInit<::Test::D1> iceC_Test_D1_init("::Test::D1");
    const IceInternal::DefaultUserExceptionFactoryInit<::Test::EBase> iceC_Test_EBase_init("::Test::EBase");
    const IceInternal::DefaultUserExceptionFactoryInit<::Test::EDerived> iceC_Test_EDerived_init("::Test::EDerived");
    const IceInternal::DefaultValueFactoryInit<::Test::Recursive> iceC_Test_Recursive_init("::Test::Recursive");
    const IceInternal::DefaultValueFactoryInit<::Test::K> iceC_Test_K_init("::Test::K");
    const IceInternal::DefaultValueFactoryInit<::Test::L> iceC_Test_L_init("::Test::L");
    const IceInternal::DefaultValueFactoryInit<::Test::M> iceC_Test_M_init("::Test::M");
    const IceInternal::DefaultValueFactoryInit<::Test::F3> iceC_Test_F3_init("::Test::F3");
}

void
Test::InitialPrx::shutdown(const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_shutdown, context).get();
}

std::future<void>
Test::InitialPrx::shutdownAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &InitialPrx::_iceI_shutdown, context);
}

std::function<void()>
Test::InitialPrx::shutdownAsync(std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_shutdown, context);
}

void
Test::InitialPrx::_iceI_shutdown(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "shutdown";

    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        nullptr,
        nullptr);
}

::Test::BPtr
Test::InitialPrx::getB1(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(true, this, &InitialPrx::_iceI_getB1, context).get();
}

std::future<::Test::BPtr>
Test::InitialPrx::getB1Async(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(false, this, &InitialPrx::_iceI_getB1, context);
}

std::function<void()>
Test::InitialPrx::getB1Async(std::function<void(::Test::BPtr)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<BPtr>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_getB1, context);
}

void
Test::InitialPrx::_iceI_getB1(const std::shared_ptr<IceInternal::OutgoingAsyncT<BPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "getB1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            BPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::BPtr
Test::InitialPrx::getB2(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(true, this, &InitialPrx::_iceI_getB2, context).get();
}

std::future<::Test::BPtr>
Test::InitialPrx::getB2Async(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(false, this, &InitialPrx::_iceI_getB2, context);
}

std::function<void()>
Test::InitialPrx::getB2Async(std::function<void(::Test::BPtr)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<BPtr>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_getB2, context);
}

void
Test::InitialPrx::_iceI_getB2(const std::shared_ptr<IceInternal::OutgoingAsyncT<BPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "getB2";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            BPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::CPtr
Test::InitialPrx::getC(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<CPtr>(true, this, &InitialPrx::_iceI_getC, context).get();
}

std::future<::Test::CPtr>
Test::InitialPrx::getCAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<CPtr>(false, this, &InitialPrx::_iceI_getC, context);
}

std::function<void()>
Test::InitialPrx::getCAsync(std::function<void(::Test::CPtr)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<CPtr>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_getC, context);
}

void
Test::InitialPrx::_iceI_getC(const std::shared_ptr<IceInternal::OutgoingAsyncT<CPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "getC";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            CPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::DPtr
Test::InitialPrx::getD(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<DPtr>(true, this, &InitialPrx::_iceI_getD, context).get();
}

std::future<::Test::DPtr>
Test::InitialPrx::getDAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<DPtr>(false, this, &InitialPrx::_iceI_getD, context);
}

std::function<void()>
Test::InitialPrx::getDAsync(std::function<void(::Test::DPtr)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<DPtr>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_getD, context);
}

void
Test::InitialPrx::_iceI_getD(const std::shared_ptr<IceInternal::OutgoingAsyncT<DPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "getD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            DPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

void
Test::InitialPrx::setRecursive(const RecursivePtr& iceP_p, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_setRecursive, iceP_p, context).get();
}

std::future<void>
Test::InitialPrx::setRecursiveAsync(const RecursivePtr& iceP_p, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &InitialPrx::_iceI_setRecursive, iceP_p, context);
}

std::function<void()>
Test::InitialPrx::setRecursiveAsync(const RecursivePtr& iceP_p, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_setRecursive, iceP_p, context);
}

void
Test::InitialPrx::_iceI_setRecursive(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const RecursivePtr& iceP_p, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "setRecursive";

    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
            ostr->writePendingValues();
        },
        nullptr);
}

void
Test::InitialPrx::setCycle(const RecursivePtr& iceP_r, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_setCycle, iceP_r, context).get();
}

std::future<void>
Test::InitialPrx::setCycleAsync(const RecursivePtr& iceP_r, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &InitialPrx::_iceI_setCycle, iceP_r, context);
}

std::function<void()>
Test::InitialPrx::setCycleAsync(const RecursivePtr& iceP_r, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_setCycle, iceP_r, context);
}

void
Test::InitialPrx::_iceI_setCycle(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const RecursivePtr& iceP_r, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "setCycle";

    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_r);
            ostr->writePendingValues();
        },
        nullptr);
}

bool
Test::InitialPrx::acceptsClassCycles(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_acceptsClassCycles, context).get();
}

std::future<bool>
Test::InitialPrx::acceptsClassCyclesAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<bool>(false, this, &InitialPrx::_iceI_acceptsClassCycles, context);
}

std::function<void()>
Test::InitialPrx::acceptsClassCyclesAsync(std::function<void(bool)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<bool>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_acceptsClassCycles, context);
}

void
Test::InitialPrx::_iceI_acceptsClassCycles(const std::shared_ptr<IceInternal::OutgoingAsyncT<bool>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "acceptsClassCycles";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        nullptr,
        nullptr);
}

::Test::BPtr
Test::InitialPrx::getMB(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(true, this, &InitialPrx::_iceI_getMB, context).get();
}

std::future<::Test::BPtr>
Test::InitialPrx::getMBAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(false, this, &InitialPrx::_iceI_getMB, context);
}

std::function<void()>
Test::InitialPrx::getMBAsync(std::function<void(::Test::BPtr)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<BPtr>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_getMB, context);
}

void
Test::InitialPrx::_iceI_getMB(const std::shared_ptr<IceInternal::OutgoingAsyncT<BPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "getMB";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            BPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::BPtr
Test::InitialPrx::getAMDMB(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(true, this, &InitialPrx::_iceI_getAMDMB, context).get();
}

std::future<::Test::BPtr>
Test::InitialPrx::getAMDMBAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(false, this, &InitialPrx::_iceI_getAMDMB, context);
}

std::function<void()>
Test::InitialPrx::getAMDMBAsync(std::function<void(::Test::BPtr)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<BPtr>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_getAMDMB, context);
}

void
Test::InitialPrx::_iceI_getAMDMB(const std::shared_ptr<IceInternal::OutgoingAsyncT<BPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "getAMDMB";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            BPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

void
Test::InitialPrx::getAll(BPtr& iceP_b1, BPtr& iceP_b2, CPtr& iceP_theC, DPtr& iceP_theD, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<BPtr, BPtr, CPtr, DPtr>>(true, this, &InitialPrx::_iceI_getAll, context).get();
    iceP_b1 = std::move(std::get<0>(result));
    iceP_b2 = std::move(std::get<1>(result));
    iceP_theC = std::move(std::get<2>(result));
    iceP_theD = std::move(std::get<3>(result));
}

std::future<std::tuple<::Test::BPtr, ::Test::BPtr, ::Test::CPtr, ::Test::DPtr>>
Test::InitialPrx::getAllAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<BPtr, BPtr, CPtr, DPtr>>(false, this, &InitialPrx::_iceI_getAll, context);
}

std::function<void()>
Test::InitialPrx::getAllAsync(std::function<void(::Test::BPtr, ::Test::BPtr, ::Test::CPtr, ::Test::DPtr)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<BPtr, BPtr, CPtr, DPtr>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<BPtr, BPtr, CPtr, DPtr>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_getAll, context);
}

void
Test::InitialPrx::_iceI_getAll(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<BPtr, BPtr, CPtr, DPtr>>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "getAll";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<BPtr, BPtr, CPtr, DPtr> v;
            istr->readAll(std::get<0>(v), std::get<1>(v), std::get<2>(v), std::get<3>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::KPtr
Test::InitialPrx::getK(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<KPtr>(true, this, &InitialPrx::_iceI_getK, context).get();
}

std::future<::Test::KPtr>
Test::InitialPrx::getKAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<KPtr>(false, this, &InitialPrx::_iceI_getK, context);
}

std::function<void()>
Test::InitialPrx::getKAsync(std::function<void(::Test::KPtr)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<KPtr>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_getK, context);
}

void
Test::InitialPrx::_iceI_getK(const std::shared_ptr<IceInternal::OutgoingAsyncT<KPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "getK";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            KPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

Ice::ValuePtr
Test::InitialPrx::opValue(const Ice::ValuePtr& iceP_v1, Ice::ValuePtr& iceP_v2, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<Ice::ValuePtr, Ice::ValuePtr>>(true, this, &InitialPrx::_iceI_opValue, iceP_v1, context).get();
    iceP_v2 = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<Ice::ValuePtr, Ice::ValuePtr>>
Test::InitialPrx::opValueAsync(const Ice::ValuePtr& iceP_v1, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<Ice::ValuePtr, Ice::ValuePtr>>(false, this, &InitialPrx::_iceI_opValue, iceP_v1, context);
}

std::function<void()>
Test::InitialPrx::opValueAsync(const Ice::ValuePtr& iceP_v1, std::function<void(Ice::ValuePtr, Ice::ValuePtr)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<Ice::ValuePtr, Ice::ValuePtr>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<Ice::ValuePtr, Ice::ValuePtr>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_opValue, iceP_v1, context);
}

void
Test::InitialPrx::_iceI_opValue(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<Ice::ValuePtr, Ice::ValuePtr>>>& outAsync, const Ice::ValuePtr& iceP_v1, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opValue";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_v1);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<Ice::ValuePtr, Ice::ValuePtr> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::ValueSeq
Test::InitialPrx::opValueSeq(const ValueSeq& iceP_v1, ValueSeq& iceP_v2, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<ValueSeq, ValueSeq>>(true, this, &InitialPrx::_iceI_opValueSeq, iceP_v1, context).get();
    iceP_v2 = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::ValueSeq, ::Test::ValueSeq>>
Test::InitialPrx::opValueSeqAsync(const ValueSeq& iceP_v1, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<ValueSeq, ValueSeq>>(false, this, &InitialPrx::_iceI_opValueSeq, iceP_v1, context);
}

std::function<void()>
Test::InitialPrx::opValueSeqAsync(const ValueSeq& iceP_v1, std::function<void(::Test::ValueSeq, ::Test::ValueSeq)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<ValueSeq, ValueSeq>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<ValueSeq, ValueSeq>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_opValueSeq, iceP_v1, context);
}

void
Test::InitialPrx::_iceI_opValueSeq(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<ValueSeq, ValueSeq>>>& outAsync, const ValueSeq& iceP_v1, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opValueSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_v1);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<ValueSeq, ValueSeq> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::ValueMap
Test::InitialPrx::opValueMap(const ValueMap& iceP_v1, ValueMap& iceP_v2, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<ValueMap, ValueMap>>(true, this, &InitialPrx::_iceI_opValueMap, iceP_v1, context).get();
    iceP_v2 = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::ValueMap, ::Test::ValueMap>>
Test::InitialPrx::opValueMapAsync(const ValueMap& iceP_v1, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<ValueMap, ValueMap>>(false, this, &InitialPrx::_iceI_opValueMap, iceP_v1, context);
}

std::function<void()>
Test::InitialPrx::opValueMapAsync(const ValueMap& iceP_v1, std::function<void(::Test::ValueMap, ::Test::ValueMap)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<ValueMap, ValueMap>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<ValueMap, ValueMap>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_opValueMap, iceP_v1, context);
}

void
Test::InitialPrx::_iceI_opValueMap(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<ValueMap, ValueMap>>>& outAsync, const ValueMap& iceP_v1, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opValueMap";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_v1);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<ValueMap, ValueMap> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::D1Ptr
Test::InitialPrx::getD1(const D1Ptr& iceP_d1, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<D1Ptr>(true, this, &InitialPrx::_iceI_getD1, iceP_d1, context).get();
}

std::future<::Test::D1Ptr>
Test::InitialPrx::getD1Async(const D1Ptr& iceP_d1, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<D1Ptr>(false, this, &InitialPrx::_iceI_getD1, iceP_d1, context);
}

std::function<void()>
Test::InitialPrx::getD1Async(const D1Ptr& iceP_d1, std::function<void(::Test::D1Ptr)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<D1Ptr>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_getD1, iceP_d1, context);
}

void
Test::InitialPrx::_iceI_getD1(const std::shared_ptr<IceInternal::OutgoingAsyncT<D1Ptr>>& outAsync, const D1Ptr& iceP_d1, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "getD1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_d1);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            D1Ptr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

void
Test::InitialPrx::throwEDerived(const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_throwEDerived, context).get();
}

std::future<void>
Test::InitialPrx::throwEDerivedAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &InitialPrx::_iceI_throwEDerived, context);
}

std::function<void()>
Test::InitialPrx::throwEDerivedAsync(std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_throwEDerived, context);
}

void
Test::InitialPrx::_iceI_throwEDerived(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "throwEDerived";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        nullptr,
        [](const Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch (const EDerived&)
            {
                throw;
            }
            catch (const Ice::UserException&)
            {
            }
        });
}

void
Test::InitialPrx::setG(const GPtr& iceP_theG, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_setG, iceP_theG, context).get();
}

std::future<void>
Test::InitialPrx::setGAsync(const GPtr& iceP_theG, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &InitialPrx::_iceI_setG, iceP_theG, context);
}

std::function<void()>
Test::InitialPrx::setGAsync(const GPtr& iceP_theG, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_setG, iceP_theG, context);
}

void
Test::InitialPrx::_iceI_setG(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const GPtr& iceP_theG, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "setG";

    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_theG);
            ostr->writePendingValues();
        },
        nullptr);
}

::Test::BaseSeq
Test::InitialPrx::opBaseSeq(const BaseSeq& iceP_inSeq, BaseSeq& iceP_outSeq, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<BaseSeq, BaseSeq>>(true, this, &InitialPrx::_iceI_opBaseSeq, iceP_inSeq, context).get();
    iceP_outSeq = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::BaseSeq, ::Test::BaseSeq>>
Test::InitialPrx::opBaseSeqAsync(const BaseSeq& iceP_inSeq, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<BaseSeq, BaseSeq>>(false, this, &InitialPrx::_iceI_opBaseSeq, iceP_inSeq, context);
}

std::function<void()>
Test::InitialPrx::opBaseSeqAsync(const BaseSeq& iceP_inSeq, std::function<void(::Test::BaseSeq, ::Test::BaseSeq)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<BaseSeq, BaseSeq>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<BaseSeq, BaseSeq>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_opBaseSeq, iceP_inSeq, context);
}

void
Test::InitialPrx::_iceI_opBaseSeq(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<BaseSeq, BaseSeq>>>& outAsync, const BaseSeq& iceP_inSeq, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opBaseSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<BaseSeq, BaseSeq> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::CompactPtr
Test::InitialPrx::getCompact(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<CompactPtr>(true, this, &InitialPrx::_iceI_getCompact, context).get();
}

std::future<::Test::CompactPtr>
Test::InitialPrx::getCompactAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<CompactPtr>(false, this, &InitialPrx::_iceI_getCompact, context);
}

std::function<void()>
Test::InitialPrx::getCompactAsync(std::function<void(::Test::CompactPtr)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<CompactPtr>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_getCompact, context);
}

void
Test::InitialPrx::_iceI_getCompact(const std::shared_ptr<IceInternal::OutgoingAsyncT<CompactPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "getCompact";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            CompactPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::MPtr
Test::InitialPrx::opM(const MPtr& iceP_v1, MPtr& iceP_v2, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<MPtr, MPtr>>(true, this, &InitialPrx::_iceI_opM, iceP_v1, context).get();
    iceP_v2 = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::MPtr, ::Test::MPtr>>
Test::InitialPrx::opMAsync(const MPtr& iceP_v1, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<MPtr, MPtr>>(false, this, &InitialPrx::_iceI_opM, iceP_v1, context);
}

std::function<void()>
Test::InitialPrx::opMAsync(const MPtr& iceP_v1, std::function<void(::Test::MPtr, ::Test::MPtr)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<MPtr, MPtr>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<MPtr, MPtr>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_opM, iceP_v1, context);
}

void
Test::InitialPrx::_iceI_opM(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<MPtr, MPtr>>>& outAsync, const MPtr& iceP_v1, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opM";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_v1);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<MPtr, MPtr> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::F1Ptr
Test::InitialPrx::opF1(const F1Ptr& iceP_f11, F1Ptr& iceP_f12, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<F1Ptr, F1Ptr>>(true, this, &InitialPrx::_iceI_opF1, iceP_f11, context).get();
    iceP_f12 = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::F1Ptr, ::Test::F1Ptr>>
Test::InitialPrx::opF1Async(const F1Ptr& iceP_f11, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<F1Ptr, F1Ptr>>(false, this, &InitialPrx::_iceI_opF1, iceP_f11, context);
}

std::function<void()>
Test::InitialPrx::opF1Async(const F1Ptr& iceP_f11, std::function<void(::Test::F1Ptr, ::Test::F1Ptr)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<F1Ptr, F1Ptr>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<F1Ptr, F1Ptr>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_opF1, iceP_f11, context);
}

void
Test::InitialPrx::_iceI_opF1(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<F1Ptr, F1Ptr>>>& outAsync, const F1Ptr& iceP_f11, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opF1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_f11);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<F1Ptr, F1Ptr> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

std::optional<::Test::F2Prx>
Test::InitialPrx::opF2(const std::optional<F2Prx>& iceP_f21, std::optional<F2Prx>& iceP_f22, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<std::optional<F2Prx>, std::optional<F2Prx>>>(true, this, &InitialPrx::_iceI_opF2, iceP_f21, context).get();
    iceP_f22 = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<std::optional<::Test::F2Prx>, std::optional<::Test::F2Prx>>>
Test::InitialPrx::opF2Async(const std::optional<F2Prx>& iceP_f21, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<std::optional<F2Prx>, std::optional<F2Prx>>>(false, this, &InitialPrx::_iceI_opF2, iceP_f21, context);
}

std::function<void()>
Test::InitialPrx::opF2Async(const std::optional<F2Prx>& iceP_f21, std::function<void(std::optional<::Test::F2Prx>, std::optional<::Test::F2Prx>)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<std::optional<F2Prx>, std::optional<F2Prx>>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<std::optional<F2Prx>, std::optional<F2Prx>>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_opF2, iceP_f21, context);
}

void
Test::InitialPrx::_iceI_opF2(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<std::optional<F2Prx>, std::optional<F2Prx>>>>& outAsync, const std::optional<F2Prx>& iceP_f21, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opF2";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_f21);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<std::optional<F2Prx>, std::optional<F2Prx>> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::F3Ptr
Test::InitialPrx::opF3(const F3Ptr& iceP_f31, F3Ptr& iceP_f32, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<F3Ptr, F3Ptr>>(true, this, &InitialPrx::_iceI_opF3, iceP_f31, context).get();
    iceP_f32 = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::F3Ptr, ::Test::F3Ptr>>
Test::InitialPrx::opF3Async(const F3Ptr& iceP_f31, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<F3Ptr, F3Ptr>>(false, this, &InitialPrx::_iceI_opF3, iceP_f31, context);
}

std::function<void()>
Test::InitialPrx::opF3Async(const F3Ptr& iceP_f31, std::function<void(::Test::F3Ptr, ::Test::F3Ptr)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<F3Ptr, F3Ptr>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<F3Ptr, F3Ptr>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_opF3, iceP_f31, context);
}

void
Test::InitialPrx::_iceI_opF3(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<F3Ptr, F3Ptr>>>& outAsync, const F3Ptr& iceP_f31, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opF3";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_f31);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<F3Ptr, F3Ptr> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

bool
Test::InitialPrx::hasF3(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_hasF3, context).get();
}

std::future<bool>
Test::InitialPrx::hasF3Async(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<bool>(false, this, &InitialPrx::_iceI_hasF3, context);
}

std::function<void()>
Test::InitialPrx::hasF3Async(std::function<void(bool)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<bool>(std::move(response), std::move(exception), std::move(sent), this, &Test::InitialPrx::_iceI_hasF3, context);
}

void
Test::InitialPrx::_iceI_hasF3(const std::shared_ptr<IceInternal::OutgoingAsyncT<bool>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "hasF3";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        nullptr,
        nullptr);
}

Test::InitialPrx::~InitialPrx() = default;

const char*
Test::InitialPrx::ice_staticId() noexcept
{
    return "::Test::Initial";
}

void
Test::S::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "str = ", this->str);
}

std::ostream&
Test::operator<<(std::ostream& os, const ::Test::S& value)
{
    os << "Test::S{";
    value.ice_printFields(os);
    os << '}';
    return os;
}

const char*
Test::Base::ice_staticId() noexcept
{
    return "::Test::Base";
}

const char*
Test::Base::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::Base::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "theS = ", this->theS);
    Ice::print(os << ", str = ", this->str);
}

Ice::ValuePtr
Test::Base::_iceCloneImpl() const
{
    return CloneEnabler<Base>::clone(*this);
}

void
Test::Base::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->theS, this->str);
    ostr->endSlice();
}

void
Test::Base::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->theS, this->str);
    istr->endSlice();
}

const char*
Test::A::ice_staticId() noexcept
{
    return "::Test::A";
}

const char*
Test::A::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::A::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "theB = ", this->theB);
    Ice::print(os << ", theC = ", this->theC);
    Ice::print(os << ", preMarshalInvoked = ", this->preMarshalInvoked);
    Ice::print(os << ", postUnmarshalInvoked = ", this->postUnmarshalInvoked);
}

Ice::ValuePtr
Test::A::_iceCloneImpl() const
{
    return CloneEnabler<A>::clone(*this);
}

void
Test::A::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->theB, this->theC, this->preMarshalInvoked, this->postUnmarshalInvoked);
    ostr->endSlice();
}

void
Test::A::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->theB, this->theC, this->preMarshalInvoked, this->postUnmarshalInvoked);
    istr->endSlice();
}

const char*
Test::B::ice_staticId() noexcept
{
    return "::Test::B";
}

const char*
Test::B::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::B::ice_printFields(std::ostream& os) const
{
    A::ice_printFields(os);
    Ice::print(os << ", theA = ", this->theA);
}

Ice::ValuePtr
Test::B::_iceCloneImpl() const
{
    return CloneEnabler<B>::clone(*this);
}

void
Test::B::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ostr->writeAll(this->theA);
    ostr->endSlice();
    A::_iceWriteImpl(ostr);
}

void
Test::B::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->theA);
    istr->endSlice();
    A::_iceReadImpl(istr);
}

const char*
Test::C::ice_staticId() noexcept
{
    return "::Test::C";
}

const char*
Test::C::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::C::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "theB = ", this->theB);
    Ice::print(os << ", preMarshalInvoked = ", this->preMarshalInvoked);
    Ice::print(os << ", postUnmarshalInvoked = ", this->postUnmarshalInvoked);
}

Ice::ValuePtr
Test::C::_iceCloneImpl() const
{
    return CloneEnabler<C>::clone(*this);
}

void
Test::C::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->theB, this->preMarshalInvoked, this->postUnmarshalInvoked);
    ostr->endSlice();
}

void
Test::C::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->theB, this->preMarshalInvoked, this->postUnmarshalInvoked);
    istr->endSlice();
}

const char*
Test::D::ice_staticId() noexcept
{
    return "::Test::D";
}

const char*
Test::D::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::D::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "theA = ", this->theA);
    Ice::print(os << ", theB = ", this->theB);
    Ice::print(os << ", theC = ", this->theC);
    Ice::print(os << ", preMarshalInvoked = ", this->preMarshalInvoked);
    Ice::print(os << ", postUnmarshalInvoked = ", this->postUnmarshalInvoked);
}

Ice::ValuePtr
Test::D::_iceCloneImpl() const
{
    return CloneEnabler<D>::clone(*this);
}

void
Test::D::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->theA, this->theB, this->theC, this->preMarshalInvoked, this->postUnmarshalInvoked);
    ostr->endSlice();
}

void
Test::D::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->theA, this->theB, this->theC, this->preMarshalInvoked, this->postUnmarshalInvoked);
    istr->endSlice();
}

const char*
Test::G::ice_staticId() noexcept
{
    return "::Test::G";
}

const char*
Test::G::ice_id() const noexcept
{
    return ice_staticId();
}

Ice::ValuePtr
Test::G::_iceCloneImpl() const
{
    return CloneEnabler<G>::clone(*this);
}

void
Test::G::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ostr->endSlice();
    Base::_iceWriteImpl(ostr);
}

void
Test::G::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->endSlice();
    Base::_iceReadImpl(istr);
}

const char*
Test::Compact::ice_staticId() noexcept
{
    return "::Test::Compact";
}

const char*
Test::Compact::ice_id() const noexcept
{
    return ice_staticId();
}

Ice::ValuePtr
Test::Compact::_iceCloneImpl() const
{
    return CloneEnabler<Compact>::clone(*this);
}

void
Test::Compact::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->endSlice();
}

void
Test::Compact::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->endSlice();
}

const char*
Test::CompactExt::ice_staticId() noexcept
{
    return "::Test::CompactExt";
}

const char*
Test::CompactExt::ice_id() const noexcept
{
    return ice_staticId();
}

Ice::ValuePtr
Test::CompactExt::_iceCloneImpl() const
{
    return CloneEnabler<CompactExt>::clone(*this);
}

void
Test::CompactExt::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ostr->endSlice();
    Compact::_iceWriteImpl(ostr);
}

void
Test::CompactExt::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->endSlice();
    Compact::_iceReadImpl(istr);
}

const char*
Test::A1::ice_staticId() noexcept
{
    return "::Test::A1";
}

const char*
Test::A1::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::A1::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "name = ", this->name);
}

Ice::ValuePtr
Test::A1::_iceCloneImpl() const
{
    return CloneEnabler<A1>::clone(*this);
}

void
Test::A1::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->name);
    ostr->endSlice();
}

void
Test::A1::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->name);
    istr->endSlice();
}

const char*
Test::B1::ice_staticId() noexcept
{
    return "::Test::B1";
}

const char*
Test::B1::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::B1::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "a1 = ", this->a1);
    Ice::print(os << ", a2 = ", this->a2);
}

Ice::ValuePtr
Test::B1::_iceCloneImpl() const
{
    return CloneEnabler<B1>::clone(*this);
}

void
Test::B1::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->a1, this->a2);
    ostr->endSlice();
}

void
Test::B1::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->a1, this->a2);
    istr->endSlice();
}

const char*
Test::D1::ice_staticId() noexcept
{
    return "::Test::D1";
}

const char*
Test::D1::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::D1::ice_printFields(std::ostream& os) const
{
    B1::ice_printFields(os);
    Ice::print(os << ", a3 = ", this->a3);
    Ice::print(os << ", a4 = ", this->a4);
}

Ice::ValuePtr
Test::D1::_iceCloneImpl() const
{
    return CloneEnabler<D1>::clone(*this);
}

void
Test::D1::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ostr->writeAll(this->a3, this->a4);
    ostr->endSlice();
    B1::_iceWriteImpl(ostr);
}

void
Test::D1::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->a3, this->a4);
    istr->endSlice();
    B1::_iceReadImpl(istr);
}

void
Test::EBase::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "a1 = ", this->a1);
    Ice::print(os << ", a2 = ", this->a2);
}

const char*
Test::EBase::ice_staticId() noexcept
{
    return "::Test::EBase";
}

const char*
Test::EBase::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::EBase::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
bool
Test::EBase::_usesClasses() const
{
    return true;
}
/// \endcond

void
Test::EBase::_writeImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->a1, this->a2);
    ostr->endSlice();
}

void
Test::EBase::_readImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->a1, this->a2);
    istr->endSlice();
}

void
Test::EDerived::ice_printFields(std::ostream& os) const
{
    EBase::ice_printFields(os);
    Ice::print(os << ", a3 = ", this->a3);
    Ice::print(os << ", a4 = ", this->a4);
}

const char*
Test::EDerived::ice_staticId() noexcept
{
    return "::Test::EDerived";
}

const char*
Test::EDerived::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::EDerived::ice_throw() const
{
    throw *this;
}

void
Test::EDerived::_writeImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ostr->writeAll(this->a3, this->a4);
    ostr->endSlice();
    EBase::_writeImpl(ostr);
}

void
Test::EDerived::_readImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->a3, this->a4);
    istr->endSlice();
    EBase::_readImpl(istr);
}

const char*
Test::Recursive::ice_staticId() noexcept
{
    return "::Test::Recursive";
}

const char*
Test::Recursive::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::Recursive::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "v = ", this->v);
}

Ice::ValuePtr
Test::Recursive::_iceCloneImpl() const
{
    return CloneEnabler<Recursive>::clone(*this);
}

void
Test::Recursive::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->v);
    ostr->endSlice();
}

void
Test::Recursive::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->v);
    istr->endSlice();
}

const char*
Test::K::ice_staticId() noexcept
{
    return "::Test::K";
}

const char*
Test::K::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::K::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "value = ", this->value);
}

Ice::ValuePtr
Test::K::_iceCloneImpl() const
{
    return CloneEnabler<K>::clone(*this);
}

void
Test::K::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->value);
    ostr->endSlice();
}

void
Test::K::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->value);
    istr->endSlice();
}

const char*
Test::L::ice_staticId() noexcept
{
    return "::Test::L";
}

const char*
Test::L::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::L::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "data = ", this->data);
}

Ice::ValuePtr
Test::L::_iceCloneImpl() const
{
    return CloneEnabler<L>::clone(*this);
}

void
Test::L::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->data);
    ostr->endSlice();
}

void
Test::L::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->data);
    istr->endSlice();
}

void
Test::StructKey::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "i = ", this->i);
    Ice::print(os << ", s = ", this->s);
}

std::ostream&
Test::operator<<(std::ostream& os, const ::Test::StructKey& value)
{
    os << "Test::StructKey{";
    value.ice_printFields(os);
    os << '}';
    return os;
}

const char*
Test::M::ice_staticId() noexcept
{
    return "::Test::M";
}

const char*
Test::M::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::M::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "v = ", this->v);
}

Ice::ValuePtr
Test::M::_iceCloneImpl() const
{
    return CloneEnabler<M>::clone(*this);
}

void
Test::M::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->v);
    ostr->endSlice();
}

void
Test::M::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->v);
    istr->endSlice();
}

const char*
Test::F3::ice_staticId() noexcept
{
    return "::Test::F3";
}

const char*
Test::F3::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::F3::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "f1 = ", this->f1);
    Ice::print(os << ", f2 = ", this->f2);
}

Ice::ValuePtr
Test::F3::_iceCloneImpl() const
{
    return CloneEnabler<F3>::clone(*this);
}

void
Test::F3::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->f1, this->f2);
    ostr->endSlice();
}

void
Test::F3::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->f1, this->f2);
    istr->endSlice();
}

std::vector<std::string>
Test::Initial::ice_ids(const Ice::Current&) const
{
    static const std::vector<std::string> allTypeIds = {"::Ice::Object", "::Test::Initial"};
    return allTypeIds;
}

std::string
Test::Initial::ice_id(const Ice::Current&) const
{
    return std::string{ice_staticId()};
}

const char*
Test::Initial::ice_staticId() noexcept
{
    return "::Test::Initial";
}

/// \cond INTERNAL
void
Test::Initial::_iceD_shutdown(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    this->shutdown(request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_getB1(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    const BPtr ret = this->getB1(request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_getB2(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    const BPtr ret = this->getB2(request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_getC(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    const CPtr ret = this->getC(request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_getD(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    const DPtr ret = this->getD(request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_setRecursive(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    RecursivePtr iceP_p;
    istr->readAll(iceP_p);
    istr->readPendingValues();
    istr->endEncapsulation();
    this->setRecursive(std::move(iceP_p), request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_setCycle(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    RecursivePtr iceP_r;
    istr->readAll(iceP_r);
    istr->readPendingValues();
    istr->endEncapsulation();
    this->setCycle(std::move(iceP_r), request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_acceptsClassCycles(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    const bool ret = this->acceptsClassCycles(request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}
/// \endcond

Test::Initial::GetMBMarshaledResult::GetMBMarshaledResult(const BPtr& ret, const Ice::Current& current):
    MarshaledResult(current)
{
    Ice::OutputStream* ostr = &_ostr;
    ostr->startEncapsulation(current.encoding, std::nullopt);
    ostr->writeAll(ret);
    ostr->writePendingValues();
    ostr->endEncapsulation();
}

/// \cond INTERNAL
void
Test::Initial::_iceD_getMB(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    sendResponse(Ice::OutgoingResponse{this->getMB(request.current()).outputStream(), request.current()});
}
/// \endcond

Test::Initial::GetAMDMBMarshaledResult::GetAMDMBMarshaledResult(const BPtr& ret, const Ice::Current& current):
    MarshaledResult(current)
{
    Ice::OutputStream* ostr = &_ostr;
    ostr->startEncapsulation(current.encoding, std::nullopt);
    ostr->writeAll(ret);
    ostr->writePendingValues();
    ostr->endEncapsulation();
}

/// \cond INTERNAL
void
Test::Initial::_iceD_getAMDMB(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    try
    {
        this->getAMDMBAsync([responseHandler](GetAMDMBMarshaledResult marshaledResult) { responseHandler->sendResponse(std::move(marshaledResult)); }, [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_getAll(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    BPtr iceP_b1;
    BPtr iceP_b2;
    CPtr iceP_theC;
    DPtr iceP_theD;
    this->getAll(iceP_b1, iceP_b2, iceP_theC, iceP_theD, request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_b1, iceP_b2, iceP_theC, iceP_theD);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_getK(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    const KPtr ret = this->getK(request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_opValue(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    Ice::ValuePtr iceP_v1;
    istr->readAll(iceP_v1);
    istr->readPendingValues();
    istr->endEncapsulation();
    Ice::ValuePtr iceP_v2;
    const Ice::ValuePtr ret = this->opValue(std::move(iceP_v1), iceP_v2, request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_v2, ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_opValueSeq(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ValueSeq iceP_v1;
    istr->readAll(iceP_v1);
    istr->readPendingValues();
    istr->endEncapsulation();
    ValueSeq iceP_v2;
    const ValueSeq ret = this->opValueSeq(std::move(iceP_v1), iceP_v2, request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_v2, ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_opValueMap(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ValueMap iceP_v1;
    istr->readAll(iceP_v1);
    istr->readPendingValues();
    istr->endEncapsulation();
    ValueMap iceP_v2;
    const ValueMap ret = this->opValueMap(std::move(iceP_v1), iceP_v2, request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_v2, ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_getD1(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    D1Ptr iceP_d1;
    istr->readAll(iceP_d1);
    istr->readPendingValues();
    istr->endEncapsulation();
    const D1Ptr ret = this->getD1(std::move(iceP_d1), request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_throwEDerived(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    this->throwEDerived(request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_setG(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    GPtr iceP_theG;
    istr->readAll(iceP_theG);
    istr->readPendingValues();
    istr->endEncapsulation();
    this->setG(std::move(iceP_theG), request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_opBaseSeq(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    BaseSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    istr->endEncapsulation();
    BaseSeq iceP_outSeq;
    const BaseSeq ret = this->opBaseSeq(std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_getCompact(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    const CompactPtr ret = this->getCompact(request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_opM(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    MPtr iceP_v1;
    istr->readAll(iceP_v1);
    istr->readPendingValues();
    istr->endEncapsulation();
    MPtr iceP_v2;
    const MPtr ret = this->opM(std::move(iceP_v1), iceP_v2, request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_v2, ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_opF1(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    F1Ptr iceP_f11;
    istr->readAll(iceP_f11);
    istr->readPendingValues();
    istr->endEncapsulation();
    F1Ptr iceP_f12;
    const F1Ptr ret = this->opF1(std::move(iceP_f11), iceP_f12, request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_f12, ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_opF2(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::optional<F2Prx> iceP_f21;
    istr->readAll(iceP_f21);
    istr->endEncapsulation();
    std::optional<F2Prx> iceP_f22;
    const std::optional<F2Prx> ret = this->opF2(std::move(iceP_f21), iceP_f22, request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_f22, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_opF3(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    F3Ptr iceP_f31;
    istr->readAll(iceP_f31);
    istr->readPendingValues();
    istr->endEncapsulation();
    F3Ptr iceP_f32;
    const F3Ptr ret = this->opF3(std::move(iceP_f31), iceP_f32, request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_f32, ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::Initial::_iceD_hasF3(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    const bool ret = this->hasF3(request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}
/// \endcond

void
Test::Initial::dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    static constexpr std::array<std::string_view, 29> allOperations{"acceptsClassCycles", "getAMDMB", "getAll", "getB1", "getB2", "getC", "getCompact", "getD", "getD1", "getK", "getMB", "hasF3", "ice_id", "ice_ids", "ice_isA", "ice_ping", "opBaseSeq", "opF1", "opF2", "opF3", "opM", "opValue", "opValueMap", "opValueSeq", "setCycle", "setG", "setRecursive", "shutdown", "throwEDerived"};

    const Ice::Current& current = request.current();
    auto r = std::equal_range(allOperations.begin(), allOperations.end(), current.operation);
    if (r.first == r.second)
    {
        sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch (r.first - allOperations.begin())
    {
        case 0:
        {
            _iceD_acceptsClassCycles(request, std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_getAMDMB(request, std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_getAll(request, std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_getB1(request, std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_getB2(request, std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_getC(request, std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_getCompact(request, std::move(sendResponse));
            break;
        }
        case 7:
        {
            _iceD_getD(request, std::move(sendResponse));
            break;
        }
        case 8:
        {
            _iceD_getD1(request, std::move(sendResponse));
            break;
        }
        case 9:
        {
            _iceD_getK(request, std::move(sendResponse));
            break;
        }
        case 10:
        {
            _iceD_getMB(request, std::move(sendResponse));
            break;
        }
        case 11:
        {
            _iceD_hasF3(request, std::move(sendResponse));
            break;
        }
        case 12:
        {
            _iceD_ice_id(request, std::move(sendResponse));
            break;
        }
        case 13:
        {
            _iceD_ice_ids(request, std::move(sendResponse));
            break;
        }
        case 14:
        {
            _iceD_ice_isA(request, std::move(sendResponse));
            break;
        }
        case 15:
        {
            _iceD_ice_ping(request, std::move(sendResponse));
            break;
        }
        case 16:
        {
            _iceD_opBaseSeq(request, std::move(sendResponse));
            break;
        }
        case 17:
        {
            _iceD_opF1(request, std::move(sendResponse));
            break;
        }
        case 18:
        {
            _iceD_opF2(request, std::move(sendResponse));
            break;
        }
        case 19:
        {
            _iceD_opF3(request, std::move(sendResponse));
            break;
        }
        case 20:
        {
            _iceD_opM(request, std::move(sendResponse));
            break;
        }
        case 21:
        {
            _iceD_opValue(request, std::move(sendResponse));
            break;
        }
        case 22:
        {
            _iceD_opValueMap(request, std::move(sendResponse));
            break;
        }
        case 23:
        {
            _iceD_opValueSeq(request, std::move(sendResponse));
            break;
        }
        case 24:
        {
            _iceD_setCycle(request, std::move(sendResponse));
            break;
        }
        case 25:
        {
            _iceD_setG(request, std::move(sendResponse));
            break;
        }
        case 26:
        {
            _iceD_setRecursive(request, std::move(sendResponse));
            break;
        }
        case 27:
        {
            _iceD_shutdown(request, std::move(sendResponse));
            break;
        }
        case 28:
        {
            _iceD_throwEDerived(request, std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}
