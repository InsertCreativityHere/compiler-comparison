# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `HashTest.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'

module ::Test

    if not defined?(::Test::BaseException)
        class BaseException < Ice::UserException
            def initialize
            end

            def to_s
                '::Test::BaseException'
            end
        end

        T_BaseException = ::Ice::__defineException('::Test::BaseException', BaseException, false, nil, [])
    end

    if not defined?(::Test::InvalidPointException)
        class InvalidPointException < ::Test::BaseException
            def initialize(index=0)
                @index = index
            end

            def to_s
                '::Test::InvalidPointException'
            end

            attr_accessor :index
        end

        T_InvalidPointException = ::Ice::__defineException('::Test::InvalidPointException', InvalidPointException, false, ::Test::T_BaseException, [["index", ::Ice::T_int, false, 0]])
    end

    if not defined?(::Test::InvalidLengthException)
        class InvalidLengthException < ::Test::BaseException
            def initialize(length=0)
                @length = length
            end

            def to_s
                '::Test::InvalidLengthException'
            end

            attr_accessor :length
        end

        T_InvalidLengthException = ::Ice::__defineException('::Test::InvalidLengthException', InvalidLengthException, false, ::Test::T_BaseException, [["length", ::Ice::T_int, false, 0]])
    end

    if not defined?(::Test::OtherException)
        class OtherException < Ice::UserException
            def initialize(x=0, y=0, z=0, b=false)
                @x = x
                @y = y
                @z = z
                @b = b
            end

            def to_s
                '::Test::OtherException'
            end

            attr_accessor :x, :y, :z, :b
        end

        T_OtherException = ::Ice::__defineException('::Test::OtherException', OtherException, false, nil, [
            ["x", ::Ice::T_int, false, 0],
            ["y", ::Ice::T_int, false, 0],
            ["z", ::Ice::T_int, false, 0],
            ["b", ::Ice::T_bool, false, 0]
        ])
    end

    if not defined?(::Test::PointF)
        class PointF
            include ::Ice::Inspect_mixin
            def initialize(x=0.0, y=0.0, z=0.0)
                @x = x
                @y = y
                @z = z
            end

            def hash
                _h = 0
                _h = 5 * _h + @x.hash
                _h = 5 * _h + @y.hash
                _h = 5 * _h + @z.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::PointF or
                    @x != other.x or
                    @y != other.y or
                    @z != other.z
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :x, :y, :z
        end

        T_PointF = ::Ice::__defineStruct('::Test::PointF', PointF, [
            ["x", ::Ice::T_float],
            ["y", ::Ice::T_float],
            ["z", ::Ice::T_float]
        ])
    end

    if not defined?(::Test::PointD)
        class PointD
            include ::Ice::Inspect_mixin
            def initialize(x=0.0, y=0.0, z=0.0)
                @x = x
                @y = y
                @z = z
            end

            def hash
                _h = 0
                _h = 5 * _h + @x.hash
                _h = 5 * _h + @y.hash
                _h = 5 * _h + @z.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::PointD or
                    @x != other.x or
                    @y != other.y or
                    @z != other.z
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :x, :y, :z
        end

        T_PointD = ::Ice::__defineStruct('::Test::PointD', PointD, [
            ["x", ::Ice::T_double],
            ["y", ::Ice::T_double],
            ["z", ::Ice::T_double]
        ])
    end

    if not defined?(::Test::Point)
        class Point
            include ::Ice::Inspect_mixin
            def initialize(x=0, y=0)
                @x = x
                @y = y
            end

            def hash
                _h = 0
                _h = 5 * _h + @x.hash
                _h = 5 * _h + @y.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::Point or
                    @x != other.x or
                    @y != other.y
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :x, :y
        end

        T_Point = ::Ice::__defineStruct('::Test::Point', Point, [
            ["x", ::Ice::T_int],
            ["y", ::Ice::T_int]
        ])
    end

    if not defined?(::Test::T_Points)
        T_Points = ::Ice::__defineSequence('::Test::Points', ::Test::T_Point)
    end

    if not defined?(::Test::Polyline)
        class Polyline
            include ::Ice::Inspect_mixin
            def initialize(vertices=nil)
                @vertices = vertices
            end

            def hash
                _h = 0
                _h = 5 * _h + @vertices.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::Polyline or
                    @vertices != other.vertices
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :vertices
        end

        T_Polyline = ::Ice::__defineStruct('::Test::Polyline', Polyline, [["vertices", ::Test::T_Points]])
    end

    if not defined?(::Test::Color)
        class Color
            include ::Ice::Inspect_mixin
            def initialize(r=0, g=0, b=0, a=0)
                @r = r
                @g = g
                @b = b
                @a = a
            end

            def hash
                _h = 0
                _h = 5 * _h + @r.hash
                _h = 5 * _h + @g.hash
                _h = 5 * _h + @b.hash
                _h = 5 * _h + @a.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::Color or
                    @r != other.r or
                    @g != other.g or
                    @b != other.b or
                    @a != other.a
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :r, :g, :b, :a
        end

        T_Color = ::Ice::__defineStruct('::Test::Color', Color, [
            ["r", ::Ice::T_int],
            ["g", ::Ice::T_int],
            ["b", ::Ice::T_int],
            ["a", ::Ice::T_int]
        ])
    end

    if not defined?(::Test::T_StringColorMap)
        T_StringColorMap = ::Ice::__defineDictionary('::Test::StringColorMap', ::Ice::T_int, ::Test::T_Color)
    end

    if not defined?(::Test::ColorPalette)
        class ColorPalette
            include ::Ice::Inspect_mixin
            def initialize(colors=nil)
                @colors = colors
            end

            def hash
                _h = 0
                _h = 5 * _h + @colors.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::ColorPalette or
                    @colors != other.colors
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :colors
        end

        T_ColorPalette = ::Ice::__defineStruct('::Test::ColorPalette', ColorPalette, [["colors", ::Test::T_StringColorMap]])
    end

    if not defined?(::Test::Pen_Mixin)

        module ::Test::Pen_Mixin
        end
        class Pen < ::Ice::Value

            def initialize(thickness=0, color=::Test::Color.new)
                @thickness = thickness
                @color = color
            end

            attr_accessor :thickness, :color
        end

        if not defined?(::Test::T_Pen)
            T_Pen = ::Ice::__declareClass('::Test::Pen')
        end

        T_Pen.defineClass(Pen, -1, false, false, nil, [
            ['thickness', ::Ice::T_int, false, 0],
            ['color', ::Test::T_Color, false, 0]
        ])
    end

    if not defined?(::Test::Draw)
        class Draw
            include ::Ice::Inspect_mixin
            def initialize(backgroundColor=::Test::Color.new, pen=nil, shared=false)
                @backgroundColor = backgroundColor
                @pen = pen
                @shared = shared
            end

            def hash
                _h = 0
                _h = 5 * _h + @backgroundColor.hash
                _h = 5 * _h + @pen.hash
                _h = 5 * _h + @shared.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::Draw or
                    @backgroundColor != other.backgroundColor or
                    @pen != other.pen or
                    @shared != other.shared
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :backgroundColor, :pen, :shared
        end

        T_Draw = ::Ice::__defineStruct('::Test::Draw', Draw, [
            ["backgroundColor", ::Test::T_Color],
            ["pen", ::Test::T_Pen],
            ["shared", ::Ice::T_bool]
        ])
    end
end
