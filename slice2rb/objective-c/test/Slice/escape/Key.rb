# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.9
#
# <auto-generated>
#
# Generated from file `Key.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'

module ::And

    if not defined?(::And::Continue)
        class Continue
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def Continue.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(Continue) or raise ArgumentError, "value must be a Continue"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def Continue.each(&block)
                @@_enumerators.each_value(&block)
            end

            Asm = Continue.new("asm", 0)

            @@_enumerators = {0=>Asm}

            def Continue._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_Continue = ::Ice::__defineEnum('::and::continue', Continue, Continue::_enumerators)
    end

    if not defined?(::And::Auto)
        class Auto
            include ::Ice::Inspect_mixin
            def initialize(default=0)
                @default = default
            end

            def hash
                _h = 0
                _h = 5 * _h + @default.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::And::Auto or
                    @default != other.default
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :default
        end

        T_Auto = ::Ice::__defineStruct('::and::auto', Auto, [["default", ::Ice::T_int]])
    end

    if not defined?(::And::Delete)
        class Delete
            include ::Ice::Inspect_mixin
            def initialize(_else='')
                @_else = _else
            end

            def hash
                _h = 0
                _h = 5 * _h + @_else.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::And::Delete or
                    @_else != other._else
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :_else
        end

        T_Delete = ::Ice::__defineStruct('::and::delete', Delete, [["_else", ::Ice::T_string]])
    end

    if not defined?(::And::Break_Mixin)

        module ::And::Break_Mixin
        end
        module BreakPrx_mixin

            def _case(catch, context=nil)
                BreakPrx_mixin::OP_case.invoke(self, [catch], context)
            end
        end

        class BreakPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include BreakPrx_mixin
        end

        if not defined?(::And::T_BreakPrx)
            T_Break = ::Ice::__declareClass('::and::break')
            T_BreakPrx = ::Ice::__declareProxy('::and::break')
        end

        T_Break.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_BreakPrx.defineProxy(BreakPrx, nil, [])

        BreakPrx_mixin::OP_case = ::Ice::__defineOperation('case', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, false, 0]], [[::Ice::T_int, false, 0]], nil, [])
    end

    if not defined?(::And::Char_Mixin)

        module ::And::Char_Mixin
        end
        module CharPrx_mixin

            def explicit(context=nil)
                CharPrx_mixin::OP_explicit.invoke(self, [], context)
            end
        end

        class CharPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include CharPrx_mixin
        end

        if not defined?(::And::T_CharPrx)
            T_Char = ::Ice::__declareClass('::and::char')
            T_CharPrx = ::Ice::__declareProxy('::and::char')
        end

        T_Char.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_CharPrx.defineProxy(CharPrx, nil, [])

        CharPrx_mixin::OP_explicit = ::Ice::__defineOperation('explicit', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
    end

    if not defined?(::And::Switch_Mixin)

        module ::And::Switch_Mixin
        end
        module SwitchPrx_mixin

            def foo(export, context=nil)
                SwitchPrx_mixin::OP_foo.invoke(self, [export], context)
            end

            def foo2(export, yES, context=nil)
                SwitchPrx_mixin::OP_foo2.invoke(self, [export, yES], context)
            end

            def foo3(export, context=nil)
                SwitchPrx_mixin::OP_foo3.invoke(self, [export], context)
            end
        end

        class SwitchPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include SwitchPrx_mixin
        end

        if not defined?(::And::T_SwitchPrx)
            T_Switch = ::Ice::__declareClass('::and::switch')
            T_SwitchPrx = ::Ice::__declareProxy('::and::switch')
        end

        T_Switch.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_SwitchPrx.defineProxy(SwitchPrx, nil, [])

        SwitchPrx_mixin::OP_foo = ::Ice::__defineOperation('foo', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::And::T_CharPrx, false, 0]], [[::Ice::T_int, false, 0]], nil, [])
        SwitchPrx_mixin::OP_foo2 = ::Ice::__defineOperation('foo2', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::And::T_CharPrx, false, 0], [::Ice::T_int, false, 0]], [[::Ice::T_int, false, 0]], nil, [])
        SwitchPrx_mixin::OP_foo3 = ::Ice::__defineOperation('foo3', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::And::T_CharPrx, false, 0]], [[::Ice::T_int, false, 0]], nil, [])
    end

    if not defined?(::And::Do_Mixin)

        module ::And::Do_Mixin
        end
        class Do < ::Ice::Value

            def initialize(_if=0)
                @_if = _if
            end

            attr_accessor :_if
        end
        module DoPrx_mixin
            include ::And::CharPrx_mixin
            include ::And::BreakPrx_mixin
            include ::And::SwitchPrx_mixin
        end

        class DoPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include DoPrx_mixin
        end

        if not defined?(::And::T_Do)
            T_Do = ::Ice::__declareClass('::and::do')
            T_DoPrx = ::Ice::__declareProxy('::and::do')
        end

        T_Do.defineClass(Do, -1, false, false, nil, [['_if', ::Ice::T_int, false, 0]])

        T_DoPrx.defineProxy(DoPrx, nil, [::And::T_CharPrx, ::And::T_BreakPrx, ::And::T_SwitchPrx])
    end

    if not defined?(::And::T_Extern)
        T_Extern = ::Ice::__defineSequence('::and::extern', ::And::T_Auto)
    end

    if not defined?(::And::T_For)
        T_For = ::Ice::__defineDictionary('::and::for', ::Ice::T_string, ::And::T_Auto)
    end

    if not defined?(::And::Return)
        class Return < Ice::UserException
            def initialize(signed=0)
                @signed = signed
            end

            def to_s
                '::and::return'
            end

            attr_accessor :signed
        end

        T_Return = ::Ice::__defineException('::and::return', Return, false, nil, [["signed", ::Ice::T_int, false, 0]])
    end

    if not defined?(::And::Sizeof)
        class Sizeof < ::And::Return
            def initialize(signed=0, static=0, switch=0)
                super(signed)
                @static = static
                @switch = switch
            end

            def to_s
                '::and::sizeof'
            end

            attr_accessor :static, :switch
        end

        T_Sizeof = ::Ice::__defineException('::and::sizeof', Sizeof, false, ::And::T_Return, [
            ["static", ::Ice::T_int, false, 0],
            ["switch", ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::And::T_Friend)
        T_Friend = ::Ice::__declareLocalClass('::and::friend')
    end

    Template = 0

    This = 0

    Throw = 0

    Typedef = 0

    Typeid = 0

    Typename = 0

    Union = 0

    Unsigned = 0

    Using = 0

    Virtual = 0

    While = 0

    Xor = 0
end
