# encoding: utf-8
# Copyright (c) ZeroC, Inc.
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file 'Test.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>

require 'Ice'

module ::Test

    if not defined?(::Test::Color)
        class Color
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def Color.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(Color) or raise ArgumentError, "value must be a Color"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def Color.each(&block)
                @@_enumerators.each_value(&block)
            end

            Red = Color.new("red", 0)
            Green = Color.new("green", 1)
            Blue = Color.new("blue", 2)

            @@_enumerators = {0=>Red, 1=>Green, 2=>Blue}

            def Color._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_Color = ::Ice::__defineEnum('::Test::Color', Color, Color::_enumerators)
    end

    module Nested

        if not defined?(::Test::Nested::Color)
            class Color
                include Comparable

                def initialize(name, value)
                    @name = name
                    @value = value
                end

                def Color.from_int(val)
                    @@_enumerators[val]
                end

                def to_s
                    @name
                end

                def to_i
                    @value
                end

                def <=>(other)
                    other.is_a?(Color) or raise ArgumentError, "value must be a Color"
                    @value <=> other.to_i
                end

                def hash
                    @value.hash
                end

                def Color.each(&block)
                    @@_enumerators.each_value(&block)
                end

                Red = Color.new("red", 0)
                Green = Color.new("green", 1)
                Blue = Color.new("blue", 2)

                @@_enumerators = {0=>Red, 1=>Green, 2=>Blue}

                def Color._enumerators
                    @@_enumerators
                end

                private_class_method :new
            end

            T_Color = ::Ice::__defineEnum('::Test::Nested::Color', Color, Color::_enumerators)
        end
    end

    if not defined?(::Test::Struct1)
        class Struct1
            include ::Ice::Inspect_mixin
            def initialize(boolFalse=false, boolTrue=true, b=254, s=16000, i=3, l=4, f=5.1, d=6.2, str="foo\s\\\s\"bar\n\s\r\n\t\v\f\a\b?\s\a\s\a", c1=::Test::Color::Red, c2=::Test::Color::Green, c3=::Test::Color::Blue, nc1=::Test::Nested::Color::Red, nc2=::Test::Nested::Color::Green, nc3=::Test::Nested::Color::Blue, noDefault='', zeroI=0, zeroL=0, zeroF=0, zeroDotF=0, zeroD=0, zeroDotD=0)
                @boolFalse = boolFalse
                @boolTrue = boolTrue
                @b = b
                @s = s
                @i = i
                @l = l
                @f = f
                @d = d
                @str = str
                @c1 = c1
                @c2 = c2
                @c3 = c3
                @nc1 = nc1
                @nc2 = nc2
                @nc3 = nc3
                @noDefault = noDefault
                @zeroI = zeroI
                @zeroL = zeroL
                @zeroF = zeroF
                @zeroDotF = zeroDotF
                @zeroD = zeroD
                @zeroDotD = zeroDotD
            end

            def hash
                _h = 0
                _h = 5 * _h + @boolFalse.hash
                _h = 5 * _h + @boolTrue.hash
                _h = 5 * _h + @b.hash
                _h = 5 * _h + @s.hash
                _h = 5 * _h + @i.hash
                _h = 5 * _h + @l.hash
                _h = 5 * _h + @f.hash
                _h = 5 * _h + @d.hash
                _h = 5 * _h + @str.hash
                _h = 5 * _h + @c1.hash
                _h = 5 * _h + @c2.hash
                _h = 5 * _h + @c3.hash
                _h = 5 * _h + @nc1.hash
                _h = 5 * _h + @nc2.hash
                _h = 5 * _h + @nc3.hash
                _h = 5 * _h + @noDefault.hash
                _h = 5 * _h + @zeroI.hash
                _h = 5 * _h + @zeroL.hash
                _h = 5 * _h + @zeroF.hash
                _h = 5 * _h + @zeroDotF.hash
                _h = 5 * _h + @zeroD.hash
                _h = 5 * _h + @zeroDotD.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::Struct1 or
                    @boolFalse != other.boolFalse or
                    @boolTrue != other.boolTrue or
                    @b != other.b or
                    @s != other.s or
                    @i != other.i or
                    @l != other.l or
                    @f != other.f or
                    @d != other.d or
                    @str != other.str or
                    @c1 != other.c1 or
                    @c2 != other.c2 or
                    @c3 != other.c3 or
                    @nc1 != other.nc1 or
                    @nc2 != other.nc2 or
                    @nc3 != other.nc3 or
                    @noDefault != other.noDefault or
                    @zeroI != other.zeroI or
                    @zeroL != other.zeroL or
                    @zeroF != other.zeroF or
                    @zeroDotF != other.zeroDotF or
                    @zeroD != other.zeroD or
                    @zeroDotD != other.zeroDotD
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :boolFalse, :boolTrue, :b, :s, :i, :l, :f, :d, :str, :c1, :c2, :c3, :nc1, :nc2, :nc3, :noDefault, :zeroI, :zeroL, :zeroF, :zeroDotF, :zeroD, :zeroDotD
        end

        T_Struct1 = ::Ice::__defineStruct('::Test::Struct1', Struct1, [
            ["boolFalse", ::Ice::T_bool],
            ["boolTrue", ::Ice::T_bool],
            ["b", ::Ice::T_byte],
            ["s", ::Ice::T_short],
            ["i", ::Ice::T_int],
            ["l", ::Ice::T_long],
            ["f", ::Ice::T_float],
            ["d", ::Ice::T_double],
            ["str", ::Ice::T_string],
            ["c1", ::Test::T_Color],
            ["c2", ::Test::T_Color],
            ["c3", ::Test::T_Color],
            ["nc1", ::Test::Nested::T_Color],
            ["nc2", ::Test::Nested::T_Color],
            ["nc3", ::Test::Nested::T_Color],
            ["noDefault", ::Ice::T_string],
            ["zeroI", ::Ice::T_int],
            ["zeroL", ::Ice::T_long],
            ["zeroF", ::Ice::T_float],
            ["zeroDotF", ::Ice::T_float],
            ["zeroD", ::Ice::T_double],
            ["zeroDotD", ::Ice::T_double]
        ])
    end

    ConstBool = true

    ConstByte = 254

    ConstShort = 16000

    ConstInt = 3

    ConstLong = 4

    ConstFloat = 5.1

    ConstDouble = 6.2

    ConstString = "foo\s\\\s\"bar\n\s\r\n\t\v\f\a\b?\s\a\s\a"

    ConstColor1 = ::Test::Color::Red

    ConstColor2 = ::Test::Color::Green

    ConstColor3 = ::Test::Color::Blue

    ConstNestedColor1 = ::Test::Nested::Color::Red

    ConstNestedColor2 = ::Test::Nested::Color::Green

    ConstNestedColor3 = ::Test::Nested::Color::Blue

    ConstZeroI = 0

    ConstZeroL = 0

    ConstZeroF = 0

    ConstZeroDotF = 0

    ConstZeroD = 0

    ConstZeroDotD = 0

    if not defined?(::Test::Struct2)
        class Struct2
            include ::Ice::Inspect_mixin
            def initialize(boolTrue=::Test::ConstBool, b=::Test::ConstByte, s=::Test::ConstShort, i=::Test::ConstInt, l=::Test::ConstLong, f=::Test::ConstFloat, d=::Test::ConstDouble, str=::Test::ConstString, c1=::Test::ConstColor1, c2=::Test::ConstColor2, c3=::Test::ConstColor3, nc1=::Test::ConstNestedColor1, nc2=::Test::ConstNestedColor2, nc3=::Test::ConstNestedColor3, zeroI=::Test::ConstZeroI, zeroL=::Test::ConstZeroL, zeroF=::Test::ConstZeroF, zeroDotF=::Test::ConstZeroDotF, zeroD=::Test::ConstZeroD, zeroDotD=::Test::ConstZeroDotD)
                @boolTrue = boolTrue
                @b = b
                @s = s
                @i = i
                @l = l
                @f = f
                @d = d
                @str = str
                @c1 = c1
                @c2 = c2
                @c3 = c3
                @nc1 = nc1
                @nc2 = nc2
                @nc3 = nc3
                @zeroI = zeroI
                @zeroL = zeroL
                @zeroF = zeroF
                @zeroDotF = zeroDotF
                @zeroD = zeroD
                @zeroDotD = zeroDotD
            end

            def hash
                _h = 0
                _h = 5 * _h + @boolTrue.hash
                _h = 5 * _h + @b.hash
                _h = 5 * _h + @s.hash
                _h = 5 * _h + @i.hash
                _h = 5 * _h + @l.hash
                _h = 5 * _h + @f.hash
                _h = 5 * _h + @d.hash
                _h = 5 * _h + @str.hash
                _h = 5 * _h + @c1.hash
                _h = 5 * _h + @c2.hash
                _h = 5 * _h + @c3.hash
                _h = 5 * _h + @nc1.hash
                _h = 5 * _h + @nc2.hash
                _h = 5 * _h + @nc3.hash
                _h = 5 * _h + @zeroI.hash
                _h = 5 * _h + @zeroL.hash
                _h = 5 * _h + @zeroF.hash
                _h = 5 * _h + @zeroDotF.hash
                _h = 5 * _h + @zeroD.hash
                _h = 5 * _h + @zeroDotD.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::Struct2 or
                    @boolTrue != other.boolTrue or
                    @b != other.b or
                    @s != other.s or
                    @i != other.i or
                    @l != other.l or
                    @f != other.f or
                    @d != other.d or
                    @str != other.str or
                    @c1 != other.c1 or
                    @c2 != other.c2 or
                    @c3 != other.c3 or
                    @nc1 != other.nc1 or
                    @nc2 != other.nc2 or
                    @nc3 != other.nc3 or
                    @zeroI != other.zeroI or
                    @zeroL != other.zeroL or
                    @zeroF != other.zeroF or
                    @zeroDotF != other.zeroDotF or
                    @zeroD != other.zeroD or
                    @zeroDotD != other.zeroDotD
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :boolTrue, :b, :s, :i, :l, :f, :d, :str, :c1, :c2, :c3, :nc1, :nc2, :nc3, :zeroI, :zeroL, :zeroF, :zeroDotF, :zeroD, :zeroDotD
        end

        T_Struct2 = ::Ice::__defineStruct('::Test::Struct2', Struct2, [
            ["boolTrue", ::Ice::T_bool],
            ["b", ::Ice::T_byte],
            ["s", ::Ice::T_short],
            ["i", ::Ice::T_int],
            ["l", ::Ice::T_long],
            ["f", ::Ice::T_float],
            ["d", ::Ice::T_double],
            ["str", ::Ice::T_string],
            ["c1", ::Test::T_Color],
            ["c2", ::Test::T_Color],
            ["c3", ::Test::T_Color],
            ["nc1", ::Test::Nested::T_Color],
            ["nc2", ::Test::Nested::T_Color],
            ["nc3", ::Test::Nested::T_Color],
            ["zeroI", ::Ice::T_int],
            ["zeroL", ::Ice::T_long],
            ["zeroF", ::Ice::T_float],
            ["zeroDotF", ::Ice::T_float],
            ["zeroD", ::Ice::T_double],
            ["zeroDotD", ::Ice::T_double]
        ])
    end

    if not defined?(::Test::T_Base)
        T_Base = ::Ice::__declareClass('::Test::Base')
    end

    if not defined?(::Test::Base)
        class Base < ::Ice::Value

            def initialize(boolFalse=false, boolTrue=true, b=1, s=2, i=3, l=4, f=5.1, d=6.2, str="foo\s\\\s\"bar\n\s\r\n\t\v\f\a\b?\s\a\s\a", noDefault='', zeroI=0, zeroL=0, zeroF=0, zeroDotF=0, zeroD=0, zeroDotD=0)
                @boolFalse = boolFalse
                @boolTrue = boolTrue
                @b = b
                @s = s
                @i = i
                @l = l
                @f = f
                @d = d
                @str = str
                @noDefault = noDefault
                @zeroI = zeroI
                @zeroL = zeroL
                @zeroF = zeroF
                @zeroDotF = zeroDotF
                @zeroD = zeroD
                @zeroDotD = zeroDotD
            end

            attr_accessor :boolFalse, :boolTrue, :b, :s, :i, :l, :f, :d, :str, :noDefault, :zeroI, :zeroL, :zeroF, :zeroDotF, :zeroD, :zeroDotD
        end

        T_Base.defineClass(Base, -1, false, nil, [
            ['boolFalse', ::Ice::T_bool, false, 0],
            ['boolTrue', ::Ice::T_bool, false, 0],
            ['b', ::Ice::T_byte, false, 0],
            ['s', ::Ice::T_short, false, 0],
            ['i', ::Ice::T_int, false, 0],
            ['l', ::Ice::T_long, false, 0],
            ['f', ::Ice::T_float, false, 0],
            ['d', ::Ice::T_double, false, 0],
            ['str', ::Ice::T_string, false, 0],
            ['noDefault', ::Ice::T_string, false, 0],
            ['zeroI', ::Ice::T_int, false, 0],
            ['zeroL', ::Ice::T_long, false, 0],
            ['zeroF', ::Ice::T_float, false, 0],
            ['zeroDotF', ::Ice::T_float, false, 0],
            ['zeroD', ::Ice::T_double, false, 0],
            ['zeroDotD', ::Ice::T_double, false, 0]
        ])
    end

    if not defined?(::Test::T_Derived)
        T_Derived = ::Ice::__declareClass('::Test::Derived')
    end

    if not defined?(::Test::Derived)
        class Derived < ::Test::Base

            def initialize(boolFalse=false, boolTrue=true, b=1, s=2, i=3, l=4, f=5.1, d=6.2, str="foo\s\\\s\"bar\n\s\r\n\t\v\f\a\b?\s\a\s\a", noDefault='', zeroI=0, zeroL=0, zeroF=0, zeroDotF=0, zeroD=0, zeroDotD=0, c1=::Test::Color::Red, c2=::Test::Color::Green, c3=::Test::Color::Blue, nc1=::Test::Nested::Color::Red, nc2=::Test::Nested::Color::Green, nc3=::Test::Nested::Color::Blue)
                super(boolFalse, boolTrue, b, s, i, l, f, d, str, noDefault, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD)
                @c1 = c1
                @c2 = c2
                @c3 = c3
                @nc1 = nc1
                @nc2 = nc2
                @nc3 = nc3
            end

            attr_accessor :c1, :c2, :c3, :nc1, :nc2, :nc3
        end

        T_Derived.defineClass(Derived, -1, false, ::Test::T_Base, [
            ['c1', ::Test::T_Color, false, 0],
            ['c2', ::Test::T_Color, false, 0],
            ['c3', ::Test::T_Color, false, 0],
            ['nc1', ::Test::Nested::T_Color, false, 0],
            ['nc2', ::Test::Nested::T_Color, false, 0],
            ['nc3', ::Test::Nested::T_Color, false, 0]
        ])
    end

    if not defined?(::Test::BaseEx)
        class BaseEx < Ice::UserException
            def to_s
                '::Test::BaseEx'
            end

            attr_accessor :boolFalse, :boolTrue, :b, :s, :i, :l, :f, :d, :str, :noDefault, :zeroI, :zeroL, :zeroF, :zeroDotF, :zeroD, :zeroDotD
        end

        T_BaseEx = ::Ice::__defineException('::Test::BaseEx', BaseEx, nil, [
            ["boolFalse", ::Ice::T_bool, false, 0],
            ["boolTrue", ::Ice::T_bool, false, 0],
            ["b", ::Ice::T_byte, false, 0],
            ["s", ::Ice::T_short, false, 0],
            ["i", ::Ice::T_int, false, 0],
            ["l", ::Ice::T_long, false, 0],
            ["f", ::Ice::T_float, false, 0],
            ["d", ::Ice::T_double, false, 0],
            ["str", ::Ice::T_string, false, 0],
            ["noDefault", ::Ice::T_string, false, 0],
            ["zeroI", ::Ice::T_int, false, 0],
            ["zeroL", ::Ice::T_long, false, 0],
            ["zeroF", ::Ice::T_float, false, 0],
            ["zeroDotF", ::Ice::T_float, false, 0],
            ["zeroD", ::Ice::T_double, false, 0],
            ["zeroDotD", ::Ice::T_double, false, 0]
        ])
    end

    if not defined?(::Test::DerivedEx)
        class DerivedEx < ::Test::BaseEx
            def to_s
                '::Test::DerivedEx'
            end

            attr_accessor :c1, :c2, :c3, :nc1, :nc2, :nc3
        end

        T_DerivedEx = ::Ice::__defineException('::Test::DerivedEx', DerivedEx, ::Test::T_BaseEx, [
            ["c1", ::Test::T_Color, false, 0],
            ["c2", ::Test::T_Color, false, 0],
            ["c3", ::Test::T_Color, false, 0],
            ["nc1", ::Test::Nested::T_Color, false, 0],
            ["nc2", ::Test::Nested::T_Color, false, 0],
            ["nc3", ::Test::Nested::T_Color, false, 0]
        ])
    end

    if not defined?(::Test::T_ByteSeq)
        T_ByteSeq = ::Ice::__defineSequence('::Test::ByteSeq', ::Ice::T_byte)
    end

    if not defined?(::Test::T_IntSeq)
        T_IntSeq = ::Ice::__defineSequence('::Test::IntSeq', ::Ice::T_int)
    end

    if not defined?(::Test::T_IntStringDict)
        T_IntStringDict = ::Ice::__defineDictionary('::Test::IntStringDict', ::Ice::T_int, ::Ice::T_string)
    end

    if not defined?(::Test::InnerStruct)
        class InnerStruct
            include ::Ice::Inspect_mixin
            def initialize(a=0)
                @a = a
            end

            def hash
                _h = 0
                _h = 5 * _h + @a.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::InnerStruct or
                    @a != other.a
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :a
        end

        T_InnerStruct = ::Ice::__defineStruct('::Test::InnerStruct', InnerStruct, [["a", ::Ice::T_int]])
    end

    if not defined?(::Test::StructNoDefaults)
        class StructNoDefaults
            include ::Ice::Inspect_mixin
            def initialize(bo=false, b=0, s=0, i=0, l=0, f=0.0, d=0.0, str='', c1=::Test::Color::Red, bs=nil, is=nil, st=::Test::InnerStruct.new, dict=nil)
                @bo = bo
                @b = b
                @s = s
                @i = i
                @l = l
                @f = f
                @d = d
                @str = str
                @c1 = c1
                @bs = bs
                @is = is
                @st = st
                @dict = dict
            end

            def hash
                _h = 0
                _h = 5 * _h + @bo.hash
                _h = 5 * _h + @b.hash
                _h = 5 * _h + @s.hash
                _h = 5 * _h + @i.hash
                _h = 5 * _h + @l.hash
                _h = 5 * _h + @f.hash
                _h = 5 * _h + @d.hash
                _h = 5 * _h + @str.hash
                _h = 5 * _h + @c1.hash
                _h = 5 * _h + @bs.hash
                _h = 5 * _h + @is.hash
                _h = 5 * _h + @st.hash
                _h = 5 * _h + @dict.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::StructNoDefaults or
                    @bo != other.bo or
                    @b != other.b or
                    @s != other.s or
                    @i != other.i or
                    @l != other.l or
                    @f != other.f or
                    @d != other.d or
                    @str != other.str or
                    @c1 != other.c1 or
                    @bs != other.bs or
                    @is != other.is or
                    @st != other.st or
                    @dict != other.dict
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :bo, :b, :s, :i, :l, :f, :d, :str, :c1, :bs, :is, :st, :dict
        end

        T_StructNoDefaults = ::Ice::__defineStruct('::Test::StructNoDefaults', StructNoDefaults, [
            ["bo", ::Ice::T_bool],
            ["b", ::Ice::T_byte],
            ["s", ::Ice::T_short],
            ["i", ::Ice::T_int],
            ["l", ::Ice::T_long],
            ["f", ::Ice::T_float],
            ["d", ::Ice::T_double],
            ["str", ::Ice::T_string],
            ["c1", ::Test::T_Color],
            ["bs", ::Test::T_ByteSeq],
            ["is", ::Test::T_IntSeq],
            ["st", ::Test::T_InnerStruct],
            ["dict", ::Test::T_IntStringDict]
        ])
    end

    if not defined?(::Test::ExceptionNoDefaultsBase)
        class ExceptionNoDefaultsBase < Ice::UserException
            def to_s
                '::Test::ExceptionNoDefaultsBase'
            end

            attr_accessor :str, :c1, :bs
        end

        T_ExceptionNoDefaultsBase = ::Ice::__defineException('::Test::ExceptionNoDefaultsBase', ExceptionNoDefaultsBase, nil, [
            ["str", ::Ice::T_string, false, 0],
            ["c1", ::Test::T_Color, false, 0],
            ["bs", ::Test::T_ByteSeq, false, 0]
        ])
    end

    if not defined?(::Test::ExceptionNoDefaults)
        class ExceptionNoDefaults < ::Test::ExceptionNoDefaultsBase
            def to_s
                '::Test::ExceptionNoDefaults'
            end

            attr_accessor :st, :dict
        end

        T_ExceptionNoDefaults = ::Ice::__defineException('::Test::ExceptionNoDefaults', ExceptionNoDefaults, ::Test::T_ExceptionNoDefaultsBase, [
            ["st", ::Test::T_InnerStruct, false, 0],
            ["dict", ::Test::T_IntStringDict, false, 0]
        ])
    end

    if not defined?(::Test::T_ClassNoDefaultsBase)
        T_ClassNoDefaultsBase = ::Ice::__declareClass('::Test::ClassNoDefaultsBase')
    end

    if not defined?(::Test::ClassNoDefaultsBase)
        class ClassNoDefaultsBase < ::Ice::Value

            def initialize(str='', c1=::Test::Color::Red, bs=nil)
                @str = str
                @c1 = c1
                @bs = bs
            end

            attr_accessor :str, :c1, :bs
        end

        T_ClassNoDefaultsBase.defineClass(ClassNoDefaultsBase, -1, false, nil, [
            ['str', ::Ice::T_string, false, 0],
            ['c1', ::Test::T_Color, false, 0],
            ['bs', ::Test::T_ByteSeq, false, 0]
        ])
    end

    if not defined?(::Test::T_ClassNoDefaults)
        T_ClassNoDefaults = ::Ice::__declareClass('::Test::ClassNoDefaults')
    end

    if not defined?(::Test::ClassNoDefaults)
        class ClassNoDefaults < ::Test::ClassNoDefaultsBase

            def initialize(str='', c1=::Test::Color::Red, bs=nil, st=::Test::InnerStruct.new, dict=nil)
                super(str, c1, bs)
                @st = st
                @dict = dict
            end

            attr_accessor :st, :dict
        end

        T_ClassNoDefaults.defineClass(ClassNoDefaults, -1, false, ::Test::T_ClassNoDefaultsBase, [
            ['st', ::Test::T_InnerStruct, false, 0],
            ['dict', ::Test::T_IntStringDict, false, 0]
        ])
    end
end
