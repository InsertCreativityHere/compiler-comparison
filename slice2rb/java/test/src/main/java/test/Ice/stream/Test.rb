# Copyright (c) ZeroC, Inc.
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file 'Test.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>

require 'Ice'
require 'Ice/BuiltinSequences.rb'

module ::Test
    if not defined?(::Test::MyEnum)
        class MyEnum
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def MyEnum.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(MyEnum) or raise ArgumentError, "value must be a MyEnum"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def MyEnum.each(&block)
                @@_enumerators.each_value(&block)
            end

            Enum1 = MyEnum.new("enum1", 0)
            Enum2 = MyEnum.new("enum2", 1)
            Enum3 = MyEnum.new("enum3", 2)

            @@_enumerators = {0=>Enum1, 1=>Enum2, 2=>Enum3}

            def MyEnum._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_MyEnum = Ice::__defineEnum('::Test::MyEnum', MyEnum, MyEnum::_enumerators)
    end

    if not defined?(::Test::T_MyClass)
        T_MyClass = Ice::__declareClass('::Test::MyClass')
    end

    if not defined?(::Test::T_MyInterfacePrx)
        T_MyInterfacePrx = Ice::__declareProxy('::Test::MyInterface')
    end

    if not defined?(::Test::T_SerialSmall)
        T_SerialSmall = Ice::__defineSequence('::Test::SerialSmall', Ice::T_byte)
    end

    if not defined?(::Test::LargeStruct)
        class LargeStruct
            include Ice::Inspect_mixin
            def initialize(bo=false, by=0, sh=0, i=0, l=0, f=0.0, d=0.0, str='', e=::Test::MyEnum::Enum1, p=nil, ss=nil)
                @bo = bo
                @by = by
                @sh = sh
                @i = i
                @l = l
                @f = f
                @d = d
                @str = str
                @e = e
                @p = p
                @ss = ss
            end

            def hash
                _h = 0
                _h = 5 * _h + @bo.hash
                _h = 5 * _h + @by.hash
                _h = 5 * _h + @sh.hash
                _h = 5 * _h + @i.hash
                _h = 5 * _h + @l.hash
                _h = 5 * _h + @f.hash
                _h = 5 * _h + @d.hash
                _h = 5 * _h + @str.hash
                _h = 5 * _h + @e.hash
                _h = 5 * _h + @p.hash
                _h = 5 * _h + @ss.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::LargeStruct or
                    @bo != other.bo or
                    @by != other.by or
                    @sh != other.sh or
                    @i != other.i or
                    @l != other.l or
                    @f != other.f or
                    @d != other.d or
                    @str != other.str or
                    @e != other.e or
                    @p != other.p or
                    @ss != other.ss
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :bo, :by, :sh, :i, :l, :f, :d, :str, :e, :p, :ss
        end

        T_LargeStruct = Ice::__defineStruct('::Test::LargeStruct', LargeStruct, [
            ["bo", Ice::T_bool],
            ["by", Ice::T_byte],
            ["sh", Ice::T_short],
            ["i", Ice::T_int],
            ["l", Ice::T_long],
            ["f", Ice::T_float],
            ["d", Ice::T_double],
            ["str", Ice::T_string],
            ["e", ::Test::T_MyEnum],
            ["p", ::Test::T_MyInterfacePrx],
            ["ss", ::Test::T_SerialSmall]
        ])
    end

    if not defined?(::Test::Point)
        class Point
            include Ice::Inspect_mixin
            def initialize(x=0, y=0)
                @x = x
                @y = y
            end

            def hash
                _h = 0
                _h = 5 * _h + @x.hash
                _h = 5 * _h + @y.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::Point or
                    @x != other.x or
                    @y != other.y
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :x, :y
        end

        T_Point = Ice::__defineStruct('::Test::Point', Point, [
            ["x", Ice::T_int],
            ["y", Ice::T_int]
        ])
    end

    if not defined?(::Test::T_MyEnumS)
        T_MyEnumS = Ice::__defineSequence('::Test::MyEnumS', ::Test::T_MyEnum)
    end

    if not defined?(::Test::T_MyClassS)
        T_MyClassS = Ice::__defineSequence('::Test::MyClassS', ::Test::T_MyClass)
    end

    if not defined?(::Test::T_ByteBoolD)
        T_ByteBoolD = Ice::__defineDictionary('::Test::ByteBoolD', Ice::T_byte, Ice::T_bool)
    end

    if not defined?(::Test::T_ShortIntD)
        T_ShortIntD = Ice::__defineDictionary('::Test::ShortIntD', Ice::T_short, Ice::T_int)
    end

    if not defined?(::Test::T_StringMyClassD)
        T_StringMyClassD = Ice::__defineDictionary('::Test::StringMyClassD', Ice::T_string, ::Test::T_MyClass)
    end

    if not defined?(::Test::T_OptionalClass)
        T_OptionalClass = Ice::__declareClass('::Test::OptionalClass')
    end

    if not defined?(::Test::OptionalClass)
        class OptionalClass < Ice::Value

            def initialize(bo=false, by=0, sh=Ice::Unset, i=Ice::Unset, s=Ice::Unset, enumS4=Ice::Unset, byteBoolD6=Ice::Unset, shortIntD7=Ice::Unset, enum8=Ice::Unset, intSeq12=Ice::Unset, byteSeq13=Ice::Unset, stringSeq14=Ice::Unset, p15=Ice::Unset)
                @bo = bo
                @by = by
                @sh = sh
                @i = i
                @s = s
                @enumS4 = enumS4
                @byteBoolD6 = byteBoolD6
                @shortIntD7 = shortIntD7
                @enum8 = enum8
                @intSeq12 = intSeq12
                @byteSeq13 = byteSeq13
                @stringSeq14 = stringSeq14
                @p15 = p15
            end

            attr_accessor :bo, :by, :sh, :i, :s, :enumS4, :byteBoolD6, :shortIntD7, :enum8, :intSeq12, :byteSeq13, :stringSeq14, :p15
        end

        T_OptionalClass.defineClass(OptionalClass, -1, false, nil, [
            ['bo', Ice::T_bool, false, 0],
            ['by', Ice::T_byte, false, 0],
            ['sh', Ice::T_short, true, 1],
            ['i', Ice::T_int, true, 2],
            ['s', ::Test::T_LargeStruct, true, 3],
            ['enumS4', ::Test::T_MyEnumS, true, 4],
            ['byteBoolD6', ::Test::T_ByteBoolD, true, 6],
            ['shortIntD7', ::Test::T_ShortIntD, true, 7],
            ['enum8', ::Test::T_MyEnum, true, 8],
            ['intSeq12', ::Ice::T_IntSeq, true, 12],
            ['byteSeq13', ::Ice::T_ByteSeq, true, 13],
            ['stringSeq14', ::Ice::T_StringSeq, true, 14],
            ['p15', ::Test::T_Point, true, 15]
        ])
    end

    if not defined?(::Test::T_BoolSS)
        T_BoolSS = Ice::__defineSequence('::Test::BoolSS', ::Ice::T_BoolSeq)
    end

    if not defined?(::Test::T_ByteSS)
        T_ByteSS = Ice::__defineSequence('::Test::ByteSS', ::Ice::T_ByteSeq)
    end

    if not defined?(::Test::T_ShortSS)
        T_ShortSS = Ice::__defineSequence('::Test::ShortSS', ::Ice::T_ShortSeq)
    end

    if not defined?(::Test::T_IntSS)
        T_IntSS = Ice::__defineSequence('::Test::IntSS', ::Ice::T_IntSeq)
    end

    if not defined?(::Test::T_LongSS)
        T_LongSS = Ice::__defineSequence('::Test::LongSS', ::Ice::T_LongSeq)
    end

    if not defined?(::Test::T_FloatSS)
        T_FloatSS = Ice::__defineSequence('::Test::FloatSS', ::Ice::T_FloatSeq)
    end

    if not defined?(::Test::T_DoubleSS)
        T_DoubleSS = Ice::__defineSequence('::Test::DoubleSS', ::Ice::T_DoubleSeq)
    end

    if not defined?(::Test::T_StringSS)
        T_StringSS = Ice::__defineSequence('::Test::StringSS', ::Ice::T_StringSeq)
    end

    if not defined?(::Test::T_MyEnumSS)
        T_MyEnumSS = Ice::__defineSequence('::Test::MyEnumSS', ::Test::T_MyEnumS)
    end

    if not defined?(::Test::T_MyClassSS)
        T_MyClassSS = Ice::__defineSequence('::Test::MyClassSS', ::Test::T_MyClassS)
    end

    if not defined?(::Test::T_LongFloatD)
        T_LongFloatD = Ice::__defineDictionary('::Test::LongFloatD', Ice::T_long, Ice::T_float)
    end

    if not defined?(::Test::T_StringStringD)
        T_StringStringD = Ice::__defineDictionary('::Test::StringStringD', Ice::T_string, Ice::T_string)
    end

    if not defined?(::Test::MyClass)
        class MyClass < Ice::Value

            def initialize(c=nil, prx=nil, o=nil, s=::Test::LargeStruct.new, seq1=nil, seq2=nil, seq3=nil, seq4=nil, seq5=nil, seq6=nil, seq7=nil, seq8=nil, seq9=nil, seq10=nil, d=nil)
                @c = c
                @prx = prx
                @o = o
                @s = s
                @seq1 = seq1
                @seq2 = seq2
                @seq3 = seq3
                @seq4 = seq4
                @seq5 = seq5
                @seq6 = seq6
                @seq7 = seq7
                @seq8 = seq8
                @seq9 = seq9
                @seq10 = seq10
                @d = d
            end

            attr_accessor :c, :prx, :o, :s, :seq1, :seq2, :seq3, :seq4, :seq5, :seq6, :seq7, :seq8, :seq9, :seq10, :d
        end

        T_MyClass.defineClass(MyClass, -1, false, nil, [
            ['c', ::Test::T_MyClass, false, 0],
            ['prx', ::Test::T_MyInterfacePrx, false, 0],
            ['o', Ice::T_Value, false, 0],
            ['s', ::Test::T_LargeStruct, false, 0],
            ['seq1', ::Ice::T_BoolSeq, false, 0],
            ['seq2', ::Ice::T_ByteSeq, false, 0],
            ['seq3', ::Ice::T_ShortSeq, false, 0],
            ['seq4', ::Ice::T_IntSeq, false, 0],
            ['seq5', ::Ice::T_LongSeq, false, 0],
            ['seq6', ::Ice::T_FloatSeq, false, 0],
            ['seq7', ::Ice::T_DoubleSeq, false, 0],
            ['seq8', ::Ice::T_StringSeq, false, 0],
            ['seq9', ::Test::T_MyEnumS, false, 0],
            ['seq10', ::Test::T_MyClassS, false, 0],
            ['d', ::Test::T_StringMyClassD, false, 0]
        ])
    end

    if not defined?(::Test::MyException)
        class MyException < Ice::UserException
            def to_s
                '::Test::MyException'
            end

            attr_accessor :c
        end

        T_MyException = Ice::__defineException('::Test::MyException', MyException, nil, [["c", ::Test::T_MyClass, false, 0]])
    end

    if not defined?(::Test::MyInterfacePrx)
        module MyInterfacePrx_mixin
        end

        class MyInterfacePrx < Ice::ObjectPrx
            include Ice::Proxy_mixin
            include MyInterfacePrx_mixin
        end

        T_MyInterfacePrx.defineProxy(MyInterfacePrx, nil, [])
    end
end
