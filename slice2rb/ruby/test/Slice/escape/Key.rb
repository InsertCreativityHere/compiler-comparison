# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file 'Key.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'

module ::BEGIN_

    if not defined?(::BEGIN_::END_)
        class END_
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def END_.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(END_) or raise ArgumentError, "value must be a END_"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def END_.each(&block)
                @@_enumerators.each_value(&block)
            end

            Alias = END_.new("alias", 0)

            @@_enumerators = {0=>Alias}

            def END_._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_END_ = ::Ice::__defineEnum('::BEGIN::END', END_, END_::_enumerators)
    end

    if not defined?(::BEGIN_::And)
        class And
            include ::Ice::Inspect_mixin
            def initialize(_begin=0)
                @_begin = _begin
            end

            def hash
                _h = 0
                _h = 5 * _h + @_begin.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::BEGIN_::And or
                    @_begin != other._begin
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :_begin
        end

        T_And = ::Ice::__defineStruct('::BEGIN::and', And, [["_begin", ::Ice::T_int]])
    end

    if not defined?(::BEGIN_::T_BreakPrx)
        T_BreakPrx = ::Ice::__declareProxy('::BEGIN::break')
    end

    if not defined?(::BEGIN_::BreakPrx)
        module BreakPrx_mixin

            def _case(_clone, _def, context=nil)
                BreakPrx_mixin::OP_case.invoke(self, [_clone, _def], context)
            end

            def _to_a(context=nil)
                BreakPrx_mixin::OP_to_a.invoke(self, [], context)
            end

            def _instance_variable_set(context=nil)
                BreakPrx_mixin::OP_instance_variable_set.invoke(self, [], context)
            end

            def _instance_variables(context=nil)
                BreakPrx_mixin::OP_instance_variables.invoke(self, [], context)
            end
        end

        class BreakPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include BreakPrx_mixin
        end

        T_BreakPrx.defineProxy(BreakPrx, nil, [])

        BreakPrx_mixin::OP_case = ::Ice::__defineOperation('case', ::Ice::OperationMode::Normal, nil, [[::Ice::T_int, false, 0], [::Ice::T_int, false, 0]], [], nil, [])
        BreakPrx_mixin::OP_to_a = ::Ice::__defineOperation('to_a', ::Ice::OperationMode::Normal, nil, [], [], nil, [])
        BreakPrx_mixin::OP_instance_variable_set = ::Ice::__defineOperation('instance_variable_set', ::Ice::OperationMode::Normal, nil, [], [], nil, [])
        BreakPrx_mixin::OP_instance_variables = ::Ice::__defineOperation('instance_variables', ::Ice::OperationMode::Normal, nil, [], [], nil, [])
    end

    if not defined?(::BEGIN_::T_Display)
        T_Display = ::Ice::__declareClass('::BEGIN::display')
    end

    if not defined?(::BEGIN_::Display)
        class Display < ::Ice::Value

            def initialize(_when=0, _do=0, _dup=nil, _else=0)
                @_when = _when
                @_do = _do
                @_dup = _dup
                @_else = _else
            end

            attr_accessor :_when, :_do, :_dup, :_else
        end

        T_Display.defineClass(Display, -1, false, nil, [
            ['_when', ::Ice::T_int, false, 0],
            ['_do', ::Ice::T_int, false, 0],
            ['_dup', ::BEGIN_::T_BreakPrx, false, 0],
            ['_else', ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::BEGIN_::T_ElsifPrx)
        T_ElsifPrx = ::Ice::__declareProxy('::BEGIN::elsif')
    end

    if not defined?(::BEGIN_::ElsifPrx)
        module ElsifPrx_mixin
            include ::BEGIN_::BreakPrx_mixin
        end

        class ElsifPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include ElsifPrx_mixin
        end

        T_ElsifPrx.defineProxy(ElsifPrx, nil, [::BEGIN_::T_BreakPrx])
    end

    if not defined?(::BEGIN_::T_Rescue)
        T_Rescue = ::Ice::__defineSequence('::BEGIN::rescue', ::BEGIN_::T_END_)
    end

    if not defined?(::BEGIN_::T_Ensure)
        T_Ensure = ::Ice::__defineDictionary('::BEGIN::ensure', ::Ice::T_string, ::BEGIN_::T_END_)
    end

    if not defined?(::BEGIN_::Next)
        class Next < Ice::UserException
            def to_s
                '::BEGIN::next'
            end

            attr_accessor :_new
        end

        T_Next = ::Ice::__defineException('::BEGIN::next', Next, nil, [["_new", ::Ice::T_int, false, 0]])
    end

    if not defined?(::BEGIN_::Nil)
        class Nil < ::BEGIN_::Next
            def to_s
                '::BEGIN::nil'
            end

            attr_accessor :_not, :_or
        end

        T_Nil = ::Ice::__defineException('::BEGIN::nil', Nil, ::BEGIN_::T_Next, [
            ["_not", ::Ice::T_int, false, 0],
            ["_or", ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::BEGIN_::T_ExtendPrx)
        T_ExtendPrx = ::Ice::__declareProxy('::BEGIN::extend')
    end

    if not defined?(::BEGIN_::ExtendPrx)
        module ExtendPrx_mixin

            def _for(_freeze, _hash, _if, _inspect, _method, _methods, context=nil)
                ExtendPrx_mixin::OP_for.invoke(self, [_freeze, _hash, _if, _inspect, _method, _methods], context)
            end
        end

        class ExtendPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include ExtendPrx_mixin
        end

        T_ExtendPrx.defineProxy(ExtendPrx, nil, [])

        ExtendPrx_mixin::OP_for = ::Ice::__defineOperation('for', ::Ice::OperationMode::Normal, nil, [[::BEGIN_::T_Display, false, 0], [::BEGIN_::T_ElsifPrx, false, 0], [::BEGIN_::T_BreakPrx, false, 0], [::BEGIN_::T_Display, false, 0], [::BEGIN_::T_ElsifPrx, false, 0], [::Ice::T_int, false, 0]], [], [::BEGIN_::T_END_, false, 0], [::BEGIN_::T_Nil])
    end

    Redo = 1
end
