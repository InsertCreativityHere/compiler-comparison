# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.9
#
# <auto-generated>
#
# Generated from file `Test.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'
require 'Ice/BuiltinSequences.rb'

module ::Test

    if not defined?(::Test::MyEnum)
        class MyEnum
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def MyEnum.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(MyEnum) or raise ArgumentError, "value must be a MyEnum"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def MyEnum.each(&block)
                @@_enumerators.each_value(&block)
            end

            Enum1 = MyEnum.new("enum1", 0)
            Enum2 = MyEnum.new("enum2", 1)
            Enum3 = MyEnum.new("enum3", 2)

            @@_enumerators = {0=>Enum1, 1=>Enum2, 2=>Enum3}

            def MyEnum._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_MyEnum = ::Ice::__defineEnum('::Test::MyEnum', MyEnum, MyEnum::_enumerators)
    end

    if not defined?(::Test::T_MyClass)
        T_MyClass = ::Ice::__declareClass('::Test::MyClass')
        T_MyClassPrx = ::Ice::__declareProxy('::Test::MyClass')
    end

    if not defined?(::Test::ValStruct)
        class ValStruct
            include ::Ice::Inspect_mixin
            def initialize(bo=false, by=0, sh=0, i=0, l=0, e=::Test::MyEnum::Enum1)
                @bo = bo
                @by = by
                @sh = sh
                @i = i
                @l = l
                @e = e
            end

            def hash
                _h = 0
                _h = 5 * _h + @bo.hash
                _h = 5 * _h + @by.hash
                _h = 5 * _h + @sh.hash
                _h = 5 * _h + @i.hash
                _h = 5 * _h + @l.hash
                _h = 5 * _h + @e.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::ValStruct or
                    @bo != other.bo or
                    @by != other.by or
                    @sh != other.sh or
                    @i != other.i or
                    @l != other.l or
                    @e != other.e
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :bo, :by, :sh, :i, :l, :e
        end

        T_ValStruct = ::Ice::__defineStruct('::Test::ValStruct', ValStruct, [
            ["bo", ::Ice::T_bool],
            ["by", ::Ice::T_byte],
            ["sh", ::Ice::T_short],
            ["i", ::Ice::T_int],
            ["l", ::Ice::T_long],
            ["e", ::Test::T_MyEnum]
        ])
    end

    if not defined?(::Test::MyInterface_Mixin)

        module ::Test::MyInterface_Mixin
        end
        module MyInterfacePrx_mixin

            def op(context=nil)
                MyInterfacePrx_mixin::OP_op.invoke(self, [], context)
            end
        end

        class MyInterfacePrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include MyInterfacePrx_mixin
        end

        if not defined?(::Test::T_MyInterfacePrx)
            T_MyInterface = ::Ice::__declareClass('::Test::MyInterface')
            T_MyInterfacePrx = ::Ice::__declareProxy('::Test::MyInterface')
        end

        T_MyInterface.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_MyInterfacePrx.defineProxy(MyInterfacePrx, nil, [])

        MyInterfacePrx_mixin::OP_op = ::Ice::__defineOperation('op', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
    end

    if not defined?(::Test::T_ProxySeq)
        T_ProxySeq = ::Ice::__defineSequence('::Test::ProxySeq', ::Test::T_MyInterfacePrx)
    end

    if not defined?(::Test::RefStruct)
        class RefStruct
            include ::Ice::Inspect_mixin
            def initialize(s='', sp='', c=nil, p=nil, seq=nil)
                @s = s
                @sp = sp
                @c = c
                @p = p
                @seq = seq
            end

            def hash
                _h = 0
                _h = 5 * _h + @s.hash
                _h = 5 * _h + @sp.hash
                _h = 5 * _h + @c.hash
                _h = 5 * _h + @p.hash
                _h = 5 * _h + @seq.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::RefStruct or
                    @s != other.s or
                    @sp != other.sp or
                    @c != other.c or
                    @p != other.p or
                    @seq != other.seq
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :s, :sp, :c, :p, :seq
        end

        T_RefStruct = ::Ice::__defineStruct('::Test::RefStruct', RefStruct, [
            ["s", ::Ice::T_string],
            ["sp", ::Ice::T_string],
            ["c", ::Test::T_MyClass],
            ["p", ::Test::T_MyInterfacePrx],
            ["seq", ::Test::T_ProxySeq]
        ])
    end

    if not defined?(::Test::T_ValStructS)
        T_ValStructS = ::Ice::__defineSequence('::Test::ValStructS', ::Test::T_ValStruct)
    end

    if not defined?(::Test::T_ValStructList)
        T_ValStructList = ::Ice::__defineSequence('::Test::ValStructList', ::Test::T_ValStruct)
    end

    if not defined?(::Test::T_ValStructLinkedList)
        T_ValStructLinkedList = ::Ice::__defineSequence('::Test::ValStructLinkedList', ::Test::T_ValStruct)
    end

    if not defined?(::Test::T_ValStructStack)
        T_ValStructStack = ::Ice::__defineSequence('::Test::ValStructStack', ::Test::T_ValStruct)
    end

    if not defined?(::Test::T_ValStructQueue)
        T_ValStructQueue = ::Ice::__defineSequence('::Test::ValStructQueue', ::Test::T_ValStruct)
    end

    if not defined?(::Test::T_IntStringD)
        T_IntStringD = ::Ice::__defineDictionary('::Test::IntStringD', ::Ice::T_int, ::Ice::T_string)
    end

    if not defined?(::Test::T_IntValStructD)
        T_IntValStructD = ::Ice::__defineDictionary('::Test::IntValStructD', ::Ice::T_int, ::Test::T_ValStruct)
    end

    if not defined?(::Test::T_IntProxyD)
        T_IntProxyD = ::Ice::__defineDictionary('::Test::IntProxyD', ::Ice::T_int, ::Test::T_MyInterfacePrx)
    end

    if not defined?(::Test::T_IntStringSD)
        T_IntStringSD = ::Ice::__defineDictionary('::Test::IntStringSD', ::Ice::T_int, ::Ice::T_string)
    end

    if not defined?(::Test::Base_Mixin)

        module ::Test::Base_Mixin
        end
        class Base < ::Ice::Value

            def initialize(bo=false, by=0, sh=0, i=0, l=0, e=::Test::MyEnum::Enum1)
                @bo = bo
                @by = by
                @sh = sh
                @i = i
                @l = l
                @e = e
            end

            attr_accessor :bo, :by, :sh, :i, :l, :e
        end

        if not defined?(::Test::T_Base)
            T_Base = ::Ice::__declareClass('::Test::Base')
        end

        T_Base.defineClass(Base, -1, false, false, nil, [
            ['bo', ::Ice::T_bool, false, 0],
            ['by', ::Ice::T_byte, false, 0],
            ['sh', ::Ice::T_short, false, 0],
            ['i', ::Ice::T_int, false, 0],
            ['l', ::Ice::T_long, false, 0],
            ['e', ::Test::T_MyEnum, false, 0]
        ])
    end

    if not defined?(::Test::MyClass_Mixin)

        module ::Test::MyClass_Mixin
        end
        class MyClass < ::Test::Base

            def initialize(bo=false, by=0, sh=0, i=0, l=0, e=::Test::MyEnum::Enum1, c=nil, o=nil, s=::Test::ValStruct.new)
                super(bo, by, sh, i, l, e)
                @c = c
                @o = o
                @s = s
            end

            attr_accessor :c, :o, :s
        end

        if not defined?(::Test::T_MyClass)
            T_MyClass = ::Ice::__declareClass('::Test::MyClass')
        end

        T_MyClass.defineClass(MyClass, -1, false, false, ::Test::T_Base, [
            ['c', ::Test::T_MyClass, false, 0],
            ['o', ::Ice::T_Value, false, 0],
            ['s', ::Test::T_ValStruct, false, 0]
        ])
    end

    if not defined?(::Test::MyException)
        class MyException < Ice::UserException
            def initialize(name='', b=0, s=0, i=0, l=0, vs=::Test::ValStruct.new, rs=::Test::RefStruct.new, c=nil, p=nil, vss=nil, vsl=nil, vsll=nil, vssk=nil, vsq=nil, isd=nil, ivd=nil, ipd=nil, issd=nil, optName=::Ice::Unset, optInt=::Ice::Unset, optValStruct=::Ice::Unset, optRefStruct=::Ice::Unset, optEnum=::Ice::Unset, optClass=::Ice::Unset, optProxy=::Ice::Unset)
                @name = name
                @b = b
                @s = s
                @i = i
                @l = l
                @vs = vs
                @rs = rs
                @c = c
                @p = p
                @vss = vss
                @vsl = vsl
                @vsll = vsll
                @vssk = vssk
                @vsq = vsq
                @isd = isd
                @ivd = ivd
                @ipd = ipd
                @issd = issd
                @optName = optName
                @optInt = optInt
                @optValStruct = optValStruct
                @optRefStruct = optRefStruct
                @optEnum = optEnum
                @optClass = optClass
                @optProxy = optProxy
            end

            def to_s
                '::Test::MyException'
            end

            attr_accessor :name, :b, :s, :i, :l, :vs, :rs, :c, :p, :vss, :vsl, :vsll, :vssk, :vsq, :isd, :ivd, :ipd, :issd, :optName, :optInt, :optValStruct, :optRefStruct, :optEnum, :optClass, :optProxy
        end

        T_MyException = ::Ice::__defineException('::Test::MyException', MyException, false, nil, [
            ["name", ::Ice::T_string, false, 0],
            ["b", ::Ice::T_byte, false, 0],
            ["s", ::Ice::T_short, false, 0],
            ["i", ::Ice::T_int, false, 0],
            ["l", ::Ice::T_long, false, 0],
            ["vs", ::Test::T_ValStruct, false, 0],
            ["rs", ::Test::T_RefStruct, false, 0],
            ["c", ::Test::T_MyClass, false, 0],
            ["p", ::Test::T_MyInterfacePrx, false, 0],
            ["vss", ::Test::T_ValStructS, false, 0],
            ["vsl", ::Test::T_ValStructList, false, 0],
            ["vsll", ::Test::T_ValStructLinkedList, false, 0],
            ["vssk", ::Test::T_ValStructStack, false, 0],
            ["vsq", ::Test::T_ValStructQueue, false, 0],
            ["isd", ::Test::T_IntStringD, false, 0],
            ["ivd", ::Test::T_IntValStructD, false, 0],
            ["ipd", ::Test::T_IntProxyD, false, 0],
            ["issd", ::Test::T_IntStringSD, false, 0],
            ["optName", ::Ice::T_string, true, 1],
            ["optInt", ::Ice::T_int, true, 2],
            ["optValStruct", ::Test::T_ValStruct, true, 3],
            ["optRefStruct", ::Test::T_RefStruct, true, 4],
            ["optEnum", ::Test::T_MyEnum, true, 5],
            ["optClass", ::Test::T_MyClass, true, 6],
            ["optProxy", ::Test::T_MyInterfacePrx, true, 7]
        ])
    end
end
