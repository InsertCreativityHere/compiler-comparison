# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `Key.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'

module ::Abstract

    if not defined?(::Abstract::As)
        class As
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def As.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(As) or raise ArgumentError, "value must be a As"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def As.each(&block)
                @@_enumerators.each_value(&block)
            end

            Base = As.new("base", 0)

            @@_enumerators = {0=>Base}

            def As._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_As = ::Ice::__defineEnum('::abstract::as', As, As::_enumerators)
    end

    if not defined?(::Abstract::Break)
        class Break
            include ::Ice::Inspect_mixin
            def initialize(readonly=0)
                @readonly = readonly
            end

            def hash
                _h = 0
                _h = 5 * _h + @readonly.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Abstract::Break or
                    @readonly != other.readonly
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :readonly
        end

        T_Break = ::Ice::__defineStruct('::abstract::break', Break, [["readonly", ::Ice::T_int]])
    end

    if not defined?(::Abstract::Case_Mixin)

        module ::Abstract::Case_Mixin
        end
        module CasePrx_mixin

            def catch(checked, context=nil)
                CasePrx_mixin::OP_catch.invoke(self, [checked], context)
            end
        end

        class CasePrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include CasePrx_mixin
        end

        if not defined?(::Abstract::T_CasePrx)
            T_Case = ::Ice::__declareClass('::abstract::case')
            T_CasePrx = ::Ice::__declareProxy('::abstract::case')
        end

        T_CasePrx.defineProxy(CasePrx, nil, [])

        CasePrx_mixin::OP_catch = ::Ice::__defineOperation('catch', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, true, nil, [[::Ice::T_int, false, 0]], [[::Ice::T_int, false, 0]], nil, [])
    end

    if not defined?(::Abstract::Decimal_Mixin)

        module ::Abstract::Decimal_Mixin
        end
        module DecimalPrx_mixin

            def default(context=nil)
                DecimalPrx_mixin::OP_default.invoke(self, [], context)
            end
        end

        class DecimalPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include DecimalPrx_mixin
        end

        if not defined?(::Abstract::T_DecimalPrx)
            T_Decimal = ::Ice::__declareClass('::abstract::decimal')
            T_DecimalPrx = ::Ice::__declareProxy('::abstract::decimal')
        end

        T_DecimalPrx.defineProxy(DecimalPrx, nil, [])

        DecimalPrx_mixin::OP_default = ::Ice::__defineOperation('default', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
    end

    if not defined?(::Abstract::Delegate_Mixin)

        module ::Abstract::Delegate_Mixin
        end
        class Delegate < ::Ice::Value

            def initialize(_if=0, _else=nil, event=0)
                @_if = _if
                @_else = _else
                @event = event
            end

            attr_accessor :_if, :_else, :event
        end

        if not defined?(::Abstract::T_Delegate)
            T_Delegate = ::Ice::__declareClass('::abstract::delegate')
        end

        T_Delegate.defineClass(Delegate, -1, false, false, nil, [
            ['_if', ::Ice::T_int, false, 0],
            ['_else', ::Abstract::T_CasePrx, false, 0],
            ['event', ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::Abstract::Explicit_Mixin)

        module ::Abstract::Explicit_Mixin
        end
        module ExplicitPrx_mixin
            include ::Abstract::DecimalPrx_mixin
            include ::Abstract::CasePrx_mixin
        end

        class ExplicitPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include ExplicitPrx_mixin
        end

        if not defined?(::Abstract::T_ExplicitPrx)
            T_Explicit = ::Ice::__declareClass('::abstract::explicit')
            T_ExplicitPrx = ::Ice::__declareProxy('::abstract::explicit')
        end

        T_ExplicitPrx.defineProxy(ExplicitPrx, nil, [::Abstract::T_DecimalPrx, ::Abstract::T_CasePrx])
    end

    if not defined?(::Abstract::T_While)
        T_While = ::Ice::__defineDictionary('::abstract::while', ::Ice::T_string, ::Abstract::T_Break)
    end

    if not defined?(::Abstract::OptionalMembers_Mixin)

        module ::Abstract::OptionalMembers_Mixin
        end
        class OptionalMembers < ::Ice::Value

            def initialize(_for=::Ice::Unset, goto=::Ice::Unset, _if=::Ice::Unset, internal=::Ice::Unset, namespace=::Ice::Unset)
                @_for = _for
                @goto = goto
                @_if = _if
                @internal = internal
                @namespace = namespace
            end

            attr_accessor :_for, :goto, :_if, :internal, :namespace
        end

        if not defined?(::Abstract::T_OptionalMembers)
            T_OptionalMembers = ::Ice::__declareClass('::abstract::optionalMembers')
        end

        T_OptionalMembers.defineClass(OptionalMembers, -1, false, false, nil, [
            ['_for', ::Abstract::T_Break, true, 1],
            ['goto', ::Abstract::T_As, true, 2],
            ['_if', ::Abstract::T_ExplicitPrx, true, 3],
            ['internal', ::Abstract::T_While, true, 5],
            ['namespace', ::Ice::T_string, true, 7]
        ])
    end

    if not defined?(::Abstract::OptionalParams_Mixin)

        module ::Abstract::OptionalParams_Mixin
        end
        module OptionalParamsPrx_mixin

            def _for(goto, _if, internal, namespace, context=nil)
                OptionalParamsPrx_mixin::OP_for.invoke(self, [goto, _if, internal, namespace], context)
            end

            def continue(goto, _if, internal, namespace, context=nil)
                OptionalParamsPrx_mixin::OP_continue.invoke(self, [goto, _if, internal, namespace], context)
            end

            def _in(context=nil)
                OptionalParamsPrx_mixin::OP_in.invoke(self, [], context)
            end

            def foreach(context=nil)
                OptionalParamsPrx_mixin::OP_foreach.invoke(self, [], context)
            end
        end

        class OptionalParamsPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include OptionalParamsPrx_mixin
        end

        if not defined?(::Abstract::T_OptionalParamsPrx)
            T_OptionalParams = ::Ice::__declareClass('::abstract::optionalParams')
            T_OptionalParamsPrx = ::Ice::__declareProxy('::abstract::optionalParams')
        end

        T_OptionalParamsPrx.defineProxy(OptionalParamsPrx, nil, [])

        OptionalParamsPrx_mixin::OP_for = ::Ice::__defineOperation('for', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Abstract::T_As, true, 2], [::Abstract::T_ExplicitPrx, true, 3], [::Abstract::T_While, true, 5], [::Ice::T_string, true, 7]], [], [::Abstract::T_Break, true, 1], [])
        OptionalParamsPrx_mixin::OP_continue = ::Ice::__defineOperation('continue', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, true, nil, [[::Abstract::T_As, true, 2], [::Abstract::T_ExplicitPrx, true, 3], [::Abstract::T_While, true, 5], [::Ice::T_string, true, 7]], [], [::Abstract::T_Break, true, 1], [])
        OptionalParamsPrx_mixin::OP_in = ::Ice::__defineOperation('in', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [[::Abstract::T_As, true, 2], [::Abstract::T_ExplicitPrx, true, 3], [::Abstract::T_While, true, 5], [::Ice::T_string, true, 7]], [::Abstract::T_Break, true, 1], [])
        OptionalParamsPrx_mixin::OP_foreach = ::Ice::__defineOperation('foreach', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, true, nil, [], [[::Abstract::T_As, true, 2], [::Abstract::T_ExplicitPrx, true, 3], [::Abstract::T_While, true, 5], [::Ice::T_string, true, 7]], [::Abstract::T_Break, true, 1], [])
    end

    if not defined?(::Abstract::Fixed)
        class Fixed < Ice::UserException
            def initialize(_for=0)
                @_for = _for
            end

            def to_s
                '::abstract::fixed'
            end

            attr_accessor :_for
        end

        T_Fixed = ::Ice::__defineException('::abstract::fixed', Fixed, false, nil, [["_for", ::Ice::T_int, false, 0]])
    end

    if not defined?(::Abstract::Foreach)
        class Foreach < ::Abstract::Fixed
            def initialize(_for=0, goto=0, _if=0)
                super(_for)
                @goto = goto
                @_if = _if
            end

            def to_s
                '::abstract::foreach'
            end

            attr_accessor :goto, :_if
        end

        T_Foreach = ::Ice::__defineException('::abstract::foreach', Foreach, false, ::Abstract::T_Fixed, [
            ["goto", ::Ice::T_int, false, 0],
            ["_if", ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::Abstract::BaseMethods)
        class BaseMethods < Ice::UserException
            def initialize(data=0, helpLink=0, innerException=0, message=0, source=0, stackTrace=0, targetSite=0, hResult=0, equals=0, getBaseException=0, getHashCode=0, getObjectData=0, getType=0, referenceEquals=0, toString=0)
                @Data = data
                @HelpLink = helpLink
                @InnerException = innerException
                @Message = message
                @Source = source
                @StackTrace = stackTrace
                @TargetSite = targetSite
                @HResult = hResult
                @Equals = equals
                @GetBaseException = getBaseException
                @GetHashCode = getHashCode
                @GetObjectData = getObjectData
                @GetType = getType
                @ReferenceEquals = referenceEquals
                @ToString = toString
            end

            def to_s
                '::abstract::BaseMethods'
            end

            attr_accessor :Data, :HelpLink, :InnerException, :Message, :Source, :StackTrace, :TargetSite, :HResult, :Equals, :GetBaseException, :GetHashCode, :GetObjectData, :GetType, :ReferenceEquals, :ToString
        end

        T_BaseMethods = ::Ice::__defineException('::abstract::BaseMethods', BaseMethods, false, nil, [
            ["Data", ::Ice::T_int, false, 0],
            ["HelpLink", ::Ice::T_int, false, 0],
            ["InnerException", ::Ice::T_int, false, 0],
            ["Message", ::Ice::T_int, false, 0],
            ["Source", ::Ice::T_int, false, 0],
            ["StackTrace", ::Ice::T_int, false, 0],
            ["TargetSite", ::Ice::T_int, false, 0],
            ["HResult", ::Ice::T_int, false, 0],
            ["Equals", ::Ice::T_int, false, 0],
            ["GetBaseException", ::Ice::T_int, false, 0],
            ["GetHashCode", ::Ice::T_int, false, 0],
            ["GetObjectData", ::Ice::T_int, false, 0],
            ["GetType", ::Ice::T_int, false, 0],
            ["ReferenceEquals", ::Ice::T_int, false, 0],
            ["ToString", ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::Abstract::Implicit_Mixin)

        module ::Abstract::Implicit_Mixin
        end
        module ImplicitPrx_mixin

            def _in(internal, is, lock, namespace, _new, null, override, params, private, context=nil)
                ImplicitPrx_mixin::OP_in.invoke(self, [internal, is, lock, namespace, _new, null, override, params, private], context)
            end
        end

        class ImplicitPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include ImplicitPrx_mixin
        end

        if not defined?(::Abstract::T_ImplicitPrx)
            T_Implicit = ::Ice::__declareClass('::abstract::implicit')
            T_ImplicitPrx = ::Ice::__declareProxy('::abstract::implicit')
        end

        T_ImplicitPrx.defineProxy(ImplicitPrx, nil, [])

        ImplicitPrx_mixin::OP_in = ::Ice::__defineOperation('in', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Abstract::T_Break, false, 0], [::Abstract::T_Delegate, false, 0], [::Abstract::T_ExplicitPrx, false, 0], [::Abstract::T_CasePrx, false, 0], [::Abstract::T_DecimalPrx, false, 0], [::Abstract::T_Delegate, false, 0], [::Ice::T_int, false, 0], [::Ice::T_int, false, 0], [::Ice::T_int, false, 0]], [], [::Abstract::T_As, false, 0], [::Abstract::T_Fixed, ::Abstract::T_Foreach])
    end

    Protected = 0

    Public = 0

    module System

        if not defined?(::Abstract::System::Test_Mixin)

            module ::Abstract::System::Test_Mixin
            end
            module TestPrx_mixin

                def op(context=nil)
                    TestPrx_mixin::OP_op.invoke(self, [], context)
                end
            end

            class TestPrx < ::Ice::ObjectPrx
                include ::Ice::Proxy_mixin
                include TestPrx_mixin
            end

            if not defined?(::Abstract::System::T_TestPrx)
                T_Test = ::Ice::__declareClass('::abstract::System::Test')
                T_TestPrx = ::Ice::__declareProxy('::abstract::System::Test')
            end

            T_TestPrx.defineProxy(TestPrx, nil, [])

            TestPrx_mixin::OP_op = ::Ice::__defineOperation('op', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
        end
    end
end

module ::System

    if not defined?(::System::Test_Mixin)

        module ::System::Test_Mixin
        end
        module TestPrx_mixin

            def op(context=nil)
                TestPrx_mixin::OP_op.invoke(self, [], context)
            end
        end

        class TestPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include TestPrx_mixin
        end

        if not defined?(::System::T_TestPrx)
            T_Test = ::Ice::__declareClass('::System::Test')
            T_TestPrx = ::Ice::__declareProxy('::System::Test')
        end

        T_TestPrx.defineProxy(TestPrx, nil, [])

        TestPrx_mixin::OP_op = ::Ice::__defineOperation('op', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
    end
end
