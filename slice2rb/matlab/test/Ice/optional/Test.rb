# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file `Test.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'

module ::Test

    if not defined?(::Test::OneOptional_Mixin)

        module ::Test::OneOptional_Mixin
        end
        class OneOptional < ::Ice::Value

            def initialize(a=::Ice::Unset)
                @a = a
            end

            attr_accessor :a
        end

        if not defined?(::Test::T_OneOptional)
            T_OneOptional = ::Ice::__declareClass('::Test::OneOptional')
        end

        T_OneOptional.defineClass(OneOptional, -1, false, nil, [['a', ::Ice::T_int, true, 1]])
    end

    if not defined?(::Test::MyInterface_Mixin)

        module ::Test::MyInterface_Mixin
        end
        module MyInterfacePrx_mixin

            def op(context=nil)
                MyInterfacePrx_mixin::OP_op.invoke(self, [], context)
            end
        end

        class MyInterfacePrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include MyInterfacePrx_mixin
        end

        if not defined?(::Test::T_MyInterfacePrx)
            T_MyInterface = ::Ice::__declareClass('::Test::MyInterface')
            T_MyInterfacePrx = ::Ice::__declareProxy('::Test::MyInterface')
        end

        T_MyInterfacePrx.defineProxy(MyInterfacePrx, nil, [])

        MyInterfacePrx_mixin::OP_op = ::Ice::__defineOperation('op', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
    end

    if not defined?(::Test::MyEnum)
        class MyEnum
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def MyEnum.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(MyEnum) or raise ArgumentError, "value must be a MyEnum"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def MyEnum.each(&block)
                @@_enumerators.each_value(&block)
            end

            MyEnumMember = MyEnum.new("MyEnumMember", 0)

            @@_enumerators = {0=>MyEnumMember}

            def MyEnum._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_MyEnum = ::Ice::__defineEnum('::Test::MyEnum', MyEnum, MyEnum::_enumerators)
    end

    if not defined?(::Test::SmallStruct)
        class SmallStruct
            include ::Ice::Inspect_mixin
            def initialize(m=0)
                @m = m
            end

            def hash
                _h = 0
                _h = 5 * _h + @m.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::SmallStruct or
                    @m != other.m
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :m
        end

        T_SmallStruct = ::Ice::__defineStruct('::Test::SmallStruct', SmallStruct, [["m", ::Ice::T_byte]])
    end

    if not defined?(::Test::FixedStruct)
        class FixedStruct
            include ::Ice::Inspect_mixin
            def initialize(m=0)
                @m = m
            end

            def hash
                _h = 0
                _h = 5 * _h + @m.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::FixedStruct or
                    @m != other.m
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :m
        end

        T_FixedStruct = ::Ice::__defineStruct('::Test::FixedStruct', FixedStruct, [["m", ::Ice::T_int]])
    end

    if not defined?(::Test::VarStruct)
        class VarStruct
            include ::Ice::Inspect_mixin
            def initialize(m='')
                @m = m
            end

            def hash
                _h = 0
                _h = 5 * _h + @m.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::VarStruct or
                    @m != other.m
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :m
        end

        T_VarStruct = ::Ice::__defineStruct('::Test::VarStruct', VarStruct, [["m", ::Ice::T_string]])
    end

    if not defined?(::Test::ClassVarStruct)
        class ClassVarStruct
            include ::Ice::Inspect_mixin
            def initialize(a=0)
                @a = a
            end

            def hash
                _h = 0
                _h = 5 * _h + @a.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::ClassVarStruct or
                    @a != other.a
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :a
        end

        T_ClassVarStruct = ::Ice::__defineStruct('::Test::ClassVarStruct', ClassVarStruct, [["a", ::Ice::T_int]])
    end

    if not defined?(::Test::T_ByteSeq)
        T_ByteSeq = ::Ice::__defineSequence('::Test::ByteSeq', ::Ice::T_byte)
    end

    if not defined?(::Test::T_BoolSeq)
        T_BoolSeq = ::Ice::__defineSequence('::Test::BoolSeq', ::Ice::T_bool)
    end

    if not defined?(::Test::T_ShortSeq)
        T_ShortSeq = ::Ice::__defineSequence('::Test::ShortSeq', ::Ice::T_short)
    end

    if not defined?(::Test::T_IntSeq)
        T_IntSeq = ::Ice::__defineSequence('::Test::IntSeq', ::Ice::T_int)
    end

    if not defined?(::Test::T_LongSeq)
        T_LongSeq = ::Ice::__defineSequence('::Test::LongSeq', ::Ice::T_long)
    end

    if not defined?(::Test::T_FloatSeq)
        T_FloatSeq = ::Ice::__defineSequence('::Test::FloatSeq', ::Ice::T_float)
    end

    if not defined?(::Test::T_DoubleSeq)
        T_DoubleSeq = ::Ice::__defineSequence('::Test::DoubleSeq', ::Ice::T_double)
    end

    if not defined?(::Test::T_StringSeq)
        T_StringSeq = ::Ice::__defineSequence('::Test::StringSeq', ::Ice::T_string)
    end

    if not defined?(::Test::T_MyEnumSeq)
        T_MyEnumSeq = ::Ice::__defineSequence('::Test::MyEnumSeq', ::Test::T_MyEnum)
    end

    if not defined?(::Test::T_SmallStructSeq)
        T_SmallStructSeq = ::Ice::__defineSequence('::Test::SmallStructSeq', ::Test::T_SmallStruct)
    end

    if not defined?(::Test::T_SmallStructList)
        T_SmallStructList = ::Ice::__defineSequence('::Test::SmallStructList', ::Test::T_SmallStruct)
    end

    if not defined?(::Test::T_FixedStructSeq)
        T_FixedStructSeq = ::Ice::__defineSequence('::Test::FixedStructSeq', ::Test::T_FixedStruct)
    end

    if not defined?(::Test::T_FixedStructList)
        T_FixedStructList = ::Ice::__defineSequence('::Test::FixedStructList', ::Test::T_FixedStruct)
    end

    if not defined?(::Test::T_VarStructSeq)
        T_VarStructSeq = ::Ice::__defineSequence('::Test::VarStructSeq', ::Test::T_VarStruct)
    end

    if not defined?(::Test::T_OneOptionalSeq)
        T_OneOptionalSeq = ::Ice::__defineSequence('::Test::OneOptionalSeq', ::Test::T_OneOptional)
    end

    if not defined?(::Test::T_MyInterfacePrxSeq)
        T_MyInterfacePrxSeq = ::Ice::__defineSequence('::Test::MyInterfacePrxSeq', ::Test::T_MyInterfacePrx)
    end

    if not defined?(::Test::T_Serializable)
        T_Serializable = ::Ice::__defineSequence('::Test::Serializable', ::Ice::T_byte)
    end

    if not defined?(::Test::T_IntIntDict)
        T_IntIntDict = ::Ice::__defineDictionary('::Test::IntIntDict', ::Ice::T_int, ::Ice::T_int)
    end

    if not defined?(::Test::T_StringIntDict)
        T_StringIntDict = ::Ice::__defineDictionary('::Test::StringIntDict', ::Ice::T_string, ::Ice::T_int)
    end

    if not defined?(::Test::T_IntEnumDict)
        T_IntEnumDict = ::Ice::__defineDictionary('::Test::IntEnumDict', ::Ice::T_int, ::Test::T_MyEnum)
    end

    if not defined?(::Test::T_IntFixedStructDict)
        T_IntFixedStructDict = ::Ice::__defineDictionary('::Test::IntFixedStructDict', ::Ice::T_int, ::Test::T_FixedStruct)
    end

    if not defined?(::Test::T_IntVarStructDict)
        T_IntVarStructDict = ::Ice::__defineDictionary('::Test::IntVarStructDict', ::Ice::T_int, ::Test::T_VarStruct)
    end

    if not defined?(::Test::T_IntOneOptionalDict)
        T_IntOneOptionalDict = ::Ice::__defineDictionary('::Test::IntOneOptionalDict', ::Ice::T_int, ::Test::T_OneOptional)
    end

    if not defined?(::Test::T_IntMyInterfacePrxDict)
        T_IntMyInterfacePrxDict = ::Ice::__defineDictionary('::Test::IntMyInterfacePrxDict', ::Ice::T_int, ::Test::T_MyInterfacePrx)
    end

    if not defined?(::Test::MultiOptional_Mixin)

        module ::Test::MultiOptional_Mixin
        end
        class MultiOptional < ::Ice::Value

            def initialize(a=::Ice::Unset, b=::Ice::Unset, c=::Ice::Unset, d=::Ice::Unset, e=::Ice::Unset, f=::Ice::Unset, g=::Ice::Unset, h=::Ice::Unset, i=::Ice::Unset, j=::Ice::Unset, k=::Ice::Unset, bs=::Ice::Unset, ss=::Ice::Unset, iid=::Ice::Unset, sid=::Ice::Unset, fs=::Ice::Unset, vs=::Ice::Unset, shs=::Ice::Unset, es=::Ice::Unset, fss=::Ice::Unset, vss=::Ice::Unset, oos=::Ice::Unset, mips=::Ice::Unset, ied=::Ice::Unset, ifsd=::Ice::Unset, ivsd=::Ice::Unset, iood=::Ice::Unset, imipd=::Ice::Unset, bos=::Ice::Unset, ser=::Ice::Unset)
                @a = a
                @b = b
                @c = c
                @d = d
                @e = e
                @f = f
                @g = g
                @h = h
                @i = i
                @j = j
                @k = k
                @bs = bs
                @ss = ss
                @iid = iid
                @sid = sid
                @fs = fs
                @vs = vs
                @shs = shs
                @es = es
                @fss = fss
                @vss = vss
                @oos = oos
                @mips = mips
                @ied = ied
                @ifsd = ifsd
                @ivsd = ivsd
                @iood = iood
                @imipd = imipd
                @bos = bos
                @ser = ser
            end

            attr_accessor :a, :b, :c, :d, :e, :f, :g, :h, :i, :j, :k, :bs, :ss, :iid, :sid, :fs, :vs, :shs, :es, :fss, :vss, :oos, :mips, :ied, :ifsd, :ivsd, :iood, :imipd, :bos, :ser
        end

        if not defined?(::Test::T_MultiOptional)
            T_MultiOptional = ::Ice::__declareClass('::Test::MultiOptional')
        end

        T_MultiOptional.defineClass(MultiOptional, -1, false, nil, [
            ['a', ::Ice::T_byte, true, 1],
            ['b', ::Ice::T_bool, true, 2],
            ['c', ::Ice::T_short, true, 3],
            ['d', ::Ice::T_int, true, 4],
            ['e', ::Ice::T_long, true, 5],
            ['f', ::Ice::T_float, true, 6],
            ['g', ::Ice::T_double, true, 7],
            ['h', ::Ice::T_string, true, 8],
            ['i', ::Test::T_MyEnum, true, 9],
            ['j', ::Test::T_MyInterfacePrx, true, 10],
            ['k', ::Test::T_MultiOptional, true, 11],
            ['bs', ::Test::T_ByteSeq, true, 12],
            ['ss', ::Test::T_StringSeq, true, 13],
            ['iid', ::Test::T_IntIntDict, true, 14],
            ['sid', ::Test::T_StringIntDict, true, 15],
            ['fs', ::Test::T_FixedStruct, true, 16],
            ['vs', ::Test::T_VarStruct, true, 17],
            ['shs', ::Test::T_ShortSeq, true, 18],
            ['es', ::Test::T_MyEnumSeq, true, 19],
            ['fss', ::Test::T_FixedStructSeq, true, 20],
            ['vss', ::Test::T_VarStructSeq, true, 21],
            ['oos', ::Test::T_OneOptionalSeq, true, 22],
            ['mips', ::Test::T_MyInterfacePrxSeq, true, 23],
            ['ied', ::Test::T_IntEnumDict, true, 24],
            ['ifsd', ::Test::T_IntFixedStructDict, true, 25],
            ['ivsd', ::Test::T_IntVarStructDict, true, 26],
            ['iood', ::Test::T_IntOneOptionalDict, true, 27],
            ['imipd', ::Test::T_IntMyInterfacePrxDict, true, 28],
            ['bos', ::Test::T_BoolSeq, true, 29],
            ['ser', ::Test::T_Serializable, true, 30]
        ])
    end

    if not defined?(::Test::A_Mixin)

        module ::Test::A_Mixin
        end
        class A < ::Ice::Value

            def initialize(requiredA=0, ma=::Ice::Unset, mb=::Ice::Unset, mc=::Ice::Unset)
                @requiredA = requiredA
                @ma = ma
                @mb = mb
                @mc = mc
            end

            attr_accessor :requiredA, :ma, :mb, :mc
        end

        if not defined?(::Test::T_A)
            T_A = ::Ice::__declareClass('::Test::A')
        end

        T_A.defineClass(A, -1, false, nil, [
            ['requiredA', ::Ice::T_int, false, 0],
            ['ma', ::Ice::T_int, true, 1],
            ['mb', ::Ice::T_int, true, 50],
            ['mc', ::Ice::T_int, true, 500]
        ])
    end

    if not defined?(::Test::B_Mixin)

        module ::Test::B_Mixin
        end
        class B < ::Test::A

            def initialize(requiredA=0, ma=::Ice::Unset, mb=::Ice::Unset, mc=::Ice::Unset, requiredB=0, md=::Ice::Unset)
                super(requiredA, ma, mb, mc)
                @requiredB = requiredB
                @md = md
            end

            attr_accessor :requiredB, :md
        end

        if not defined?(::Test::T_B)
            T_B = ::Ice::__declareClass('::Test::B')
        end

        T_B.defineClass(B, -1, false, ::Test::T_A, [
            ['requiredB', ::Ice::T_int, false, 0],
            ['md', ::Ice::T_int, true, 10]
        ])
    end

    if not defined?(::Test::C_Mixin)

        module ::Test::C_Mixin
        end
        class C < ::Test::B

            def initialize(requiredA=0, ma=::Ice::Unset, mb=::Ice::Unset, mc=::Ice::Unset, requiredB=0, md=::Ice::Unset, ss='', ms=::Ice::Unset)
                super(requiredA, ma, mb, mc, requiredB, md)
                @ss = ss
                @ms = ms
            end

            attr_accessor :ss, :ms
        end

        if not defined?(::Test::T_C)
            T_C = ::Ice::__declareClass('::Test::C')
        end

        T_C.defineClass(C, -1, false, ::Test::T_B, [
            ['ss', ::Ice::T_string, false, 0],
            ['ms', ::Ice::T_string, true, 890]
        ])
    end

    if not defined?(::Test::WD_Mixin)

        module ::Test::WD_Mixin
        end
        class WD < ::Ice::Value

            def initialize(a=5, s="test")
                @a = a
                @s = s
            end

            attr_accessor :a, :s
        end

        if not defined?(::Test::T_WD)
            T_WD = ::Ice::__declareClass('::Test::WD')
        end

        T_WD.defineClass(WD, -1, false, nil, [
            ['a', ::Ice::T_int, true, 1],
            ['s', ::Ice::T_string, true, 2]
        ])
    end

    if not defined?(::Test::OptionalException)
        class OptionalException < Ice::UserException
            def initialize(req=false, a=5, b=::Ice::Unset, o=::Ice::Unset)
                @req = req
                @a = a
                @b = b
                @o = o
            end

            def to_s
                '::Test::OptionalException'
            end

            attr_accessor :req, :a, :b, :o
        end

        T_OptionalException = ::Ice::__defineException('::Test::OptionalException', OptionalException, nil, [
            ["req", ::Ice::T_bool, false, 0],
            ["a", ::Ice::T_int, true, 1],
            ["b", ::Ice::T_string, true, 2],
            ["o", ::Test::T_OneOptional, true, 50]
        ])
    end

    if not defined?(::Test::DerivedException)
        class DerivedException < ::Test::OptionalException
            def initialize(req=false, a=5, b=::Ice::Unset, o=::Ice::Unset, d1='', ss="test", o2=::Ice::Unset, d2='')
                super(req, a, b, o)
                @d1 = d1
                @ss = ss
                @o2 = o2
                @d2 = d2
            end

            def to_s
                '::Test::DerivedException'
            end

            attr_accessor :d1, :ss, :o2, :d2
        end

        T_DerivedException = ::Ice::__defineException('::Test::DerivedException', DerivedException, ::Test::T_OptionalException, [
            ["d1", ::Ice::T_string, false, 0],
            ["ss", ::Ice::T_string, true, 600],
            ["o2", ::Test::T_OneOptional, true, 601],
            ["d2", ::Ice::T_string, false, 0]
        ])
    end

    if not defined?(::Test::RequiredException)
        class RequiredException < ::Test::OptionalException
            def initialize(req=false, a=5, b=::Ice::Unset, o=::Ice::Unset, ss="test", o2=nil)
                super(req, a, b, o)
                @ss = ss
                @o2 = o2
            end

            def to_s
                '::Test::RequiredException'
            end

            attr_accessor :ss, :o2
        end

        T_RequiredException = ::Ice::__defineException('::Test::RequiredException', RequiredException, ::Test::T_OptionalException, [
            ["ss", ::Ice::T_string, false, 0],
            ["o2", ::Test::T_OneOptional, false, 0]
        ])
    end

    if not defined?(::Test::OptionalWithCustom_Mixin)

        module ::Test::OptionalWithCustom_Mixin
        end
        class OptionalWithCustom < ::Ice::Value

            def initialize(l=::Ice::Unset, lp=::Ice::Unset, s=::Ice::Unset)
                @l = l
                @lp = lp
                @s = s
            end

            attr_accessor :l, :lp, :s
            protected :lp, :lp=
        end

        if not defined?(::Test::T_OptionalWithCustom)
            T_OptionalWithCustom = ::Ice::__declareClass('::Test::OptionalWithCustom')
        end

        T_OptionalWithCustom.defineClass(OptionalWithCustom, -1, false, nil, [
            ['l', ::Test::T_SmallStructList, true, 1],
            ['lp', ::Test::T_SmallStructList, true, 2],
            ['s', ::Test::T_ClassVarStruct, true, 3]
        ])
    end

    if not defined?(::Test::E_Mixin)

        module ::Test::E_Mixin
        end
        class E < ::Ice::Value

            def initialize(ae=nil)
                @ae = ae
            end

            attr_accessor :ae
        end

        if not defined?(::Test::T_E)
            T_E = ::Ice::__declareClass('::Test::E')
        end

        T_E.defineClass(E, -1, false, nil, [['ae', ::Test::T_A, false, 0]])
    end

    if not defined?(::Test::F_Mixin)

        module ::Test::F_Mixin
        end
        class F < ::Test::E

            def initialize(ae=nil, af=::Ice::Unset)
                super(ae)
                @af = af
            end

            attr_accessor :af
        end

        if not defined?(::Test::T_F)
            T_F = ::Ice::__declareClass('::Test::F')
        end

        T_F.defineClass(F, -1, false, ::Test::T_E, [['af', ::Test::T_A, true, 1]])
    end

    if not defined?(::Test::G1_Mixin)

        module ::Test::G1_Mixin
        end
        class G1 < ::Ice::Value

            def initialize(a='')
                @a = a
            end

            attr_accessor :a
        end

        if not defined?(::Test::T_G1)
            T_G1 = ::Ice::__declareClass('::Test::G1')
        end

        T_G1.defineClass(G1, -1, false, nil, [['a', ::Ice::T_string, false, 0]])
    end

    if not defined?(::Test::G2_Mixin)

        module ::Test::G2_Mixin
        end
        class G2 < ::Ice::Value

            def initialize(a=0)
                @a = a
            end

            attr_accessor :a
        end

        if not defined?(::Test::T_G2)
            T_G2 = ::Ice::__declareClass('::Test::G2')
        end

        T_G2.defineClass(G2, -1, false, nil, [['a', ::Ice::T_long, false, 0]])
    end

    if not defined?(::Test::G_Mixin)

        module ::Test::G_Mixin
        end
        class G < ::Ice::Value

            def initialize(gg1Opt=::Ice::Unset, gg2=nil, gg2Opt=::Ice::Unset, gg1=nil)
                @gg1Opt = gg1Opt
                @gg2 = gg2
                @gg2Opt = gg2Opt
                @gg1 = gg1
            end

            attr_accessor :gg1Opt, :gg2, :gg2Opt, :gg1
        end

        if not defined?(::Test::T_G)
            T_G = ::Ice::__declareClass('::Test::G')
        end

        T_G.defineClass(G, -1, false, nil, [
            ['gg1Opt', ::Test::T_G1, true, 1],
            ['gg2', ::Test::T_G2, false, 0],
            ['gg2Opt', ::Test::T_G2, true, 0],
            ['gg1', ::Test::T_G1, false, 0]
        ])
    end

    if not defined?(::Test::T_Recursive)
        T_Recursive = ::Ice::__declareClass('::Test::Recursive')
    end

    if not defined?(::Test::T_RecursiveSeq)
        T_RecursiveSeq = ::Ice::__defineSequence('::Test::RecursiveSeq', ::Test::T_Recursive)
    end

    if not defined?(::Test::Recursive_Mixin)

        module ::Test::Recursive_Mixin
        end
        class Recursive < ::Ice::Value

            def initialize(value=::Ice::Unset)
                @value = value
            end

            attr_accessor :value
        end

        if not defined?(::Test::T_Recursive)
            T_Recursive = ::Ice::__declareClass('::Test::Recursive')
        end

        T_Recursive.defineClass(Recursive, -1, false, nil, [['value', ::Test::T_RecursiveSeq, true, 0]])
    end

    if not defined?(::Test::Initial_Mixin)

        module ::Test::Initial_Mixin
        end
        module InitialPrx_mixin

            def shutdown(context=nil)
                InitialPrx_mixin::OP_shutdown.invoke(self, [], context)
            end

            def pingPong(o, context=nil)
                InitialPrx_mixin::OP_pingPong.invoke(self, [o], context)
            end

            def opOptionalException(a, b, o, context=nil)
                InitialPrx_mixin::OP_opOptionalException.invoke(self, [a, b, o], context)
            end

            def opDerivedException(a, b, o, context=nil)
                InitialPrx_mixin::OP_opDerivedException.invoke(self, [a, b, o], context)
            end

            def opRequiredException(a, b, o, context=nil)
                InitialPrx_mixin::OP_opRequiredException.invoke(self, [a, b, o], context)
            end

            def opByte(p1, context=nil)
                InitialPrx_mixin::OP_opByte.invoke(self, [p1], context)
            end

            def opBool(p1, context=nil)
                InitialPrx_mixin::OP_opBool.invoke(self, [p1], context)
            end

            def opShort(p1, context=nil)
                InitialPrx_mixin::OP_opShort.invoke(self, [p1], context)
            end

            def opInt(p1, context=nil)
                InitialPrx_mixin::OP_opInt.invoke(self, [p1], context)
            end

            def opLong(p1, context=nil)
                InitialPrx_mixin::OP_opLong.invoke(self, [p1], context)
            end

            def opFloat(p1, context=nil)
                InitialPrx_mixin::OP_opFloat.invoke(self, [p1], context)
            end

            def opDouble(p1, context=nil)
                InitialPrx_mixin::OP_opDouble.invoke(self, [p1], context)
            end

            def opString(p1, context=nil)
                InitialPrx_mixin::OP_opString.invoke(self, [p1], context)
            end

            def opMyEnum(p1, context=nil)
                InitialPrx_mixin::OP_opMyEnum.invoke(self, [p1], context)
            end

            def opSmallStruct(p1, context=nil)
                InitialPrx_mixin::OP_opSmallStruct.invoke(self, [p1], context)
            end

            def opFixedStruct(p1, context=nil)
                InitialPrx_mixin::OP_opFixedStruct.invoke(self, [p1], context)
            end

            def opVarStruct(p1, context=nil)
                InitialPrx_mixin::OP_opVarStruct.invoke(self, [p1], context)
            end

            def opOneOptional(p1, context=nil)
                InitialPrx_mixin::OP_opOneOptional.invoke(self, [p1], context)
            end

            def opMyInterfaceProxy(p1, context=nil)
                InitialPrx_mixin::OP_opMyInterfaceProxy.invoke(self, [p1], context)
            end

            def opByteSeq(p1, context=nil)
                InitialPrx_mixin::OP_opByteSeq.invoke(self, [p1], context)
            end

            def opBoolSeq(p1, context=nil)
                InitialPrx_mixin::OP_opBoolSeq.invoke(self, [p1], context)
            end

            def opShortSeq(p1, context=nil)
                InitialPrx_mixin::OP_opShortSeq.invoke(self, [p1], context)
            end

            def opIntSeq(p1, context=nil)
                InitialPrx_mixin::OP_opIntSeq.invoke(self, [p1], context)
            end

            def opLongSeq(p1, context=nil)
                InitialPrx_mixin::OP_opLongSeq.invoke(self, [p1], context)
            end

            def opFloatSeq(p1, context=nil)
                InitialPrx_mixin::OP_opFloatSeq.invoke(self, [p1], context)
            end

            def opDoubleSeq(p1, context=nil)
                InitialPrx_mixin::OP_opDoubleSeq.invoke(self, [p1], context)
            end

            def opStringSeq(p1, context=nil)
                InitialPrx_mixin::OP_opStringSeq.invoke(self, [p1], context)
            end

            def opSmallStructSeq(p1, context=nil)
                InitialPrx_mixin::OP_opSmallStructSeq.invoke(self, [p1], context)
            end

            def opSmallStructList(p1, context=nil)
                InitialPrx_mixin::OP_opSmallStructList.invoke(self, [p1], context)
            end

            def opFixedStructSeq(p1, context=nil)
                InitialPrx_mixin::OP_opFixedStructSeq.invoke(self, [p1], context)
            end

            def opFixedStructList(p1, context=nil)
                InitialPrx_mixin::OP_opFixedStructList.invoke(self, [p1], context)
            end

            def opVarStructSeq(p1, context=nil)
                InitialPrx_mixin::OP_opVarStructSeq.invoke(self, [p1], context)
            end

            def opSerializable(p1, context=nil)
                InitialPrx_mixin::OP_opSerializable.invoke(self, [p1], context)
            end

            def opIntIntDict(p1, context=nil)
                InitialPrx_mixin::OP_opIntIntDict.invoke(self, [p1], context)
            end

            def opStringIntDict(p1, context=nil)
                InitialPrx_mixin::OP_opStringIntDict.invoke(self, [p1], context)
            end

            def opIntOneOptionalDict(p1, context=nil)
                InitialPrx_mixin::OP_opIntOneOptionalDict.invoke(self, [p1], context)
            end

            def opClassAndUnknownOptional(p, context=nil)
                InitialPrx_mixin::OP_opClassAndUnknownOptional.invoke(self, [p], context)
            end

            def sendOptionalClass(req, o, context=nil)
                InitialPrx_mixin::OP_sendOptionalClass.invoke(self, [req, o], context)
            end

            def returnOptionalClass(req, context=nil)
                InitialPrx_mixin::OP_returnOptionalClass.invoke(self, [req], context)
            end

            def opG(g, context=nil)
                InitialPrx_mixin::OP_opG.invoke(self, [g], context)
            end

            def opVoid(context=nil)
                InitialPrx_mixin::OP_opVoid.invoke(self, [], context)
            end

            def opMStruct1(context=nil)
                InitialPrx_mixin::OP_opMStruct1.invoke(self, [], context)
            end

            def opMStruct2(p1, context=nil)
                InitialPrx_mixin::OP_opMStruct2.invoke(self, [p1], context)
            end

            def opMSeq1(context=nil)
                InitialPrx_mixin::OP_opMSeq1.invoke(self, [], context)
            end

            def opMSeq2(p1, context=nil)
                InitialPrx_mixin::OP_opMSeq2.invoke(self, [p1], context)
            end

            def opMDict1(context=nil)
                InitialPrx_mixin::OP_opMDict1.invoke(self, [], context)
            end

            def opMDict2(p1, context=nil)
                InitialPrx_mixin::OP_opMDict2.invoke(self, [p1], context)
            end

            def opMG1(context=nil)
                InitialPrx_mixin::OP_opMG1.invoke(self, [], context)
            end

            def opMG2(p1, context=nil)
                InitialPrx_mixin::OP_opMG2.invoke(self, [p1], context)
            end

            def supportsRequiredParams(context=nil)
                InitialPrx_mixin::OP_supportsRequiredParams.invoke(self, [], context)
            end

            def supportsJavaSerializable(context=nil)
                InitialPrx_mixin::OP_supportsJavaSerializable.invoke(self, [], context)
            end

            def supportsCsharpSerializable(context=nil)
                InitialPrx_mixin::OP_supportsCsharpSerializable.invoke(self, [], context)
            end

            def supportsNullOptional(context=nil)
                InitialPrx_mixin::OP_supportsNullOptional.invoke(self, [], context)
            end
        end

        class InitialPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include InitialPrx_mixin
        end

        if not defined?(::Test::T_InitialPrx)
            T_Initial = ::Ice::__declareClass('::Test::Initial')
            T_InitialPrx = ::Ice::__declareProxy('::Test::Initial')
        end

        T_InitialPrx.defineProxy(InitialPrx, nil, [])

        InitialPrx_mixin::OP_shutdown = ::Ice::__defineOperation('shutdown', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
        InitialPrx_mixin::OP_pingPong = ::Ice::__defineOperation('pingPong', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_Value, false, 0]], [], [::Ice::T_Value, false, 0], [])
        InitialPrx_mixin::OP_opOptionalException = ::Ice::__defineOperation('opOptionalException', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, true, 1], [::Ice::T_string, true, 2], [::Test::T_OneOptional, true, 3]], [], nil, [::Test::T_OptionalException])
        InitialPrx_mixin::OP_opDerivedException = ::Ice::__defineOperation('opDerivedException', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, true, 1], [::Ice::T_string, true, 2], [::Test::T_OneOptional, true, 3]], [], nil, [::Test::T_OptionalException])
        InitialPrx_mixin::OP_opRequiredException = ::Ice::__defineOperation('opRequiredException', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, true, 1], [::Ice::T_string, true, 2], [::Test::T_OneOptional, true, 3]], [], nil, [::Test::T_OptionalException])
        InitialPrx_mixin::OP_opByte = ::Ice::__defineOperation('opByte', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_byte, true, 2]], [[::Ice::T_byte, true, 3]], [::Ice::T_byte, true, 1], [])
        InitialPrx_mixin::OP_opBool = ::Ice::__defineOperation('opBool', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_bool, true, 2]], [[::Ice::T_bool, true, 3]], [::Ice::T_bool, true, 1], [])
        InitialPrx_mixin::OP_opShort = ::Ice::__defineOperation('opShort', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_short, true, 2]], [[::Ice::T_short, true, 3]], [::Ice::T_short, true, 1], [])
        InitialPrx_mixin::OP_opInt = ::Ice::__defineOperation('opInt', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, true, 2]], [[::Ice::T_int, true, 3]], [::Ice::T_int, true, 1], [])
        InitialPrx_mixin::OP_opLong = ::Ice::__defineOperation('opLong', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_long, true, 1]], [[::Ice::T_long, true, 2]], [::Ice::T_long, true, 3], [])
        InitialPrx_mixin::OP_opFloat = ::Ice::__defineOperation('opFloat', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_float, true, 2]], [[::Ice::T_float, true, 3]], [::Ice::T_float, true, 1], [])
        InitialPrx_mixin::OP_opDouble = ::Ice::__defineOperation('opDouble', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_double, true, 2]], [[::Ice::T_double, true, 3]], [::Ice::T_double, true, 1], [])
        InitialPrx_mixin::OP_opString = ::Ice::__defineOperation('opString', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_string, true, 2]], [[::Ice::T_string, true, 3]], [::Ice::T_string, true, 1], [])
        InitialPrx_mixin::OP_opMyEnum = ::Ice::__defineOperation('opMyEnum', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_MyEnum, true, 2]], [[::Test::T_MyEnum, true, 3]], [::Test::T_MyEnum, true, 1], [])
        InitialPrx_mixin::OP_opSmallStruct = ::Ice::__defineOperation('opSmallStruct', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_SmallStruct, true, 2]], [[::Test::T_SmallStruct, true, 3]], [::Test::T_SmallStruct, true, 1], [])
        InitialPrx_mixin::OP_opFixedStruct = ::Ice::__defineOperation('opFixedStruct', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_FixedStruct, true, 2]], [[::Test::T_FixedStruct, true, 3]], [::Test::T_FixedStruct, true, 1], [])
        InitialPrx_mixin::OP_opVarStruct = ::Ice::__defineOperation('opVarStruct', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_VarStruct, true, 2]], [[::Test::T_VarStruct, true, 3]], [::Test::T_VarStruct, true, 1], [])
        InitialPrx_mixin::OP_opOneOptional = ::Ice::__defineOperation('opOneOptional', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_OneOptional, true, 2]], [[::Test::T_OneOptional, true, 3]], [::Test::T_OneOptional, true, 1], [])
        InitialPrx_mixin::OP_opMyInterfaceProxy = ::Ice::__defineOperation('opMyInterfaceProxy', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_MyInterfacePrx, true, 2]], [[::Test::T_MyInterfacePrx, true, 3]], [::Test::T_MyInterfacePrx, true, 1], [])
        InitialPrx_mixin::OP_opByteSeq = ::Ice::__defineOperation('opByteSeq', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_ByteSeq, true, 2]], [[::Test::T_ByteSeq, true, 3]], [::Test::T_ByteSeq, true, 1], [])
        InitialPrx_mixin::OP_opBoolSeq = ::Ice::__defineOperation('opBoolSeq', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_BoolSeq, true, 2]], [[::Test::T_BoolSeq, true, 3]], [::Test::T_BoolSeq, true, 1], [])
        InitialPrx_mixin::OP_opShortSeq = ::Ice::__defineOperation('opShortSeq', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_ShortSeq, true, 2]], [[::Test::T_ShortSeq, true, 3]], [::Test::T_ShortSeq, true, 1], [])
        InitialPrx_mixin::OP_opIntSeq = ::Ice::__defineOperation('opIntSeq', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_IntSeq, true, 2]], [[::Test::T_IntSeq, true, 3]], [::Test::T_IntSeq, true, 1], [])
        InitialPrx_mixin::OP_opLongSeq = ::Ice::__defineOperation('opLongSeq', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_LongSeq, true, 2]], [[::Test::T_LongSeq, true, 3]], [::Test::T_LongSeq, true, 1], [])
        InitialPrx_mixin::OP_opFloatSeq = ::Ice::__defineOperation('opFloatSeq', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_FloatSeq, true, 2]], [[::Test::T_FloatSeq, true, 3]], [::Test::T_FloatSeq, true, 1], [])
        InitialPrx_mixin::OP_opDoubleSeq = ::Ice::__defineOperation('opDoubleSeq', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_DoubleSeq, true, 2]], [[::Test::T_DoubleSeq, true, 3]], [::Test::T_DoubleSeq, true, 1], [])
        InitialPrx_mixin::OP_opStringSeq = ::Ice::__defineOperation('opStringSeq', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_StringSeq, true, 2]], [[::Test::T_StringSeq, true, 3]], [::Test::T_StringSeq, true, 1], [])
        InitialPrx_mixin::OP_opSmallStructSeq = ::Ice::__defineOperation('opSmallStructSeq', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_SmallStructSeq, true, 2]], [[::Test::T_SmallStructSeq, true, 3]], [::Test::T_SmallStructSeq, true, 1], [])
        InitialPrx_mixin::OP_opSmallStructList = ::Ice::__defineOperation('opSmallStructList', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_SmallStructList, true, 2]], [[::Test::T_SmallStructList, true, 3]], [::Test::T_SmallStructList, true, 1], [])
        InitialPrx_mixin::OP_opFixedStructSeq = ::Ice::__defineOperation('opFixedStructSeq', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_FixedStructSeq, true, 2]], [[::Test::T_FixedStructSeq, true, 3]], [::Test::T_FixedStructSeq, true, 1], [])
        InitialPrx_mixin::OP_opFixedStructList = ::Ice::__defineOperation('opFixedStructList', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_FixedStructList, true, 2]], [[::Test::T_FixedStructList, true, 3]], [::Test::T_FixedStructList, true, 1], [])
        InitialPrx_mixin::OP_opVarStructSeq = ::Ice::__defineOperation('opVarStructSeq', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_VarStructSeq, true, 2]], [[::Test::T_VarStructSeq, true, 3]], [::Test::T_VarStructSeq, true, 1], [])
        InitialPrx_mixin::OP_opSerializable = ::Ice::__defineOperation('opSerializable', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_Serializable, true, 2]], [[::Test::T_Serializable, true, 3]], [::Test::T_Serializable, true, 1], [])
        InitialPrx_mixin::OP_opIntIntDict = ::Ice::__defineOperation('opIntIntDict', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_IntIntDict, true, 2]], [[::Test::T_IntIntDict, true, 3]], [::Test::T_IntIntDict, true, 1], [])
        InitialPrx_mixin::OP_opStringIntDict = ::Ice::__defineOperation('opStringIntDict', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_StringIntDict, true, 2]], [[::Test::T_StringIntDict, true, 3]], [::Test::T_StringIntDict, true, 1], [])
        InitialPrx_mixin::OP_opIntOneOptionalDict = ::Ice::__defineOperation('opIntOneOptionalDict', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_IntOneOptionalDict, true, 2]], [[::Test::T_IntOneOptionalDict, true, 3]], [::Test::T_IntOneOptionalDict, true, 1], [])
        InitialPrx_mixin::OP_opClassAndUnknownOptional = ::Ice::__defineOperation('opClassAndUnknownOptional', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_A, false, 0]], [], nil, [])
        InitialPrx_mixin::OP_sendOptionalClass = ::Ice::__defineOperation('sendOptionalClass', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_bool, false, 0], [::Test::T_OneOptional, true, 1]], [], nil, [])
        InitialPrx_mixin::OP_returnOptionalClass = ::Ice::__defineOperation('returnOptionalClass', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_bool, false, 0]], [[::Test::T_OneOptional, true, 1]], nil, [])
        InitialPrx_mixin::OP_opG = ::Ice::__defineOperation('opG', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_G, false, 0]], [], [::Test::T_G, false, 0], [])
        InitialPrx_mixin::OP_opVoid = ::Ice::__defineOperation('opVoid', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
        InitialPrx_mixin::OP_opMStruct1 = ::Ice::__defineOperation('opMStruct1', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], [::Test::T_SmallStruct, true, 1], [])
        InitialPrx_mixin::OP_opMStruct2 = ::Ice::__defineOperation('opMStruct2', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_SmallStruct, true, 2]], [[::Test::T_SmallStruct, true, 3]], [::Test::T_SmallStruct, true, 1], [])
        InitialPrx_mixin::OP_opMSeq1 = ::Ice::__defineOperation('opMSeq1', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], [::Test::T_StringSeq, true, 1], [])
        InitialPrx_mixin::OP_opMSeq2 = ::Ice::__defineOperation('opMSeq2', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_StringSeq, true, 2]], [[::Test::T_StringSeq, true, 3]], [::Test::T_StringSeq, true, 1], [])
        InitialPrx_mixin::OP_opMDict1 = ::Ice::__defineOperation('opMDict1', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], [::Test::T_StringIntDict, true, 1], [])
        InitialPrx_mixin::OP_opMDict2 = ::Ice::__defineOperation('opMDict2', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_StringIntDict, true, 2]], [[::Test::T_StringIntDict, true, 3]], [::Test::T_StringIntDict, true, 1], [])
        InitialPrx_mixin::OP_opMG1 = ::Ice::__defineOperation('opMG1', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], [::Test::T_G, true, 1], [])
        InitialPrx_mixin::OP_opMG2 = ::Ice::__defineOperation('opMG2', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Test::T_G, true, 2]], [[::Test::T_G, true, 3]], [::Test::T_G, true, 1], [])
        InitialPrx_mixin::OP_supportsRequiredParams = ::Ice::__defineOperation('supportsRequiredParams', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], [::Ice::T_bool, false, 0], [])
        InitialPrx_mixin::OP_supportsJavaSerializable = ::Ice::__defineOperation('supportsJavaSerializable', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], [::Ice::T_bool, false, 0], [])
        InitialPrx_mixin::OP_supportsCsharpSerializable = ::Ice::__defineOperation('supportsCsharpSerializable', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], [::Ice::T_bool, false, 0], [])
        InitialPrx_mixin::OP_supportsNullOptional = ::Ice::__defineOperation('supportsNullOptional', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], [::Ice::T_bool, false, 0], [])
    end
end
