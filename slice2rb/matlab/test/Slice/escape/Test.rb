# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file `Test.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'

module ::Classdef

    module Break

        if not defined?(::Classdef::Break::Bitand)
            class Bitand
                include Comparable

                def initialize(name, value)
                    @name = name
                    @value = value
                end

                def Bitand.from_int(val)
                    @@_enumerators[val]
                end

                def to_s
                    @name
                end

                def to_i
                    @value
                end

                def <=>(other)
                    other.is_a?(Bitand) or raise ArgumentError, "value must be a Bitand"
                    @value <=> other.to_i
                end

                def hash
                    @value.hash
                end

                def Bitand.each(&block)
                    @@_enumerators.each_value(&block)
                end

                Break = Bitand.new("break", 0)
                Case = Bitand.new("case", 1)
                Catch = Bitand.new("catch", 2)
                Classdef = Bitand.new("classdef", 3)
                Continue = Bitand.new("continue", 4)
                Else = Bitand.new("else", 5)
                Elseif = Bitand.new("elseif", 6)
                End = Bitand.new("end", 7)
                Enumeration = Bitand.new("enumeration", 8)
                Events = Bitand.new("events", 9)
                For = Bitand.new("for", 10)
                Function = Bitand.new("function", 11)
                Global = Bitand.new("global", 12)
                If = Bitand.new("if", 13)
                Methods = Bitand.new("methods", 14)
                Otherwise = Bitand.new("otherwise", 15)
                Parfor = Bitand.new("parfor", 16)
                Persistent = Bitand.new("persistent", 17)
                Properties = Bitand.new("properties", 18)
                Return = Bitand.new("return", 19)
                Spmd = Bitand.new("spmd", 20)
                Switch = Bitand.new("switch", 21)
                Try = Bitand.new("try", 22)
                While = Bitand.new("while", 23)
                Abs = Bitand.new("abs", 24)
                And = Bitand.new("and", 25)
                Char = Bitand.new("char", 26)
                Eq = Bitand.new("eq", 27)
                Length = Bitand.new("length", 28)
                Size = Bitand.new("size", 29)
                Xor = Bitand.new("xor", 30)
                LAST = Bitand.new("LAST", 31)

                @@_enumerators = {0=>Break, 1=>Case, 2=>Catch, 3=>Classdef, 4=>Continue, 5=>Else, 6=>Elseif, 7=>End, 8=>Enumeration, 9=>Events, 10=>For, 11=>Function, 12=>Global, 13=>If, 14=>Methods, 15=>Otherwise, 16=>Parfor, 17=>Persistent, 18=>Properties, 19=>Return, 20=>Spmd, 21=>Switch, 22=>Try, 23=>While, 24=>Abs, 25=>And, 26=>Char, 27=>Eq, 28=>Length, 29=>Size, 30=>Xor, 31=>LAST}

                def Bitand._enumerators
                    @@_enumerators
                end

                private_class_method :new
            end

            T_Bitand = ::Ice::__defineEnum('::classdef::break::bitand', Bitand, Bitand::_enumerators)
        end

        if not defined?(::Classdef::Break::Bitor)
            class Bitor
                include ::Ice::Inspect_mixin
                def initialize(_case=::Classdef::Break::Bitand::Catch, continue=1, eq=2, ne=3)
                    @_case = _case
                    @continue = continue
                    @eq = eq
                    @ne = ne
                end

                def hash
                    _h = 0
                    _h = 5 * _h + @_case.hash
                    _h = 5 * _h + @continue.hash
                    _h = 5 * _h + @eq.hash
                    _h = 5 * _h + @ne.hash
                    _h % 0x7fffffff
                end

                def ==(other)
                    return false if !other.is_a? ::Classdef::Break::Bitor or
                        @_case != other._case or
                        @continue != other.continue or
                        @eq != other.eq or
                        @ne != other.ne
                    true
                end

                def eql?(other)
                    return other.class == self.class && other == self
                end

                attr_accessor :_case, :continue, :eq, :ne
            end

            T_Bitor = ::Ice::__defineStruct('::classdef::break::bitor', Bitor, [
                ["_case", ::Classdef::Break::T_Bitand],
                ["continue", ::Ice::T_int],
                ["eq", ::Ice::T_int],
                ["ne", ::Ice::T_int]
            ])
        end

        if not defined?(::Classdef::Break::Logical_Mixin)

            module ::Classdef::Break::Logical_Mixin
            end
            class Logical < ::Ice::Value

                def initialize(_else=::Classdef::Break::Bitand::Enumeration, _for=::Classdef::Break::Bitor.new, int64=true)
                    @_else = _else
                    @_for = _for
                    @int64 = int64
                end

                attr_accessor :_else, :_for, :int64
            end

            if not defined?(::Classdef::Break::T_Logical)
                T_Logical = ::Ice::__declareClass('::classdef::break::logical')
            end

            T_Logical.defineClass(Logical, -1, false, nil, [
                ['_else', ::Classdef::Break::T_Bitand, false, 0],
                ['_for', ::Classdef::Break::T_Bitor, false, 0],
                ['int64', ::Ice::T_bool, false, 0]
            ])
        end

        if not defined?(::Classdef::Break::Xor_Mixin)

            module ::Classdef::Break::Xor_Mixin
            end
            class Xor < ::Classdef::Break::Logical

                def initialize(_else=::Classdef::Break::Bitand::Enumeration, _for=::Classdef::Break::Bitor.new, int64=true, _return=1)
                    super(_else, _for, int64)
                    @_return = _return
                end

                attr_accessor :_return
            end

            if not defined?(::Classdef::Break::T_Xor)
                T_Xor = ::Ice::__declareClass('::classdef::break::xor')
            end

            T_Xor.defineClass(Xor, -1, false, ::Classdef::Break::T_Logical, [['_return', ::Ice::T_int, false, 0]])
        end

        if not defined?(::Classdef::Break::T_Parfor)
            T_Parfor = ::Ice::__defineSequence('::classdef::break::parfor', ::Classdef::Break::T_Bitor)
        end

        if not defined?(::Classdef::Break::T_Switch)
            T_Switch = ::Ice::__defineDictionary('::classdef::break::switch', ::Ice::T_int, ::Classdef::Break::T_Bitor)
        end

        if not defined?(::Classdef::Break::Try_Mixin)

            module ::Classdef::Break::Try_Mixin
            end
            class Try < ::Ice::Value

                def initialize(_while=1, delete=2)
                    @_while = _while
                    @delete = delete
                end

                attr_accessor :_while, :delete
            end

            if not defined?(::Classdef::Break::T_Try)
                T_Try = ::Ice::__declareClass('::classdef::break::try')
            end

            T_Try.defineClass(Try, -1, false, nil, [
                ['_while', ::Ice::T_int, false, 0],
                ['delete', ::Ice::T_int, false, 0]
            ])
        end

        if not defined?(::Classdef::Break::Properties_Mixin)

            module ::Classdef::Break::Properties_Mixin
            end
            class Properties < ::Classdef::Break::Try

                def initialize(_while=1, delete=2, _if=2, catch=nil, spmd=nil, otherwise=nil)
                    super(_while, delete)
                    @_if = _if
                    @catch = catch
                    @spmd = spmd
                    @otherwise = otherwise
                end

                attr_accessor :_if, :catch, :spmd, :otherwise
            end

            if not defined?(::Classdef::Break::T_Properties)
                T_Properties = ::Ice::__declareClass('::classdef::break::properties')
            end

            T_Properties.defineClass(Properties, -1, false, ::Classdef::Break::T_Try, [
                ['_if', ::Ice::T_int, false, 0],
                ['catch', ::Classdef::Break::T_Xor, false, 0],
                ['spmd', ::Classdef::Break::T_Parfor, false, 0],
                ['otherwise', ::Classdef::Break::T_Switch, false, 0]
            ])
        end

        if not defined?(::Classdef::Break::Persistent)
            class Persistent < Ice::UserException
                def initialize(identifier="1", message="2", stack="3", cause="4", type="5", _end=nil)
                    @identifier = identifier
                    @message = message
                    @stack = stack
                    @cause = cause
                    @type = type
                    @_end = _end
                end

                def to_s
                    '::classdef::break::persistent'
                end

                attr_accessor :identifier, :message, :stack, :cause, :type, :_end
            end

            T_Persistent = ::Ice::__defineException('::classdef::break::persistent', Persistent, nil, [
                ["identifier", ::Ice::T_string, false, 0],
                ["message", ::Ice::T_string, false, 0],
                ["stack", ::Ice::T_string, false, 0],
                ["cause", ::Ice::T_string, false, 0],
                ["type", ::Ice::T_string, false, 0],
                ["_end", ::Classdef::Break::T_Logical, false, 0]
            ])
        end

        if not defined?(::Classdef::Break::Global)
            class Global < ::Classdef::Break::Persistent
                def initialize(identifier="1", message="2", stack="3", cause="4", type="5", _end=nil, enumeration=1)
                    super(identifier, message, stack, cause, type, _end)
                    @enumeration = enumeration
                end

                def to_s
                    '::classdef::break::global'
                end

                attr_accessor :enumeration
            end

            T_Global = ::Ice::__defineException('::classdef::break::global', Global, ::Classdef::Break::T_Persistent, [["enumeration", ::Ice::T_int, false, 0]])
        end

        if not defined?(::Classdef::Break::Elseif_Mixin)

            module ::Classdef::Break::Elseif_Mixin
            end
            module ElseifPrx_mixin

                def events(context=nil)
                    ElseifPrx_mixin::OP_events.invoke(self, [], context)
                end

                def function(context=nil)
                    ElseifPrx_mixin::OP_function.invoke(self, [], context)
                end

                def delete(context=nil)
                    ElseifPrx_mixin::OP_delete.invoke(self, [], context)
                end

                def _checkedCast(context=nil)
                    ElseifPrx_mixin::OP_checkedCast.invoke(self, [], context)
                end
            end

            class ElseifPrx < ::Ice::ObjectPrx
                include ::Ice::Proxy_mixin
                include ElseifPrx_mixin
            end

            if not defined?(::Classdef::Break::T_ElseifPrx)
                T_Elseif = ::Ice::__declareClass('::classdef::break::elseif')
                T_ElseifPrx = ::Ice::__declareProxy('::classdef::break::elseif')
            end

            T_ElseifPrx.defineProxy(ElseifPrx, nil, [])

            ElseifPrx_mixin::OP_events = ::Ice::__defineOperation('events', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
            ElseifPrx_mixin::OP_function = ::Ice::__defineOperation('function', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
            ElseifPrx_mixin::OP_delete = ::Ice::__defineOperation('delete', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
            ElseifPrx_mixin::OP_checkedCast = ::Ice::__defineOperation('checkedCast', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
        end

        Methods = 1
    end
end
