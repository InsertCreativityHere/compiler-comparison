# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `Key.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'

module ::And

    if not defined?(::And::::Array)
        class Array
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def Array.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(Array) or raise ArgumentError, "value must be a Array"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def Array.each(&block)
                @@_enumerators.each_value(&block)
            end

            As = Array.new("as", 0)

            @@_enumerators = {0=>As}

            def Array._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_Array = ::Ice::__defineEnum('::and::array', Array, Array::_enumerators)
    end

    if not defined?(::And::::Xor)
        class Xor
            include ::Ice::Inspect_mixin
            def initialize(abstract=0, _clone=0, private=0, protected=0, public=0, this=0, throw=0, use=0, var=0)
                @abstract = abstract
                @_clone = _clone
                @private = private
                @protected = protected
                @public = public
                @this = this
                @throw = throw
                @use = use
                @var = var
            end

            def hash
                _h = 0
                _h = 5 * _h + @abstract.hash
                _h = 5 * _h + @_clone.hash
                _h = 5 * _h + @private.hash
                _h = 5 * _h + @protected.hash
                _h = 5 * _h + @public.hash
                _h = 5 * _h + @this.hash
                _h = 5 * _h + @throw.hash
                _h = 5 * _h + @use.hash
                _h = 5 * _h + @var.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::And::::Xor or
                    @abstract != other.abstract or
                    @_clone != other._clone or
                    @private != other.private or
                    @protected != other.protected or
                    @public != other.public or
                    @this != other.this or
                    @throw != other.throw or
                    @use != other.use or
                    @var != other.var
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :abstract, :_clone, :private, :protected, :public, :this, :throw, :use, :var
        end

        T_Xor = ::Ice::__defineStruct('::and::xor', Xor, [
            ["abstract", ::Ice::T_int],
            ["_clone", ::Ice::T_int],
            ["private", ::Ice::T_int],
            ["protected", ::Ice::T_int],
            ["public", ::Ice::T_int],
            ["this", ::Ice::T_int],
            ["throw", ::Ice::T_int],
            ["use", ::Ice::T_int],
            ["var", ::Ice::T_int]
        ])
    end

    if not defined?(::And::::Break_Mixin)

        module ::And::::Break_Mixin
        end
        module BreakPrx_mixin

            def _case(catch, context=nil)
                BreakPrx_mixin::OP_case.invoke(self, [catch], context)
            end
        end

        class BreakPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include BreakPrx_mixin
        end

        if not defined?(::And::::T_BreakPrx)
            T_Break = ::Ice::__declareClass('::and::break')
            T_BreakPrx = ::Ice::__declareProxy('::and::break')
        end

        T_Break.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_BreakPrx.defineProxy(BreakPrx, nil, [])

        BreakPrx_mixin::OP_case = ::Ice::__defineOperation('case', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, false, 0]], [[::Ice::T_int, false, 0]], nil, [])
    end

    if not defined?(::And::::Function_Mixin)

        module ::And::::Function_Mixin
        end
        module FunctionPrx_mixin

            def continue(declare, default, context=nil)
                FunctionPrx_mixin::OP_continue.invoke(self, [declare, default], context)
            end
        end

        class FunctionPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include FunctionPrx_mixin
        end

        if not defined?(::And::::T_FunctionPrx)
            T_Function = ::Ice::__declareClass('::and::function')
            T_FunctionPrx = ::Ice::__declareProxy('::and::function')
        end

        T_Function.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_FunctionPrx.defineProxy(FunctionPrx, nil, [])

        FunctionPrx_mixin::OP_continue = ::Ice::__defineOperation('continue', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, false, 0], [::Ice::T_int, false, 0]], [], nil, [])
    end

    if not defined?(::And::::Die_Mixin)

        module ::And::::Die_Mixin
        end
        module DiePrx_mixin

            def _do(context=nil)
                DiePrx_mixin::OP_do.invoke(self, [], context)
            end
        end

        class DiePrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include DiePrx_mixin
        end

        if not defined?(::And::::T_DiePrx)
            T_Die = ::Ice::__declareClass('::and::die')
            T_DiePrx = ::Ice::__declareProxy('::and::die')
        end

        T_Die.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_DiePrx.defineProxy(DiePrx, nil, [])

        DiePrx_mixin::OP_do = ::Ice::__defineOperation('do', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
    end

    if not defined?(::And::::Echo_Mixin)

        module ::And::::Echo_Mixin
        end
        class Echo < ::Ice::Value

            def initialize(_if=0, _else=0, elseif=nil, empty=0)
                @_if = _if
                @_else = _else
                @elseif = elseif
                @empty = empty
            end

            attr_accessor :_if, :_else, :elseif, :empty
        end

        if not defined?(::And::::T_Echo)
            T_Echo = ::Ice::__declareClass('::and::echo')
        end

        T_Echo.defineClass(Echo, -1, false, false, nil, [
            ['_if', ::Ice::T_int, false, 0],
            ['_else', ::Ice::T_int, false, 0],
            ['elseif', ::And::::T_DiePrx, false, 0],
            ['empty', ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::And::::Enddeclare_Mixin)

        module ::And::::Enddeclare_Mixin
        end
        module EnddeclarePrx_mixin
            include ::And::::DiePrx_mixin
            include ::And::::FunctionPrx_mixin
        end

        class EnddeclarePrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include EnddeclarePrx_mixin
        end

        if not defined?(::And::::T_EnddeclarePrx)
            T_Enddeclare = ::Ice::__declareClass('::and::enddeclare')
            T_EnddeclarePrx = ::Ice::__declareProxy('::and::enddeclare')
        end

        T_Enddeclare.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_EnddeclarePrx.defineProxy(EnddeclarePrx, nil, [::And::::T_DiePrx, ::And::::T_FunctionPrx])
    end

    if not defined?(::And::::T_Endfor)
        T_Endfor = ::Ice::__defineSequence('::and::endfor', ::And::::T_Array)
    end

    if not defined?(::And::::T_Endforeach)
        T_Endforeach = ::Ice::__defineDictionary('::and::endforeach', ::Ice::T_string, ::And::::T_Array)
    end

    if not defined?(::And::::Endif)
        class Endif < Ice::UserException
            def initialize(endswitch=0)
                @endswitch = endswitch
            end

            def to_s
                '::and::endif'
            end

            attr_accessor :endswitch
        end

        T_Endif = ::Ice::__defineException('::and::endif', Endif, false, nil, [["endswitch", ::Ice::T_int, false, 0]])
    end

    if not defined?(::And::::Endwhile)
        class Endwhile < ::And::::Endif
            def initialize(endswitch=0, eval=0, exit=0)
                super(endswitch)
                @eval = eval
                @exit = exit
            end

            def to_s
                '::and::endwhile'
            end

            attr_accessor :eval, :exit
        end

        T_Endwhile = ::Ice::__defineException('::and::endwhile', Endwhile, false, ::And::::T_Endif, [
            ["eval", ::Ice::T_int, false, 0],
            ["exit", ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::And::::T_For)
        T_For = ::Ice::__declareLocalClass('::and::for')
    end

    Or = 0

    Print = 0

    Require_once = 0
end
