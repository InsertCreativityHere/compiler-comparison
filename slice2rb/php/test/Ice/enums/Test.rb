# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file `Test.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'

module ::Test

    ByteConst1 = 10

    ShortConst1 = 20

    IntConst1 = 30

    LongConst1 = 40

    ByteConst2 = 126

    ShortConst2 = 32766

    IntConst2 = 2147483647

    LongConst2 = 2147483646

    if not defined?(::Test::ByteEnum)
        class ByteEnum
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def ByteEnum.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(ByteEnum) or raise ArgumentError, "value must be a ByteEnum"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def ByteEnum.each(&block)
                @@_enumerators.each_value(&block)
            end

            Benum1 = ByteEnum.new("benum1", 0)
            Benum2 = ByteEnum.new("benum2", 1)
            Benum3 = ByteEnum.new("benum3", 10)
            Benum4 = ByteEnum.new("benum4", 11)
            Benum5 = ByteEnum.new("benum5", 20)
            Benum6 = ByteEnum.new("benum6", 21)
            Benum7 = ByteEnum.new("benum7", 30)
            Benum8 = ByteEnum.new("benum8", 31)
            Benum9 = ByteEnum.new("benum9", 40)
            Benum10 = ByteEnum.new("benum10", 41)
            Benum11 = ByteEnum.new("benum11", 126)

            @@_enumerators = {0=>Benum1, 1=>Benum2, 10=>Benum3, 11=>Benum4, 20=>Benum5, 21=>Benum6, 30=>Benum7, 31=>Benum8, 40=>Benum9, 41=>Benum10, 126=>Benum11}

            def ByteEnum._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_ByteEnum = ::Ice::__defineEnum('::Test::ByteEnum', ByteEnum, ByteEnum::_enumerators)
    end

    if not defined?(::Test::ShortEnum)
        class ShortEnum
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def ShortEnum.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(ShortEnum) or raise ArgumentError, "value must be a ShortEnum"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def ShortEnum.each(&block)
                @@_enumerators.each_value(&block)
            end

            Senum1 = ShortEnum.new("senum1", 3)
            Senum2 = ShortEnum.new("senum2", 4)
            Senum3 = ShortEnum.new("senum3", 10)
            Senum4 = ShortEnum.new("senum4", 11)
            Senum5 = ShortEnum.new("senum5", 20)
            Senum6 = ShortEnum.new("senum6", 21)
            Senum7 = ShortEnum.new("senum7", 30)
            Senum8 = ShortEnum.new("senum8", 31)
            Senum9 = ShortEnum.new("senum9", 40)
            Senum10 = ShortEnum.new("senum10", 41)
            Senum11 = ShortEnum.new("senum11", 32766)

            @@_enumerators = {3=>Senum1, 4=>Senum2, 10=>Senum3, 11=>Senum4, 20=>Senum5, 21=>Senum6, 30=>Senum7, 31=>Senum8, 40=>Senum9, 41=>Senum10, 32766=>Senum11}

            def ShortEnum._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_ShortEnum = ::Ice::__defineEnum('::Test::ShortEnum', ShortEnum, ShortEnum::_enumerators)
    end

    if not defined?(::Test::IntEnum)
        class IntEnum
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def IntEnum.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(IntEnum) or raise ArgumentError, "value must be a IntEnum"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def IntEnum.each(&block)
                @@_enumerators.each_value(&block)
            end

            Ienum1 = IntEnum.new("ienum1", 0)
            Ienum2 = IntEnum.new("ienum2", 1)
            Ienum3 = IntEnum.new("ienum3", 10)
            Ienum4 = IntEnum.new("ienum4", 11)
            Ienum5 = IntEnum.new("ienum5", 20)
            Ienum6 = IntEnum.new("ienum6", 21)
            Ienum7 = IntEnum.new("ienum7", 30)
            Ienum8 = IntEnum.new("ienum8", 31)
            Ienum9 = IntEnum.new("ienum9", 40)
            Ienum10 = IntEnum.new("ienum10", 41)
            Ienum11 = IntEnum.new("ienum11", 2147483647)
            Ienum12 = IntEnum.new("ienum12", 2147483646)

            @@_enumerators = {0=>Ienum1, 1=>Ienum2, 10=>Ienum3, 11=>Ienum4, 20=>Ienum5, 21=>Ienum6, 30=>Ienum7, 31=>Ienum8, 40=>Ienum9, 41=>Ienum10, 2147483647=>Ienum11, 2147483646=>Ienum12}

            def IntEnum._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_IntEnum = ::Ice::__defineEnum('::Test::IntEnum', IntEnum, IntEnum::_enumerators)
    end

    if not defined?(::Test::SimpleEnum)
        class SimpleEnum
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def SimpleEnum.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(SimpleEnum) or raise ArgumentError, "value must be a SimpleEnum"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def SimpleEnum.each(&block)
                @@_enumerators.each_value(&block)
            end

            Red = SimpleEnum.new("red", 0)
            Green = SimpleEnum.new("green", 1)
            Blue = SimpleEnum.new("blue", 2)

            @@_enumerators = {0=>Red, 1=>Green, 2=>Blue}

            def SimpleEnum._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_SimpleEnum = ::Ice::__defineEnum('::Test::SimpleEnum', SimpleEnum, SimpleEnum::_enumerators)
    end

    if not defined?(::Test::TestIntfPrx)
        module TestIntfPrx_mixin

            def opByte(b1, context=nil)
                TestIntfPrx_mixin::OP_opByte.invoke(self, [b1], context)
            end

            def opShort(s1, context=nil)
                TestIntfPrx_mixin::OP_opShort.invoke(self, [s1], context)
            end

            def opInt(i1, context=nil)
                TestIntfPrx_mixin::OP_opInt.invoke(self, [i1], context)
            end

            def opSimple(s1, context=nil)
                TestIntfPrx_mixin::OP_opSimple.invoke(self, [s1], context)
            end

            def shutdown(context=nil)
                TestIntfPrx_mixin::OP_shutdown.invoke(self, [], context)
            end
        end

        class TestIntfPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include TestIntfPrx_mixin
        end

        if not defined?(::Test::T_TestIntfPrx)
            T_TestIntfPrx = ::Ice::__declareProxy('::Test::TestIntf')
        end

        T_TestIntfPrx.defineProxy(TestIntfPrx, nil, [])

        TestIntfPrx_mixin::OP_opByte = ::Ice::__defineOperation('opByte', ::Ice::OperationMode::Normal, false, nil, [[::Test::T_ByteEnum, false, 0]], [[::Test::T_ByteEnum, false, 0]], [::Test::T_ByteEnum, false, 0], [])
        TestIntfPrx_mixin::OP_opShort = ::Ice::__defineOperation('opShort', ::Ice::OperationMode::Normal, false, nil, [[::Test::T_ShortEnum, false, 0]], [[::Test::T_ShortEnum, false, 0]], [::Test::T_ShortEnum, false, 0], [])
        TestIntfPrx_mixin::OP_opInt = ::Ice::__defineOperation('opInt', ::Ice::OperationMode::Normal, false, nil, [[::Test::T_IntEnum, false, 0]], [[::Test::T_IntEnum, false, 0]], [::Test::T_IntEnum, false, 0], [])
        TestIntfPrx_mixin::OP_opSimple = ::Ice::__defineOperation('opSimple', ::Ice::OperationMode::Normal, false, nil, [[::Test::T_SimpleEnum, false, 0]], [[::Test::T_SimpleEnum, false, 0]], [::Test::T_SimpleEnum, false, 0], [])
        TestIntfPrx_mixin::OP_shutdown = ::Ice::__defineOperation('shutdown', ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
    end
end
