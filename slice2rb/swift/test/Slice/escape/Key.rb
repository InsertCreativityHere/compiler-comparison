# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `Key.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'

module ::And

    if not defined?(::And::Continue)
        class Continue
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def Continue.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(Continue) or raise ArgumentError, "value must be a Continue"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def Continue.each(&block)
                @@_enumerators.each_value(&block)
            end

            Let = Continue.new("let", 0)
            Var = Continue.new("var", 1)

            @@_enumerators = {0=>Let, 1=>Var}

            def Continue._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_Continue = ::Ice::__defineEnum('::and::continue', Continue, Continue::_enumerators)
    end

    if not defined?(::And::Guard)
        class Guard
            include ::Ice::Inspect_mixin
            def initialize(default=0)
                @default = default
            end

            def hash
                _h = 0
                _h = 5 * _h + @default.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::And::Guard or
                    @default != other.default
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :default
        end

        T_Guard = ::Ice::__defineStruct('::and::guard', Guard, [["default", ::Ice::T_int]])
    end

    if not defined?(::And::Defer)
        class Defer
            include ::Ice::Inspect_mixin
            def initialize(_else='')
                @_else = _else
            end

            def hash
                _h = 0
                _h = 5 * _h + @_else.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::And::Defer or
                    @_else != other._else
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :_else
        end

        T_Defer = ::Ice::__defineStruct('::and::defer', Defer, [["_else", ::Ice::T_string]])
    end

    if not defined?(::And::Break_Mixin)

        module ::And::Break_Mixin
        end
        module BreakPrx_mixin

            def _case(catch, context=nil)
                BreakPrx_mixin::OP_case.invoke(self, [catch], context)
            end
        end

        class BreakPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include BreakPrx_mixin
        end

        if not defined?(::And::T_BreakPrx)
            T_Break = ::Ice::__declareClass('::and::break')
            T_BreakPrx = ::Ice::__declareProxy('::and::break')
        end

        T_Break.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_BreakPrx.defineProxy(BreakPrx, nil, [])

        BreakPrx_mixin::OP_case = ::Ice::__defineOperation('case', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, true, nil, [[::Ice::T_int, false, 0]], [[::Ice::T_int, false, 0]], nil, [])
    end

    if not defined?(::And::Func_Mixin)

        module ::And::Func_Mixin
        end
        module FuncPrx_mixin

            def public(context=nil)
                FuncPrx_mixin::OP_public.invoke(self, [], context)
            end
        end

        class FuncPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include FuncPrx_mixin
        end

        if not defined?(::And::T_FuncPrx)
            T_Func = ::Ice::__declareClass('::and::func')
            T_FuncPrx = ::Ice::__declareProxy('::and::func')
        end

        T_Func.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_FuncPrx.defineProxy(FuncPrx, nil, [])

        FuncPrx_mixin::OP_public = ::Ice::__defineOperation('public', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
    end

    if not defined?(::And::Switch_Mixin)

        module ::And::Switch_Mixin
        end
        class Switch < ::Ice::Value

            def initialize(_if=0, export=nil, volatile=0)
                @_if = _if
                @export = export
                @volatile = volatile
            end

            attr_accessor :_if, :export, :volatile
        end

        if not defined?(::And::T_Switch)
            T_Switch = ::Ice::__declareClass('::and::switch')
        end

        T_Switch.defineClass(Switch, -1, false, false, nil, [
            ['_if', ::Ice::T_int, false, 0],
            ['export', ::And::T_FuncPrx, false, 0],
            ['volatile', ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::And::Do_Mixin)

        module ::And::Do_Mixin
        end
        module DoPrx_mixin
            include ::And::FuncPrx_mixin
            include ::And::BreakPrx_mixin
        end

        class DoPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include DoPrx_mixin
        end

        if not defined?(::And::T_DoPrx)
            T_Do = ::Ice::__declareClass('::and::do')
            T_DoPrx = ::Ice::__declareProxy('::and::do')
        end

        T_Do.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_DoPrx.defineProxy(DoPrx, nil, [::And::T_FuncPrx, ::And::T_BreakPrx])
    end

    if not defined?(::And::T_Fileprivate)
        T_Fileprivate = ::Ice::__defineSequence('::and::fileprivate', ::And::T_Guard)
    end

    if not defined?(::And::T_For)
        T_For = ::Ice::__defineDictionary('::and::for', ::Ice::T_string, ::And::T_Guard)
    end

    if not defined?(::And::Return)
        class Return < Ice::UserException
            def initialize(int32=0)
                @Int32 = int32
            end

            def to_s
                '::and::return'
            end

            attr_accessor :Int32
        end

        T_Return = ::Ice::__defineException('::and::return', Return, false, nil, [["Int32", ::Ice::T_int, false, 0]])
    end

    if not defined?(::And::As)
        class As < ::And::Return
            def initialize(int32=0, static=0, switch=0)
                super(int32)
                @static = static
                @switch = switch
            end

            def to_s
                '::and::as'
            end

            attr_accessor :static, :switch
        end

        T_As = ::Ice::__defineException('::and::as', As, false, ::And::T_Return, [
            ["static", ::Ice::T_int, false, 0],
            ["switch", ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::And::T_Friend)
        T_Friend = ::Ice::__declareLocalClass('::and::friend')
    end

    Is = 0

    Self = 0

    Throw = 0

    Typealias = 0

    Internal = 0

    While = 0

    Import = 0
end
