# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file 'Metrics.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'
require_relative 'BuiltinSequences.rb'

module ::IceMX

    if not defined?(::IceMX::T_StringIntDict)
        T_StringIntDict = ::Ice::__defineDictionary('::IceMX::StringIntDict', ::Ice::T_string, ::Ice::T_int)
    end

    if not defined?(::IceMX::Metrics)
        class Metrics < ::Ice::Value

            def initialize(id='', total=0, current=0, totalLifetime=0, failures=0)
                @id = id
                @total = total
                @current = current
                @totalLifetime = totalLifetime
                @failures = failures
            end

            attr_accessor :id, :total, :current, :totalLifetime, :failures
        end

        if not defined?(::IceMX::T_Metrics)
            T_Metrics = ::Ice::__declareClass('::IceMX::Metrics')
        end

        T_Metrics.defineClass(Metrics, -1, false, nil, [
            ['id', ::Ice::T_string, false, 0],
            ['total', ::Ice::T_long, false, 0],
            ['current', ::Ice::T_int, false, 0],
            ['totalLifetime', ::Ice::T_long, false, 0],
            ['failures', ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::IceMX::MetricsFailures)
        class MetricsFailures
            include ::Ice::Inspect_mixin
            def initialize(id='', failures=nil)
                @id = id
                @failures = failures
            end

            def hash
                _h = 0
                _h = 5 * _h + @id.hash
                _h = 5 * _h + @failures.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::IceMX::MetricsFailures or
                    @id != other.id or
                    @failures != other.failures
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :id, :failures
        end

        T_MetricsFailures = ::Ice::__defineStruct('::IceMX::MetricsFailures', MetricsFailures, [
            ["id", ::Ice::T_string],
            ["failures", ::IceMX::T_StringIntDict]
        ])
    end

    if not defined?(::IceMX::T_MetricsFailuresSeq)
        T_MetricsFailuresSeq = ::Ice::__defineSequence('::IceMX::MetricsFailuresSeq', ::IceMX::T_MetricsFailures)
    end

    if not defined?(::IceMX::T_MetricsMap)
        T_MetricsMap = ::Ice::__defineSequence('::IceMX::MetricsMap', ::IceMX::T_Metrics)
    end

    if not defined?(::IceMX::T_MetricsView)
        T_MetricsView = ::Ice::__defineDictionary('::IceMX::MetricsView', ::Ice::T_string, ::IceMX::T_MetricsMap)
    end

    if not defined?(::IceMX::UnknownMetricsView)
        class UnknownMetricsView < Ice::UserException
            def to_s
                '::IceMX::UnknownMetricsView'
            end
        end

        T_UnknownMetricsView = ::Ice::__defineException('::IceMX::UnknownMetricsView', UnknownMetricsView, nil, [])
    end

    if not defined?(::IceMX::MetricsAdminPrx)
        module MetricsAdminPrx_mixin

            def getMetricsViewNames(context=nil)
                MetricsAdminPrx_mixin::OP_getMetricsViewNames.invoke(self, [], context)
            end

            def enableMetricsView(name, context=nil)
                MetricsAdminPrx_mixin::OP_enableMetricsView.invoke(self, [name], context)
            end

            def disableMetricsView(name, context=nil)
                MetricsAdminPrx_mixin::OP_disableMetricsView.invoke(self, [name], context)
            end

            def getMetricsView(view, context=nil)
                MetricsAdminPrx_mixin::OP_getMetricsView.invoke(self, [view], context)
            end

            def getMapMetricsFailures(view, map, context=nil)
                MetricsAdminPrx_mixin::OP_getMapMetricsFailures.invoke(self, [view, map], context)
            end

            def getMetricsFailures(view, map, id, context=nil)
                MetricsAdminPrx_mixin::OP_getMetricsFailures.invoke(self, [view, map, id], context)
            end
        end

        class MetricsAdminPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include MetricsAdminPrx_mixin
        end

        if not defined?(::IceMX::T_MetricsAdminPrx)
            T_MetricsAdminPrx = ::Ice::__declareProxy('::IceMX::MetricsAdmin')
        end

        T_MetricsAdminPrx.defineProxy(MetricsAdminPrx, nil, [])

        MetricsAdminPrx_mixin::OP_getMetricsViewNames = ::Ice::__defineOperation('getMetricsViewNames', ::Ice::OperationMode::Normal, nil, [], [[::Ice::T_StringSeq, false, 0]], [::Ice::T_StringSeq, false, 0], [])
        MetricsAdminPrx_mixin::OP_enableMetricsView = ::Ice::__defineOperation('enableMetricsView', ::Ice::OperationMode::Normal, nil, [[::Ice::T_string, false, 0]], [], nil, [::IceMX::T_UnknownMetricsView])
        MetricsAdminPrx_mixin::OP_disableMetricsView = ::Ice::__defineOperation('disableMetricsView', ::Ice::OperationMode::Normal, nil, [[::Ice::T_string, false, 0]], [], nil, [::IceMX::T_UnknownMetricsView])
        MetricsAdminPrx_mixin::OP_getMetricsView = ::Ice::__defineOperation('getMetricsView', ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, [[::Ice::T_string, false, 0]], [[::Ice::T_long, false, 0]], [::IceMX::T_MetricsView, false, 0], [::IceMX::T_UnknownMetricsView])
        MetricsAdminPrx_mixin::OP_getMapMetricsFailures = ::Ice::__defineOperation('getMapMetricsFailures', ::Ice::OperationMode::Normal, nil, [[::Ice::T_string, false, 0], [::Ice::T_string, false, 0]], [], [::IceMX::T_MetricsFailuresSeq, false, 0], [::IceMX::T_UnknownMetricsView])
        MetricsAdminPrx_mixin::OP_getMetricsFailures = ::Ice::__defineOperation('getMetricsFailures', ::Ice::OperationMode::Normal, nil, [[::Ice::T_string, false, 0], [::Ice::T_string, false, 0], [::Ice::T_string, false, 0]], [], [::IceMX::T_MetricsFailures, false, 0], [::IceMX::T_UnknownMetricsView])
    end

    if not defined?(::IceMX::ThreadMetrics)
        class ThreadMetrics < ::IceMX::Metrics

            def initialize(id='', total=0, current=0, totalLifetime=0, failures=0, inUseForIO=0, inUseForUser=0, inUseForOther=0)
                super(id, total, current, totalLifetime, failures)
                @inUseForIO = inUseForIO
                @inUseForUser = inUseForUser
                @inUseForOther = inUseForOther
            end

            attr_accessor :inUseForIO, :inUseForUser, :inUseForOther
        end

        if not defined?(::IceMX::T_ThreadMetrics)
            T_ThreadMetrics = ::Ice::__declareClass('::IceMX::ThreadMetrics')
        end

        T_ThreadMetrics.defineClass(ThreadMetrics, -1, false, ::IceMX::T_Metrics, [
            ['inUseForIO', ::Ice::T_int, false, 0],
            ['inUseForUser', ::Ice::T_int, false, 0],
            ['inUseForOther', ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::IceMX::DispatchMetrics)
        class DispatchMetrics < ::IceMX::Metrics

            def initialize(id='', total=0, current=0, totalLifetime=0, failures=0, userException=0, size=0, replySize=0)
                super(id, total, current, totalLifetime, failures)
                @userException = userException
                @size = size
                @replySize = replySize
            end

            attr_accessor :userException, :size, :replySize
        end

        if not defined?(::IceMX::T_DispatchMetrics)
            T_DispatchMetrics = ::Ice::__declareClass('::IceMX::DispatchMetrics')
        end

        T_DispatchMetrics.defineClass(DispatchMetrics, -1, false, ::IceMX::T_Metrics, [
            ['userException', ::Ice::T_int, false, 0],
            ['size', ::Ice::T_long, false, 0],
            ['replySize', ::Ice::T_long, false, 0]
        ])
    end

    if not defined?(::IceMX::ChildInvocationMetrics)
        class ChildInvocationMetrics < ::IceMX::Metrics

            def initialize(id='', total=0, current=0, totalLifetime=0, failures=0, size=0, replySize=0)
                super(id, total, current, totalLifetime, failures)
                @size = size
                @replySize = replySize
            end

            attr_accessor :size, :replySize
        end

        if not defined?(::IceMX::T_ChildInvocationMetrics)
            T_ChildInvocationMetrics = ::Ice::__declareClass('::IceMX::ChildInvocationMetrics')
        end

        T_ChildInvocationMetrics.defineClass(ChildInvocationMetrics, -1, false, ::IceMX::T_Metrics, [
            ['size', ::Ice::T_long, false, 0],
            ['replySize', ::Ice::T_long, false, 0]
        ])
    end

    if not defined?(::IceMX::CollocatedMetrics)
        class CollocatedMetrics < ::IceMX::ChildInvocationMetrics

            def initialize(id='', total=0, current=0, totalLifetime=0, failures=0, size=0, replySize=0)
                super(id, total, current, totalLifetime, failures, size, replySize)
            end
        end

        if not defined?(::IceMX::T_CollocatedMetrics)
            T_CollocatedMetrics = ::Ice::__declareClass('::IceMX::CollocatedMetrics')
        end

        T_CollocatedMetrics.defineClass(CollocatedMetrics, -1, false, ::IceMX::T_ChildInvocationMetrics, [])
    end

    if not defined?(::IceMX::RemoteMetrics)
        class RemoteMetrics < ::IceMX::ChildInvocationMetrics

            def initialize(id='', total=0, current=0, totalLifetime=0, failures=0, size=0, replySize=0)
                super(id, total, current, totalLifetime, failures, size, replySize)
            end
        end

        if not defined?(::IceMX::T_RemoteMetrics)
            T_RemoteMetrics = ::Ice::__declareClass('::IceMX::RemoteMetrics')
        end

        T_RemoteMetrics.defineClass(RemoteMetrics, -1, false, ::IceMX::T_ChildInvocationMetrics, [])
    end

    if not defined?(::IceMX::InvocationMetrics)
        class InvocationMetrics < ::IceMX::Metrics

            def initialize(id='', total=0, current=0, totalLifetime=0, failures=0, _retry=0, userException=0, remotes=nil, collocated=nil)
                super(id, total, current, totalLifetime, failures)
                @_retry = _retry
                @userException = userException
                @remotes = remotes
                @collocated = collocated
            end

            attr_accessor :_retry, :userException, :remotes, :collocated
        end

        if not defined?(::IceMX::T_InvocationMetrics)
            T_InvocationMetrics = ::Ice::__declareClass('::IceMX::InvocationMetrics')
        end

        T_InvocationMetrics.defineClass(InvocationMetrics, -1, false, ::IceMX::T_Metrics, [
            ['_retry', ::Ice::T_int, false, 0],
            ['userException', ::Ice::T_int, false, 0],
            ['remotes', ::IceMX::T_MetricsMap, false, 0],
            ['collocated', ::IceMX::T_MetricsMap, false, 0]
        ])
    end

    if not defined?(::IceMX::ConnectionMetrics)
        class ConnectionMetrics < ::IceMX::Metrics

            def initialize(id='', total=0, current=0, totalLifetime=0, failures=0, receivedBytes=0, sentBytes=0)
                super(id, total, current, totalLifetime, failures)
                @receivedBytes = receivedBytes
                @sentBytes = sentBytes
            end

            attr_accessor :receivedBytes, :sentBytes
        end

        if not defined?(::IceMX::T_ConnectionMetrics)
            T_ConnectionMetrics = ::Ice::__declareClass('::IceMX::ConnectionMetrics')
        end

        T_ConnectionMetrics.defineClass(ConnectionMetrics, -1, false, ::IceMX::T_Metrics, [
            ['receivedBytes', ::Ice::T_long, false, 0],
            ['sentBytes', ::Ice::T_long, false, 0]
        ])
    end
end
