# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `RemoteLogger.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'
require 'BuiltinSequences.rb'

module ::Ice

    if not defined?(::Ice::LogMessageType)
        class LogMessageType
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def LogMessageType.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(LogMessageType) or raise ArgumentError, "value must be a LogMessageType"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def LogMessageType.each(&block)
                @@_enumerators.each_value(&block)
            end

            PrintMessage = LogMessageType.new("PrintMessage", 0)
            TraceMessage = LogMessageType.new("TraceMessage", 1)
            WarningMessage = LogMessageType.new("WarningMessage", 2)
            ErrorMessage = LogMessageType.new("ErrorMessage", 3)

            @@_enumerators = {0=>PrintMessage, 1=>TraceMessage, 2=>WarningMessage, 3=>ErrorMessage}

            def LogMessageType._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_LogMessageType = ::Ice::__defineEnum('::Ice::LogMessageType', LogMessageType, LogMessageType::_enumerators)
    end

    if not defined?(::Ice::T_LogMessageTypeSeq)
        T_LogMessageTypeSeq = ::Ice::__defineSequence('::Ice::LogMessageTypeSeq', ::Ice::T_LogMessageType)
    end

    if not defined?(::Ice::LogMessage)
        class LogMessage
            include ::Ice::Inspect_mixin
            def initialize(type=::Ice::LogMessageType::PrintMessage, timestamp=0, traceCategory='', message='')
                @type = type
                @timestamp = timestamp
                @traceCategory = traceCategory
                @message = message
            end

            def hash
                _h = 0
                _h = 5 * _h + @type.hash
                _h = 5 * _h + @timestamp.hash
                _h = 5 * _h + @traceCategory.hash
                _h = 5 * _h + @message.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Ice::LogMessage or
                    @type != other.type or
                    @timestamp != other.timestamp or
                    @traceCategory != other.traceCategory or
                    @message != other.message
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :type, :timestamp, :traceCategory, :message
        end

        T_LogMessage = ::Ice::__defineStruct('::Ice::LogMessage', LogMessage, [
            ["type", ::Ice::T_LogMessageType],
            ["timestamp", ::Ice::T_long],
            ["traceCategory", ::Ice::T_string],
            ["message", ::Ice::T_string]
        ])
    end

    if not defined?(::Ice::T_LogMessageSeq)
        T_LogMessageSeq = ::Ice::__defineSequence('::Ice::LogMessageSeq', ::Ice::T_LogMessage)
    end

    if not defined?(::Ice::RemoteLogger_Mixin)

        module ::Ice::RemoteLogger_Mixin
        end
        module RemoteLoggerPrx_mixin

            def init(prefix, logMessages, context=nil)
                RemoteLoggerPrx_mixin::OP_init.invoke(self, [prefix, logMessages], context)
            end

            def log(message, context=nil)
                RemoteLoggerPrx_mixin::OP_log.invoke(self, [message], context)
            end
        end

        class RemoteLoggerPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include RemoteLoggerPrx_mixin
        end

        if not defined?(::Ice::T_RemoteLoggerPrx)
            T_RemoteLogger = ::Ice::__declareClass('::Ice::RemoteLogger')
            T_RemoteLoggerPrx = ::Ice::__declareProxy('::Ice::RemoteLogger')
        end

        T_RemoteLoggerPrx.defineProxy(RemoteLoggerPrx, nil, [])

        RemoteLoggerPrx_mixin::OP_init = ::Ice::__defineOperation('init', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_string, false, 0], [::Ice::T_LogMessageSeq, false, 0]], [], nil, [])
        RemoteLoggerPrx_mixin::OP_log = ::Ice::__defineOperation('log', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_LogMessage, false, 0]], [], nil, [])
    end

    if not defined?(::Ice::RemoteLoggerAlreadyAttachedException)
        class RemoteLoggerAlreadyAttachedException < Ice::UserException
            def initialize
            end

            def to_s
                '::Ice::RemoteLoggerAlreadyAttachedException'
            end
        end

        T_RemoteLoggerAlreadyAttachedException = ::Ice::__defineException('::Ice::RemoteLoggerAlreadyAttachedException', RemoteLoggerAlreadyAttachedException, false, nil, [])
    end

    if not defined?(::Ice::LoggerAdmin_Mixin)

        module ::Ice::LoggerAdmin_Mixin
        end
        module LoggerAdminPrx_mixin

            def attachRemoteLogger(prx, messageTypes, traceCategories, messageMax, context=nil)
                LoggerAdminPrx_mixin::OP_attachRemoteLogger.invoke(self, [prx, messageTypes, traceCategories, messageMax], context)
            end

            def detachRemoteLogger(prx, context=nil)
                LoggerAdminPrx_mixin::OP_detachRemoteLogger.invoke(self, [prx], context)
            end

            def getLog(messageTypes, traceCategories, messageMax, context=nil)
                LoggerAdminPrx_mixin::OP_getLog.invoke(self, [messageTypes, traceCategories, messageMax], context)
            end
        end

        class LoggerAdminPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include LoggerAdminPrx_mixin
        end

        if not defined?(::Ice::T_LoggerAdminPrx)
            T_LoggerAdmin = ::Ice::__declareClass('::Ice::LoggerAdmin')
            T_LoggerAdminPrx = ::Ice::__declareProxy('::Ice::LoggerAdmin')
        end

        T_LoggerAdminPrx.defineProxy(LoggerAdminPrx, nil, [])

        LoggerAdminPrx_mixin::OP_attachRemoteLogger = ::Ice::__defineOperation('attachRemoteLogger', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_RemoteLoggerPrx, false, 0], [::Ice::T_LogMessageTypeSeq, false, 0], [::Ice::T_StringSeq, false, 0], [::Ice::T_int, false, 0]], [], nil, [::Ice::T_RemoteLoggerAlreadyAttachedException])
        LoggerAdminPrx_mixin::OP_detachRemoteLogger = ::Ice::__defineOperation('detachRemoteLogger', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_RemoteLoggerPrx, false, 0]], [], [::Ice::T_bool, false, 0], [])
        LoggerAdminPrx_mixin::OP_getLog = ::Ice::__defineOperation('getLog', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_LogMessageTypeSeq, false, 0], [::Ice::T_StringSeq, false, 0], [::Ice::T_int, false, 0]], [[::Ice::T_string, false, 0]], [::Ice::T_LogMessageSeq, false, 0], [])
    end
end
