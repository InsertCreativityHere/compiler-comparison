# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `STypes.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'

module ::Test

    IntConst1 = 100

    IntConst2 = 1000

    IntConst3 = 100

    if not defined?(::Test::Enum1)
        class Enum1
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def Enum1.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(Enum1) or raise ArgumentError, "value must be a Enum1"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def Enum1.each(&block)
                @@_enumerators.each_value(&block)
            end

            Enum11 = Enum1.new("Enum11", 0)
            Enum12 = Enum1.new("Enum12", 1)
            Enum13 = Enum1.new("Enum13", 2)

            @@_enumerators = {0=>Enum11, 1=>Enum12, 2=>Enum13}

            def Enum1._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_Enum1 = ::Ice::__defineEnum('::Test::Enum1', Enum1, Enum1::_enumerators)
    end

    if not defined?(::Test::Enum2)
        class Enum2
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def Enum2.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(Enum2) or raise ArgumentError, "value must be a Enum2"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def Enum2.each(&block)
                @@_enumerators.each_value(&block)
            end

            Enum21 = Enum2.new("Enum21", 0)
            Enum22 = Enum2.new("Enum22", 1)
            Enum23 = Enum2.new("Enum23", 2)
            Enum24 = Enum2.new("Enum24", 3)

            @@_enumerators = {0=>Enum21, 1=>Enum22, 2=>Enum23, 3=>Enum24}

            def Enum2._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_Enum2 = ::Ice::__defineEnum('::Test::Enum2', Enum2, Enum2::_enumerators)
    end

    if not defined?(::Test::Enum3)
        class Enum3
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def Enum3.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(Enum3) or raise ArgumentError, "value must be a Enum3"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def Enum3.each(&block)
                @@_enumerators.each_value(&block)
            end

            Enum32 = Enum3.new("Enum32", 0)
            Enum33 = Enum3.new("Enum33", 1)

            @@_enumerators = {0=>Enum32, 1=>Enum33}

            def Enum3._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_Enum3 = ::Ice::__defineEnum('::Test::Enum3', Enum3, Enum3::_enumerators)
    end

    if not defined?(::Test::EnumExplicit0)
        class EnumExplicit0
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def EnumExplicit0.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(EnumExplicit0) or raise ArgumentError, "value must be a EnumExplicit0"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def EnumExplicit0.each(&block)
                @@_enumerators.each_value(&block)
            end

            EnumExplicit01 = EnumExplicit0.new("EnumExplicit01", 1)
            EnumExplicit02 = EnumExplicit0.new("EnumExplicit02", 2)
            EnumExplicit03 = EnumExplicit0.new("EnumExplicit03", 3)

            @@_enumerators = {1=>EnumExplicit01, 2=>EnumExplicit02, 3=>EnumExplicit03}

            def EnumExplicit0._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_EnumExplicit0 = ::Ice::__defineEnum('::Test::EnumExplicit0', EnumExplicit0, EnumExplicit0::_enumerators)
    end

    if not defined?(::Test::EnumExplicit1)
        class EnumExplicit1
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def EnumExplicit1.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(EnumExplicit1) or raise ArgumentError, "value must be a EnumExplicit1"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def EnumExplicit1.each(&block)
                @@_enumerators.each_value(&block)
            end

            EnumExplicit11 = EnumExplicit1.new("EnumExplicit11", 1)
            EnumExplicit13 = EnumExplicit1.new("EnumExplicit13", 3)
            EnumExplicit12 = EnumExplicit1.new("EnumExplicit12", 2)

            @@_enumerators = {1=>EnumExplicit11, 3=>EnumExplicit13, 2=>EnumExplicit12}

            def EnumExplicit1._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_EnumExplicit1 = ::Ice::__defineEnum('::Test::EnumExplicit1', EnumExplicit1, EnumExplicit1::_enumerators)
    end

    if not defined?(::Test::EnumExplicit2)
        class EnumExplicit2
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def EnumExplicit2.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(EnumExplicit2) or raise ArgumentError, "value must be a EnumExplicit2"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def EnumExplicit2.each(&block)
                @@_enumerators.each_value(&block)
            end

            EnumExplicit21 = EnumExplicit2.new("EnumExplicit21", 1)
            EnumExplicit22 = EnumExplicit2.new("EnumExplicit22", 3)
            EnumExplicit23 = EnumExplicit2.new("EnumExplicit23", 4)

            @@_enumerators = {1=>EnumExplicit21, 3=>EnumExplicit22, 4=>EnumExplicit23}

            def EnumExplicit2._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_EnumExplicit2 = ::Ice::__defineEnum('::Test::EnumExplicit2', EnumExplicit2, EnumExplicit2::_enumerators)
    end

    if not defined?(::Test::EnumExplicit3)
        class EnumExplicit3
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def EnumExplicit3.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(EnumExplicit3) or raise ArgumentError, "value must be a EnumExplicit3"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def EnumExplicit3.each(&block)
                @@_enumerators.each_value(&block)
            end

            EnumExplicit31 = EnumExplicit3.new("EnumExplicit31", 1)
            EnumExplicit32 = EnumExplicit3.new("EnumExplicit32", 2)

            @@_enumerators = {1=>EnumExplicit31, 2=>EnumExplicit32}

            def EnumExplicit3._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_EnumExplicit3 = ::Ice::__defineEnum('::Test::EnumExplicit3', EnumExplicit3, EnumExplicit3::_enumerators)
    end

    if not defined?(::Test::Enum4_Mixin)

        module ::Test::Enum4_Mixin
        end
        class Enum4 < ::Ice::Value
        end

        if not defined?(::Test::T_Enum4)
            T_Enum4 = ::Ice::__declareClass('::Test::Enum4')
        end

        T_Enum4.defineClass(Enum4, -1, false, false, nil, [])
    end

    if not defined?(::Test::T_Sequence1)
        T_Sequence1 = ::Ice::__defineSequence('::Test::Sequence1', ::Ice::T_int)
    end

    if not defined?(::Test::T_Sequence2)
        T_Sequence2 = ::Ice::__defineSequence('::Test::Sequence2', ::Ice::T_short)
    end

    if not defined?(::Test::Sequence3_Mixin)

        module ::Test::Sequence3_Mixin
        end
        class Sequence3 < ::Ice::Value
        end

        if not defined?(::Test::T_Sequence3)
            T_Sequence3 = ::Ice::__declareClass('::Test::Sequence3')
        end

        T_Sequence3.defineClass(Sequence3, -1, false, false, nil, [])
    end

    if not defined?(::Test::T_Dictionary1)
        T_Dictionary1 = ::Ice::__defineDictionary('::Test::Dictionary1', ::Ice::T_string, ::Ice::T_int)
    end

    if not defined?(::Test::T_Dictionary2)
        T_Dictionary2 = ::Ice::__defineDictionary('::Test::Dictionary2', ::Ice::T_long, ::Ice::T_int)
    end

    if not defined?(::Test::T_Dictionary3)
        T_Dictionary3 = ::Ice::__defineDictionary('::Test::Dictionary3', ::Ice::T_string, ::Ice::T_bool)
    end

    if not defined?(::Test::Dictionary4_Mixin)

        module ::Test::Dictionary4_Mixin
        end
        class Dictionary4 < ::Ice::Value
        end

        if not defined?(::Test::T_Dictionary4)
            T_Dictionary4 = ::Ice::__declareClass('::Test::Dictionary4')
        end

        T_Dictionary4.defineClass(Dictionary4, -1, false, false, nil, [])
    end

    if not defined?(::Test::Struct1)
        class Struct1
            include ::Ice::Inspect_mixin
            def initialize(str='', b=false)
                @str = str
                @b = b
            end

            def hash
                _h = 0
                _h = 5 * _h + @str.hash
                _h = 5 * _h + @b.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::Struct1 or
                    @str != other.str or
                    @b != other.b
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :str, :b
        end

        T_Struct1 = ::Ice::__defineStruct('::Test::Struct1', Struct1, [
            ["str", ::Ice::T_string],
            ["b", ::Ice::T_bool]
        ])
    end

    if not defined?(::Test::Struct2)
        class Struct2
            include ::Ice::Inspect_mixin
            def initialize(str='', b=false, f=0.0)
                @str = str
                @b = b
                @f = f
            end

            def hash
                _h = 0
                _h = 5 * _h + @str.hash
                _h = 5 * _h + @b.hash
                _h = 5 * _h + @f.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::Struct2 or
                    @str != other.str or
                    @b != other.b or
                    @f != other.f
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :str, :b, :f
        end

        T_Struct2 = ::Ice::__defineStruct('::Test::Struct2', Struct2, [
            ["str", ::Ice::T_string],
            ["b", ::Ice::T_bool],
            ["f", ::Ice::T_float]
        ])
    end

    if not defined?(::Test::Struct3)
        class Struct3
            include ::Ice::Inspect_mixin
            def initialize(str='', b=0.0)
                @str = str
                @b = b
            end

            def hash
                _h = 0
                _h = 5 * _h + @str.hash
                _h = 5 * _h + @b.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::Struct3 or
                    @str != other.str or
                    @b != other.b
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :str, :b
        end

        T_Struct3 = ::Ice::__defineStruct('::Test::Struct3', Struct3, [
            ["str", ::Ice::T_string],
            ["b", ::Ice::T_double]
        ])
    end

    if not defined?(::Test::Struct4)
        class Struct4
            include ::Ice::Inspect_mixin
            def initialize(b=false)
                @b = b
            end

            def hash
                _h = 0
                _h = 5 * _h + @b.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::Struct4 or
                    @b != other.b
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :b
        end

        T_Struct4 = ::Ice::__defineStruct('::Test::Struct4', Struct4, [["b", ::Ice::T_bool]])
    end

    if not defined?(::Test::Struct5_Mixin)

        module ::Test::Struct5_Mixin
        end
        class Struct5 < ::Ice::Value
        end

        if not defined?(::Test::T_Struct5)
            T_Struct5 = ::Ice::__declareClass('::Test::Struct5')
        end

        T_Struct5.defineClass(Struct5, -1, false, false, nil, [])
    end

    if not defined?(::Test::Interface1_Mixin)

        module ::Test::Interface1_Mixin
        end
        module Interface1Prx_mixin
        end

        class Interface1Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include Interface1Prx_mixin
        end

        if not defined?(::Test::T_Interface1Prx)
            T_Interface1 = ::Ice::__declareClass('::Test::Interface1')
            T_Interface1Prx = ::Ice::__declareProxy('::Test::Interface1')
        end

        T_Interface1.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_Interface1Prx.defineProxy(Interface1Prx, nil, [])
    end

    if not defined?(::Test::Interface2_Mixin)

        module ::Test::Interface2_Mixin
        end
        class Interface2 < ::Ice::Value
        end

        if not defined?(::Test::T_Interface2)
            T_Interface2 = ::Ice::__declareClass('::Test::Interface2')
        end

        T_Interface2.defineClass(Interface2, -1, false, false, nil, [])
    end

    if not defined?(::Test::Interface3_Mixin)

        module ::Test::Interface3_Mixin
        end
        module Interface3Prx_mixin
            include ::Test::Interface1Prx_mixin
        end

        class Interface3Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include Interface3Prx_mixin
        end

        if not defined?(::Test::T_Interface3Prx)
            T_Interface3 = ::Ice::__declareClass('::Test::Interface3')
            T_Interface3Prx = ::Ice::__declareProxy('::Test::Interface3')
        end

        T_Interface3.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_Interface3Prx.defineProxy(Interface3Prx, nil, [::Test::T_Interface1Prx])
    end

    if not defined?(::Test::Interface4_Mixin)

        module ::Test::Interface4_Mixin
        end
        module Interface4Prx_mixin

            def opInterface4(context=nil)
                Interface4Prx_mixin::OP_opInterface4.invoke(self, [], context)
            end
        end

        class Interface4Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include Interface4Prx_mixin
        end

        if not defined?(::Test::T_Interface4Prx)
            T_Interface4 = ::Ice::__declareClass('::Test::Interface4')
            T_Interface4Prx = ::Ice::__declareProxy('::Test::Interface4')
        end

        T_Interface4.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_Interface4Prx.defineProxy(Interface4Prx, nil, [])

        Interface4Prx_mixin::OP_opInterface4 = ::Ice::__defineOperation('opInterface4', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
    end

    if not defined?(::Test::EmptyClass1_Mixin)

        module ::Test::EmptyClass1_Mixin
        end
        class EmptyClass1 < ::Ice::Value
        end

        if not defined?(::Test::T_EmptyClass1)
            T_EmptyClass1 = ::Ice::__declareClass('::Test::EmptyClass1')
        end

        T_EmptyClass1.defineClass(EmptyClass1, -1, false, false, nil, [])
    end

    if not defined?(::Test::EmptyClass2_Mixin)

        module ::Test::EmptyClass2_Mixin
        end
        class EmptyClass2 < ::Ice::Value

            def initialize(d=0.0)
                @d = d
            end

            attr_accessor :d
        end

        if not defined?(::Test::T_EmptyClass2)
            T_EmptyClass2 = ::Ice::__declareClass('::Test::EmptyClass2')
        end

        T_EmptyClass2.defineClass(EmptyClass2, -1, false, false, nil, [['d', ::Ice::T_double, false, 0]])
    end

    if not defined?(::Test::EmptyClass3_Mixin)

        module ::Test::EmptyClass3_Mixin
        end
        class EmptyClass3 < ::Ice::Value
        end
        module EmptyClass3Prx_mixin

            def newOp(context=nil)
                EmptyClass3Prx_mixin::OP_newOp.invoke(self, [], context)
            end
        end

        class EmptyClass3Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include EmptyClass3Prx_mixin
        end

        if not defined?(::Test::T_EmptyClass3)
            T_EmptyClass3 = ::Ice::__declareClass('::Test::EmptyClass3')
            T_EmptyClass3Prx = ::Ice::__declareProxy('::Test::EmptyClass3')
        end

        T_EmptyClass3.defineClass(EmptyClass3, -1, false, false, nil, [])

        T_EmptyClass3Prx.defineProxy(EmptyClass3Prx, nil, [])

        EmptyClass3Prx_mixin::OP_newOp = ::Ice::__defineOperation('newOp', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
    end

    if not defined?(::Test::EmptyClass4_Mixin)

        module ::Test::EmptyClass4_Mixin
        end
        class EmptyClass4 < ::Test::EmptyClass1
        end

        if not defined?(::Test::T_EmptyClass4)
            T_EmptyClass4 = ::Ice::__declareClass('::Test::EmptyClass4')
        end

        T_EmptyClass4.defineClass(EmptyClass4, -1, false, false, ::Test::T_EmptyClass1, [])
    end

    if not defined?(::Test::EmptyClass5_Mixin)

        module ::Test::EmptyClass5_Mixin
        end
        class EmptyClass5 < ::Ice::Value
        end

        if not defined?(::Test::T_EmptyClass5)
            T_EmptyClass5 = ::Ice::__declareClass('::Test::EmptyClass5')
        end

        T_EmptyClass5.defineClass(EmptyClass5, -1, false, false, nil, [])
    end

    if not defined?(::Test::SimpleClass1_Mixin)

        module ::Test::SimpleClass1_Mixin
        end
        class SimpleClass1 < ::Ice::Value

            def initialize(str='', f=0.0)
                @str = str
                @f = f
            end

            attr_accessor :str, :f
        end

        if not defined?(::Test::T_SimpleClass1)
            T_SimpleClass1 = ::Ice::__declareClass('::Test::SimpleClass1')
        end

        T_SimpleClass1.defineClass(SimpleClass1, -1, false, false, nil, [
            ['str', ::Ice::T_string, false, 0],
            ['f', ::Ice::T_float, false, 0]
        ])
    end

    if not defined?(::Test::SimpleClass2_Mixin)

        module ::Test::SimpleClass2_Mixin
        end
        class SimpleClass2 < ::Ice::Value

            def initialize(str='', f=0.0)
                @str = str
                @f = f
            end

            attr_accessor :str, :f
        end
        module SimpleClass2Prx_mixin

            def newOp(context=nil)
                SimpleClass2Prx_mixin::OP_newOp.invoke(self, [], context)
            end
        end

        class SimpleClass2Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include SimpleClass2Prx_mixin
        end

        if not defined?(::Test::T_SimpleClass2)
            T_SimpleClass2 = ::Ice::__declareClass('::Test::SimpleClass2')
            T_SimpleClass2Prx = ::Ice::__declareProxy('::Test::SimpleClass2')
        end

        T_SimpleClass2.defineClass(SimpleClass2, -1, false, false, nil, [
            ['str', ::Ice::T_string, false, 0],
            ['f', ::Ice::T_float, false, 0]
        ])

        T_SimpleClass2Prx.defineProxy(SimpleClass2Prx, nil, [])

        SimpleClass2Prx_mixin::OP_newOp = ::Ice::__defineOperation('newOp', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
    end

    if not defined?(::Test::SimpleClass3_Mixin)

        module ::Test::SimpleClass3_Mixin
        end
        class SimpleClass3 < ::Ice::Value

            def initialize(str='', g=0.0)
                @str = str
                @g = g
            end

            attr_accessor :str, :g
        end

        if not defined?(::Test::T_SimpleClass3)
            T_SimpleClass3 = ::Ice::__declareClass('::Test::SimpleClass3')
        end

        T_SimpleClass3.defineClass(SimpleClass3, -1, false, false, nil, [
            ['str', ::Ice::T_string, false, 0],
            ['g', ::Ice::T_float, false, 0]
        ])
    end

    if not defined?(::Test::SimpleClass4_Mixin)

        module ::Test::SimpleClass4_Mixin
        end
        class SimpleClass4 < ::Ice::Value

            def initialize(str='', f=0.0, b=false)
                @str = str
                @f = f
                @b = b
            end

            attr_accessor :str, :f, :b
        end

        if not defined?(::Test::T_SimpleClass4)
            T_SimpleClass4 = ::Ice::__declareClass('::Test::SimpleClass4')
        end

        T_SimpleClass4.defineClass(SimpleClass4, -1, false, false, nil, [
            ['str', ::Ice::T_string, false, 0],
            ['f', ::Ice::T_float, false, 0],
            ['b', ::Ice::T_bool, false, 0]
        ])
    end

    if not defined?(::Test::SimpleClass5_Mixin)

        module ::Test::SimpleClass5_Mixin
        end
        class SimpleClass5 < ::Ice::Value

            def initialize(str='')
                @str = str
            end

            attr_accessor :str
        end

        if not defined?(::Test::T_SimpleClass5)
            T_SimpleClass5 = ::Ice::__declareClass('::Test::SimpleClass5')
        end

        T_SimpleClass5.defineClass(SimpleClass5, -1, false, false, nil, [['str', ::Ice::T_string, false, 0]])
    end

    if not defined?(::Test::SimpleClass6_Mixin)

        module ::Test::SimpleClass6_Mixin
        end
        class SimpleClass6 < ::Ice::Value

            def initialize(f=0.0, str='')
                @f = f
                @str = str
            end

            attr_accessor :f, :str
        end

        if not defined?(::Test::T_SimpleClass6)
            T_SimpleClass6 = ::Ice::__declareClass('::Test::SimpleClass6')
        end

        T_SimpleClass6.defineClass(SimpleClass6, -1, false, false, nil, [
            ['f', ::Ice::T_float, false, 0],
            ['str', ::Ice::T_string, false, 0]
        ])
    end

    if not defined?(::Test::SimpleClass7_Mixin)

        module ::Test::SimpleClass7_Mixin
        end
        class SimpleClass7 < ::Ice::Value

            def initialize(str='', f=0.0)
                @str = str
                @f = f
            end

            attr_accessor :str, :f
        end

        if not defined?(::Test::T_SimpleClass7)
            T_SimpleClass7 = ::Ice::__declareClass('::Test::SimpleClass7')
        end

        T_SimpleClass7.defineClass(SimpleClass7, -1, false, false, nil, [
            ['str', ::Ice::T_string, false, 0],
            ['f', ::Ice::T_double, false, 0]
        ])
    end

    if not defined?(::Test::Exception1)
        class Exception1 < Ice::UserException
            def initialize(str='', b=false)
                @str = str
                @b = b
            end

            def to_s
                '::Test::Exception1'
            end

            attr_accessor :str, :b
        end

        T_Exception1 = ::Ice::__defineException('::Test::Exception1', Exception1, false, nil, [
            ["str", ::Ice::T_string, false, 0],
            ["b", ::Ice::T_bool, false, 0]
        ])
    end

    if not defined?(::Test::Exception2)
        class Exception2 < Ice::UserException
            def initialize(str='', b=false, f=0.0)
                @str = str
                @b = b
                @f = f
            end

            def to_s
                '::Test::Exception2'
            end

            attr_accessor :str, :b, :f
        end

        T_Exception2 = ::Ice::__defineException('::Test::Exception2', Exception2, false, nil, [
            ["str", ::Ice::T_string, false, 0],
            ["b", ::Ice::T_bool, false, 0],
            ["f", ::Ice::T_float, false, 0]
        ])
    end

    if not defined?(::Test::Exception3)
        class Exception3 < Ice::UserException
            def initialize(str='', b=0.0)
                @str = str
                @b = b
            end

            def to_s
                '::Test::Exception3'
            end

            attr_accessor :str, :b
        end

        T_Exception3 = ::Ice::__defineException('::Test::Exception3', Exception3, false, nil, [
            ["str", ::Ice::T_string, false, 0],
            ["b", ::Ice::T_double, false, 0]
        ])
    end

    if not defined?(::Test::Exception4)
        class Exception4 < Ice::UserException
            def initialize(b=false)
                @b = b
            end

            def to_s
                '::Test::Exception4'
            end

            attr_accessor :b
        end

        T_Exception4 = ::Ice::__defineException('::Test::Exception4', Exception4, false, nil, [["b", ::Ice::T_bool, false, 0]])
    end

    if not defined?(::Test::Exception5)
        class Exception5 < ::Test::Exception1
            def initialize(str='', b=false)
                super(str, b)
            end

            def to_s
                '::Test::Exception5'
            end
        end

        T_Exception5 = ::Ice::__defineException('::Test::Exception5', Exception5, false, ::Test::T_Exception1, [])
    end

    if not defined?(::Test::Exception6_Mixin)

        module ::Test::Exception6_Mixin
        end
        class Exception6 < ::Ice::Value
        end

        if not defined?(::Test::T_Exception6)
            T_Exception6 = ::Ice::__declareClass('::Test::Exception6')
        end

        T_Exception6.defineClass(Exception6, -1, false, false, nil, [])
    end

    if not defined?(::Test::OptionalEx0)
        class OptionalEx0 < Ice::UserException
            def initialize(firstName='', secondName=::Ice::Unset, emailAddress=::Ice::Unset)
                @firstName = firstName
                @secondName = secondName
                @emailAddress = emailAddress
            end

            def to_s
                '::Test::OptionalEx0'
            end

            attr_accessor :firstName, :secondName, :emailAddress
        end

        T_OptionalEx0 = ::Ice::__defineException('::Test::OptionalEx0', OptionalEx0, false, nil, [
            ["firstName", ::Ice::T_string, false, 0],
            ["secondName", ::Ice::T_string, true, 1],
            ["emailAddress", ::Ice::T_string, true, 2]
        ])
    end

    if not defined?(::Test::OptionalEx1)
        class OptionalEx1 < Ice::UserException
            def initialize(firstName='', emailAddress=::Ice::Unset, secondName=::Ice::Unset)
                @firstName = firstName
                @emailAddress = emailAddress
                @secondName = secondName
            end

            def to_s
                '::Test::OptionalEx1'
            end

            attr_accessor :firstName, :emailAddress, :secondName
        end

        T_OptionalEx1 = ::Ice::__defineException('::Test::OptionalEx1', OptionalEx1, false, nil, [
            ["firstName", ::Ice::T_string, false, 0],
            ["emailAddress", ::Ice::T_string, true, 2],
            ["secondName", ::Ice::T_string, true, 1]
        ])
    end

    if not defined?(::Test::OptionalEx2)
        class OptionalEx2 < Ice::UserException
            def initialize(firstName='', secondName=::Ice::Unset, emailAddress='')
                @firstName = firstName
                @secondName = secondName
                @emailAddress = emailAddress
            end

            def to_s
                '::Test::OptionalEx2'
            end

            attr_accessor :firstName, :secondName, :emailAddress
        end

        T_OptionalEx2 = ::Ice::__defineException('::Test::OptionalEx2', OptionalEx2, false, nil, [
            ["firstName", ::Ice::T_string, false, 0],
            ["secondName", ::Ice::T_string, true, 1],
            ["emailAddress", ::Ice::T_string, false, 0]
        ])
    end

    if not defined?(::Test::OptionalEx3)
        class OptionalEx3 < Ice::UserException
            def initialize(firstName='', secondName=::Ice::Unset, emailAddress=::Ice::Unset, phoneNumber=::Ice::Unset)
                @firstName = firstName
                @secondName = secondName
                @emailAddress = emailAddress
                @phoneNumber = phoneNumber
            end

            def to_s
                '::Test::OptionalEx3'
            end

            attr_accessor :firstName, :secondName, :emailAddress, :phoneNumber
        end

        T_OptionalEx3 = ::Ice::__defineException('::Test::OptionalEx3', OptionalEx3, false, nil, [
            ["firstName", ::Ice::T_string, false, 0],
            ["secondName", ::Ice::T_string, true, 1],
            ["emailAddress", ::Ice::T_string, true, 2],
            ["phoneNumber", ::Ice::T_string, true, 3]
        ])
    end

    if not defined?(::Test::OptionalEx4)
        class OptionalEx4 < Ice::UserException
            def initialize(firstName='', secondName=::Ice::Unset, emailAddress=::Ice::Unset)
                @firstName = firstName
                @secondName = secondName
                @emailAddress = emailAddress
            end

            def to_s
                '::Test::OptionalEx4'
            end

            attr_accessor :firstName, :secondName, :emailAddress
        end

        T_OptionalEx4 = ::Ice::__defineException('::Test::OptionalEx4', OptionalEx4, false, nil, [
            ["firstName", ::Ice::T_string, false, 0],
            ["secondName", ::Ice::T_string, true, 2],
            ["emailAddress", ::Ice::T_string, true, 1]
        ])
    end

    if not defined?(::Test::BaseInterface1_Mixin)

        module ::Test::BaseInterface1_Mixin
        end
        module BaseInterface1Prx_mixin

            def baseOp1(context=nil)
                BaseInterface1Prx_mixin::OP_baseOp1.invoke(self, [], context)
            end

            def baseOp2(i, context=nil)
                BaseInterface1Prx_mixin::OP_baseOp2.invoke(self, [i], context)
            end
        end

        class BaseInterface1Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include BaseInterface1Prx_mixin
        end

        if not defined?(::Test::T_BaseInterface1Prx)
            T_BaseInterface1 = ::Ice::__declareClass('::Test::BaseInterface1')
            T_BaseInterface1Prx = ::Ice::__declareProxy('::Test::BaseInterface1')
        end

        T_BaseInterface1.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_BaseInterface1Prx.defineProxy(BaseInterface1Prx, nil, [])

        BaseInterface1Prx_mixin::OP_baseOp1 = ::Ice::__defineOperation('baseOp1', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
        BaseInterface1Prx_mixin::OP_baseOp2 = ::Ice::__defineOperation('baseOp2', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, false, 0]], [[::Ice::T_string, false, 0]], nil, [::Test::T_Exception1])
    end

    if not defined?(::Test::BaseInterface2_Mixin)

        module ::Test::BaseInterface2_Mixin
        end
        module BaseInterface2Prx_mixin

            def baseOp(context=nil)
                BaseInterface2Prx_mixin::OP_baseOp.invoke(self, [], context)
            end

            def baseOp2(i, context=nil)
                BaseInterface2Prx_mixin::OP_baseOp2.invoke(self, [i], context)
            end
        end

        class BaseInterface2Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include BaseInterface2Prx_mixin
        end

        if not defined?(::Test::T_BaseInterface2Prx)
            T_BaseInterface2 = ::Ice::__declareClass('::Test::BaseInterface2')
            T_BaseInterface2Prx = ::Ice::__declareProxy('::Test::BaseInterface2')
        end

        T_BaseInterface2.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_BaseInterface2Prx.defineProxy(BaseInterface2Prx, nil, [])

        BaseInterface2Prx_mixin::OP_baseOp = ::Ice::__defineOperation('baseOp', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], [::Ice::T_int, false, 0], [])
        BaseInterface2Prx_mixin::OP_baseOp2 = ::Ice::__defineOperation('baseOp2', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, false, 0]], [[::Ice::T_string, false, 0]], nil, [::Test::T_Exception1])
    end

    if not defined?(::Test::BaseInterface3_Mixin)

        module ::Test::BaseInterface3_Mixin
        end
        module BaseInterface3Prx_mixin

            def baseOp(o, context=nil)
                BaseInterface3Prx_mixin::OP_baseOp.invoke(self, [o], context)
            end

            def baseOp2(i, context=nil)
                BaseInterface3Prx_mixin::OP_baseOp2.invoke(self, [i], context)
            end
        end

        class BaseInterface3Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include BaseInterface3Prx_mixin
        end

        if not defined?(::Test::T_BaseInterface3Prx)
            T_BaseInterface3 = ::Ice::__declareClass('::Test::BaseInterface3')
            T_BaseInterface3Prx = ::Ice::__declareProxy('::Test::BaseInterface3')
        end

        T_BaseInterface3.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_BaseInterface3Prx.defineProxy(BaseInterface3Prx, nil, [])

        BaseInterface3Prx_mixin::OP_baseOp = ::Ice::__defineOperation('baseOp', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_Value, false, 0]], [], nil, [])
        BaseInterface3Prx_mixin::OP_baseOp2 = ::Ice::__defineOperation('baseOp2', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, false, 0]], [[::Ice::T_string, false, 0]], nil, [::Test::T_Exception1])
    end

    if not defined?(::Test::BaseInterface4_Mixin)

        module ::Test::BaseInterface4_Mixin
        end
        module BaseInterface4Prx_mixin

            def baseOp(context=nil)
                BaseInterface4Prx_mixin::OP_baseOp.invoke(self, [], context)
            end

            def baseOp2(i, context=nil)
                BaseInterface4Prx_mixin::OP_baseOp2.invoke(self, [i], context)
            end
        end

        class BaseInterface4Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include BaseInterface4Prx_mixin
        end

        if not defined?(::Test::T_BaseInterface4Prx)
            T_BaseInterface4 = ::Ice::__declareClass('::Test::BaseInterface4')
            T_BaseInterface4Prx = ::Ice::__declareProxy('::Test::BaseInterface4')
        end

        T_BaseInterface4.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_BaseInterface4Prx.defineProxy(BaseInterface4Prx, nil, [])

        BaseInterface4Prx_mixin::OP_baseOp = ::Ice::__defineOperation('baseOp', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
        BaseInterface4Prx_mixin::OP_baseOp2 = ::Ice::__defineOperation('baseOp2', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, false, 0]], [[::Ice::T_string, false, 0]], nil, [::Test::T_Exception1, ::Test::T_Exception2])
    end

    if not defined?(::Test::BaseInterface5_Mixin)

        module ::Test::BaseInterface5_Mixin
        end
        module BaseInterface5Prx_mixin

            def baseOp(context=nil)
                BaseInterface5Prx_mixin::OP_baseOp.invoke(self, [], context)
            end

            def baseOp2(i, s, context=nil)
                BaseInterface5Prx_mixin::OP_baseOp2.invoke(self, [i, s], context)
            end
        end

        class BaseInterface5Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include BaseInterface5Prx_mixin
        end

        if not defined?(::Test::T_BaseInterface5Prx)
            T_BaseInterface5 = ::Ice::__declareClass('::Test::BaseInterface5')
            T_BaseInterface5Prx = ::Ice::__declareProxy('::Test::BaseInterface5')
        end

        T_BaseInterface5.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_BaseInterface5Prx.defineProxy(BaseInterface5Prx, nil, [])

        BaseInterface5Prx_mixin::OP_baseOp = ::Ice::__defineOperation('baseOp', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
        BaseInterface5Prx_mixin::OP_baseOp2 = ::Ice::__defineOperation('baseOp2', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, false, 0], [::Ice::T_string, false, 0]], [], nil, [::Test::T_Exception1])
    end

    if not defined?(::Test::BaseInterface6_Mixin)

        module ::Test::BaseInterface6_Mixin
        end
        module BaseInterface6Prx_mixin

            def baseOp(context=nil)
                BaseInterface6Prx_mixin::OP_baseOp.invoke(self, [], context)
            end

            def baseOp2(context=nil)
                BaseInterface6Prx_mixin::OP_baseOp2.invoke(self, [], context)
            end
        end

        class BaseInterface6Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include BaseInterface6Prx_mixin
        end

        if not defined?(::Test::T_BaseInterface6Prx)
            T_BaseInterface6 = ::Ice::__declareClass('::Test::BaseInterface6')
            T_BaseInterface6Prx = ::Ice::__declareProxy('::Test::BaseInterface6')
        end

        T_BaseInterface6.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_BaseInterface6Prx.defineProxy(BaseInterface6Prx, nil, [])

        BaseInterface6Prx_mixin::OP_baseOp = ::Ice::__defineOperation('baseOp', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
        BaseInterface6Prx_mixin::OP_baseOp2 = ::Ice::__defineOperation('baseOp2', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [[::Ice::T_string, false, 0]], nil, [::Test::T_Exception1])
    end

    if not defined?(::Test::BaseInterface7_Mixin)

        module ::Test::BaseInterface7_Mixin
        end
        module BaseInterface7Prx_mixin

            def baseOp(context=nil)
                BaseInterface7Prx_mixin::OP_baseOp.invoke(self, [], context)
            end

            def baseOp2(i, context=nil)
                BaseInterface7Prx_mixin::OP_baseOp2.invoke(self, [i], context)
            end
        end

        class BaseInterface7Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include BaseInterface7Prx_mixin
        end

        if not defined?(::Test::T_BaseInterface7Prx)
            T_BaseInterface7 = ::Ice::__declareClass('::Test::BaseInterface7')
            T_BaseInterface7Prx = ::Ice::__declareProxy('::Test::BaseInterface7')
        end

        T_BaseInterface7.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_BaseInterface7Prx.defineProxy(BaseInterface7Prx, nil, [])

        BaseInterface7Prx_mixin::OP_baseOp = ::Ice::__defineOperation('baseOp', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
        BaseInterface7Prx_mixin::OP_baseOp2 = ::Ice::__defineOperation('baseOp2', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, false, 0]], [[::Ice::T_string, false, 0]], nil, [])
    end

    if not defined?(::Test::BaseInterface8_Mixin)

        module ::Test::BaseInterface8_Mixin
        end
        module BaseInterface8Prx_mixin

            def baseOp2(i, context=nil)
                BaseInterface8Prx_mixin::OP_baseOp2.invoke(self, [i], context)
            end
        end

        class BaseInterface8Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include BaseInterface8Prx_mixin
        end

        if not defined?(::Test::T_BaseInterface8Prx)
            T_BaseInterface8 = ::Ice::__declareClass('::Test::BaseInterface8')
            T_BaseInterface8Prx = ::Ice::__declareProxy('::Test::BaseInterface8')
        end

        T_BaseInterface8.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_BaseInterface8Prx.defineProxy(BaseInterface8Prx, nil, [])

        BaseInterface8Prx_mixin::OP_baseOp2 = ::Ice::__defineOperation('baseOp2', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, false, 0]], [[::Ice::T_string, false, 0]], nil, [::Test::T_Exception1])
    end

    if not defined?(::Test::BaseInterface9_Mixin)

        module ::Test::BaseInterface9_Mixin
        end
        module BaseInterface9Prx_mixin
            include ::Test::Interface1Prx_mixin

            def baseOp(context=nil)
                BaseInterface9Prx_mixin::OP_baseOp.invoke(self, [], context)
            end

            def baseOp2(i, context=nil)
                BaseInterface9Prx_mixin::OP_baseOp2.invoke(self, [i], context)
            end
        end

        class BaseInterface9Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include BaseInterface9Prx_mixin
        end

        if not defined?(::Test::T_BaseInterface9Prx)
            T_BaseInterface9 = ::Ice::__declareClass('::Test::BaseInterface9')
            T_BaseInterface9Prx = ::Ice::__declareProxy('::Test::BaseInterface9')
        end

        T_BaseInterface9.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_BaseInterface9Prx.defineProxy(BaseInterface9Prx, nil, [::Test::T_Interface1Prx])

        BaseInterface9Prx_mixin::OP_baseOp = ::Ice::__defineOperation('baseOp', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
        BaseInterface9Prx_mixin::OP_baseOp2 = ::Ice::__defineOperation('baseOp2', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_int, false, 0]], [[::Ice::T_string, false, 0]], nil, [::Test::T_Exception1])
    end

    if not defined?(::Test::Compact1_Mixin)

        module ::Test::Compact1_Mixin
        end
        class Compact1 < ::Ice::Value

            def initialize(id=0)
                @id = id
            end

            attr_accessor :id
        end

        if not defined?(::Test::T_Compact1)
            T_Compact1 = ::Ice::__declareClass('::Test::Compact1')
        end

        T_Compact1.defineClass(Compact1, 1, false, false, nil, [['id', ::Ice::T_int, false, 0]])
    end

    if not defined?(::Test::Derived1_Mixin)

        module ::Test::Derived1_Mixin
        end
        class Derived1 < ::Test::Compact1

            def initialize(id=0)
                super(id)
            end
        end

        if not defined?(::Test::T_Derived1)
            T_Derived1 = ::Ice::__declareClass('::Test::Derived1')
        end

        T_Derived1.defineClass(Derived1, -1, false, false, ::Test::T_Compact1, [])
    end

    if not defined?(::Test::Compact2_Mixin)

        module ::Test::Compact2_Mixin
        end
        class Compact2 < ::Ice::Value

            def initialize(id=0)
                @id = id
            end

            attr_accessor :id
        end

        if not defined?(::Test::T_Compact2)
            T_Compact2 = ::Ice::__declareClass('::Test::Compact2')
        end

        T_Compact2.defineClass(Compact2, 3, false, false, nil, [['id', ::Ice::T_int, false, 0]])
    end

    if not defined?(::Test::Optional0_Mixin)

        module ::Test::Optional0_Mixin
        end
        class Optional0 < ::Ice::Value

            def initialize(firstName='', secondName=::Ice::Unset, emailAddress=::Ice::Unset)
                @firstName = firstName
                @secondName = secondName
                @emailAddress = emailAddress
            end

            attr_accessor :firstName, :secondName, :emailAddress
        end

        if not defined?(::Test::T_Optional0)
            T_Optional0 = ::Ice::__declareClass('::Test::Optional0')
        end

        T_Optional0.defineClass(Optional0, -1, false, false, nil, [
            ['firstName', ::Ice::T_string, false, 0],
            ['secondName', ::Ice::T_string, true, 1],
            ['emailAddress', ::Ice::T_string, true, 2]
        ])
    end

    if not defined?(::Test::Optional1_Mixin)

        module ::Test::Optional1_Mixin
        end
        class Optional1 < ::Ice::Value

            def initialize(firstName='', emailAddress=::Ice::Unset, secondName=::Ice::Unset)
                @firstName = firstName
                @emailAddress = emailAddress
                @secondName = secondName
            end

            attr_accessor :firstName, :emailAddress, :secondName
        end

        if not defined?(::Test::T_Optional1)
            T_Optional1 = ::Ice::__declareClass('::Test::Optional1')
        end

        T_Optional1.defineClass(Optional1, -1, false, false, nil, [
            ['firstName', ::Ice::T_string, false, 0],
            ['emailAddress', ::Ice::T_string, true, 2],
            ['secondName', ::Ice::T_string, true, 1]
        ])
    end

    if not defined?(::Test::Optional2_Mixin)

        module ::Test::Optional2_Mixin
        end
        class Optional2 < ::Ice::Value

            def initialize(firstName='', secondName=::Ice::Unset, emailAddress='')
                @firstName = firstName
                @secondName = secondName
                @emailAddress = emailAddress
            end

            attr_accessor :firstName, :secondName, :emailAddress
        end

        if not defined?(::Test::T_Optional2)
            T_Optional2 = ::Ice::__declareClass('::Test::Optional2')
        end

        T_Optional2.defineClass(Optional2, -1, false, false, nil, [
            ['firstName', ::Ice::T_string, false, 0],
            ['secondName', ::Ice::T_string, true, 1],
            ['emailAddress', ::Ice::T_string, false, 0]
        ])
    end

    if not defined?(::Test::Optional3_Mixin)

        module ::Test::Optional3_Mixin
        end
        class Optional3 < ::Ice::Value

            def initialize(firstName='', secondName=::Ice::Unset, emailAddress=::Ice::Unset, phoneNumber=::Ice::Unset)
                @firstName = firstName
                @secondName = secondName
                @emailAddress = emailAddress
                @phoneNumber = phoneNumber
            end

            attr_accessor :firstName, :secondName, :emailAddress, :phoneNumber
        end

        if not defined?(::Test::T_Optional3)
            T_Optional3 = ::Ice::__declareClass('::Test::Optional3')
        end

        T_Optional3.defineClass(Optional3, -1, false, false, nil, [
            ['firstName', ::Ice::T_string, false, 0],
            ['secondName', ::Ice::T_string, true, 1],
            ['emailAddress', ::Ice::T_string, true, 2],
            ['phoneNumber', ::Ice::T_string, true, 3]
        ])
    end

    if not defined?(::Test::Optional4_Mixin)

        module ::Test::Optional4_Mixin
        end
        class Optional4 < ::Ice::Value

            def initialize(firstName='', secondName=::Ice::Unset, emailAddress=::Ice::Unset)
                @firstName = firstName
                @secondName = secondName
                @emailAddress = emailAddress
            end

            attr_accessor :firstName, :secondName, :emailAddress
        end

        if not defined?(::Test::T_Optional4)
            T_Optional4 = ::Ice::__declareClass('::Test::Optional4')
        end

        T_Optional4.defineClass(Optional4, -1, false, false, nil, [
            ['firstName', ::Ice::T_string, false, 0],
            ['secondName', ::Ice::T_string, true, 2],
            ['emailAddress', ::Ice::T_string, true, 1]
        ])
    end

    if not defined?(::Test::OptionalParameters0_Mixin)

        module ::Test::OptionalParameters0_Mixin
        end
        module OptionalParameters0Prx_mixin

            def op1(firstName, secondName, emailAddress, context=nil)
                OptionalParameters0Prx_mixin::OP_op1.invoke(self, [firstName, secondName, emailAddress], context)
            end
        end

        class OptionalParameters0Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include OptionalParameters0Prx_mixin
        end

        if not defined?(::Test::T_OptionalParameters0Prx)
            T_OptionalParameters0 = ::Ice::__declareClass('::Test::OptionalParameters0')
            T_OptionalParameters0Prx = ::Ice::__declareProxy('::Test::OptionalParameters0')
        end

        T_OptionalParameters0.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_OptionalParameters0Prx.defineProxy(OptionalParameters0Prx, nil, [])

        OptionalParameters0Prx_mixin::OP_op1 = ::Ice::__defineOperation('op1', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_string, false, 0], [::Ice::T_string, true, 1], [::Ice::T_string, true, 2]], [], nil, [])
    end

    if not defined?(::Test::OptionalParameters1_Mixin)

        module ::Test::OptionalParameters1_Mixin
        end
        module OptionalParameters1Prx_mixin

            def op1(firstName, emailAddress, secondName, context=nil)
                OptionalParameters1Prx_mixin::OP_op1.invoke(self, [firstName, emailAddress, secondName], context)
            end
        end

        class OptionalParameters1Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include OptionalParameters1Prx_mixin
        end

        if not defined?(::Test::T_OptionalParameters1Prx)
            T_OptionalParameters1 = ::Ice::__declareClass('::Test::OptionalParameters1')
            T_OptionalParameters1Prx = ::Ice::__declareProxy('::Test::OptionalParameters1')
        end

        T_OptionalParameters1.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_OptionalParameters1Prx.defineProxy(OptionalParameters1Prx, nil, [])

        OptionalParameters1Prx_mixin::OP_op1 = ::Ice::__defineOperation('op1', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_string, false, 0], [::Ice::T_string, true, 2], [::Ice::T_string, true, 1]], [], nil, [])
    end

    if not defined?(::Test::OptionalParameters2_Mixin)

        module ::Test::OptionalParameters2_Mixin
        end
        module OptionalParameters2Prx_mixin

            def op1(firstName, emailAddress, secondName, context=nil)
                OptionalParameters2Prx_mixin::OP_op1.invoke(self, [firstName, emailAddress, secondName], context)
            end
        end

        class OptionalParameters2Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include OptionalParameters2Prx_mixin
        end

        if not defined?(::Test::T_OptionalParameters2Prx)
            T_OptionalParameters2 = ::Ice::__declareClass('::Test::OptionalParameters2')
            T_OptionalParameters2Prx = ::Ice::__declareProxy('::Test::OptionalParameters2')
        end

        T_OptionalParameters2.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_OptionalParameters2Prx.defineProxy(OptionalParameters2Prx, nil, [])

        OptionalParameters2Prx_mixin::OP_op1 = ::Ice::__defineOperation('op1', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_string, false, 0], [::Ice::T_string, true, 2], [::Ice::T_string, true, 1]], [], nil, [])
    end

    if not defined?(::Test::OptionalParameters3_Mixin)

        module ::Test::OptionalParameters3_Mixin
        end
        module OptionalParameters3Prx_mixin

            def op1(firstName, emailAddress, secondName, context=nil)
                OptionalParameters3Prx_mixin::OP_op1.invoke(self, [firstName, emailAddress, secondName], context)
            end
        end

        class OptionalParameters3Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include OptionalParameters3Prx_mixin
        end

        if not defined?(::Test::T_OptionalParameters3Prx)
            T_OptionalParameters3 = ::Ice::__declareClass('::Test::OptionalParameters3')
            T_OptionalParameters3Prx = ::Ice::__declareProxy('::Test::OptionalParameters3')
        end

        T_OptionalParameters3.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_OptionalParameters3Prx.defineProxy(OptionalParameters3Prx, nil, [])

        OptionalParameters3Prx_mixin::OP_op1 = ::Ice::__defineOperation('op1', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_string, false, 0], [::Ice::T_string, false, 0], [::Ice::T_string, true, 1]], [], nil, [])
    end

    if not defined?(::Test::OptionalReturn0_Mixin)

        module ::Test::OptionalReturn0_Mixin
        end
        module OptionalReturn0Prx_mixin

            def op(context=nil)
                OptionalReturn0Prx_mixin::OP_op.invoke(self, [], context)
            end
        end

        class OptionalReturn0Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include OptionalReturn0Prx_mixin
        end

        if not defined?(::Test::T_OptionalReturn0Prx)
            T_OptionalReturn0 = ::Ice::__declareClass('::Test::OptionalReturn0')
            T_OptionalReturn0Prx = ::Ice::__declareProxy('::Test::OptionalReturn0')
        end

        T_OptionalReturn0.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_OptionalReturn0Prx.defineProxy(OptionalReturn0Prx, nil, [])

        OptionalReturn0Prx_mixin::OP_op = ::Ice::__defineOperation('op', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], [::Ice::T_int, true, 1], [])
    end

    if not defined?(::Test::OptionalReturn2_Mixin)

        module ::Test::OptionalReturn2_Mixin
        end
        module OptionalReturn2Prx_mixin

            def op(context=nil)
                OptionalReturn2Prx_mixin::OP_op.invoke(self, [], context)
            end
        end

        class OptionalReturn2Prx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include OptionalReturn2Prx_mixin
        end

        if not defined?(::Test::T_OptionalReturn2Prx)
            T_OptionalReturn2 = ::Ice::__declareClass('::Test::OptionalReturn2')
            T_OptionalReturn2Prx = ::Ice::__declareProxy('::Test::OptionalReturn2')
        end

        T_OptionalReturn2.defineClass(::Ice::Value, -1, false, true, nil, [])

        T_OptionalReturn2Prx.defineProxy(OptionalReturn2Prx, nil, [])

        OptionalReturn2Prx_mixin::OP_op = ::Ice::__defineOperation('op', ::Ice::OperationMode::Normal, ::Ice::OperationMode::Normal, false, nil, [], [], [::Ice::T_int, false, 0], [])
    end

    if not defined?(::Test::LocalEnum)
        class LocalEnum
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def LocalEnum.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(LocalEnum) or raise ArgumentError, "value must be a LocalEnum"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def LocalEnum.each(&block)
                @@_enumerators.each_value(&block)
            end

            LocalEnum1 = LocalEnum.new("LocalEnum1", 0)
            LocalEnum2 = LocalEnum.new("LocalEnum2", 1)
            LocalEnum3 = LocalEnum.new("LocalEnum3", 2)

            @@_enumerators = {0=>LocalEnum1, 1=>LocalEnum2, 2=>LocalEnum3}

            def LocalEnum._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_LocalEnum = ::Ice::__defineEnum('::Test::LocalEnum', LocalEnum, LocalEnum::_enumerators)
    end

    if not defined?(::Test::T_LocalSequence)
        T_LocalSequence = ::Ice::__defineSequence('::Test::LocalSequence', ::Ice::T_string)
    end

    if not defined?(::Test::T_LocalDictionary)
        T_LocalDictionary = ::Ice::__defineDictionary('::Test::LocalDictionary', ::Ice::T_string, ::Ice::T_string)
    end

    if not defined?(::Test::LocalStruct)
        class LocalStruct
            include ::Ice::Inspect_mixin
            def initialize(str='')
                @str = str
            end

            def hash
                _h = 0
                _h = 5 * _h + @str.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::LocalStruct or
                    @str != other.str
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :str
        end

        T_LocalStruct = ::Ice::__defineStruct('::Test::LocalStruct', LocalStruct, [["str", ::Ice::T_string]])
    end

    if not defined?(::Test::LocalClass_Mixin)

        module ::Test::LocalClass_Mixin
        end
        class LocalClass
        end

        if not defined?(::Test::T_LocalClass)
            T_LocalClass = ::Ice::__declareLocalClass('::Test::LocalClass')
        end

        T_LocalClass.defineClass(LocalClass, -1, false, false, nil, [])
    end
end
