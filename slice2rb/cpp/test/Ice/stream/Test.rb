# Copyright (c) ZeroC, Inc.
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file 'Test.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>

require 'Ice'
require 'Ice/BuiltinSequences.rb'

module ::Test
    if not defined?(::Test::MyEnum)
        class MyEnum
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def MyEnum.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(MyEnum) or raise ArgumentError, "value must be a MyEnum"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def MyEnum.each(&block)
                @@_enumerators.each_value(&block)
            end

            Enum1 = MyEnum.new("enum1", 0)
            Enum2 = MyEnum.new("enum2", 1)
            Enum3 = MyEnum.new("enum3", 2)

            @@_enumerators = {0=>Enum1, 1=>Enum2, 2=>Enum3}

            def MyEnum._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_MyEnum = Ice::__defineEnum('::Test::MyEnum', MyEnum, MyEnum::_enumerators)
    end

    if not defined?(::Test::T_MyInterfacePrx)
        T_MyInterfacePrx = Ice::__declareProxy('::Test::MyInterface')
    end

    if not defined?(::Test::T_MyClass)
        T_MyClass = Ice::__declareClass('::Test::MyClass')
    end

    if not defined?(::Test::LargeStruct)
        class LargeStruct
            include Ice::Inspect_mixin
            def initialize(bo=false, by=0, sh=0, i=0, l=0, f=0.0, d=0.0, str='', e=::Test::MyEnum::Enum1, p=nil)
                @bo = bo
                @by = by
                @sh = sh
                @i = i
                @l = l
                @f = f
                @d = d
                @str = str
                @e = e
                @p = p
            end

            def hash
                _h = 0
                _h = 5 * _h + @bo.hash
                _h = 5 * _h + @by.hash
                _h = 5 * _h + @sh.hash
                _h = 5 * _h + @i.hash
                _h = 5 * _h + @l.hash
                _h = 5 * _h + @f.hash
                _h = 5 * _h + @d.hash
                _h = 5 * _h + @str.hash
                _h = 5 * _h + @e.hash
                _h = 5 * _h + @p.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::LargeStruct or
                    @bo != other.bo or
                    @by != other.by or
                    @sh != other.sh or
                    @i != other.i or
                    @l != other.l or
                    @f != other.f or
                    @d != other.d or
                    @str != other.str or
                    @e != other.e or
                    @p != other.p
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :bo, :by, :sh, :i, :l, :f, :d, :str, :e, :p
        end

        T_LargeStruct = Ice::__defineStruct('::Test::LargeStruct', LargeStruct, [
            ["bo", Ice::T_bool],
            ["by", Ice::T_byte],
            ["sh", Ice::T_short],
            ["i", Ice::T_int],
            ["l", Ice::T_long],
            ["f", Ice::T_float],
            ["d", Ice::T_double],
            ["str", Ice::T_string],
            ["e", ::Test::T_MyEnum],
            ["p", ::Test::T_MyInterfacePrx]
        ])
    end

    if not defined?(::Test::ClassStruct)
        class ClassStruct
            include Ice::Inspect_mixin
            def initialize(i=0)
                @i = i
            end

            def hash
                _h = 0
                _h = 5 * _h + @i.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Test::ClassStruct or
                    @i != other.i
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :i
        end

        T_ClassStruct = Ice::__defineStruct('::Test::ClassStruct', ClassStruct, [["i", Ice::T_int]])
    end

    if not defined?(::Test::T_OptionalClass)
        T_OptionalClass = Ice::__declareClass('::Test::OptionalClass')
    end

    if not defined?(::Test::OptionalClass)
        class OptionalClass < Ice::Value

            def initialize(bo=false, by=0, sh=Ice::Unset, i=Ice::Unset)
                @bo = bo
                @by = by
                @sh = sh
                @i = i
            end

            attr_accessor :bo, :by, :sh, :i
        end

        T_OptionalClass.defineClass(OptionalClass, -1, false, nil, [
            ['bo', Ice::T_bool, false, 0],
            ['by', Ice::T_byte, false, 0],
            ['sh', Ice::T_short, true, 1],
            ['i', Ice::T_int, true, 2]
        ])
    end

    if not defined?(::Test::T_MyEnumS)
        T_MyEnumS = Ice::__defineSequence('::Test::MyEnumS', ::Test::T_MyEnum)
    end

    if not defined?(::Test::T_LargeStructS)
        T_LargeStructS = Ice::__defineSequence('::Test::LargeStructS', ::Test::T_LargeStruct)
    end

    if not defined?(::Test::T_MyClassS)
        T_MyClassS = Ice::__defineSequence('::Test::MyClassS', ::Test::T_MyClass)
    end

    if not defined?(::Test::T_BoolSS)
        T_BoolSS = Ice::__defineSequence('::Test::BoolSS', ::Ice::T_BoolSeq)
    end

    if not defined?(::Test::T_ByteSS)
        T_ByteSS = Ice::__defineSequence('::Test::ByteSS', ::Ice::T_ByteSeq)
    end

    if not defined?(::Test::T_ShortSS)
        T_ShortSS = Ice::__defineSequence('::Test::ShortSS', ::Ice::T_ShortSeq)
    end

    if not defined?(::Test::T_IntSS)
        T_IntSS = Ice::__defineSequence('::Test::IntSS', ::Ice::T_IntSeq)
    end

    if not defined?(::Test::T_LongSS)
        T_LongSS = Ice::__defineSequence('::Test::LongSS', ::Ice::T_LongSeq)
    end

    if not defined?(::Test::T_FloatSS)
        T_FloatSS = Ice::__defineSequence('::Test::FloatSS', ::Ice::T_FloatSeq)
    end

    if not defined?(::Test::T_DoubleSS)
        T_DoubleSS = Ice::__defineSequence('::Test::DoubleSS', ::Ice::T_DoubleSeq)
    end

    if not defined?(::Test::T_StringSS)
        T_StringSS = Ice::__defineSequence('::Test::StringSS', ::Ice::T_StringSeq)
    end

    if not defined?(::Test::T_MyEnumSS)
        T_MyEnumSS = Ice::__defineSequence('::Test::MyEnumSS', ::Test::T_MyEnumS)
    end

    if not defined?(::Test::T_LargeStructSS)
        T_LargeStructSS = Ice::__defineSequence('::Test::LargeStructSS', ::Test::T_LargeStructS)
    end

    if not defined?(::Test::T_MyClassSS)
        T_MyClassSS = Ice::__defineSequence('::Test::MyClassSS', ::Test::T_MyClassS)
    end

    if not defined?(::Test::T_ByteBoolD)
        T_ByteBoolD = Ice::__defineDictionary('::Test::ByteBoolD', Ice::T_byte, Ice::T_bool)
    end

    if not defined?(::Test::T_ShortIntD)
        T_ShortIntD = Ice::__defineDictionary('::Test::ShortIntD', Ice::T_short, Ice::T_int)
    end

    if not defined?(::Test::T_LongFloatD)
        T_LongFloatD = Ice::__defineDictionary('::Test::LongFloatD', Ice::T_long, Ice::T_float)
    end

    if not defined?(::Test::T_StringStringD)
        T_StringStringD = Ice::__defineDictionary('::Test::StringStringD', Ice::T_string, Ice::T_string)
    end

    if not defined?(::Test::T_StringMyClassD)
        T_StringMyClassD = Ice::__defineDictionary('::Test::StringMyClassD', Ice::T_string, ::Test::T_MyClass)
    end

    if not defined?(::Test::MyClass)
        class MyClass < Ice::Value

            def initialize(c=nil, o=nil, s=::Test::LargeStruct.new, seq1=nil, seq2=nil, seq3=nil, seq4=nil, seq5=nil, seq6=nil, seq7=nil, seq8=nil, seq9=nil, seq10=nil, d=nil)
                @c = c
                @o = o
                @s = s
                @seq1 = seq1
                @seq2 = seq2
                @seq3 = seq3
                @seq4 = seq4
                @seq5 = seq5
                @seq6 = seq6
                @seq7 = seq7
                @seq8 = seq8
                @seq9 = seq9
                @seq10 = seq10
                @d = d
            end

            attr_accessor :c, :o, :s, :seq1, :seq2, :seq3, :seq4, :seq5, :seq6, :seq7, :seq8, :seq9, :seq10, :d
        end

        T_MyClass.defineClass(MyClass, -1, false, nil, [
            ['c', ::Test::T_MyClass, false, 0],
            ['o', Ice::T_Value, false, 0],
            ['s', ::Test::T_LargeStruct, false, 0],
            ['seq1', ::Ice::T_BoolSeq, false, 0],
            ['seq2', ::Ice::T_ByteSeq, false, 0],
            ['seq3', ::Ice::T_ShortSeq, false, 0],
            ['seq4', ::Ice::T_IntSeq, false, 0],
            ['seq5', ::Ice::T_LongSeq, false, 0],
            ['seq6', ::Ice::T_FloatSeq, false, 0],
            ['seq7', ::Ice::T_DoubleSeq, false, 0],
            ['seq8', ::Ice::T_StringSeq, false, 0],
            ['seq9', ::Test::T_MyEnumS, false, 0],
            ['seq10', ::Test::T_MyClassS, false, 0],
            ['d', ::Test::T_StringMyClassD, false, 0]
        ])
    end

    if not defined?(::Test::MyInterfacePrx)
        module MyInterfacePrx_mixin
        end

        class MyInterfacePrx < Ice::ObjectPrx
            include Ice::Proxy_mixin
            include MyInterfacePrx_mixin
        end

        T_MyInterfacePrx.defineProxy(MyInterfacePrx, nil, [])
    end

    if not defined?(::Test::MyException)
        class MyException < Ice::UserException
            def to_s
                '::Test::MyException'
            end

            attr_accessor :c
        end

        T_MyException = Ice::__defineException('::Test::MyException', MyException, nil, [["c", ::Test::T_MyClass, false, 0]])
    end

    module Sub

        if not defined?(::Test::Sub::NestedEnum)
            class NestedEnum
                include Comparable

                def initialize(name, value)
                    @name = name
                    @value = value
                end

                def NestedEnum.from_int(val)
                    @@_enumerators[val]
                end

                def to_s
                    @name
                end

                def to_i
                    @value
                end

                def <=>(other)
                    other.is_a?(NestedEnum) or raise ArgumentError, "value must be a NestedEnum"
                    @value <=> other.to_i
                end

                def hash
                    @value.hash
                end

                def NestedEnum.each(&block)
                    @@_enumerators.each_value(&block)
                end

                NestedEnum1 = NestedEnum.new("nestedEnum1", 0)
                NestedEnum2 = NestedEnum.new("nestedEnum2", 1)
                NestedEnum3 = NestedEnum.new("nestedEnum3", 2)

                @@_enumerators = {0=>NestedEnum1, 1=>NestedEnum2, 2=>NestedEnum3}

                def NestedEnum._enumerators
                    @@_enumerators
                end

                private_class_method :new
            end

            T_NestedEnum = Ice::__defineEnum('::Test::Sub::NestedEnum', NestedEnum, NestedEnum::_enumerators)
        end

        if not defined?(::Test::Sub::NestedStruct)
            class NestedStruct
                include Ice::Inspect_mixin
                def initialize(bo=false, by=0, sh=0, i=0, l=0, f=0.0, d=0.0, str='', e=::Test::Sub::NestedEnum::NestedEnum1)
                    @bo = bo
                    @by = by
                    @sh = sh
                    @i = i
                    @l = l
                    @f = f
                    @d = d
                    @str = str
                    @e = e
                end

                def hash
                    _h = 0
                    _h = 5 * _h + @bo.hash
                    _h = 5 * _h + @by.hash
                    _h = 5 * _h + @sh.hash
                    _h = 5 * _h + @i.hash
                    _h = 5 * _h + @l.hash
                    _h = 5 * _h + @f.hash
                    _h = 5 * _h + @d.hash
                    _h = 5 * _h + @str.hash
                    _h = 5 * _h + @e.hash
                    _h % 0x7fffffff
                end

                def ==(other)
                    return false if !other.is_a? ::Test::Sub::NestedStruct or
                        @bo != other.bo or
                        @by != other.by or
                        @sh != other.sh or
                        @i != other.i or
                        @l != other.l or
                        @f != other.f or
                        @d != other.d or
                        @str != other.str or
                        @e != other.e
                    true
                end

                def eql?(other)
                    return other.class == self.class && other == self
                end

                attr_accessor :bo, :by, :sh, :i, :l, :f, :d, :str, :e
            end

            T_NestedStruct = Ice::__defineStruct('::Test::Sub::NestedStruct', NestedStruct, [
                ["bo", Ice::T_bool],
                ["by", Ice::T_byte],
                ["sh", Ice::T_short],
                ["i", Ice::T_int],
                ["l", Ice::T_long],
                ["f", Ice::T_float],
                ["d", Ice::T_double],
                ["str", Ice::T_string],
                ["e", ::Test::Sub::T_NestedEnum]
            ])
        end

        if not defined?(::Test::Sub::NestedException)
            class NestedException < Ice::UserException
                def to_s
                    '::Test::Sub::NestedException'
                end

                attr_accessor :str
            end

            T_NestedException = Ice::__defineException('::Test::Sub::NestedException', NestedException, nil, [["str", Ice::T_string, false, 0]])
        end
    end
end

module ::Test2

    module Sub2

        if not defined?(::Test2::Sub2::NestedEnum2)
            class NestedEnum2
                include Comparable

                def initialize(name, value)
                    @name = name
                    @value = value
                end

                def NestedEnum2.from_int(val)
                    @@_enumerators[val]
                end

                def to_s
                    @name
                end

                def to_i
                    @value
                end

                def <=>(other)
                    other.is_a?(NestedEnum2) or raise ArgumentError, "value must be a NestedEnum2"
                    @value <=> other.to_i
                end

                def hash
                    @value.hash
                end

                def NestedEnum2.each(&block)
                    @@_enumerators.each_value(&block)
                end

                NestedEnum4 = NestedEnum2.new("nestedEnum4", 0)
                NestedEnum5 = NestedEnum2.new("nestedEnum5", 1)
                NestedEnum6 = NestedEnum2.new("nestedEnum6", 2)

                @@_enumerators = {0=>NestedEnum4, 1=>NestedEnum5, 2=>NestedEnum6}

                def NestedEnum2._enumerators
                    @@_enumerators
                end

                private_class_method :new
            end

            T_NestedEnum2 = Ice::__defineEnum('::Test2::Sub2::NestedEnum2', NestedEnum2, NestedEnum2::_enumerators)
        end

        if not defined?(::Test2::Sub2::NestedStruct2)
            class NestedStruct2
                include Ice::Inspect_mixin
                def initialize(bo=false, by=0, sh=0, i=0, l=0, f=0.0, d=0.0, str='', e=::Test2::Sub2::NestedEnum2::NestedEnum4)
                    @bo = bo
                    @by = by
                    @sh = sh
                    @i = i
                    @l = l
                    @f = f
                    @d = d
                    @str = str
                    @e = e
                end

                def hash
                    _h = 0
                    _h = 5 * _h + @bo.hash
                    _h = 5 * _h + @by.hash
                    _h = 5 * _h + @sh.hash
                    _h = 5 * _h + @i.hash
                    _h = 5 * _h + @l.hash
                    _h = 5 * _h + @f.hash
                    _h = 5 * _h + @d.hash
                    _h = 5 * _h + @str.hash
                    _h = 5 * _h + @e.hash
                    _h % 0x7fffffff
                end

                def ==(other)
                    return false if !other.is_a? ::Test2::Sub2::NestedStruct2 or
                        @bo != other.bo or
                        @by != other.by or
                        @sh != other.sh or
                        @i != other.i or
                        @l != other.l or
                        @f != other.f or
                        @d != other.d or
                        @str != other.str or
                        @e != other.e
                    true
                end

                def eql?(other)
                    return other.class == self.class && other == self
                end

                attr_accessor :bo, :by, :sh, :i, :l, :f, :d, :str, :e
            end

            T_NestedStruct2 = Ice::__defineStruct('::Test2::Sub2::NestedStruct2', NestedStruct2, [
                ["bo", Ice::T_bool],
                ["by", Ice::T_byte],
                ["sh", Ice::T_short],
                ["i", Ice::T_int],
                ["l", Ice::T_long],
                ["f", Ice::T_float],
                ["d", Ice::T_double],
                ["str", Ice::T_string],
                ["e", ::Test2::Sub2::T_NestedEnum2]
            ])
        end

        if not defined?(::Test2::Sub2::NestedException2)
            class NestedException2 < Ice::UserException
                def to_s
                    '::Test2::Sub2::NestedException2'
                end

                attr_accessor :str
            end

            T_NestedException2 = Ice::__defineException('::Test2::Sub2::NestedException2', NestedException2, nil, [["str", Ice::T_string, false, 0]])
        end
    end
end
