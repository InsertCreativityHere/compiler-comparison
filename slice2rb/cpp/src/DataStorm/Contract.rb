# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file `Contract.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'
require 'Ice/Identity.rb'
require 'Ice/BuiltinSequences.rb'
require 'DataStorm/Sample.rb'

module ::DataStormContract

    if not defined?(::DataStormContract::ClearHistoryPolicy)
        class ClearHistoryPolicy
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def ClearHistoryPolicy.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(ClearHistoryPolicy) or raise ArgumentError, "value must be a ClearHistoryPolicy"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def ClearHistoryPolicy.each(&block)
                @@_enumerators.each_value(&block)
            end

            OnAdd = ClearHistoryPolicy.new("OnAdd", 0)
            OnRemove = ClearHistoryPolicy.new("OnRemove", 1)
            OnAll = ClearHistoryPolicy.new("OnAll", 2)
            OnAllExceptPartialUpdate = ClearHistoryPolicy.new("OnAllExceptPartialUpdate", 3)
            Never = ClearHistoryPolicy.new("Never", 4)

            @@_enumerators = {0=>OnAdd, 1=>OnRemove, 2=>OnAll, 3=>OnAllExceptPartialUpdate, 4=>Never}

            def ClearHistoryPolicy._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_ClearHistoryPolicy = ::Ice::__defineEnum('::DataStormContract::ClearHistoryPolicy', ClearHistoryPolicy, ClearHistoryPolicy::_enumerators)
    end

    if not defined?(::DataStormContract::T_LongLongDict)
        T_LongLongDict = ::Ice::__defineDictionary('::DataStormContract::LongLongDict', ::Ice::T_long, ::Ice::T_long)
    end

    if not defined?(::DataStormContract::DataSample)
        class DataSample
            include ::Ice::Inspect_mixin
            def initialize(id=0, keyId=0, keyValue=nil, timestamp=0, tag=0, event=::DataStorm::SampleEvent::Add, value=nil)
                @id = id
                @keyId = keyId
                @keyValue = keyValue
                @timestamp = timestamp
                @tag = tag
                @event = event
                @value = value
            end

            def hash
                _h = 0
                _h = 5 * _h + @id.hash
                _h = 5 * _h + @keyId.hash
                _h = 5 * _h + @keyValue.hash
                _h = 5 * _h + @timestamp.hash
                _h = 5 * _h + @tag.hash
                _h = 5 * _h + @event.hash
                _h = 5 * _h + @value.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::DataStormContract::DataSample or
                    @id != other.id or
                    @keyId != other.keyId or
                    @keyValue != other.keyValue or
                    @timestamp != other.timestamp or
                    @tag != other.tag or
                    @event != other.event or
                    @value != other.value
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :id, :keyId, :keyValue, :timestamp, :tag, :event, :value
        end

        T_DataSample = ::Ice::__defineStruct('::DataStormContract::DataSample', DataSample, [
            ["id", ::Ice::T_long],
            ["keyId", ::Ice::T_long],
            ["keyValue", ::Ice::T_ByteSeq],
            ["timestamp", ::Ice::T_long],
            ["tag", ::Ice::T_long],
            ["event", ::DataStorm::T_SampleEvent],
            ["value", ::Ice::T_ByteSeq]
        ])
    end

    if not defined?(::DataStormContract::T_DataSampleSeq)
        T_DataSampleSeq = ::Ice::__defineSequence('::DataStormContract::DataSampleSeq', ::DataStormContract::T_DataSample)
    end

    if not defined?(::DataStormContract::DataSamples)
        class DataSamples
            include ::Ice::Inspect_mixin
            def initialize(id=0, samples=nil)
                @id = id
                @samples = samples
            end

            def hash
                _h = 0
                _h = 5 * _h + @id.hash
                _h = 5 * _h + @samples.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::DataStormContract::DataSamples or
                    @id != other.id or
                    @samples != other.samples
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :id, :samples
        end

        T_DataSamples = ::Ice::__defineStruct('::DataStormContract::DataSamples', DataSamples, [
            ["id", ::Ice::T_long],
            ["samples", ::DataStormContract::T_DataSampleSeq]
        ])
    end

    if not defined?(::DataStormContract::T_DataSamplesSeq)
        T_DataSamplesSeq = ::Ice::__defineSequence('::DataStormContract::DataSamplesSeq', ::DataStormContract::T_DataSamples)
    end

    if not defined?(::DataStormContract::ElementInfo)
        class ElementInfo
            include ::Ice::Inspect_mixin
            def initialize(id=0, name='', value=nil)
                @id = id
                @name = name
                @value = value
            end

            def hash
                _h = 0
                _h = 5 * _h + @id.hash
                _h = 5 * _h + @name.hash
                _h = 5 * _h + @value.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::DataStormContract::ElementInfo or
                    @id != other.id or
                    @name != other.name or
                    @value != other.value
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :id, :name, :value
        end

        T_ElementInfo = ::Ice::__defineStruct('::DataStormContract::ElementInfo', ElementInfo, [
            ["id", ::Ice::T_long],
            ["name", ::Ice::T_string],
            ["value", ::Ice::T_ByteSeq]
        ])
    end

    if not defined?(::DataStormContract::T_ElementInfoSeq)
        T_ElementInfoSeq = ::Ice::__defineSequence('::DataStormContract::ElementInfoSeq', ::DataStormContract::T_ElementInfo)
    end

    if not defined?(::DataStormContract::TopicInfo)
        class TopicInfo
            include ::Ice::Inspect_mixin
            def initialize(name='', ids=nil)
                @name = name
                @ids = ids
            end

            def hash
                _h = 0
                _h = 5 * _h + @name.hash
                _h = 5 * _h + @ids.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::DataStormContract::TopicInfo or
                    @name != other.name or
                    @ids != other.ids
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :name, :ids
        end

        T_TopicInfo = ::Ice::__defineStruct('::DataStormContract::TopicInfo', TopicInfo, [
            ["name", ::Ice::T_string],
            ["ids", ::Ice::T_LongSeq]
        ])
    end

    if not defined?(::DataStormContract::T_TopicInfoSeq)
        T_TopicInfoSeq = ::Ice::__defineSequence('::DataStormContract::TopicInfoSeq', ::DataStormContract::T_TopicInfo)
    end

    if not defined?(::DataStormContract::TopicSpec)
        class TopicSpec
            include ::Ice::Inspect_mixin
            def initialize(id=0, name='', elements=nil, tags=nil)
                @id = id
                @name = name
                @elements = elements
                @tags = tags
            end

            def hash
                _h = 0
                _h = 5 * _h + @id.hash
                _h = 5 * _h + @name.hash
                _h = 5 * _h + @elements.hash
                _h = 5 * _h + @tags.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::DataStormContract::TopicSpec or
                    @id != other.id or
                    @name != other.name or
                    @elements != other.elements or
                    @tags != other.tags
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :id, :name, :elements, :tags
        end

        T_TopicSpec = ::Ice::__defineStruct('::DataStormContract::TopicSpec', TopicSpec, [
            ["id", ::Ice::T_long],
            ["name", ::Ice::T_string],
            ["elements", ::DataStormContract::T_ElementInfoSeq],
            ["tags", ::DataStormContract::T_ElementInfoSeq]
        ])
    end

    if not defined?(::DataStormContract::FilterInfo)
        class FilterInfo
            include ::Ice::Inspect_mixin
            def initialize(name='', criteria=nil)
                @name = name
                @criteria = criteria
            end

            def hash
                _h = 0
                _h = 5 * _h + @name.hash
                _h = 5 * _h + @criteria.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::DataStormContract::FilterInfo or
                    @name != other.name or
                    @criteria != other.criteria
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :name, :criteria
        end

        T_FilterInfo = ::Ice::__defineStruct('::DataStormContract::FilterInfo', FilterInfo, [
            ["name", ::Ice::T_string],
            ["criteria", ::Ice::T_ByteSeq]
        ])
    end

    if not defined?(::DataStormContract::ElementConfig)
        class ElementConfig < ::Ice::Value

            def initialize(facet=::Ice::Unset, sampleFilter=::Ice::Unset, name=::Ice::Unset, priority=::Ice::Unset, sampleCount=::Ice::Unset, sampleLifetime=::Ice::Unset, clearHistory=::Ice::Unset)
                @facet = facet
                @sampleFilter = sampleFilter
                @name = name
                @priority = priority
                @sampleCount = sampleCount
                @sampleLifetime = sampleLifetime
                @clearHistory = clearHistory
            end

            attr_accessor :facet, :sampleFilter, :name, :priority, :sampleCount, :sampleLifetime, :clearHistory
        end

        if not defined?(::DataStormContract::T_ElementConfig)
            T_ElementConfig = ::Ice::__declareClass('::DataStormContract::ElementConfig')
        end

        T_ElementConfig.defineClass(ElementConfig, 1, false, nil, [
            ['facet', ::Ice::T_string, true, 1],
            ['sampleFilter', ::DataStormContract::T_FilterInfo, true, 2],
            ['name', ::Ice::T_string, true, 3],
            ['priority', ::Ice::T_int, true, 4],
            ['sampleCount', ::Ice::T_int, true, 10],
            ['sampleLifetime', ::Ice::T_int, true, 11],
            ['clearHistory', ::DataStormContract::T_ClearHistoryPolicy, true, 12]
        ])
    end

    if not defined?(::DataStormContract::ElementData)
        class ElementData
            include ::Ice::Inspect_mixin
            def initialize(id=0, config=nil, lastIds=nil)
                @id = id
                @config = config
                @lastIds = lastIds
            end

            def hash
                _h = 0
                _h = 5 * _h + @id.hash
                _h = 5 * _h + @config.hash
                _h = 5 * _h + @lastIds.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::DataStormContract::ElementData or
                    @id != other.id or
                    @config != other.config or
                    @lastIds != other.lastIds
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :id, :config, :lastIds
        end

        T_ElementData = ::Ice::__defineStruct('::DataStormContract::ElementData', ElementData, [
            ["id", ::Ice::T_long],
            ["config", ::DataStormContract::T_ElementConfig],
            ["lastIds", ::DataStormContract::T_LongLongDict]
        ])
    end

    if not defined?(::DataStormContract::T_ElementDataSeq)
        T_ElementDataSeq = ::Ice::__defineSequence('::DataStormContract::ElementDataSeq', ::DataStormContract::T_ElementData)
    end

    if not defined?(::DataStormContract::ElementSpec)
        class ElementSpec
            include ::Ice::Inspect_mixin
            def initialize(elements=nil, id=0, name='', value=nil, peerId=0, peerName='')
                @elements = elements
                @id = id
                @name = name
                @value = value
                @peerId = peerId
                @peerName = peerName
            end

            def hash
                _h = 0
                _h = 5 * _h + @elements.hash
                _h = 5 * _h + @id.hash
                _h = 5 * _h + @name.hash
                _h = 5 * _h + @value.hash
                _h = 5 * _h + @peerId.hash
                _h = 5 * _h + @peerName.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::DataStormContract::ElementSpec or
                    @elements != other.elements or
                    @id != other.id or
                    @name != other.name or
                    @value != other.value or
                    @peerId != other.peerId or
                    @peerName != other.peerName
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :elements, :id, :name, :value, :peerId, :peerName
        end

        T_ElementSpec = ::Ice::__defineStruct('::DataStormContract::ElementSpec', ElementSpec, [
            ["elements", ::DataStormContract::T_ElementDataSeq],
            ["id", ::Ice::T_long],
            ["name", ::Ice::T_string],
            ["value", ::Ice::T_ByteSeq],
            ["peerId", ::Ice::T_long],
            ["peerName", ::Ice::T_string]
        ])
    end

    if not defined?(::DataStormContract::T_ElementSpecSeq)
        T_ElementSpecSeq = ::Ice::__defineSequence('::DataStormContract::ElementSpecSeq', ::DataStormContract::T_ElementSpec)
    end

    if not defined?(::DataStormContract::ElementDataAck)
        class ElementDataAck
            include ::Ice::Inspect_mixin
            def initialize(id=0, config=nil, lastIds=nil, samples=nil, peerId=0)
                @id = id
                @config = config
                @lastIds = lastIds
                @samples = samples
                @peerId = peerId
            end

            def hash
                _h = 0
                _h = 5 * _h + @id.hash
                _h = 5 * _h + @config.hash
                _h = 5 * _h + @lastIds.hash
                _h = 5 * _h + @samples.hash
                _h = 5 * _h + @peerId.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::DataStormContract::ElementDataAck or
                    @id != other.id or
                    @config != other.config or
                    @lastIds != other.lastIds or
                    @samples != other.samples or
                    @peerId != other.peerId
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :id, :config, :lastIds, :samples, :peerId
        end

        T_ElementDataAck = ::Ice::__defineStruct('::DataStormContract::ElementDataAck', ElementDataAck, [
            ["id", ::Ice::T_long],
            ["config", ::DataStormContract::T_ElementConfig],
            ["lastIds", ::DataStormContract::T_LongLongDict],
            ["samples", ::DataStormContract::T_DataSampleSeq],
            ["peerId", ::Ice::T_long]
        ])
    end

    if not defined?(::DataStormContract::T_ElementDataAckSeq)
        T_ElementDataAckSeq = ::Ice::__defineSequence('::DataStormContract::ElementDataAckSeq', ::DataStormContract::T_ElementDataAck)
    end

    if not defined?(::DataStormContract::ElementSpecAck)
        class ElementSpecAck
            include ::Ice::Inspect_mixin
            def initialize(elements=nil, id=0, name='', value=nil, peerId=0, peerName='')
                @elements = elements
                @id = id
                @name = name
                @value = value
                @peerId = peerId
                @peerName = peerName
            end

            def hash
                _h = 0
                _h = 5 * _h + @elements.hash
                _h = 5 * _h + @id.hash
                _h = 5 * _h + @name.hash
                _h = 5 * _h + @value.hash
                _h = 5 * _h + @peerId.hash
                _h = 5 * _h + @peerName.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::DataStormContract::ElementSpecAck or
                    @elements != other.elements or
                    @id != other.id or
                    @name != other.name or
                    @value != other.value or
                    @peerId != other.peerId or
                    @peerName != other.peerName
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :elements, :id, :name, :value, :peerId, :peerName
        end

        T_ElementSpecAck = ::Ice::__defineStruct('::DataStormContract::ElementSpecAck', ElementSpecAck, [
            ["elements", ::DataStormContract::T_ElementDataAckSeq],
            ["id", ::Ice::T_long],
            ["name", ::Ice::T_string],
            ["value", ::Ice::T_ByteSeq],
            ["peerId", ::Ice::T_long],
            ["peerName", ::Ice::T_string]
        ])
    end

    if not defined?(::DataStormContract::T_ElementSpecAckSeq)
        T_ElementSpecAckSeq = ::Ice::__defineSequence('::DataStormContract::ElementSpecAckSeq', ::DataStormContract::T_ElementSpecAck)
    end

    if not defined?(::DataStormContract::SessionPrx)
        module SessionPrx_mixin

            def announceTopics(topics, initialize, context=nil)
                SessionPrx_mixin::OP_announceTopics.invoke(self, [topics, initialize], context)
            end

            def attachTopic(topic, context=nil)
                SessionPrx_mixin::OP_attachTopic.invoke(self, [topic], context)
            end

            def detachTopic(topic, context=nil)
                SessionPrx_mixin::OP_detachTopic.invoke(self, [topic], context)
            end

            def attachTags(topic, tags, initialize, context=nil)
                SessionPrx_mixin::OP_attachTags.invoke(self, [topic, tags, initialize], context)
            end

            def detachTags(topic, tags, context=nil)
                SessionPrx_mixin::OP_detachTags.invoke(self, [topic, tags], context)
            end

            def announceElements(topic, keys, context=nil)
                SessionPrx_mixin::OP_announceElements.invoke(self, [topic, keys], context)
            end

            def attachElements(topic, elements, initialize, context=nil)
                SessionPrx_mixin::OP_attachElements.invoke(self, [topic, elements, initialize], context)
            end

            def attachElementsAck(topic, elements, context=nil)
                SessionPrx_mixin::OP_attachElementsAck.invoke(self, [topic, elements], context)
            end

            def detachElements(topic, keys, context=nil)
                SessionPrx_mixin::OP_detachElements.invoke(self, [topic, keys], context)
            end

            def initSamples(topic, samples, context=nil)
                SessionPrx_mixin::OP_initSamples.invoke(self, [topic, samples], context)
            end

            def disconnected(context=nil)
                SessionPrx_mixin::OP_disconnected.invoke(self, [], context)
            end
        end

        class SessionPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include SessionPrx_mixin
        end

        if not defined?(::DataStormContract::T_SessionPrx)
            T_SessionPrx = ::Ice::__declareProxy('::DataStormContract::Session')
        end

        T_SessionPrx.defineProxy(SessionPrx, nil, [])

        SessionPrx_mixin::OP_announceTopics = ::Ice::__defineOperation('announceTopics', ::Ice::OperationMode::Normal, false, nil, [[::DataStormContract::T_TopicInfoSeq, false, 0], [::Ice::T_bool, false, 0]], [], nil, [])
        SessionPrx_mixin::OP_attachTopic = ::Ice::__defineOperation('attachTopic', ::Ice::OperationMode::Normal, false, nil, [[::DataStormContract::T_TopicSpec, false, 0]], [], nil, [])
        SessionPrx_mixin::OP_detachTopic = ::Ice::__defineOperation('detachTopic', ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_long, false, 0]], [], nil, [])
        SessionPrx_mixin::OP_attachTags = ::Ice::__defineOperation('attachTags', ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_long, false, 0], [::DataStormContract::T_ElementInfoSeq, false, 0], [::Ice::T_bool, false, 0]], [], nil, [])
        SessionPrx_mixin::OP_detachTags = ::Ice::__defineOperation('detachTags', ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_long, false, 0], [::Ice::T_LongSeq, false, 0]], [], nil, [])
        SessionPrx_mixin::OP_announceElements = ::Ice::__defineOperation('announceElements', ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_long, false, 0], [::DataStormContract::T_ElementInfoSeq, false, 0]], [], nil, [])
        SessionPrx_mixin::OP_attachElements = ::Ice::__defineOperation('attachElements', ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_long, false, 0], [::DataStormContract::T_ElementSpecSeq, false, 0], [::Ice::T_bool, false, 0]], [], nil, [])
        SessionPrx_mixin::OP_attachElementsAck = ::Ice::__defineOperation('attachElementsAck', ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_long, false, 0], [::DataStormContract::T_ElementSpecAckSeq, false, 0]], [], nil, [])
        SessionPrx_mixin::OP_detachElements = ::Ice::__defineOperation('detachElements', ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_long, false, 0], [::Ice::T_LongSeq, false, 0]], [], nil, [])
        SessionPrx_mixin::OP_initSamples = ::Ice::__defineOperation('initSamples', ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_long, false, 0], [::DataStormContract::T_DataSamplesSeq, false, 0]], [], nil, [])
        SessionPrx_mixin::OP_disconnected = ::Ice::__defineOperation('disconnected', ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
    end

    if not defined?(::DataStormContract::PublisherSessionPrx)
        module PublisherSessionPrx_mixin
            include ::DataStormContract::SessionPrx_mixin
        end

        class PublisherSessionPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include PublisherSessionPrx_mixin
        end

        if not defined?(::DataStormContract::T_PublisherSessionPrx)
            T_PublisherSessionPrx = ::Ice::__declareProxy('::DataStormContract::PublisherSession')
        end

        T_PublisherSessionPrx.defineProxy(PublisherSessionPrx, nil, [::DataStormContract::T_SessionPrx])
    end

    if not defined?(::DataStormContract::SubscriberSessionPrx)
        module SubscriberSessionPrx_mixin
            include ::DataStormContract::SessionPrx_mixin

            def s(topicId, elementId, sample, context=nil)
                SubscriberSessionPrx_mixin::OP_s.invoke(self, [topicId, elementId, sample], context)
            end
        end

        class SubscriberSessionPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include SubscriberSessionPrx_mixin
        end

        if not defined?(::DataStormContract::T_SubscriberSessionPrx)
            T_SubscriberSessionPrx = ::Ice::__declareProxy('::DataStormContract::SubscriberSession')
        end

        T_SubscriberSessionPrx.defineProxy(SubscriberSessionPrx, nil, [::DataStormContract::T_SessionPrx])

        SubscriberSessionPrx_mixin::OP_s = ::Ice::__defineOperation('s', ::Ice::OperationMode::Normal, false, nil, [[::Ice::T_long, false, 0], [::Ice::T_long, false, 0], [::DataStormContract::T_DataSample, false, 0]], [], nil, [])
    end

    if not defined?(::DataStormContract::NodePrx)
        module NodePrx_mixin

            def initiateCreateSession(publisher, context=nil)
                NodePrx_mixin::OP_initiateCreateSession.invoke(self, [publisher], context)
            end

            def createSession(subscriber, session, fromRelay, context=nil)
                NodePrx_mixin::OP_createSession.invoke(self, [subscriber, session, fromRelay], context)
            end

            def confirmCreateSession(publisher, session, context=nil)
                NodePrx_mixin::OP_confirmCreateSession.invoke(self, [publisher, session], context)
            end
        end

        class NodePrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include NodePrx_mixin
        end

        if not defined?(::DataStormContract::T_NodePrx)
            T_NodePrx = ::Ice::__declareProxy('::DataStormContract::Node')
        end

        T_NodePrx.defineProxy(NodePrx, nil, [])

        NodePrx_mixin::OP_initiateCreateSession = ::Ice::__defineOperation('initiateCreateSession', ::Ice::OperationMode::Normal, false, nil, [[::DataStormContract::T_NodePrx, false, 0]], [], nil, [])
        NodePrx_mixin::OP_createSession = ::Ice::__defineOperation('createSession', ::Ice::OperationMode::Normal, false, nil, [[::DataStormContract::T_NodePrx, false, 0], [::DataStormContract::T_SubscriberSessionPrx, false, 0], [::Ice::T_bool, false, 0]], [], nil, [])
        NodePrx_mixin::OP_confirmCreateSession = ::Ice::__defineOperation('confirmCreateSession', ::Ice::OperationMode::Normal, false, nil, [[::DataStormContract::T_NodePrx, false, 0], [::DataStormContract::T_PublisherSessionPrx, false, 0]], [], nil, [])
    end

    if not defined?(::DataStormContract::LookupPrx)
        module LookupPrx_mixin

            def announceTopicReader(topic, node, context=nil)
                LookupPrx_mixin::OP_announceTopicReader.invoke(self, [topic, node], context)
            end

            def announceTopicWriter(topic, node, context=nil)
                LookupPrx_mixin::OP_announceTopicWriter.invoke(self, [topic, node], context)
            end

            def announceTopics(readers, writers, node, context=nil)
                LookupPrx_mixin::OP_announceTopics.invoke(self, [readers, writers, node], context)
            end

            def createSession(node, context=nil)
                LookupPrx_mixin::OP_createSession.invoke(self, [node], context)
            end
        end

        class LookupPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include LookupPrx_mixin
        end

        if not defined?(::DataStormContract::T_LookupPrx)
            T_LookupPrx = ::Ice::__declareProxy('::DataStormContract::Lookup')
        end

        T_LookupPrx.defineProxy(LookupPrx, nil, [])

        LookupPrx_mixin::OP_announceTopicReader = ::Ice::__defineOperation('announceTopicReader', ::Ice::OperationMode::Idempotent, false, nil, [[::Ice::T_string, false, 0], [::DataStormContract::T_NodePrx, false, 0]], [], nil, [])
        LookupPrx_mixin::OP_announceTopicWriter = ::Ice::__defineOperation('announceTopicWriter', ::Ice::OperationMode::Idempotent, false, nil, [[::Ice::T_string, false, 0], [::DataStormContract::T_NodePrx, false, 0]], [], nil, [])
        LookupPrx_mixin::OP_announceTopics = ::Ice::__defineOperation('announceTopics', ::Ice::OperationMode::Idempotent, false, nil, [[::Ice::T_StringSeq, false, 0], [::Ice::T_StringSeq, false, 0], [::DataStormContract::T_NodePrx, false, 0]], [], nil, [])
        LookupPrx_mixin::OP_createSession = ::Ice::__defineOperation('createSession', ::Ice::OperationMode::Normal, false, nil, [[::DataStormContract::T_NodePrx, false, 0]], [], [::DataStormContract::T_NodePrx, false, 0], [])
    end
end
