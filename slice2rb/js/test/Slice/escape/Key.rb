# encoding: utf-8
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file `Key.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

require 'Ice'

module ::Await

    if not defined?(::Await::Var)
        class Var
            include Comparable

            def initialize(name, value)
                @name = name
                @value = value
            end

            def Var.from_int(val)
                @@_enumerators[val]
            end

            def to_s
                @name
            end

            def to_i
                @value
            end

            def <=>(other)
                other.is_a?(Var) or raise ArgumentError, "value must be a Var"
                @value <=> other.to_i
            end

            def hash
                @value.hash
            end

            def Var.each(&block)
                @@_enumerators.each_value(&block)
            end

            Base = Var.new("base", 0)

            @@_enumerators = {0=>Base}

            def Var._enumerators
                @@_enumerators
            end

            private_class_method :new
        end

        T_Var = ::Ice::__defineEnum('::await::var', Var, Var::_enumerators)
    end

    if not defined?(::Await::Break)
        class Break
            include ::Ice::Inspect_mixin
            def initialize(_while=0)
                @_while = _while
            end

            def hash
                _h = 0
                _h = 5 * _h + @_while.hash
                _h % 0x7fffffff
            end

            def ==(other)
                return false if !other.is_a? ::Await::Break or
                    @_while != other._while
                true
            end

            def eql?(other)
                return other.class == self.class && other == self
            end

            attr_accessor :_while
        end

        T_Break = ::Ice::__defineStruct('::await::break', Break, [["_while", ::Ice::T_int]])
    end

    if not defined?(::Await::Case_Mixin)

        module ::Await::Case_Mixin
        end
        module CasePrx_mixin

            def catch(checked, context=nil)
                CasePrx_mixin::OP_catch.invoke(self, [checked], context)
            end
        end

        class CasePrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include CasePrx_mixin
        end

        if not defined?(::Await::T_CasePrx)
            T_Case = ::Ice::__declareClass('::await::case')
            T_CasePrx = ::Ice::__declareProxy('::await::case')
        end

        T_CasePrx.defineProxy(CasePrx, nil, [])

        CasePrx_mixin::OP_catch = ::Ice::__defineOperation('catch', ::Ice::OperationMode::Normal, true, nil, [[::Ice::T_int, false, 0]], [[::Ice::T_int, false, 0]], nil, [])
    end

    if not defined?(::Await::Typeof_Mixin)

        module ::Await::Typeof_Mixin
        end
        module TypeofPrx_mixin

            def default(context=nil)
                TypeofPrx_mixin::OP_default.invoke(self, [], context)
            end
        end

        class TypeofPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include TypeofPrx_mixin
        end

        if not defined?(::Await::T_TypeofPrx)
            T_Typeof = ::Ice::__declareClass('::await::typeof')
            T_TypeofPrx = ::Ice::__declareProxy('::await::typeof')
        end

        T_TypeofPrx.defineProxy(TypeofPrx, nil, [])

        TypeofPrx_mixin::OP_default = ::Ice::__defineOperation('default', ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
    end

    if not defined?(::Await::Delete_Mixin)

        module ::Await::Delete_Mixin
        end
        class Delete < ::Ice::Value

            def initialize(_if=0, _else=nil, export=0)
                @_if = _if
                @_else = _else
                @export = export
            end

            attr_accessor :_if, :_else, :export
        end

        if not defined?(::Await::T_Delete)
            T_Delete = ::Ice::__declareClass('::await::delete')
        end

        T_Delete.defineClass(Delete, -1, false, nil, [
            ['_if', ::Ice::T_int, false, 0],
            ['_else', ::Await::T_CasePrx, false, 0],
            ['export', ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::Await::Explicit_Mixin)

        module ::Await::Explicit_Mixin
        end
        module ExplicitPrx_mixin
            include ::Await::TypeofPrx_mixin
            include ::Await::CasePrx_mixin
        end

        class ExplicitPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include ExplicitPrx_mixin
        end

        if not defined?(::Await::T_ExplicitPrx)
            T_Explicit = ::Ice::__declareClass('::await::explicit')
            T_ExplicitPrx = ::Ice::__declareProxy('::await::explicit')
        end

        T_ExplicitPrx.defineProxy(ExplicitPrx, nil, [::Await::T_TypeofPrx, ::Await::T_CasePrx])
    end

    if not defined?(::Await::T_While)
        T_While = ::Ice::__defineDictionary('::await::while', ::Ice::T_string, ::Await::T_Break)
    end

    if not defined?(::Await::Package_Mixin)

        module ::Await::Package_Mixin
        end
        class Package < ::Ice::Value

            def initialize(_for=::Ice::Unset, goto=::Ice::Unset, _if=::Ice::Unset, internal=::Ice::Unset, debugger=::Ice::Unset, null=::Ice::Unset)
                @_for = _for
                @goto = goto
                @_if = _if
                @internal = internal
                @debugger = debugger
                @null = null
            end

            attr_accessor :_for, :goto, :_if, :internal, :debugger, :null
        end

        if not defined?(::Await::T_Package)
            T_Package = ::Ice::__declareClass('::await::package')
        end

        T_Package.defineClass(Package, -1, false, nil, [
            ['_for', ::Await::T_Break, true, 1],
            ['goto', ::Await::T_Var, true, 2],
            ['_if', ::Await::T_ExplicitPrx, true, 3],
            ['internal', ::Await::T_While, true, 5],
            ['debugger', ::Ice::T_string, true, 7],
            ['null', ::Await::T_ExplicitPrx, true, 8]
        ])
    end

    if not defined?(::Await::OptionalParams_Mixin)

        module ::Await::OptionalParams_Mixin
        end
        module OptionalParamsPrx_mixin

            def _for(goto, _if, internal, namespace, null, context=nil)
                OptionalParamsPrx_mixin::OP_for.invoke(self, [goto, _if, internal, namespace, null], context)
            end

            def continue(goto, _if, internal, namespace, null, context=nil)
                OptionalParamsPrx_mixin::OP_continue.invoke(self, [goto, _if, internal, namespace, null], context)
            end

            def _in(context=nil)
                OptionalParamsPrx_mixin::OP_in.invoke(self, [], context)
            end

            def foreach(context=nil)
                OptionalParamsPrx_mixin::OP_foreach.invoke(self, [], context)
            end
        end

        class OptionalParamsPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include OptionalParamsPrx_mixin
        end

        if not defined?(::Await::T_OptionalParamsPrx)
            T_OptionalParams = ::Ice::__declareClass('::await::optionalParams')
            T_OptionalParamsPrx = ::Ice::__declareProxy('::await::optionalParams')
        end

        T_OptionalParamsPrx.defineProxy(OptionalParamsPrx, nil, [])

        OptionalParamsPrx_mixin::OP_for = ::Ice::__defineOperation('for', ::Ice::OperationMode::Normal, false, nil, [[::Await::T_Var, true, 2], [::Await::T_ExplicitPrx, true, 3], [::Await::T_While, true, 5], [::Ice::T_string, true, 7], [::Await::T_ExplicitPrx, true, 8]], [], [::Await::T_Break, true, 1], [])
        OptionalParamsPrx_mixin::OP_continue = ::Ice::__defineOperation('continue', ::Ice::OperationMode::Normal, true, nil, [[::Await::T_Var, true, 2], [::Await::T_ExplicitPrx, true, 3], [::Await::T_While, true, 5], [::Ice::T_string, true, 7], [::Await::T_ExplicitPrx, true, 8]], [], [::Await::T_Break, true, 1], [])
        OptionalParamsPrx_mixin::OP_in = ::Ice::__defineOperation('in', ::Ice::OperationMode::Normal, false, nil, [], [[::Await::T_Var, true, 2], [::Await::T_ExplicitPrx, true, 3], [::Await::T_While, true, 5], [::Ice::T_string, true, 7], [::Await::T_ExplicitPrx, true, 8]], [::Await::T_Break, true, 1], [])
        OptionalParamsPrx_mixin::OP_foreach = ::Ice::__defineOperation('foreach', ::Ice::OperationMode::Normal, true, nil, [], [[::Await::T_Var, true, 2], [::Await::T_ExplicitPrx, true, 3], [::Await::T_While, true, 5], [::Ice::T_string, true, 7], [::Await::T_ExplicitPrx, true, 8]], [::Await::T_Break, true, 1], [])
    end

    if not defined?(::Await::Fixed)
        class Fixed < Ice::UserException
            def initialize(_for=0)
                @_for = _for
            end

            def to_s
                '::await::fixed'
            end

            attr_accessor :_for
        end

        T_Fixed = ::Ice::__defineException('::await::fixed', Fixed, nil, [["_for", ::Ice::T_int, false, 0]])
    end

    if not defined?(::Await::Foreach)
        class Foreach < ::Await::Fixed
            def initialize(_for=0, goto=0, _if=0)
                super(_for)
                @goto = goto
                @_if = _if
            end

            def to_s
                '::await::foreach'
            end

            attr_accessor :goto, :_if
        end

        T_Foreach = ::Ice::__defineException('::await::foreach', Foreach, ::Await::T_Fixed, [
            ["goto", ::Ice::T_int, false, 0],
            ["_if", ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::Await::BaseMethods)
        class BaseMethods < Ice::UserException
            def initialize(data=0, helpLink=0, innerException=0, message=0, source=0, stackTrace=0, targetSite=0, hResult=0, equals=0, getBaseException=0, getHashCode=0, getObjectData=0, getType=0, referenceEquals=0, toString=0)
                @Data = data
                @HelpLink = helpLink
                @InnerException = innerException
                @Message = message
                @Source = source
                @StackTrace = stackTrace
                @TargetSite = targetSite
                @HResult = hResult
                @Equals = equals
                @GetBaseException = getBaseException
                @GetHashCode = getHashCode
                @GetObjectData = getObjectData
                @GetType = getType
                @ReferenceEquals = referenceEquals
                @ToString = toString
            end

            def to_s
                '::await::BaseMethods'
            end

            attr_accessor :Data, :HelpLink, :InnerException, :Message, :Source, :StackTrace, :TargetSite, :HResult, :Equals, :GetBaseException, :GetHashCode, :GetObjectData, :GetType, :ReferenceEquals, :ToString
        end

        T_BaseMethods = ::Ice::__defineException('::await::BaseMethods', BaseMethods, nil, [
            ["Data", ::Ice::T_int, false, 0],
            ["HelpLink", ::Ice::T_int, false, 0],
            ["InnerException", ::Ice::T_int, false, 0],
            ["Message", ::Ice::T_int, false, 0],
            ["Source", ::Ice::T_int, false, 0],
            ["StackTrace", ::Ice::T_int, false, 0],
            ["TargetSite", ::Ice::T_int, false, 0],
            ["HResult", ::Ice::T_int, false, 0],
            ["Equals", ::Ice::T_int, false, 0],
            ["GetBaseException", ::Ice::T_int, false, 0],
            ["GetHashCode", ::Ice::T_int, false, 0],
            ["GetObjectData", ::Ice::T_int, false, 0],
            ["GetType", ::Ice::T_int, false, 0],
            ["ReferenceEquals", ::Ice::T_int, false, 0],
            ["ToString", ::Ice::T_int, false, 0]
        ])
    end

    if not defined?(::Await::Implicit_Mixin)

        module ::Await::Implicit_Mixin
        end
        module ImplicitPrx_mixin

            def _in(internal, is, lock, namespace, _new, null, operator, override, params, private, context=nil)
                ImplicitPrx_mixin::OP_in.invoke(self, [internal, is, lock, namespace, _new, null, operator, override, params, private], context)
            end
        end

        class ImplicitPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include ImplicitPrx_mixin
        end

        if not defined?(::Await::T_ImplicitPrx)
            T_Implicit = ::Ice::__declareClass('::await::implicit')
            T_ImplicitPrx = ::Ice::__declareProxy('::await::implicit')
        end

        T_ImplicitPrx.defineProxy(ImplicitPrx, nil, [])

        ImplicitPrx_mixin::OP_in = ::Ice::__defineOperation('in', ::Ice::OperationMode::Normal, false, nil, [[::Await::T_Break, false, 0], [::Await::T_Delete, false, 0], [::Await::T_ExplicitPrx, false, 0], [::Await::T_CasePrx, false, 0], [::Await::T_TypeofPrx, false, 0], [::Await::T_Delete, false, 0], [::Await::T_ExplicitPrx, false, 0], [::Ice::T_int, false, 0], [::Ice::T_int, false, 0], [::Ice::T_int, false, 0]], [], [::Await::T_Var, false, 0], [::Await::T_Fixed, ::Await::T_Foreach])
    end

    Protected = 0

    Public = 0

    module System

        if not defined?(::Await::System::Test_Mixin)

            module ::Await::System::Test_Mixin
            end
            module TestPrx_mixin

                def op(context=nil)
                    TestPrx_mixin::OP_op.invoke(self, [], context)
                end
            end

            class TestPrx < ::Ice::ObjectPrx
                include ::Ice::Proxy_mixin
                include TestPrx_mixin
            end

            if not defined?(::Await::System::T_TestPrx)
                T_Test = ::Ice::__declareClass('::await::System::Test')
                T_TestPrx = ::Ice::__declareProxy('::await::System::Test')
            end

            T_TestPrx.defineProxy(TestPrx, nil, [])

            TestPrx_mixin::OP_op = ::Ice::__defineOperation('op', ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
        end
    end
end

module ::System

    if not defined?(::System::Test_Mixin)

        module ::System::Test_Mixin
        end
        module TestPrx_mixin

            def op(context=nil)
                TestPrx_mixin::OP_op.invoke(self, [], context)
            end
        end

        class TestPrx < ::Ice::ObjectPrx
            include ::Ice::Proxy_mixin
            include TestPrx_mixin
        end

        if not defined?(::System::T_TestPrx)
            T_Test = ::Ice::__declareClass('::System::Test')
            T_TestPrx = ::Ice::__declareProxy('::System::Test')
        end

        T_TestPrx.defineProxy(TestPrx, nil, [])

        TestPrx_mixin::OP_op = ::Ice::__defineOperation('op', ::Ice::OperationMode::Normal, false, nil, [], [], nil, [])
    end
end
